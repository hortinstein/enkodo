// deno-fmt-ignore-file
// deno-lint-ignore-file
// This code was bundled using `deno bundle` and it's not recommended to edit it manually

class DenoStdInternalError extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError(msg);
    }
}
function unreachable() {
    throw new DenoStdInternalError("unreachable");
}
const osType = (()=>{
    const { Deno: Deno1  } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator: navigator1  } = globalThis;
    if (navigator1?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows = osType === "windows";
const isLinux = osType === "linux";
function uvTranslateSysError(sysErrno) {
    switch(sysErrno){
        case 5:
            return "EACCES";
        case 998:
            return "EACCES";
        case 10013:
            return "EACCES";
        case 1920:
            return "EACCES";
        case 1227:
            return "EADDRINUSE";
        case 10048:
            return "EADDRINUSE";
        case 10049:
            return "EADDRNOTAVAIL";
        case 10047:
            return "EAFNOSUPPORT";
        case 10035:
            return "EAGAIN";
        case 10037:
            return "EALREADY";
        case 1004:
            return "EBADF";
        case 6:
            return "EBADF";
        case 33:
            return "EBUSY";
        case 231:
            return "EBUSY";
        case 32:
            return "EBUSY";
        case 995:
            return "ECANCELED";
        case 10004:
            return "ECANCELED";
        case 1113:
            return "ECHARSET";
        case 1236:
            return "ECONNABORTED";
        case 10053:
            return "ECONNABORTED";
        case 1225:
            return "ECONNREFUSED";
        case 10061:
            return "ECONNREFUSED";
        case 64:
            return "ECONNRESET";
        case 10054:
            return "ECONNRESET";
        case 183:
            return "EEXIST";
        case 80:
            return "EEXIST";
        case 111:
            return "EFAULT";
        case 10014:
            return "EFAULT";
        case 1232:
            return "EHOSTUNREACH";
        case 10065:
            return "EHOSTUNREACH";
        case 122:
            return "EINVAL";
        case 13:
            return "EINVAL";
        case 123:
            return "EINVAL";
        case 87:
            return "EINVAL";
        case 10022:
            return "EINVAL";
        case 10046:
            return "EINVAL";
        case 1102:
            return "EIO";
        case 1111:
            return "EIO";
        case 23:
            return "EIO";
        case 1166:
            return "EIO";
        case 1165:
            return "EIO";
        case 1393:
            return "EIO";
        case 1129:
            return "EIO";
        case 1101:
            return "EIO";
        case 31:
            return "EIO";
        case 1106:
            return "EIO";
        case 1117:
            return "EIO";
        case 1104:
            return "EIO";
        case 205:
            return "EIO";
        case 110:
            return "EIO";
        case 1103:
            return "EIO";
        case 156:
            return "EIO";
        case 10056:
            return "EISCONN";
        case 1921:
            return "ELOOP";
        case 4:
            return "EMFILE";
        case 10024:
            return "EMFILE";
        case 10040:
            return "EMSGSIZE";
        case 206:
            return "ENAMETOOLONG";
        case 1231:
            return "ENETUNREACH";
        case 10051:
            return "ENETUNREACH";
        case 10055:
            return "ENOBUFS";
        case 161:
            return "ENOENT";
        case 267:
            return "ENOTDIR";
        case 203:
            return "ENOENT";
        case 2:
            return "ENOENT";
        case 15:
            return "ENOENT";
        case 4392:
            return "ENOENT";
        case 126:
            return "ENOENT";
        case 3:
            return "ENOENT";
        case 11001:
            return "ENOENT";
        case 11004:
            return "ENOENT";
        case 8:
            return "ENOMEM";
        case 14:
            return "ENOMEM";
        case 82:
            return "ENOSPC";
        case 112:
            return "ENOSPC";
        case 277:
            return "ENOSPC";
        case 1100:
            return "ENOSPC";
        case 39:
            return "ENOSPC";
        case 2250:
            return "ENOTCONN";
        case 10057:
            return "ENOTCONN";
        case 145:
            return "ENOTEMPTY";
        case 10038:
            return "ENOTSOCK";
        case 50:
            return "ENOTSUP";
        case 109:
            return "EOF";
        case 1314:
            return "EPERM";
        case 230:
            return "EPIPE";
        case 232:
            return "EPIPE";
        case 233:
            return "EPIPE";
        case 10058:
            return "EPIPE";
        case 10043:
            return "EPROTONOSUPPORT";
        case 19:
            return "EROFS";
        case 121:
            return "ETIMEDOUT";
        case 10060:
            return "ETIMEDOUT";
        case 17:
            return "EXDEV";
        case 1:
            return "EISDIR";
        case 208:
            return "E2BIG";
        case 10044:
            return "ESOCKTNOSUPPORT";
        default:
            return "UNKNOWN";
    }
}
const codeToErrorWindows = [
    [
        -4093,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -4092,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -4091,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -4090,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -4089,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -4088,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -4084,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -4083,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -4082,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -4081,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -4079,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -4078,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -4077,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -4076,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -4075,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -4074,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -4036,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -4073,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4072,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -4071,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -4070,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -4069,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -4068,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -4067,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -4066,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -4065,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -4064,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -4063,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -4062,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -4061,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -4060,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -4059,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -4058,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -4057,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -4035,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -4055,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -4054,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -4053,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -4052,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -4051,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -4050,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -4049,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -4048,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -4047,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -4046,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -4045,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -4044,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -4034,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -4043,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -4042,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -4041,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -4040,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -4039,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -4038,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -4037,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -4033,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -4032,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -4031,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -4029,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -4027,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ]
];
const errorToCodeWindows = codeToErrorWindows.map(([status, [error]])=>[
        error,
        status
    ]);
const codeToErrorDarwin = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -48,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -49,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -47,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -35,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -37,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -89,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -53,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -61,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -54,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -39,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -65,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -56,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -62,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -40,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -63,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -50,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -51,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -55,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -42,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -78,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -57,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -66,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -38,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -45,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -100,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -43,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -41,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -58,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -60,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -64,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -79,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -92,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ]
];
const errorToCodeDarwin = codeToErrorDarwin.map(([status, [code]])=>[
        code,
        status
    ]);
const codeToErrorLinux = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -98,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -99,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -97,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -11,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -114,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -125,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -103,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -111,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -104,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -89,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -113,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -106,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -40,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -90,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -36,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -100,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -101,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -105,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -64,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -92,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -38,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -107,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -39,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -88,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -95,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -71,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -93,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -91,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -108,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -110,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -112,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -121,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -84,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ]
];
const errorToCodeLinux = codeToErrorLinux.map(([status, [code]])=>[
        code,
        status
    ]);
const codeToErrorFreebsd = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -48,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -49,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -47,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -35,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -37,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -85,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -53,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -61,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -54,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -39,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -65,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -56,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -62,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -40,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -63,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -50,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -51,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -55,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -42,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -78,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -57,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -66,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -38,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -45,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -84,
        [
            "EOVERFLOW",
            "value too large for defined data type"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -92,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -43,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -41,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -58,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -60,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -64,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -79,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -86,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ],
    [
        -44,
        [
            "ESOCKTNOSUPPORT",
            "socket type not supported"
        ]
    ]
];
const errorToCodeFreebsd = codeToErrorFreebsd.map(([status, [code]])=>[
        code,
        status
    ]);
const errorMap = new Map(osType === "windows" ? codeToErrorWindows : osType === "darwin" ? codeToErrorDarwin : osType === "linux" ? codeToErrorLinux : osType === "freebsd" ? codeToErrorFreebsd : unreachable());
const codeMap = new Map(osType === "windows" ? errorToCodeWindows : osType === "darwin" ? errorToCodeDarwin : osType === "linux" ? errorToCodeLinux : osType === "freebsd" ? errorToCodeFreebsd : unreachable());
function mapSysErrnoToUvErrno(sysErrno) {
    if (osType === "windows") {
        const code = uvTranslateSysError(sysErrno);
        return codeMap.get(code) ?? -sysErrno;
    } else {
        return -sysErrno;
    }
}
const UV_EAI_MEMORY = codeMap.get("EAI_MEMORY");
const UV_EBADF = codeMap.get("EBADF");
const UV_EEXIST = codeMap.get("EEXIST");
const UV_EINVAL = codeMap.get("EINVAL");
const UV_ENOENT = codeMap.get("ENOENT");
const UV_ENOTSOCK = codeMap.get("ENOTSOCK");
const UV_UNKNOWN = codeMap.get("UNKNOWN");
const mod = {
    errorMap: errorMap,
    codeMap: codeMap,
    mapSysErrnoToUvErrno: mapSysErrnoToUvErrno,
    UV_EAI_MEMORY: UV_EAI_MEMORY,
    UV_EBADF: UV_EBADF,
    UV_EEXIST: UV_EEXIST,
    UV_EINVAL: UV_EINVAL,
    UV_ENOENT: UV_ENOENT,
    UV_ENOTSOCK: UV_ENOTSOCK,
    UV_UNKNOWN: UV_UNKNOWN
};
const codes = {};
function notImplemented(msg) {
    const message = msg ? `Not implemented: ${msg}` : "Not implemented";
    throw new Error(message);
}
function warnNotImplemented(msg) {
    const message = msg ? `Warning: Not implemented: ${msg}` : "Warning: Not implemented";
    console.warn(message);
}
const _TextDecoder = TextDecoder;
const _TextEncoder = TextEncoder;
function intoCallbackAPIWithIntercept(func, interceptor, cb, ...args) {
    func(...args).then((value)=>cb && cb(null, interceptor(value)), (err)=>cb && cb(err));
}
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function normalizeEncoding(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases(enc);
}
function slowCases(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function validateIntegerRange(value, name, min = -2147483648, max = 2147483647) {
    if (!Number.isInteger(value)) {
        throw new Error(`${name} must be 'an integer' but was ${value}`);
    }
    if (value < min || value > max) {
        throw new Error(`${name} must be >= ${min} && <= ${max}. Value was ${value}`);
    }
}
const NumberIsSafeInteger = Number.isSafeInteger;
function getSystemErrorName(code) {
    if (typeof code !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE("err", "number", code);
    }
    if (code >= 0 || !NumberIsSafeInteger(code)) {
        throw new codes.ERR_OUT_OF_RANGE("err", "a negative integer", code);
    }
    return errorMap.get(code)?.[0];
}
let DenoCore;
const { Deno: Deno1  } = globalThis;
if (Deno1?.[Deno1.internal]?.core) {
    DenoCore = Deno1[Deno1.internal].core;
} else if (Deno1?.core) {
    DenoCore = Deno1.core;
} else {
    DenoCore = {};
}
const core = {
    runMicrotasks: DenoCore.runMicrotasks ?? function() {
        throw new Error("Deno.core.runMicrotasks() is not supported in this environment");
    },
    setHasTickScheduled: DenoCore.setHasTickScheduled ?? function() {
        throw new Error("Deno.core.setHasTickScheduled() is not supported in this environment");
    },
    hasTickScheduled: DenoCore.hasTickScheduled ?? function() {
        throw new Error("Deno.core.hasTickScheduled() is not supported in this environment");
    },
    setNextTickCallback: DenoCore.setNextTickCallback ?? undefined,
    setMacrotaskCallback: DenoCore.setMacrotaskCallback ?? function() {
        throw new Error("Deno.core.setNextTickCallback() is not supported in this environment");
    },
    evalContext: DenoCore.evalContext ?? function(_code, _filename) {
        throw new Error("Deno.core.evalContext is not supported in this environment");
    },
    encode: DenoCore.encode ?? function(chunk) {
        return new TextEncoder().encode(chunk);
    },
    eventLoopHasMoreWork: DenoCore.eventLoopHasMoreWork ?? function() {
        return false;
    },
    isProxy: DenoCore.isProxy ?? function() {
        return false;
    },
    getPromiseDetails: DenoCore.getPromiseDetails ?? function(_promise) {
        throw new Error("Deno.core.getPromiseDetails is not supported in this environment");
    },
    setPromiseHooks: DenoCore.setPromiseHooks ?? function() {
        throw new Error("Deno.core.setPromiseHooks is not supported in this environment");
    },
    ops: DenoCore.ops ?? {
        op_napi_open (_filename) {
            throw new Error("Node API is not supported in this environment");
        }
    }
};
const _toString = Object.prototype.toString;
const _bigIntValueOf = BigInt.prototype.valueOf;
const _booleanValueOf = Boolean.prototype.valueOf;
const _dateValueOf = Date.prototype.valueOf;
const _numberValueOf = Number.prototype.valueOf;
const _stringValueOf = String.prototype.valueOf;
const _symbolValueOf = Symbol.prototype.valueOf;
const _weakMapHas = WeakMap.prototype.has;
const _weakSetHas = WeakSet.prototype.has;
const _getArrayBufferByteLength = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
const _getSharedArrayBufferByteLength = globalThis.SharedArrayBuffer ? Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, "byteLength").get : undefined;
const _getTypedArrayToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array).prototype, Symbol.toStringTag).get;
const _getSetSize = Object.getOwnPropertyDescriptor(Set.prototype, "size").get;
const _getMapSize = Object.getOwnPropertyDescriptor(Map.prototype, "size").get;
function isObjectLike(value) {
    return value !== null && typeof value === "object";
}
function isAnyArrayBuffer(value) {
    return isArrayBuffer(value) || isSharedArrayBuffer(value);
}
function isArgumentsObject(value) {
    return isObjectLike(value) && value[Symbol.toStringTag] === undefined && _toString.call(value) === "[object Arguments]";
}
function isArrayBuffer(value) {
    try {
        _getArrayBufferByteLength.call(value);
        return true;
    } catch  {
        return false;
    }
}
function isAsyncFunction(value) {
    return typeof value === "function" && value[Symbol.toStringTag] === "AsyncFunction";
}
function isBooleanObject(value) {
    if (!isObjectLike(value)) {
        return false;
    }
    try {
        _booleanValueOf.call(value);
        return true;
    } catch  {
        return false;
    }
}
function isBoxedPrimitive(value) {
    return isBooleanObject(value) || isStringObject(value) || isNumberObject(value) || isSymbolObject(value) || isBigIntObject(value);
}
function isDataView(value) {
    return ArrayBuffer.isView(value) && _getTypedArrayToStringTag.call(value) === undefined;
}
function isDate(value) {
    try {
        _dateValueOf.call(value);
        return true;
    } catch  {
        return false;
    }
}
function isGeneratorFunction(value) {
    return typeof value === "function" && value[Symbol.toStringTag] === "GeneratorFunction";
}
function isGeneratorObject(value) {
    return isObjectLike(value) && value[Symbol.toStringTag] === "Generator";
}
function isMap(value) {
    try {
        _getMapSize.call(value);
        return true;
    } catch  {
        return false;
    }
}
function isMapIterator(value) {
    return isObjectLike(value) && value[Symbol.toStringTag] === "Map Iterator";
}
function isModuleNamespaceObject(value) {
    return isObjectLike(value) && value[Symbol.toStringTag] === "Module";
}
function isNativeError(value) {
    return isObjectLike(value) && value[Symbol.toStringTag] === undefined && _toString.call(value) === "[object Error]";
}
function isNumberObject(value) {
    if (!isObjectLike(value)) {
        return false;
    }
    try {
        _numberValueOf.call(value);
        return true;
    } catch  {
        return false;
    }
}
function isBigIntObject(value) {
    if (!isObjectLike(value)) {
        return false;
    }
    try {
        _bigIntValueOf.call(value);
        return true;
    } catch  {
        return false;
    }
}
function isPromise(value) {
    return isObjectLike(value) && value[Symbol.toStringTag] === "Promise";
}
function isProxy(value) {
    return core.isProxy(value);
}
function isRegExp(value) {
    return isObjectLike(value) && value[Symbol.toStringTag] === undefined && _toString.call(value) === "[object RegExp]";
}
function isSet(value) {
    try {
        _getSetSize.call(value);
        return true;
    } catch  {
        return false;
    }
}
function isSetIterator(value) {
    return isObjectLike(value) && value[Symbol.toStringTag] === "Set Iterator";
}
function isSharedArrayBuffer(value) {
    if (_getSharedArrayBufferByteLength === undefined) {
        return false;
    }
    try {
        _getSharedArrayBufferByteLength.call(value);
        return true;
    } catch  {
        return false;
    }
}
function isStringObject(value) {
    if (!isObjectLike(value)) {
        return false;
    }
    try {
        _stringValueOf.call(value);
        return true;
    } catch  {
        return false;
    }
}
function isSymbolObject(value) {
    if (!isObjectLike(value)) {
        return false;
    }
    try {
        _symbolValueOf.call(value);
        return true;
    } catch  {
        return false;
    }
}
function isWeakMap(value) {
    try {
        _weakMapHas.call(value, null);
        return true;
    } catch  {
        return false;
    }
}
function isWeakSet(value) {
    try {
        _weakSetHas.call(value, null);
        return true;
    } catch  {
        return false;
    }
}
const __default = {
    isAsyncFunction,
    isGeneratorFunction,
    isAnyArrayBuffer,
    isArrayBuffer,
    isArgumentsObject,
    isBoxedPrimitive,
    isDataView,
    isMap,
    isMapIterator,
    isModuleNamespaceObject,
    isNativeError,
    isPromise,
    isSet,
    isSetIterator,
    isWeakMap,
    isWeakSet,
    isRegExp,
    isDate,
    isStringObject,
    isNumberObject,
    isBooleanObject,
    isBigIntObject
};
const mod1 = {
    isAnyArrayBuffer: isAnyArrayBuffer,
    isArgumentsObject: isArgumentsObject,
    isArrayBuffer: isArrayBuffer,
    isAsyncFunction: isAsyncFunction,
    isBooleanObject: isBooleanObject,
    isBoxedPrimitive: isBoxedPrimitive,
    isDataView: isDataView,
    isDate: isDate,
    isGeneratorFunction: isGeneratorFunction,
    isGeneratorObject: isGeneratorObject,
    isMap: isMap,
    isMapIterator: isMapIterator,
    isModuleNamespaceObject: isModuleNamespaceObject,
    isNativeError: isNativeError,
    isNumberObject: isNumberObject,
    isBigIntObject: isBigIntObject,
    isPromise: isPromise,
    isProxy: isProxy,
    isRegExp: isRegExp,
    isSet: isSet,
    isSetIterator: isSetIterator,
    isSharedArrayBuffer: isSharedArrayBuffer,
    isStringObject: isStringObject,
    isSymbolObject: isSymbolObject,
    isWeakMap: isWeakMap,
    isWeakSet: isWeakSet,
    default: __default
};
const kHandle = Symbol("kHandle");
const kKeyObject = Symbol("kKeyObject");
const kKeyType = Symbol("kKeyType");
function isKeyObject(obj) {
    return obj != null && obj[kKeyType] !== undefined;
}
function isCryptoKey(obj) {
    return obj != null && obj[kKeyObject] !== undefined;
}
const _getTypedArrayToStringTag1 = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array).prototype, Symbol.toStringTag).get;
function isArrayBufferView(value) {
    return ArrayBuffer.isView(value);
}
function isBigInt64Array(value) {
    return _getTypedArrayToStringTag1.call(value) === "BigInt64Array";
}
function isBigUint64Array(value) {
    return _getTypedArrayToStringTag1.call(value) === "BigUint64Array";
}
function isFloat32Array(value) {
    return _getTypedArrayToStringTag1.call(value) === "Float32Array";
}
function isFloat64Array(value) {
    return _getTypedArrayToStringTag1.call(value) === "Float64Array";
}
function isInt8Array(value) {
    return _getTypedArrayToStringTag1.call(value) === "Int8Array";
}
function isInt16Array(value) {
    return _getTypedArrayToStringTag1.call(value) === "Int16Array";
}
function isInt32Array(value) {
    return _getTypedArrayToStringTag1.call(value) === "Int32Array";
}
function isTypedArray(value) {
    return _getTypedArrayToStringTag1.call(value) !== undefined;
}
function isUint8Array(value) {
    return _getTypedArrayToStringTag1.call(value) === "Uint8Array";
}
function isUint8ClampedArray(value) {
    return _getTypedArrayToStringTag1.call(value) === "Uint8ClampedArray";
}
function isUint16Array(value) {
    return _getTypedArrayToStringTag1.call(value) === "Uint16Array";
}
function isUint32Array(value) {
    return _getTypedArrayToStringTag1.call(value) === "Uint32Array";
}
const { isDate: isDate1 , isArgumentsObject: isArgumentsObject1 , isBigIntObject: isBigIntObject1 , isBooleanObject: isBooleanObject1 , isNumberObject: isNumberObject1 , isStringObject: isStringObject1 , isSymbolObject: isSymbolObject1 , isNativeError: isNativeError1 , isRegExp: isRegExp1 , isAsyncFunction: isAsyncFunction1 , isGeneratorFunction: isGeneratorFunction1 , isGeneratorObject: isGeneratorObject1 , isPromise: isPromise1 , isMap: isMap1 , isSet: isSet1 , isMapIterator: isMapIterator1 , isSetIterator: isSetIterator1 , isWeakMap: isWeakMap1 , isWeakSet: isWeakSet1 , isArrayBuffer: isArrayBuffer1 , isDataView: isDataView1 , isSharedArrayBuffer: isSharedArrayBuffer1 , isProxy: isProxy1 , isModuleNamespaceObject: isModuleNamespaceObject1 , isAnyArrayBuffer: isAnyArrayBuffer1 , isBoxedPrimitive: isBoxedPrimitive1  } = mod1;
const mod2 = {
    isCryptoKey: isCryptoKey,
    isKeyObject: isKeyObject,
    isArrayBufferView: isArrayBufferView,
    isBigInt64Array: isBigInt64Array,
    isBigUint64Array: isBigUint64Array,
    isFloat32Array: isFloat32Array,
    isFloat64Array: isFloat64Array,
    isInt8Array: isInt8Array,
    isInt16Array: isInt16Array,
    isInt32Array: isInt32Array,
    isTypedArray: isTypedArray,
    isUint8Array: isUint8Array,
    isUint8ClampedArray: isUint8ClampedArray,
    isUint16Array: isUint16Array,
    isUint32Array: isUint32Array,
    isDate: isDate1,
    isArgumentsObject: isArgumentsObject1,
    isBigIntObject: isBigIntObject1,
    isBooleanObject: isBooleanObject1,
    isNumberObject: isNumberObject1,
    isStringObject: isStringObject1,
    isSymbolObject: isSymbolObject1,
    isNativeError: isNativeError1,
    isRegExp: isRegExp1,
    isAsyncFunction: isAsyncFunction1,
    isGeneratorFunction: isGeneratorFunction1,
    isGeneratorObject: isGeneratorObject1,
    isPromise: isPromise1,
    isMap: isMap1,
    isSet: isSet1,
    isMapIterator: isMapIterator1,
    isSetIterator: isSetIterator1,
    isWeakMap: isWeakMap1,
    isWeakSet: isWeakSet1,
    isArrayBuffer: isArrayBuffer1,
    isDataView: isDataView1,
    isSharedArrayBuffer: isSharedArrayBuffer1,
    isProxy: isProxy1,
    isModuleNamespaceObject: isModuleNamespaceObject1,
    isAnyArrayBuffer: isAnyArrayBuffer1,
    isBoxedPrimitive: isBoxedPrimitive1
};
function hideStackFrames(fn) {
    const hidden = "__node_internal_" + fn.name;
    Object.defineProperty(fn, "name", {
        value: hidden
    });
    return fn;
}
function normalizeEncoding1(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases1(enc);
}
function slowCases1(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        case 9:
            if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
                return "base64url";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function isInt32(value) {
    return value === (value | 0);
}
function isUint32(value) {
    return value === value >>> 0;
}
const octalReg = /^[0-7]+$/;
const modeDesc = "must be a 32-bit unsigned integer or an octal string";
function parseFileMode(value, name, def) {
    value ??= def;
    if (typeof value === "string") {
        if (!octalReg.test(value)) {
            throw new codes.ERR_INVALID_ARG_VALUE(name, value, modeDesc);
        }
        value = Number.parseInt(value, 8);
    }
    validateInt32(value, name, 0, 2 ** 32 - 1);
    return value;
}
const validateBuffer = hideStackFrames((buffer, name = "buffer")=>{
    if (!isArrayBufferView(buffer)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, [
            "Buffer",
            "TypedArray",
            "DataView"
        ], buffer);
    }
});
const validateInteger = hideStackFrames((value, name, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER)=>{
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
const validateObject = hideStackFrames((value, name, options)=>{
    const useDefaultOptions = options == null;
    const allowArray = useDefaultOptions ? false : options.allowArray;
    const allowFunction = useDefaultOptions ? false : options.allowFunction;
    const nullable = useDefaultOptions ? false : options.nullable;
    if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Object", value);
    }
});
const validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647)=>{
    if (!isInt32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
const validateUint32 = hideStackFrames((value, name, positive)=>{
    if (!isUint32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        const min = positive ? 1 : 0;
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && < 4294967296`, value);
    }
    if (positive && value === 0) {
        throw new codes.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
    }
});
function validateString(value, name) {
    if (typeof value !== "string") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "string", value);
    }
}
function validateNumber(value, name) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
}
function validateBoolean(value, name) {
    if (typeof value !== "boolean") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "boolean", value);
    }
}
const validateOneOf = hideStackFrames((value, name, oneOf)=>{
    if (!Array.prototype.includes.call(oneOf, value)) {
        const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v)=>typeof v === "string" ? `'${v}'` : String(v)), ", ");
        const reason = "must be one of: " + allowed;
        throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
function validateEncoding(data, encoding) {
    const normalizedEncoding = normalizeEncoding1(encoding);
    const length = data.length;
    if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new codes.ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
    }
}
function validatePort(port, name = "Port", allowZero = true) {
    if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && String.prototype.trim.call(port).length === 0 || +port !== +port >>> 0 || port > 0xFFFF || port === 0 && !allowZero) {
        throw new codes.ERR_SOCKET_BAD_PORT(name, port, allowZero);
    }
    return port;
}
const validateAbortSignal = hideStackFrames((signal, name)=>{
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
});
const validateFunction = hideStackFrames((value, name)=>{
    if (typeof value !== "function") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Function", value);
    }
});
const validateArray = hideStackFrames((value, name, minLength = 0)=>{
    if (!Array.isArray(value)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Array", value);
    }
    if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
function guessHandleType(_fd) {
    notImplemented("util.guessHandleType");
}
const isNumericLookup = {};
function isArrayIndex(value) {
    switch(typeof value){
        case "number":
            return value >= 0 && (value | 0) === value;
        case "string":
            {
                const result = isNumericLookup[value];
                if (result !== void 0) {
                    return result;
                }
                const length = value.length;
                if (length === 0) {
                    return isNumericLookup[value] = false;
                }
                let ch = 0;
                let i = 0;
                for(; i < length; ++i){
                    ch = value.charCodeAt(i);
                    if (i === 0 && ch === 0x30 && length > 1 || ch < 0x30 || ch > 0x39) {
                        return isNumericLookup[value] = false;
                    }
                }
                return isNumericLookup[value] = true;
            }
        default:
            return false;
    }
}
function getOwnNonIndexProperties(obj, filter) {
    let allProperties = [
        ...Object.getOwnPropertyNames(obj),
        ...Object.getOwnPropertySymbols(obj)
    ];
    if (Array.isArray(obj)) {
        allProperties = allProperties.filter((k)=>!isArrayIndex(k));
    }
    if (filter === 0) {
        return allProperties;
    }
    const result = [];
    for (const key of allProperties){
        const desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc === undefined) {
            continue;
        }
        if (filter & 1 && !desc.writable) {
            continue;
        }
        if (filter & 2 && !desc.enumerable) {
            continue;
        }
        if (filter & 4 && !desc.configurable) {
            continue;
        }
        if (filter & 8 && typeof key === "string") {
            continue;
        }
        if (filter & 16 && typeof key === "symbol") {
            continue;
        }
        result.push(key);
    }
    return result;
}
const mod3 = function() {
    return {
        guessHandleType: guessHandleType,
        ALL_PROPERTIES: 0,
        ONLY_WRITABLE: 1,
        ONLY_ENUMERABLE: 2,
        ONLY_CONFIGURABLE: 4,
        ONLY_ENUM_WRITABLE: 6,
        SKIP_STRINGS: 8,
        SKIP_SYMBOLS: 16,
        isArrayIndex: isArrayIndex,
        getOwnNonIndexProperties: getOwnNonIndexProperties
    };
}();
const kObjectType = 0;
const kArrayExtrasType = 2;
const kRejected = 2;
const meta = [
    '\\x00',
    '\\x01',
    '\\x02',
    '\\x03',
    '\\x04',
    '\\x05',
    '\\x06',
    '\\x07',
    '\\b',
    '\\t',
    '\\n',
    '\\x0B',
    '\\f',
    '\\r',
    '\\x0E',
    '\\x0F',
    '\\x10',
    '\\x11',
    '\\x12',
    '\\x13',
    '\\x14',
    '\\x15',
    '\\x16',
    '\\x17',
    '\\x18',
    '\\x19',
    '\\x1A',
    '\\x1B',
    '\\x1C',
    '\\x1D',
    '\\x1E',
    '\\x1F',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    "\\'",
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\\\',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\x7F',
    '\\x80',
    '\\x81',
    '\\x82',
    '\\x83',
    '\\x84',
    '\\x85',
    '\\x86',
    '\\x87',
    '\\x88',
    '\\x89',
    '\\x8A',
    '\\x8B',
    '\\x8C',
    '\\x8D',
    '\\x8E',
    '\\x8F',
    '\\x90',
    '\\x91',
    '\\x92',
    '\\x93',
    '\\x94',
    '\\x95',
    '\\x96',
    '\\x97',
    '\\x98',
    '\\x99',
    '\\x9A',
    '\\x9B',
    '\\x9C',
    '\\x9D',
    '\\x9E',
    '\\x9F'
];
const isUndetectableObject = (v)=>typeof v === "undefined" && v !== undefined;
const strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
const strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c\x7f-\x9f]/g;
const keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
const numberRegExp = /^(0|[1-9][0-9]*)$/;
const nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
const classRegExp = /^(\s+[^(]*?)\s*{/;
const stripCommentsRegExp = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
const inspectDefaultOptions = {
    showHidden: false,
    depth: 2,
    colors: false,
    customInspect: true,
    showProxy: false,
    maxArrayLength: 100,
    maxStringLength: 10000,
    breakLength: 80,
    compact: 3,
    sorted: false,
    getters: false
};
function getUserOptions(ctx, isCrossContext) {
    const ret = {
        stylize: ctx.stylize,
        showHidden: ctx.showHidden,
        depth: ctx.depth,
        colors: ctx.colors,
        customInspect: ctx.customInspect,
        showProxy: ctx.showProxy,
        maxArrayLength: ctx.maxArrayLength,
        maxStringLength: ctx.maxStringLength,
        breakLength: ctx.breakLength,
        compact: ctx.compact,
        sorted: ctx.sorted,
        getters: ctx.getters,
        ...ctx.userOptions
    };
    if (isCrossContext) {
        Object.setPrototypeOf(ret, null);
        for (const key of Object.keys(ret)){
            if ((typeof ret[key] === "object" || typeof ret[key] === "function") && ret[key] !== null) {
                delete ret[key];
            }
        }
        ret.stylize = Object.setPrototypeOf((value, flavour)=>{
            let stylized;
            try {
                stylized = `${ctx.stylize(value, flavour)}`;
            } catch  {}
            if (typeof stylized !== "string") return value;
            return stylized;
        }, null);
    }
    return ret;
}
function inspect(value, opts) {
    const ctx = {
        budget: {},
        indentationLvl: 0,
        seen: [],
        currentDepth: 0,
        stylize: stylizeNoColor,
        showHidden: inspectDefaultOptions.showHidden,
        depth: inspectDefaultOptions.depth,
        colors: inspectDefaultOptions.colors,
        customInspect: inspectDefaultOptions.customInspect,
        showProxy: inspectDefaultOptions.showProxy,
        maxArrayLength: inspectDefaultOptions.maxArrayLength,
        maxStringLength: inspectDefaultOptions.maxStringLength,
        breakLength: inspectDefaultOptions.breakLength,
        compact: inspectDefaultOptions.compact,
        sorted: inspectDefaultOptions.sorted,
        getters: inspectDefaultOptions.getters
    };
    if (arguments.length > 1) {
        if (arguments.length > 2) {
            if (arguments[2] !== undefined) {
                ctx.depth = arguments[2];
            }
            if (arguments.length > 3 && arguments[3] !== undefined) {
                ctx.colors = arguments[3];
            }
        }
        if (typeof opts === "boolean") {
            ctx.showHidden = opts;
        } else if (opts) {
            const optKeys = Object.keys(opts);
            for(let i = 0; i < optKeys.length; ++i){
                const key = optKeys[i];
                if (inspectDefaultOptions.hasOwnProperty(key) || key === "stylize") {
                    ctx[key] = opts[key];
                } else if (ctx.userOptions === undefined) {
                    ctx.userOptions = opts;
                }
            }
        }
    }
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;
    if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;
    return formatValue(ctx, value, 0);
}
const customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
inspect.custom = customInspectSymbol;
Object.defineProperty(inspect, "defaultOptions", {
    get () {
        return inspectDefaultOptions;
    },
    set (options) {
        validateObject(options, "options");
        return Object.assign(inspectDefaultOptions, options);
    }
});
const defaultFG = 39;
const defaultBG = 49;
inspect.colors = Object.assign(Object.create(null), {
    reset: [
        0,
        0
    ],
    bold: [
        1,
        22
    ],
    dim: [
        2,
        22
    ],
    italic: [
        3,
        23
    ],
    underline: [
        4,
        24
    ],
    blink: [
        5,
        25
    ],
    inverse: [
        7,
        27
    ],
    hidden: [
        8,
        28
    ],
    strikethrough: [
        9,
        29
    ],
    doubleunderline: [
        21,
        24
    ],
    black: [
        30,
        defaultFG
    ],
    red: [
        31,
        defaultFG
    ],
    green: [
        32,
        defaultFG
    ],
    yellow: [
        33,
        defaultFG
    ],
    blue: [
        34,
        defaultFG
    ],
    magenta: [
        35,
        defaultFG
    ],
    cyan: [
        36,
        defaultFG
    ],
    white: [
        37,
        defaultFG
    ],
    bgBlack: [
        40,
        defaultBG
    ],
    bgRed: [
        41,
        defaultBG
    ],
    bgGreen: [
        42,
        defaultBG
    ],
    bgYellow: [
        43,
        defaultBG
    ],
    bgBlue: [
        44,
        defaultBG
    ],
    bgMagenta: [
        45,
        defaultBG
    ],
    bgCyan: [
        46,
        defaultBG
    ],
    bgWhite: [
        47,
        defaultBG
    ],
    framed: [
        51,
        54
    ],
    overlined: [
        53,
        55
    ],
    gray: [
        90,
        defaultFG
    ],
    redBright: [
        91,
        defaultFG
    ],
    greenBright: [
        92,
        defaultFG
    ],
    yellowBright: [
        93,
        defaultFG
    ],
    blueBright: [
        94,
        defaultFG
    ],
    magentaBright: [
        95,
        defaultFG
    ],
    cyanBright: [
        96,
        defaultFG
    ],
    whiteBright: [
        97,
        defaultFG
    ],
    bgGray: [
        100,
        defaultBG
    ],
    bgRedBright: [
        101,
        defaultBG
    ],
    bgGreenBright: [
        102,
        defaultBG
    ],
    bgYellowBright: [
        103,
        defaultBG
    ],
    bgBlueBright: [
        104,
        defaultBG
    ],
    bgMagentaBright: [
        105,
        defaultBG
    ],
    bgCyanBright: [
        106,
        defaultBG
    ],
    bgWhiteBright: [
        107,
        defaultBG
    ]
});
function defineColorAlias(target, alias) {
    Object.defineProperty(inspect.colors, alias, {
        get () {
            return this[target];
        },
        set (value) {
            this[target] = value;
        },
        configurable: true,
        enumerable: false
    });
}
defineColorAlias("gray", "grey");
defineColorAlias("gray", "blackBright");
defineColorAlias("bgGray", "bgGrey");
defineColorAlias("bgGray", "bgBlackBright");
defineColorAlias("dim", "faint");
defineColorAlias("strikethrough", "crossedout");
defineColorAlias("strikethrough", "strikeThrough");
defineColorAlias("strikethrough", "crossedOut");
defineColorAlias("hidden", "conceal");
defineColorAlias("inverse", "swapColors");
defineColorAlias("inverse", "swapcolors");
defineColorAlias("doubleunderline", "doubleUnderline");
inspect.styles = Object.assign(Object.create(null), {
    special: "cyan",
    number: "yellow",
    bigint: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    symbol: "green",
    date: "magenta",
    regexp: "red",
    module: "underline"
});
function addQuotes(str, quotes) {
    if (quotes === -1) {
        return `"${str}"`;
    }
    if (quotes === -2) {
        return `\`${str}\``;
    }
    return `'${str}'`;
}
const escapeFn = (str)=>meta[str.charCodeAt(0)];
function strEscape(str) {
    let escapeTest = strEscapeSequencesRegExp;
    let escapeReplace = strEscapeSequencesReplacer;
    let singleQuote = 39;
    if (str.includes("'")) {
        if (!str.includes('"')) {
            singleQuote = -1;
        } else if (!str.includes("`") && !str.includes("${")) {
            singleQuote = -2;
        }
        if (singleQuote !== 39) {
            escapeTest = strEscapeSequencesRegExpSingle;
            escapeReplace = strEscapeSequencesReplacerSingle;
        }
    }
    if (str.length < 5000 && !escapeTest.test(str)) {
        return addQuotes(str, singleQuote);
    }
    if (str.length > 100) {
        str = str.replace(escapeReplace, escapeFn);
        return addQuotes(str, singleQuote);
    }
    let result = "";
    let last = 0;
    const lastIndex = str.length;
    for(let i = 0; i < lastIndex; i++){
        const point = str.charCodeAt(i);
        if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
            if (last === i) {
                result += meta[point];
            } else {
                result += `${str.slice(last, i)}${meta[point]}`;
            }
            last = i + 1;
        }
    }
    if (last !== lastIndex) {
        result += str.slice(last);
    }
    return addQuotes(result, singleQuote);
}
function stylizeWithColor(str, styleType) {
    const style = inspect.styles[styleType];
    if (style !== undefined) {
        const color = inspect.colors[style];
        if (color !== undefined) {
            return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`;
        }
    }
    return str;
}
function stylizeNoColor(str) {
    return str;
}
function formatValue(ctx, value, recurseTimes, typedArray) {
    if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject(value)) {
        return formatPrimitive(ctx.stylize, value, ctx);
    }
    if (value === null) {
        return ctx.stylize("null", "null");
    }
    const context = value;
    const proxy = undefined;
    if (ctx.customInspect) {
        const maybeCustom = value[customInspectSymbol];
        if (typeof maybeCustom === "function" && maybeCustom !== inspect && !(value.constructor && value.constructor.prototype === value)) {
            const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
            const isCrossContext = proxy !== undefined || !(context instanceof Object);
            const ret = maybeCustom.call(context, depth, getUserOptions(ctx, isCrossContext));
            if (ret !== context) {
                if (typeof ret !== "string") {
                    return formatValue(ctx, ret, recurseTimes);
                }
                return ret.replace(/\n/g, `\n${" ".repeat(ctx.indentationLvl)}`);
            }
        }
    }
    if (ctx.seen.includes(value)) {
        let index = 1;
        if (ctx.circular === undefined) {
            ctx.circular = new Map();
            ctx.circular.set(value, index);
        } else {
            index = ctx.circular.get(value);
            if (index === undefined) {
                index = ctx.circular.size + 1;
                ctx.circular.set(value, index);
            }
        }
        return ctx.stylize(`[Circular *${index}]`, "special");
    }
    return formatRaw(ctx, value, recurseTimes, typedArray);
}
function formatRaw(ctx, value, recurseTimes, typedArray) {
    let keys;
    let protoProps;
    if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
        protoProps = [];
    }
    const constructor = getConstructorName(value, ctx, recurseTimes, protoProps);
    if (protoProps !== undefined && protoProps.length === 0) {
        protoProps = undefined;
    }
    let tag = value[Symbol.toStringTag];
    if (typeof tag !== "string") {
        tag = "";
    }
    let base = "";
    let formatter = getEmptyFormatArray;
    let braces;
    let noIterator = true;
    let i = 0;
    const filter = ctx.showHidden ? 0 : 2;
    let extrasType = 0;
    if (value[Symbol.iterator] || constructor === null) {
        noIterator = false;
        if (Array.isArray(value)) {
            const prefix = constructor !== "Array" || tag !== "" ? getPrefix(constructor, tag, "Array", `(${value.length})`) : "";
            keys = getOwnNonIndexProperties(value, filter);
            braces = [
                `${prefix}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}]`;
            }
            extrasType = kArrayExtrasType;
            formatter = formatArray;
        } else if (isSet1(value)) {
            const size = value.size;
            const prefix = getPrefix(constructor, tag, "Set", `(${size})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatSet.bind(null, value) : formatSet.bind(null, value.values());
            if (size === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix}{}`;
            }
            braces = [
                `${prefix}{`,
                "}"
            ];
        } else if (isMap1(value)) {
            const size = value.size;
            const prefix = getPrefix(constructor, tag, "Map", `(${size})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatMap.bind(null, value) : formatMap.bind(null, value.entries());
            if (size === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix}{}`;
            }
            braces = [
                `${prefix}{`,
                "}"
            ];
        } else if (isTypedArray(value)) {
            keys = getOwnNonIndexProperties(value, filter);
            const bound = value;
            const fallback = "";
            if (constructor === null) {}
            const size = value.length;
            const prefix = getPrefix(constructor, tag, fallback, `(${size})`);
            braces = [
                `${prefix}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
                return `${braces[0]}]`;
            }
            formatter = formatTypedArray.bind(null, bound, size);
            extrasType = kArrayExtrasType;
        } else if (isMapIterator1(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Map", tag);
            formatter = formatIterator.bind(null, braces);
        } else if (isSetIterator1(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Set", tag);
            formatter = formatIterator.bind(null, braces);
        } else {
            noIterator = true;
        }
    }
    if (noIterator) {
        keys = getKeys(value, ctx.showHidden);
        braces = [
            "{",
            "}"
        ];
        if (constructor === "Object") {
            if (isArgumentsObject1(value)) {
                braces[0] = "[Arguments] {";
            } else if (tag !== "") {
                braces[0] = `${getPrefix(constructor, tag, "Object")}{`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}}`;
            }
        } else if (typeof value === "function") {
            base = getFunctionBase(value, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base, "special");
            }
        } else if (isRegExp1(value)) {
            base = RegExp(constructor !== null ? value : new RegExp(value)).toString();
            const prefix = getPrefix(constructor, tag, "RegExp");
            if (prefix !== "RegExp ") {
                base = `${prefix}${base}`;
            }
            if (keys.length === 0 && protoProps === undefined || recurseTimes > ctx.depth && ctx.depth !== null) {
                return ctx.stylize(base, "regexp");
            }
        } else if (isDate1(value)) {
            base = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
            const prefix = getPrefix(constructor, tag, "Date");
            if (prefix !== "Date ") {
                base = `${prefix}${base}`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base, "date");
            }
        } else if (value instanceof Error) {
            base = formatError(value, constructor, tag, ctx, keys);
            if (keys.length === 0 && protoProps === undefined) {
                return base;
            }
        } else if (isAnyArrayBuffer1(value)) {
            const arrayType = isArrayBuffer1(value) ? "ArrayBuffer" : "SharedArrayBuffer";
            const prefix = getPrefix(constructor, tag, arrayType);
            if (typedArray === undefined) {
                formatter = formatArrayBuffer;
            } else if (keys.length === 0 && protoProps === undefined) {
                return prefix + `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;
            }
            braces[0] = `${prefix}{`;
            Array.prototype.unshift.call(keys, "byteLength");
        } else if (isDataView1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "DataView")}{`;
            Array.prototype.unshift.call(keys, "byteLength", "byteOffset", "buffer");
        } else if (isPromise1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "Promise")}{`;
            formatter = formatPromise;
        } else if (isWeakSet1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "WeakSet")}{`;
            formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
        } else if (isWeakMap1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "WeakMap")}{`;
            formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
        } else if (isModuleNamespaceObject1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "Module")}{`;
            formatter = formatNamespaceObject.bind(null, keys);
        } else if (isBoxedPrimitive1(value)) {
            base = getBoxedBase(value, ctx, keys, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return base;
            }
        } else {
            if (keys.length === 0 && protoProps === undefined) {
                return `${getCtxStyle(value, constructor, tag)}{}`;
            }
            braces[0] = `${getCtxStyle(value, constructor, tag)}{`;
        }
    }
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        let constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
        if (constructor !== null) {
            constructorName = `[${constructorName}]`;
        }
        return ctx.stylize(constructorName, "special");
    }
    recurseTimes += 1;
    ctx.seen.push(value);
    ctx.currentDepth = recurseTimes;
    let output;
    const indentationLvl = ctx.indentationLvl;
    try {
        output = formatter(ctx, value, recurseTimes);
        for(i = 0; i < keys.length; i++){
            output.push(formatProperty(ctx, value, recurseTimes, keys[i], extrasType));
        }
        if (protoProps !== undefined) {
            output.push(...protoProps);
        }
    } catch (err) {
        const constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
        return handleMaxCallStackSize(ctx, err, constructorName, indentationLvl);
    }
    if (ctx.circular !== undefined) {
        const index = ctx.circular.get(value);
        if (index !== undefined) {
            const reference = ctx.stylize(`<ref *${index}>`, "special");
            if (ctx.compact !== true) {
                base = base === "" ? reference : `${reference} ${base}`;
            } else {
                braces[0] = `${reference} ${braces[0]}`;
            }
        }
    }
    ctx.seen.pop();
    if (ctx.sorted) {
        const comparator = ctx.sorted === true ? undefined : ctx.sorted;
        if (extrasType === 0) {
            output = output.sort(comparator);
        } else if (keys.length > 1) {
            const sorted = output.slice(output.length - keys.length).sort(comparator);
            output.splice(output.length - keys.length, keys.length, ...sorted);
        }
    }
    const res = reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value);
    const budget = ctx.budget[ctx.indentationLvl] || 0;
    const newLength = budget + res.length;
    ctx.budget[ctx.indentationLvl] = newLength;
    if (newLength > 2 ** 27) {
        ctx.depth = -1;
    }
    return res;
}
const builtInObjects = new Set(Object.getOwnPropertyNames(globalThis).filter((e)=>/^[A-Z][a-zA-Z0-9]+$/.test(e)));
function addPrototypeProperties(ctx, main, obj, recurseTimes, output) {
    let depth = 0;
    let keys;
    let keySet;
    do {
        if (depth !== 0 || main === obj) {
            obj = Object.getPrototypeOf(obj);
            if (obj === null) {
                return;
            }
            const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
            if (descriptor !== undefined && typeof descriptor.value === "function" && builtInObjects.has(descriptor.value.name)) {
                return;
            }
        }
        if (depth === 0) {
            keySet = new Set();
        } else {
            Array.prototype.forEach.call(keys, (key)=>keySet.add(key));
        }
        keys = Reflect.ownKeys(obj);
        Array.prototype.push.call(ctx.seen, main);
        for (const key of keys){
            if (key === "constructor" || main.hasOwnProperty(key) || depth !== 0 && keySet.has(key)) {
                continue;
            }
            const desc = Object.getOwnPropertyDescriptor(obj, key);
            if (typeof desc.value === "function") {
                continue;
            }
            const value = formatProperty(ctx, obj, recurseTimes, key, 0, desc, main);
            if (ctx.colors) {
                Array.prototype.push.call(output, `\u001b[2m${value}\u001b[22m`);
            } else {
                Array.prototype.push.call(output, value);
            }
        }
        Array.prototype.pop.call(ctx.seen);
    }while (++depth !== 3)
}
function getConstructorName(obj, ctx, recurseTimes, protoProps) {
    let firstProto;
    const tmp = obj;
    while(obj || isUndetectableObject(obj)){
        const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
        if (descriptor !== undefined && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof(tmp, descriptor.value)) {
            if (protoProps !== undefined && (firstProto !== obj || !builtInObjects.has(descriptor.value.name))) {
                addPrototypeProperties(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
            }
            return descriptor.value.name;
        }
        obj = Object.getPrototypeOf(obj);
        if (firstProto === undefined) {
            firstProto = obj;
        }
    }
    if (firstProto === null) {
        return null;
    }
    const res = undefined;
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        return `${res} <Complex prototype>`;
    }
    const protoConstr = getConstructorName(firstProto, ctx, recurseTimes + 1, protoProps);
    if (protoConstr === null) {
        return `${res} <${inspect(firstProto, {
            ...ctx,
            customInspect: false,
            depth: -1
        })}>`;
    }
    return `${res} <${protoConstr}>`;
}
function formatPrimitive(fn, value, ctx) {
    if (typeof value === "string") {
        let trailer = "";
        if (value.length > ctx.maxStringLength) {
            const remaining = value.length - ctx.maxStringLength;
            value = value.slice(0, ctx.maxStringLength);
            trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
        }
        if (ctx.compact !== true && value.length > 16 && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
            return value.split(/(?<=\n)/).map((line)=>fn(strEscape(line), "string")).join(` +\n${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
        }
        return fn(strEscape(value), "string") + trailer;
    }
    if (typeof value === "number") {
        return formatNumber(fn, value);
    }
    if (typeof value === "bigint") {
        return formatBigInt(fn, value);
    }
    if (typeof value === "boolean") {
        return fn(`${value}`, "boolean");
    }
    if (typeof value === "undefined") {
        return fn("undefined", "undefined");
    }
    return fn(value.toString(), "symbol");
}
function getEmptyFormatArray() {
    return [];
}
function isInstanceof(object, proto) {
    try {
        return object instanceof proto;
    } catch  {
        return false;
    }
}
function getPrefix(constructor, tag, fallback, size = "") {
    if (constructor === null) {
        if (tag !== "" && fallback !== tag) {
            return `[${fallback}${size}: null prototype] [${tag}] `;
        }
        return `[${fallback}${size}: null prototype] `;
    }
    if (tag !== "" && constructor !== tag) {
        return `${constructor}${size} [${tag}] `;
    }
    return `${constructor}${size} `;
}
function formatArray(ctx, value, recurseTimes) {
    const valLen = value.length;
    const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
    const remaining = valLen - len;
    const output = [];
    for(let i = 0; i < len; i++){
        if (!value.hasOwnProperty(i)) {
            return formatSpecialArray(ctx, value, recurseTimes, len, output, i);
        }
        output.push(formatProperty(ctx, value, recurseTimes, i, 1));
    }
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getCtxStyle(_value, constructor, tag) {
    let fallback = "";
    if (constructor === null) {
        if (fallback === tag) {
            fallback = "Object";
        }
    }
    return getPrefix(constructor, tag, fallback);
}
function getKeys(value, showHidden) {
    let keys;
    const symbols = Object.getOwnPropertySymbols(value);
    if (showHidden) {
        keys = Object.getOwnPropertyNames(value);
        if (symbols.length !== 0) {
            Array.prototype.push.apply(keys, symbols);
        }
    } else {
        try {
            keys = Object.keys(value);
        } catch (_err) {
            keys = Object.getOwnPropertyNames(value);
        }
        if (symbols.length !== 0) {}
    }
    return keys;
}
function formatSet(value, ctx, _ignored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const v of value){
        Array.prototype.push.call(output, formatValue(ctx, v, recurseTimes));
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatMap(value, ctx, _gnored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const { 0: k , 1: v  } of value){
        output.push(`${formatValue(ctx, k, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`);
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatTypedArray(value, length, ctx, _ignored, recurseTimes) {
    const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
    const remaining = value.length - maxLength;
    const output = new Array(maxLength);
    const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber : formatBigInt;
    for(let i = 0; i < maxLength; ++i){
        output[i] = elementFormatter(ctx.stylize, value[i]);
    }
    if (remaining > 0) {
        output[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.showHidden) {
        ctx.indentationLvl += 2;
        for (const key of [
            "BYTES_PER_ELEMENT",
            "length",
            "byteLength",
            "byteOffset",
            "buffer"
        ]){
            const str = formatValue(ctx, value[key], recurseTimes, true);
            Array.prototype.push.call(output, `[${key}]: ${str}`);
        }
        ctx.indentationLvl -= 2;
    }
    return output;
}
function getIteratorBraces(type, tag) {
    if (tag !== `${type} Iterator`) {
        if (tag !== "") {
            tag += "] [";
        }
        tag += `${type} Iterator`;
    }
    return [
        `[${tag}] {`,
        "}"
    ];
}
function formatIterator(braces, ctx, value, recurseTimes) {
    const { 0: entries , 1: isKeyValue  } = value;
    if (isKeyValue) {
        braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
        return formatMapIterInner(ctx, recurseTimes, entries, 2);
    }
    return formatSetIterInner(ctx, recurseTimes, entries, 1);
}
function getFunctionBase(value, constructor, tag) {
    const stringified = Function.prototype.toString.call(value);
    if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
        const slice = stringified.slice(5, -1);
        const bracketIndex = slice.indexOf("{");
        if (bracketIndex !== -1 && (!slice.slice(0, bracketIndex).includes("(") || classRegExp.test(slice.replace(stripCommentsRegExp)))) {
            return getClassBase(value, constructor, tag);
        }
    }
    let type = "Function";
    if (isGeneratorFunction1(value)) {
        type = `Generator${type}`;
    }
    if (isAsyncFunction1(value)) {
        type = `Async${type}`;
    }
    let base = `[${type}`;
    if (constructor === null) {
        base += " (null prototype)";
    }
    if (value.name === "") {
        base += " (anonymous)";
    } else {
        base += `: ${value.name}`;
    }
    base += "]";
    if (constructor !== type && constructor !== null) {
        base += ` ${constructor}`;
    }
    if (tag !== "" && constructor !== tag) {
        base += ` [${tag}]`;
    }
    return base;
}
function formatError(err, constructor, tag, ctx, keys) {
    const name = err.name != null ? String(err.name) : "Error";
    let len = name.length;
    let stack = err.stack ? String(err.stack) : err.toString();
    if (!ctx.showHidden && keys.length !== 0) {
        for (const name of [
            "name",
            "message",
            "stack"
        ]){
            const index = keys.indexOf(name);
            if (index !== -1 && stack.includes(err[name])) {
                keys.splice(index, 1);
            }
        }
    }
    if (constructor === null || name.endsWith("Error") && stack.startsWith(name) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
        let fallback = "Error";
        if (constructor === null) {
            const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
            fallback = start && start[1] || "";
            len = fallback.length;
            fallback = fallback || "Error";
        }
        const prefix = getPrefix(constructor, tag, fallback).slice(0, -1);
        if (name !== prefix) {
            if (prefix.includes(name)) {
                if (len === 0) {
                    stack = `${prefix}: ${stack}`;
                } else {
                    stack = `${prefix}${stack.slice(len)}`;
                }
            } else {
                stack = `${prefix} [${name}]${stack.slice(len)}`;
            }
        }
    }
    let pos = err.message && stack.indexOf(err.message) || -1;
    if (pos !== -1) {
        pos += err.message.length;
    }
    const stackStart = stack.indexOf("\n    at", pos);
    if (stackStart === -1) {
        stack = `[${stack}]`;
    } else if (ctx.colors) {
        let newStack = stack.slice(0, stackStart);
        const lines = stack.slice(stackStart + 1).split("\n");
        for (const line of lines){
            let nodeModule;
            newStack += "\n";
            let pos = 0;
            while(nodeModule = nodeModulesRegExp.exec(line)){
                newStack += line.slice(pos, nodeModule.index + 14);
                newStack += ctx.stylize(nodeModule[1], "module");
                pos = nodeModule.index + nodeModule[0].length;
            }
            newStack += pos === 0 ? line : line.slice(pos);
        }
        stack = newStack;
    }
    if (ctx.indentationLvl !== 0) {
        const indentation = " ".repeat(ctx.indentationLvl);
        stack = stack.replace(/\n/g, `\n${indentation}`);
    }
    return stack;
}
let hexSlice;
function formatArrayBuffer(ctx, value) {
    let buffer;
    try {
        buffer = new Uint8Array(value);
    } catch  {
        return [
            ctx.stylize("(detached)", "special")
        ];
    }
    let str = hexSlice(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, "$1 ").trim();
    const remaining = buffer.length - ctx.maxArrayLength;
    if (remaining > 0) {
        str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
    }
    return [
        `${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`
    ];
}
function formatNumber(fn, value) {
    return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise(ctx, value, recurseTimes) {
    let output;
    const { 0: state , 1: result  } = value;
    if (state === 0) {
        output = [
            ctx.stylize("<pending>", "special")
        ];
    } else {
        ctx.indentationLvl += 2;
        const str = formatValue(ctx, result, recurseTimes);
        ctx.indentationLvl -= 2;
        output = [
            state === kRejected ? `${ctx.stylize("<rejected>", "special")} ${str}` : str
        ];
    }
    return output;
}
function formatWeakCollection(ctx) {
    return [
        ctx.stylize("<items unknown>", "special")
    ];
}
function formatWeakSet(ctx, value, recurseTimes) {
    const entries = value;
    return formatSetIterInner(ctx, recurseTimes, entries, 0);
}
function formatWeakMap(ctx, value, recurseTimes) {
    const entries = value;
    return formatMapIterInner(ctx, recurseTimes, entries, 0);
}
function formatProperty(ctx, value, recurseTimes, key, type, desc, original = value) {
    let name, str;
    let extra = " ";
    desc = desc || Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key],
        enumerable: true
    };
    if (desc.value !== undefined) {
        const diff = ctx.compact !== true || type !== 0 ? 2 : 3;
        ctx.indentationLvl += diff;
        str = formatValue(ctx, desc.value, recurseTimes);
        if (diff === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {
            extra = `\n${" ".repeat(ctx.indentationLvl)}`;
        }
        ctx.indentationLvl -= diff;
    } else if (desc.get !== undefined) {
        const label = desc.set !== undefined ? "Getter/Setter" : "Getter";
        const s = ctx.stylize;
        const sp = "special";
        if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === undefined || ctx.getters === "set" && desc.set !== undefined)) {
            try {
                const tmp = desc.get.call(original);
                ctx.indentationLvl += 2;
                if (tmp === null) {
                    str = `${s(`[${label}:`, sp)} ${s("null", "null")}${s("]", sp)}`;
                } else if (typeof tmp === "object") {
                    str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
                } else {
                    const primitive = formatPrimitive(s, tmp, ctx);
                    str = `${s(`[${label}:`, sp)} ${primitive}${s("]", sp)}`;
                }
                ctx.indentationLvl -= 2;
            } catch (err) {
                const message = `<Inspection threw (${err.message})>`;
                str = `${s(`[${label}:`, sp)} ${message}${s("]", sp)}`;
            }
        } else {
            str = ctx.stylize(`[${label}]`, sp);
        }
    } else if (desc.set !== undefined) {
        str = ctx.stylize("[Setter]", "special");
    } else {
        str = ctx.stylize("undefined", "undefined");
    }
    if (type === 1) {
        return str;
    }
    if (typeof key === "symbol") {
        const tmp = key.toString().replace(strEscapeSequencesReplacer, escapeFn);
        name = `[${ctx.stylize(tmp, "symbol")}]`;
    } else if (key === "__proto__") {
        name = "['__proto__']";
    } else if (desc.enumerable === false) {
        const tmp = key.replace(strEscapeSequencesReplacer, escapeFn);
        name = `[${tmp}]`;
    } else if (keyStrRegExp.test(key)) {
        name = ctx.stylize(key, "name");
    } else {
        name = ctx.stylize(strEscape(key), "string");
    }
    return `${name}:${extra}${str}`;
}
function handleMaxCallStackSize(_ctx, _err, _constructorName, _indentationLvl) {}
const colorRegExp = /\u001b\[\d\d?m/g;
function removeColors(str) {
    return str.replace(colorRegExp, "");
}
function isBelowBreakLength(ctx, output, start, base) {
    let totalLength = output.length + start;
    if (totalLength + output.length > ctx.breakLength) {
        return false;
    }
    for(let i = 0; i < output.length; i++){
        if (ctx.colors) {
            totalLength += removeColors(output[i]).length;
        } else {
            totalLength += output[i].length;
        }
        if (totalLength > ctx.breakLength) {
            return false;
        }
    }
    return base === "" || !base.includes("\n");
}
function formatBigInt(fn, value) {
    return fn(`${value}n`, "bigint");
}
function formatNamespaceObject(keys, ctx, value, recurseTimes) {
    const output = new Array(keys.length);
    for(let i = 0; i < keys.length; i++){
        try {
            output[i] = formatProperty(ctx, value, recurseTimes, keys[i], kObjectType);
        } catch (_err) {
            const tmp = {
                [keys[i]]: ""
            };
            output[i] = formatProperty(ctx, tmp, recurseTimes, keys[i], kObjectType);
            const pos = output[i].lastIndexOf(" ");
            output[i] = output[i].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
        }
    }
    keys.length = 0;
    return output;
}
function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {
    const keys = Object.keys(value);
    let index = i;
    for(; i < keys.length && output.length < maxLength; i++){
        const key = keys[i];
        const tmp = +key;
        if (tmp > 2 ** 32 - 2) {
            break;
        }
        if (`${index}` !== key) {
            if (!numberRegExp.test(key)) {
                break;
            }
            const emptyItems = tmp - index;
            const ending = emptyItems > 1 ? "s" : "";
            const message = `<${emptyItems} empty item${ending}>`;
            output.push(ctx.stylize(message, "undefined"));
            index = tmp;
            if (output.length === maxLength) {
                break;
            }
        }
        output.push(formatProperty(ctx, value, recurseTimes, key, 1));
        index++;
    }
    const remaining = value.length - index;
    if (output.length !== maxLength) {
        if (remaining > 0) {
            const ending = remaining > 1 ? "s" : "";
            const message = `<${remaining} empty item${ending}>`;
            output.push(ctx.stylize(message, "undefined"));
        }
    } else if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getBoxedBase(value, ctx, keys, constructor, tag) {
    let type;
    if (isNumberObject1(value)) {
        type = "Number";
    } else if (isStringObject1(value)) {
        type = "String";
        keys.splice(0, value.length);
    } else if (isBooleanObject1(value)) {
        type = "Boolean";
    } else if (isBigIntObject1(value)) {
        type = "BigInt";
    } else {
        type = "Symbol";
    }
    let base = `[${type}`;
    if (type !== constructor) {
        if (constructor === null) {
            base += " (null prototype)";
        } else {
            base += ` (${constructor})`;
        }
    }
    base += `: ${formatPrimitive(stylizeNoColor, value.valueOf(), ctx)}]`;
    if (tag !== "" && tag !== constructor) {
        base += ` [${tag}]`;
    }
    if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
        return base;
    }
    return ctx.stylize(base, type.toLowerCase());
}
function getClassBase(value, constructor, tag) {
    const hasName = value.hasOwnProperty("name");
    const name = hasName && value.name || "(anonymous)";
    let base = `class ${name}`;
    if (constructor !== "Function" && constructor !== null) {
        base += ` [${constructor}]`;
    }
    if (tag !== "" && constructor !== tag) {
        base += ` [${tag}]`;
    }
    if (constructor !== null) {
        const superName = Object.getPrototypeOf(value).name;
        if (superName) {
            base += ` extends ${superName}`;
        }
    } else {
        base += " extends [null prototype]";
    }
    return `[${base}]`;
}
function reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value) {
    if (ctx.compact !== true) {
        if (typeof ctx.compact === "number" && ctx.compact >= 1) {
            const entries = output.length;
            if (extrasType === 2 && entries > 6) {
                output = groupArrayElements(ctx, output, value);
            }
            if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
                const start = output.length + ctx.indentationLvl + braces[0].length + base.length + 10;
                if (isBelowBreakLength(ctx, output, start, base)) {
                    return `${base ? `${base} ` : ""}${braces[0]} ${join(output, ", ")}` + ` ${braces[1]}`;
                }
            }
        }
        const indentation = `\n${" ".repeat(ctx.indentationLvl)}`;
        return `${base ? `${base} ` : ""}${braces[0]}${indentation}  ` + `${join(output, `,${indentation}  `)}${indentation}${braces[1]}`;
    }
    if (isBelowBreakLength(ctx, output, 0, base)) {
        return `${braces[0]}${base ? ` ${base}` : ""} ${join(output, ", ")} ` + braces[1];
    }
    const indentation = " ".repeat(ctx.indentationLvl);
    const ln = base === "" && braces[0].length === 1 ? " " : `${base ? ` ${base}` : ""}\n${indentation}  `;
    return `${braces[0]}${ln}${join(output, `,\n${indentation}  `)} ${braces[1]}`;
}
function join(output, separator) {
    let str = "";
    if (output.length !== 0) {
        const lastIndex = output.length - 1;
        for(let i = 0; i < lastIndex; i++){
            str += output[i];
            str += separator;
        }
        str += output[lastIndex];
    }
    return str;
}
function groupArrayElements(ctx, output, value) {
    let totalLength = 0;
    let maxLength = 0;
    let i = 0;
    let outputLength = output.length;
    if (ctx.maxArrayLength < output.length) {
        outputLength--;
    }
    const separatorSpace = 2;
    const dataLen = new Array(outputLength);
    for(; i < outputLength; i++){
        const len = getStringWidth(output[i], ctx.colors);
        dataLen[i] = len;
        totalLength += len + separatorSpace;
        if (maxLength < len) {
            maxLength = len;
        }
    }
    const actualMax = maxLength + 2;
    if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
        const averageBias = Math.sqrt(actualMax - totalLength / output.length);
        const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
        const columns = Math.min(Math.round(Math.sqrt(2.5 * biasedMax * outputLength) / biasedMax), Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);
        if (columns <= 1) {
            return output;
        }
        const tmp = [];
        const maxLineLength = [];
        for(let i = 0; i < columns; i++){
            let lineMaxLength = 0;
            for(let j = i; j < output.length; j += columns){
                if (dataLen[j] > lineMaxLength) {
                    lineMaxLength = dataLen[j];
                }
            }
            lineMaxLength += separatorSpace;
            maxLineLength[i] = lineMaxLength;
        }
        let order = String.prototype.padStart;
        if (value !== undefined) {
            for(let i = 0; i < output.length; i++){
                if (typeof value[i] !== "number" && typeof value[i] !== "bigint") {
                    order = String.prototype.padEnd;
                    break;
                }
            }
        }
        for(let i = 0; i < outputLength; i += columns){
            const max = Math.min(i + columns, outputLength);
            let str = "";
            let j = i;
            for(; j < max - 1; j++){
                const padding = maxLineLength[j - i] + output[j].length - dataLen[j];
                str += `${output[j]}, `.padStart(padding, " ");
            }
            if (order === String.prototype.padStart) {
                const padding = maxLineLength[j - i] + output[j].length - dataLen[j] - 2;
                str += output[j].padStart(padding, " ");
            } else {
                str += output[j];
            }
            Array.prototype.push.call(tmp, str);
        }
        if (ctx.maxArrayLength < output.length) {
            Array.prototype.push.call(tmp, output[outputLength]);
        }
        output = tmp;
    }
    return output;
}
function formatMapIterInner(ctx, recurseTimes, entries, state) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const len = entries.length / 2;
    const remaining = len - maxArrayLength;
    const maxLength = Math.min(maxArrayLength, len);
    let output = new Array(maxLength);
    let i = 0;
    ctx.indentationLvl += 2;
    if (state === 0) {
        for(; i < maxLength; i++){
            const pos = i * 2;
            output[i] = `${formatValue(ctx, entries[pos], recurseTimes)} => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
        }
        if (!ctx.sorted) {
            output = output.sort();
        }
    } else {
        for(; i < maxLength; i++){
            const pos = i * 2;
            const res = [
                formatValue(ctx, entries[pos], recurseTimes),
                formatValue(ctx, entries[pos + 1], recurseTimes)
            ];
            output[i] = reduceToSingleString(ctx, res, "", [
                "[",
                "]"
            ], kArrayExtrasType, recurseTimes);
        }
    }
    ctx.indentationLvl -= 2;
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function formatSetIterInner(ctx, recurseTimes, entries, state) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const maxLength = Math.min(maxArrayLength, entries.length);
    const output = new Array(maxLength);
    ctx.indentationLvl += 2;
    for(let i = 0; i < maxLength; i++){
        output[i] = formatValue(ctx, entries[i], recurseTimes);
    }
    ctx.indentationLvl -= 2;
    if (state === 0 && !ctx.sorted) {
        output.sort();
    }
    const remaining = entries.length - maxLength;
    if (remaining > 0) {
        Array.prototype.push.call(output, `... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
const ansiPattern = "[\\u001B\\u009B][[\\]()#;?]*" + "(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*" + "|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)" + "|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
const ansi = new RegExp(ansiPattern, "g");
function getStringWidth(str, removeControlChars = true) {
    let width = 0;
    if (removeControlChars) {
        str = stripVTControlCharacters(str);
    }
    str = str.normalize("NFC");
    for (const __char of str[Symbol.iterator]()){
        const code = __char.codePointAt(0);
        if (isFullWidthCodePoint(code)) {
            width += 2;
        } else if (!isZeroWidthCodePoint(code)) {
            width++;
        }
    }
    return width;
}
const isFullWidthCodePoint = (code)=>{
    return code >= 0x1100 && (code <= 0x115f || code === 0x2329 || code === 0x232a || code >= 0x2e80 && code <= 0x3247 && code !== 0x303f || code >= 0x3250 && code <= 0x4dbf || code >= 0x4e00 && code <= 0xa4c6 || code >= 0xa960 && code <= 0xa97c || code >= 0xac00 && code <= 0xd7a3 || code >= 0xf900 && code <= 0xfaff || code >= 0xfe10 && code <= 0xfe19 || code >= 0xfe30 && code <= 0xfe6b || code >= 0xff01 && code <= 0xff60 || code >= 0xffe0 && code <= 0xffe6 || code >= 0x1b000 && code <= 0x1b001 || code >= 0x1f200 && code <= 0x1f251 || code >= 0x1f300 && code <= 0x1f64f || code >= 0x20000 && code <= 0x3fffd);
};
const isZeroWidthCodePoint = (code)=>{
    return code <= 0x1F || code >= 0x7F && code <= 0x9F || code >= 0x300 && code <= 0x36F || code >= 0x200B && code <= 0x200F || code >= 0x20D0 && code <= 0x20FF || code >= 0xFE00 && code <= 0xFE0F || code >= 0xFE20 && code <= 0xFE2F || code >= 0xE0100 && code <= 0xE01EF;
};
function hasBuiltInToString(value) {
    const proxyTarget = undefined;
    if (proxyTarget !== undefined) {
        value = proxyTarget;
    }
    if (typeof value.toString !== "function") {
        return true;
    }
    if (Object.prototype.hasOwnProperty.call(value, "toString")) {
        return false;
    }
    let pointer = value;
    do {
        pointer = Object.getPrototypeOf(pointer);
    }while (!Object.prototype.hasOwnProperty.call(pointer, "toString"))
    const descriptor = Object.getOwnPropertyDescriptor(pointer, "constructor");
    return descriptor !== undefined && typeof descriptor.value === "function" && builtInObjects.has(descriptor.value.name);
}
const firstErrorLine = (error)=>error.message.split("\n", 1)[0];
let CIRCULAR_ERROR_MESSAGE;
function tryStringify(arg) {
    try {
        return JSON.stringify(arg);
    } catch (err) {
        if (!CIRCULAR_ERROR_MESSAGE) {
            try {
                const a = {};
                a.a = a;
                JSON.stringify(a);
            } catch (circularError) {
                CIRCULAR_ERROR_MESSAGE = firstErrorLine(circularError);
            }
        }
        if (err.name === "TypeError" && firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {
            return "[Circular]";
        }
        throw err;
    }
}
function format(...args) {
    return formatWithOptionsInternal(undefined, args);
}
function formatWithOptions(inspectOptions, ...args) {
    if (typeof inspectOptions !== "object" || inspectOptions === null) {
        throw new codes.ERR_INVALID_ARG_TYPE("inspectOptions", "object", inspectOptions);
    }
    return formatWithOptionsInternal(inspectOptions, args);
}
function formatNumberNoColor(number, options) {
    return formatNumber(stylizeNoColor, number, options?.numericSeparator ?? inspectDefaultOptions.numericSeparator);
}
function formatBigIntNoColor(bigint, options) {
    return formatBigInt(stylizeNoColor, bigint, options?.numericSeparator ?? inspectDefaultOptions.numericSeparator);
}
function formatWithOptionsInternal(inspectOptions, args) {
    const first = args[0];
    let a = 0;
    let str = "";
    let join = "";
    if (typeof first === "string") {
        if (args.length === 1) {
            return first;
        }
        let tempStr;
        let lastPos = 0;
        for(let i = 0; i < first.length - 1; i++){
            if (first.charCodeAt(i) === 37) {
                const nextChar = first.charCodeAt(++i);
                if (a + 1 !== args.length) {
                    switch(nextChar){
                        case 115:
                            const tempArg = args[++a];
                            if (typeof tempArg === "number") {
                                tempStr = formatNumberNoColor(tempArg, inspectOptions);
                            } else if (typeof tempArg === "bigint") {
                                tempStr = formatBigIntNoColor(tempArg, inspectOptions);
                            } else if (typeof tempArg !== "object" || tempArg === null || !hasBuiltInToString(tempArg)) {
                                tempStr = String(tempArg);
                            } else {
                                tempStr = inspect(tempArg, {
                                    ...inspectOptions,
                                    compact: 3,
                                    colors: false,
                                    depth: 0
                                });
                            }
                            break;
                        case 106:
                            tempStr = tryStringify(args[++a]);
                            break;
                        case 100:
                            const tempNum = args[++a];
                            if (typeof tempNum === "bigint") {
                                tempStr = formatBigIntNoColor(tempNum, inspectOptions);
                            } else if (typeof tempNum === "symbol") {
                                tempStr = "NaN";
                            } else {
                                tempStr = formatNumberNoColor(Number(tempNum), inspectOptions);
                            }
                            break;
                        case 79:
                            tempStr = inspect(args[++a], inspectOptions);
                            break;
                        case 111:
                            tempStr = inspect(args[++a], {
                                ...inspectOptions,
                                showHidden: true,
                                showProxy: true,
                                depth: 4
                            });
                            break;
                        case 105:
                            const tempInteger = args[++a];
                            if (typeof tempInteger === "bigint") {
                                tempStr = formatBigIntNoColor(tempInteger, inspectOptions);
                            } else if (typeof tempInteger === "symbol") {
                                tempStr = "NaN";
                            } else {
                                tempStr = formatNumberNoColor(Number.parseInt(tempInteger), inspectOptions);
                            }
                            break;
                        case 102:
                            const tempFloat = args[++a];
                            if (typeof tempFloat === "symbol") {
                                tempStr = "NaN";
                            } else {
                                tempStr = formatNumberNoColor(Number.parseFloat(tempFloat), inspectOptions);
                            }
                            break;
                        case 99:
                            a += 1;
                            tempStr = "";
                            break;
                        case 37:
                            str += first.slice(lastPos, i);
                            lastPos = i + 1;
                            continue;
                        default:
                            continue;
                    }
                    if (lastPos !== i - 1) {
                        str += first.slice(lastPos, i - 1);
                    }
                    str += tempStr;
                    lastPos = i + 1;
                } else if (nextChar === 37) {
                    str += first.slice(lastPos, i);
                    lastPos = i + 1;
                }
            }
        }
        if (lastPos !== 0) {
            a++;
            join = " ";
            if (lastPos < first.length) {
                str += first.slice(lastPos);
            }
        }
    }
    while(a < args.length){
        const value = args[a];
        str += join;
        str += typeof value !== "string" ? inspect(value, inspectOptions) : value;
        join = " ";
        a++;
    }
    return str;
}
function stripVTControlCharacters(str) {
    validateString(str, "str");
    return str.replace(ansi, "");
}
const __default1 = {
    format,
    getStringWidth,
    inspect,
    stripVTControlCharacters,
    formatWithOptions
};
let os;
if (Deno.build.os === "darwin") {
    os = {
        UV_UDP_REUSEADDR: 4,
        dlopen: {
            RTLD_LAZY: 1,
            RTLD_NOW: 2,
            RTLD_GLOBAL: 8,
            RTLD_LOCAL: 4
        },
        errno: {
            E2BIG: 7,
            EACCES: 13,
            EADDRINUSE: 48,
            EADDRNOTAVAIL: 49,
            EAFNOSUPPORT: 47,
            EAGAIN: 35,
            EALREADY: 37,
            EBADF: 9,
            EBADMSG: 94,
            EBUSY: 16,
            ECANCELED: 89,
            ECHILD: 10,
            ECONNABORTED: 53,
            ECONNREFUSED: 61,
            ECONNRESET: 54,
            EDEADLK: 11,
            EDESTADDRREQ: 39,
            EDOM: 33,
            EDQUOT: 69,
            EEXIST: 17,
            EFAULT: 14,
            EFBIG: 27,
            EHOSTUNREACH: 65,
            EIDRM: 90,
            EILSEQ: 92,
            EINPROGRESS: 36,
            EINTR: 4,
            EINVAL: 22,
            EIO: 5,
            EISCONN: 56,
            EISDIR: 21,
            ELOOP: 62,
            EMFILE: 24,
            EMLINK: 31,
            EMSGSIZE: 40,
            EMULTIHOP: 95,
            ENAMETOOLONG: 63,
            ENETDOWN: 50,
            ENETRESET: 52,
            ENETUNREACH: 51,
            ENFILE: 23,
            ENOBUFS: 55,
            ENODATA: 96,
            ENODEV: 19,
            ENOENT: 2,
            ENOEXEC: 8,
            ENOLCK: 77,
            ENOLINK: 97,
            ENOMEM: 12,
            ENOMSG: 91,
            ENOPROTOOPT: 42,
            ENOSPC: 28,
            ENOSR: 98,
            ENOSTR: 99,
            ENOSYS: 78,
            ENOTCONN: 57,
            ENOTDIR: 20,
            ENOTEMPTY: 66,
            ENOTSOCK: 38,
            ENOTSUP: 45,
            ENOTTY: 25,
            ENXIO: 6,
            EOPNOTSUPP: 102,
            EOVERFLOW: 84,
            EPERM: 1,
            EPIPE: 32,
            EPROTO: 100,
            EPROTONOSUPPORT: 43,
            EPROTOTYPE: 41,
            ERANGE: 34,
            EROFS: 30,
            ESPIPE: 29,
            ESRCH: 3,
            ESTALE: 70,
            ETIME: 101,
            ETIMEDOUT: 60,
            ETXTBSY: 26,
            EWOULDBLOCK: 35,
            EXDEV: 18
        },
        signals: {
            SIGHUP: 1,
            SIGINT: 2,
            SIGQUIT: 3,
            SIGILL: 4,
            SIGTRAP: 5,
            SIGABRT: 6,
            SIGIOT: 6,
            SIGBUS: 10,
            SIGFPE: 8,
            SIGKILL: 9,
            SIGUSR1: 30,
            SIGSEGV: 11,
            SIGUSR2: 31,
            SIGPIPE: 13,
            SIGALRM: 14,
            SIGTERM: 15,
            SIGCHLD: 20,
            SIGCONT: 19,
            SIGSTOP: 17,
            SIGTSTP: 18,
            SIGTTIN: 21,
            SIGTTOU: 22,
            SIGURG: 16,
            SIGXCPU: 24,
            SIGXFSZ: 25,
            SIGVTALRM: 26,
            SIGPROF: 27,
            SIGWINCH: 28,
            SIGIO: 23,
            SIGINFO: 29,
            SIGSYS: 12
        },
        priority: {
            PRIORITY_LOW: 19,
            PRIORITY_BELOW_NORMAL: 10,
            PRIORITY_NORMAL: 0,
            PRIORITY_ABOVE_NORMAL: -7,
            PRIORITY_HIGH: -14,
            PRIORITY_HIGHEST: -20
        }
    };
} else if (Deno.build.os === "linux") {
    os = {
        UV_UDP_REUSEADDR: 4,
        dlopen: {
            RTLD_LAZY: 1,
            RTLD_NOW: 2,
            RTLD_GLOBAL: 256,
            RTLD_LOCAL: 0,
            RTLD_DEEPBIND: 8
        },
        errno: {
            E2BIG: 7,
            EACCES: 13,
            EADDRINUSE: 98,
            EADDRNOTAVAIL: 99,
            EAFNOSUPPORT: 97,
            EAGAIN: 11,
            EALREADY: 114,
            EBADF: 9,
            EBADMSG: 74,
            EBUSY: 16,
            ECANCELED: 125,
            ECHILD: 10,
            ECONNABORTED: 103,
            ECONNREFUSED: 111,
            ECONNRESET: 104,
            EDEADLK: 35,
            EDESTADDRREQ: 89,
            EDOM: 33,
            EDQUOT: 122,
            EEXIST: 17,
            EFAULT: 14,
            EFBIG: 27,
            EHOSTUNREACH: 113,
            EIDRM: 43,
            EILSEQ: 84,
            EINPROGRESS: 115,
            EINTR: 4,
            EINVAL: 22,
            EIO: 5,
            EISCONN: 106,
            EISDIR: 21,
            ELOOP: 40,
            EMFILE: 24,
            EMLINK: 31,
            EMSGSIZE: 90,
            EMULTIHOP: 72,
            ENAMETOOLONG: 36,
            ENETDOWN: 100,
            ENETRESET: 102,
            ENETUNREACH: 101,
            ENFILE: 23,
            ENOBUFS: 105,
            ENODATA: 61,
            ENODEV: 19,
            ENOENT: 2,
            ENOEXEC: 8,
            ENOLCK: 37,
            ENOLINK: 67,
            ENOMEM: 12,
            ENOMSG: 42,
            ENOPROTOOPT: 92,
            ENOSPC: 28,
            ENOSR: 63,
            ENOSTR: 60,
            ENOSYS: 38,
            ENOTCONN: 107,
            ENOTDIR: 20,
            ENOTEMPTY: 39,
            ENOTSOCK: 88,
            ENOTSUP: 95,
            ENOTTY: 25,
            ENXIO: 6,
            EOPNOTSUPP: 95,
            EOVERFLOW: 75,
            EPERM: 1,
            EPIPE: 32,
            EPROTO: 71,
            EPROTONOSUPPORT: 93,
            EPROTOTYPE: 91,
            ERANGE: 34,
            EROFS: 30,
            ESPIPE: 29,
            ESRCH: 3,
            ESTALE: 116,
            ETIME: 62,
            ETIMEDOUT: 110,
            ETXTBSY: 26,
            EWOULDBLOCK: 11,
            EXDEV: 18
        },
        signals: {
            SIGHUP: 1,
            SIGINT: 2,
            SIGQUIT: 3,
            SIGILL: 4,
            SIGTRAP: 5,
            SIGABRT: 6,
            SIGIOT: 6,
            SIGBUS: 7,
            SIGFPE: 8,
            SIGKILL: 9,
            SIGUSR1: 10,
            SIGSEGV: 11,
            SIGUSR2: 12,
            SIGPIPE: 13,
            SIGALRM: 14,
            SIGTERM: 15,
            SIGCHLD: 17,
            SIGSTKFLT: 16,
            SIGCONT: 18,
            SIGSTOP: 19,
            SIGTSTP: 20,
            SIGTTIN: 21,
            SIGTTOU: 22,
            SIGURG: 23,
            SIGXCPU: 24,
            SIGXFSZ: 25,
            SIGVTALRM: 26,
            SIGPROF: 27,
            SIGWINCH: 28,
            SIGIO: 29,
            SIGPOLL: 29,
            SIGPWR: 30,
            SIGSYS: 31,
            SIGUNUSED: 31
        },
        priority: {
            PRIORITY_LOW: 19,
            PRIORITY_BELOW_NORMAL: 10,
            PRIORITY_NORMAL: 0,
            PRIORITY_ABOVE_NORMAL: -7,
            PRIORITY_HIGH: -14,
            PRIORITY_HIGHEST: -20
        }
    };
} else {
    os = {
        UV_UDP_REUSEADDR: 4,
        dlopen: {},
        errno: {
            E2BIG: 7,
            EACCES: 13,
            EADDRINUSE: 100,
            EADDRNOTAVAIL: 101,
            EAFNOSUPPORT: 102,
            EAGAIN: 11,
            EALREADY: 103,
            EBADF: 9,
            EBADMSG: 104,
            EBUSY: 16,
            ECANCELED: 105,
            ECHILD: 10,
            ECONNABORTED: 106,
            ECONNREFUSED: 107,
            ECONNRESET: 108,
            EDEADLK: 36,
            EDESTADDRREQ: 109,
            EDOM: 33,
            EEXIST: 17,
            EFAULT: 14,
            EFBIG: 27,
            EHOSTUNREACH: 110,
            EIDRM: 111,
            EILSEQ: 42,
            EINPROGRESS: 112,
            EINTR: 4,
            EINVAL: 22,
            EIO: 5,
            EISCONN: 113,
            EISDIR: 21,
            ELOOP: 114,
            EMFILE: 24,
            EMLINK: 31,
            EMSGSIZE: 115,
            ENAMETOOLONG: 38,
            ENETDOWN: 116,
            ENETRESET: 117,
            ENETUNREACH: 118,
            ENFILE: 23,
            ENOBUFS: 119,
            ENODATA: 120,
            ENODEV: 19,
            ENOENT: 2,
            ENOEXEC: 8,
            ENOLCK: 39,
            ENOLINK: 121,
            ENOMEM: 12,
            ENOMSG: 122,
            ENOPROTOOPT: 123,
            ENOSPC: 28,
            ENOSR: 124,
            ENOSTR: 125,
            ENOSYS: 40,
            ENOTCONN: 126,
            ENOTDIR: 20,
            ENOTEMPTY: 41,
            ENOTSOCK: 128,
            ENOTSUP: 129,
            ENOTTY: 25,
            ENXIO: 6,
            EOPNOTSUPP: 130,
            EOVERFLOW: 132,
            EPERM: 1,
            EPIPE: 32,
            EPROTO: 134,
            EPROTONOSUPPORT: 135,
            EPROTOTYPE: 136,
            ERANGE: 34,
            EROFS: 30,
            ESPIPE: 29,
            ESRCH: 3,
            ETIME: 137,
            ETIMEDOUT: 138,
            ETXTBSY: 139,
            EWOULDBLOCK: 140,
            EXDEV: 18,
            WSAEINTR: 10004,
            WSAEBADF: 10009,
            WSAEACCES: 10013,
            WSAEFAULT: 10014,
            WSAEINVAL: 10022,
            WSAEMFILE: 10024,
            WSAEWOULDBLOCK: 10035,
            WSAEINPROGRESS: 10036,
            WSAEALREADY: 10037,
            WSAENOTSOCK: 10038,
            WSAEDESTADDRREQ: 10039,
            WSAEMSGSIZE: 10040,
            WSAEPROTOTYPE: 10041,
            WSAENOPROTOOPT: 10042,
            WSAEPROTONOSUPPORT: 10043,
            WSAESOCKTNOSUPPORT: 10044,
            WSAEOPNOTSUPP: 10045,
            WSAEPFNOSUPPORT: 10046,
            WSAEAFNOSUPPORT: 10047,
            WSAEADDRINUSE: 10048,
            WSAEADDRNOTAVAIL: 10049,
            WSAENETDOWN: 10050,
            WSAENETUNREACH: 10051,
            WSAENETRESET: 10052,
            WSAECONNABORTED: 10053,
            WSAECONNRESET: 10054,
            WSAENOBUFS: 10055,
            WSAEISCONN: 10056,
            WSAENOTCONN: 10057,
            WSAESHUTDOWN: 10058,
            WSAETOOMANYREFS: 10059,
            WSAETIMEDOUT: 10060,
            WSAECONNREFUSED: 10061,
            WSAELOOP: 10062,
            WSAENAMETOOLONG: 10063,
            WSAEHOSTDOWN: 10064,
            WSAEHOSTUNREACH: 10065,
            WSAENOTEMPTY: 10066,
            WSAEPROCLIM: 10067,
            WSAEUSERS: 10068,
            WSAEDQUOT: 10069,
            WSAESTALE: 10070,
            WSAEREMOTE: 10071,
            WSASYSNOTREADY: 10091,
            WSAVERNOTSUPPORTED: 10092,
            WSANOTINITIALISED: 10093,
            WSAEDISCON: 10101,
            WSAENOMORE: 10102,
            WSAECANCELLED: 10103,
            WSAEINVALIDPROCTABLE: 10104,
            WSAEINVALIDPROVIDER: 10105,
            WSAEPROVIDERFAILEDINIT: 10106,
            WSASYSCALLFAILURE: 10107,
            WSASERVICE_NOT_FOUND: 10108,
            WSATYPE_NOT_FOUND: 10109,
            WSA_E_NO_MORE: 10110,
            WSA_E_CANCELLED: 10111,
            WSAEREFUSED: 10112
        },
        signals: {
            SIGHUP: 1,
            SIGINT: 2,
            SIGILL: 4,
            SIGABRT: 22,
            SIGFPE: 8,
            SIGKILL: 9,
            SIGSEGV: 11,
            SIGTERM: 15,
            SIGBREAK: 21,
            SIGWINCH: 28
        },
        priority: {
            PRIORITY_LOW: 19,
            PRIORITY_BELOW_NORMAL: 10,
            PRIORITY_NORMAL: 0,
            PRIORITY_ABOVE_NORMAL: -7,
            PRIORITY_HIGH: -14,
            PRIORITY_HIGHEST: -20
        }
    };
}
const fs = {
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    UV_DIRENT_UNKNOWN: 0,
    UV_DIRENT_FILE: 1,
    UV_DIRENT_DIR: 2,
    UV_DIRENT_LINK: 3,
    UV_DIRENT_FIFO: 4,
    UV_DIRENT_SOCKET: 5,
    UV_DIRENT_CHAR: 6,
    UV_DIRENT_BLOCK: 7,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 512,
    O_EXCL: 2048,
    UV_FS_O_FILEMAP: 0,
    O_NOCTTY: 131072,
    O_TRUNC: 1024,
    O_APPEND: 8,
    O_DIRECTORY: 1048576,
    O_NOFOLLOW: 256,
    O_SYNC: 128,
    O_DSYNC: 4194304,
    O_SYMLINK: 2097152,
    O_NONBLOCK: 4,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_COPYFILE_EXCL: 1,
    COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_FICLONE_FORCE: 4
};
const crypto1 = {
    OPENSSL_VERSION_NUMBER: 269488319,
    SSL_OP_ALL: 2147485780,
    SSL_OP_ALLOW_NO_DHE_KEX: 1024,
    SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
    SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
    SSL_OP_CISCO_ANYCONNECT: 32768,
    SSL_OP_COOKIE_EXCHANGE: 8192,
    SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
    SSL_OP_EPHEMERAL_RSA: 0,
    SSL_OP_LEGACY_SERVER_CONNECT: 4,
    SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: 0,
    SSL_OP_MICROSOFT_SESS_ID_BUG: 0,
    SSL_OP_MSIE_SSLV2_RSA_PADDING: 0,
    SSL_OP_NETSCAPE_CA_DN_BUG: 0,
    SSL_OP_NETSCAPE_CHALLENGE_BUG: 0,
    SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: 0,
    SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: 0,
    SSL_OP_NO_COMPRESSION: 131072,
    SSL_OP_NO_ENCRYPT_THEN_MAC: 524288,
    SSL_OP_NO_QUERY_MTU: 4096,
    SSL_OP_NO_RENEGOTIATION: 1073741824,
    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
    SSL_OP_NO_SSLv2: 0,
    SSL_OP_NO_SSLv3: 33554432,
    SSL_OP_NO_TICKET: 16384,
    SSL_OP_NO_TLSv1: 67108864,
    SSL_OP_NO_TLSv1_1: 268435456,
    SSL_OP_NO_TLSv1_2: 134217728,
    SSL_OP_NO_TLSv1_3: 536870912,
    SSL_OP_PKCS1_CHECK_1: 0,
    SSL_OP_PKCS1_CHECK_2: 0,
    SSL_OP_PRIORITIZE_CHACHA: 2097152,
    SSL_OP_SINGLE_DH_USE: 0,
    SSL_OP_SINGLE_ECDH_USE: 0,
    SSL_OP_SSLEAY_080_CLIENT_DH_BUG: 0,
    SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: 0,
    SSL_OP_TLS_BLOCK_PADDING_BUG: 0,
    SSL_OP_TLS_D5_BUG: 0,
    SSL_OP_TLS_ROLLBACK_BUG: 8388608,
    ENGINE_METHOD_RSA: 1,
    ENGINE_METHOD_DSA: 2,
    ENGINE_METHOD_DH: 4,
    ENGINE_METHOD_RAND: 8,
    ENGINE_METHOD_EC: 2048,
    ENGINE_METHOD_CIPHERS: 64,
    ENGINE_METHOD_DIGESTS: 128,
    ENGINE_METHOD_PKEY_METHS: 512,
    ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
    ENGINE_METHOD_ALL: 65535,
    ENGINE_METHOD_NONE: 0,
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    RSA_PSS_SALTLEN_DIGEST: -1,
    RSA_PSS_SALTLEN_MAX_SIGN: -2,
    RSA_PSS_SALTLEN_AUTO: -2,
    defaultCoreCipherList: "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
    TLS1_VERSION: 769,
    TLS1_1_VERSION: 770,
    TLS1_2_VERSION: 771,
    TLS1_3_VERSION: 772,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
};
const zlib = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    ZLIB_VERNUM: 4784,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    BROTLI_DECODE: 8,
    BROTLI_ENCODE: 9,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_PARAM_MODE: 0,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31
};
const trace = {
    TRACE_EVENT_PHASE_BEGIN: 66,
    TRACE_EVENT_PHASE_END: 69,
    TRACE_EVENT_PHASE_COMPLETE: 88,
    TRACE_EVENT_PHASE_INSTANT: 73,
    TRACE_EVENT_PHASE_ASYNC_BEGIN: 83,
    TRACE_EVENT_PHASE_ASYNC_STEP_INTO: 84,
    TRACE_EVENT_PHASE_ASYNC_STEP_PAST: 112,
    TRACE_EVENT_PHASE_ASYNC_END: 70,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN: 98,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_END: 101,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT: 110,
    TRACE_EVENT_PHASE_FLOW_BEGIN: 115,
    TRACE_EVENT_PHASE_FLOW_STEP: 116,
    TRACE_EVENT_PHASE_FLOW_END: 102,
    TRACE_EVENT_PHASE_METADATA: 77,
    TRACE_EVENT_PHASE_COUNTER: 67,
    TRACE_EVENT_PHASE_SAMPLE: 80,
    TRACE_EVENT_PHASE_CREATE_OBJECT: 78,
    TRACE_EVENT_PHASE_SNAPSHOT_OBJECT: 79,
    TRACE_EVENT_PHASE_DELETE_OBJECT: 68,
    TRACE_EVENT_PHASE_MEMORY_DUMP: 118,
    TRACE_EVENT_PHASE_MARK: 82,
    TRACE_EVENT_PHASE_CLOCK_SYNC: 99,
    TRACE_EVENT_PHASE_ENTER_CONTEXT: 40,
    TRACE_EVENT_PHASE_LEAVE_CONTEXT: 41,
    TRACE_EVENT_PHASE_LINK_IDS: 61
};
const mod4 = {
    os: os,
    fs: fs,
    crypto: crypto1,
    zlib: zlib,
    trace: trace
};
const { errno: { ENOTDIR , ENOENT  }  } = os;
const kIsNodeError = Symbol("kIsNodeError");
const classRegExp1 = /^([A-Z][a-z0-9]*)+$/;
const kTypes = [
    "string",
    "function",
    "number",
    "object",
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol"
];
class AbortError extends Error {
    code;
    constructor(message = "The operation was aborted", options){
        if (options !== undefined && typeof options !== "object") {
            throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
    }
}
let maxStack_ErrorName;
let maxStack_ErrorMessage;
function isStackOverflowError(err) {
    if (maxStack_ErrorMessage === undefined) {
        try {
            function overflowStack() {
                overflowStack();
            }
            overflowStack();
        } catch (err) {
            maxStack_ErrorMessage = err.message;
            maxStack_ErrorName = err.name;
        }
    }
    return err && err.name === maxStack_ErrorName && err.message === maxStack_ErrorMessage;
}
function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3){
        res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
}
const captureLargerStackTrace = hideStackFrames(function captureLargerStackTrace(err) {
    Error.captureStackTrace(err);
    return err;
});
const uvExceptionWithHostPort = hideStackFrames(function uvExceptionWithHostPort(err, syscall, address, port) {
    const { 0: code , 1: uvmsg  } = uvErrmapGet(err) || uvUnmappedError;
    const message = `${syscall} ${code}: ${uvmsg}`;
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    const ex = new Error(`${message}${details}`);
    ex.code = code;
    ex.errno = err;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
const errnoException = hideStackFrames(function errnoException(err, syscall, original) {
    const code = getSystemErrorName(err);
    const message = original ? `${syscall} ${code} ${original}` : `${syscall} ${code}`;
    const ex = new Error(message);
    ex.errno = err;
    ex.code = code;
    ex.syscall = syscall;
    return captureLargerStackTrace(ex);
});
function uvErrmapGet(name) {
    return errorMap.get(name);
}
const uvUnmappedError = [
    "UNKNOWN",
    "unknown error"
];
const uvException = hideStackFrames(function uvException(ctx) {
    const { 0: code , 1: uvmsg  } = uvErrmapGet(ctx.errno) || uvUnmappedError;
    let message = `${code}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
    let path;
    let dest;
    if (ctx.path) {
        path = ctx.path.toString();
        message += ` '${path}'`;
    }
    if (ctx.dest) {
        dest = ctx.dest.toString();
        message += ` -> '${dest}'`;
    }
    const err = new Error(message);
    for (const prop of Object.keys(ctx)){
        if (prop === "message" || prop === "path" || prop === "dest") {
            continue;
        }
        err[prop] = ctx[prop];
    }
    err.code = code;
    if (path) {
        err.path = path;
    }
    if (dest) {
        err.dest = dest;
    }
    return captureLargerStackTrace(err);
});
const exceptionWithHostPort = hideStackFrames(function exceptionWithHostPort(err, syscall, address, port, additional) {
    const code = getSystemErrorName(err);
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    if (additional) {
        details += ` - Local (${additional})`;
    }
    const ex = new Error(`${syscall} ${code}${details}`);
    ex.errno = err;
    ex.code = code;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
const dnsException = hideStackFrames(function(code, syscall, hostname) {
    let errno;
    if (typeof code === "number") {
        errno = code;
        if (code === codeMap.get("EAI_NODATA") || code === codeMap.get("EAI_NONAME")) {
            code = "ENOTFOUND";
        } else {
            code = getSystemErrorName(code);
        }
    }
    const message = `${syscall} ${code}${hostname ? ` ${hostname}` : ""}`;
    const ex = new Error(message);
    ex.errno = errno;
    ex.code = code;
    ex.syscall = syscall;
    if (hostname) {
        ex.hostname = hostname;
    }
    return captureLargerStackTrace(ex);
});
class NodeErrorAbstraction extends Error {
    code;
    constructor(name, code, message){
        super(message);
        this.code = code;
        this.name = name;
        this.stack = this.stack && `${name} [${this.code}]${this.stack.slice(20)}`;
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
class NodeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(Error.prototype.name, code, message);
    }
}
class NodeSyntaxError extends NodeErrorAbstraction {
    constructor(code, message){
        super(SyntaxError.prototype.name, code, message);
        Object.setPrototypeOf(this, SyntaxError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeRangeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(RangeError.prototype.name, code, message);
        Object.setPrototypeOf(this, RangeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeTypeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(TypeError.prototype.name, code, message);
        Object.setPrototypeOf(this, TypeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeURIError extends NodeErrorAbstraction {
    constructor(code, message){
        super(URIError.prototype.name, code, message);
        Object.setPrototypeOf(this, URIError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeSystemError extends NodeErrorAbstraction {
    constructor(key, context, msgPrefix){
        let message = `${msgPrefix}: ${context.syscall} returned ` + `${context.code} (${context.message})`;
        if (context.path !== undefined) {
            message += ` ${context.path}`;
        }
        if (context.dest !== undefined) {
            message += ` => ${context.dest}`;
        }
        super("SystemError", key, message);
        captureLargerStackTrace(this);
        Object.defineProperties(this, {
            [kIsNodeError]: {
                value: true,
                enumerable: false,
                writable: false,
                configurable: true
            },
            info: {
                value: context,
                enumerable: true,
                configurable: true,
                writable: false
            },
            errno: {
                get () {
                    return context.errno;
                },
                set: (value)=>{
                    context.errno = value;
                },
                enumerable: true,
                configurable: true
            },
            syscall: {
                get () {
                    return context.syscall;
                },
                set: (value)=>{
                    context.syscall = value;
                },
                enumerable: true,
                configurable: true
            }
        });
        if (context.path !== undefined) {
            Object.defineProperty(this, "path", {
                get () {
                    return context.path;
                },
                set: (value)=>{
                    context.path = value;
                },
                enumerable: true,
                configurable: true
            });
        }
        if (context.dest !== undefined) {
            Object.defineProperty(this, "dest", {
                get () {
                    return context.dest;
                },
                set: (value)=>{
                    context.dest = value;
                },
                enumerable: true,
                configurable: true
            });
        }
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
function makeSystemErrorWithCode(key, msgPrfix) {
    return class NodeError extends NodeSystemError {
        constructor(ctx){
            super(key, ctx, msgPrfix);
        }
    };
}
const ERR_FS_EISDIR = makeSystemErrorWithCode("ERR_FS_EISDIR", "Path is a directory");
function createInvalidArgType(name, expected) {
    expected = Array.isArray(expected) ? expected : [
        expected
    ];
    let msg = "The ";
    if (name.endsWith(" argument")) {
        msg += `${name} `;
    } else {
        const type = name.includes(".") ? "property" : "argument";
        msg += `"${name}" ${type} `;
    }
    msg += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected){
        if (kTypes.includes(value)) {
            types.push(value.toLocaleLowerCase());
        } else if (classRegExp1.test(value)) {
            instances.push(value);
        } else {
            other.push(value);
        }
    }
    if (instances.length > 0) {
        const pos = types.indexOf("object");
        if (pos !== -1) {
            types.splice(pos, 1);
            instances.push("Object");
        }
    }
    if (types.length > 0) {
        if (types.length > 2) {
            const last = types.pop();
            msg += `one of type ${types.join(", ")}, or ${last}`;
        } else if (types.length === 2) {
            msg += `one of type ${types[0]} or ${types[1]}`;
        } else {
            msg += `of type ${types[0]}`;
        }
        if (instances.length > 0 || other.length > 0) {
            msg += " or ";
        }
    }
    if (instances.length > 0) {
        if (instances.length > 2) {
            const last = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last}`;
        } else {
            msg += `an instance of ${instances[0]}`;
            if (instances.length === 2) {
                msg += ` or ${instances[1]}`;
            }
        }
        if (other.length > 0) {
            msg += " or ";
        }
    }
    if (other.length > 0) {
        if (other.length > 2) {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
        } else if (other.length === 2) {
            msg += `one of ${other[0]} or ${other[1]}`;
        } else {
            if (other[0].toLowerCase() !== other[0]) {
                msg += "an ";
            }
            msg += `${other[0]}`;
        }
    }
    return msg;
}
class ERR_INVALID_ARG_TYPE_RANGE extends NodeRangeError {
    constructor(name, expected, actual){
        const msg = createInvalidArgType(name, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
}
class ERR_INVALID_ARG_TYPE extends NodeTypeError {
    constructor(name, expected, actual){
        const msg = createInvalidArgType(name, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
    static RangeError = ERR_INVALID_ARG_TYPE_RANGE;
}
class ERR_INVALID_ARG_VALUE_RANGE extends NodeRangeError {
    constructor(name, value, reason = "is invalid"){
        const type = name.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
    }
}
class ERR_INVALID_ARG_VALUE extends NodeTypeError {
    constructor(name, value, reason = "is invalid"){
        const type = name.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
    }
    static RangeError = ERR_INVALID_ARG_VALUE_RANGE;
}
function invalidArgTypeHelper(input) {
    if (input == null) {
        return ` Received ${input}`;
    }
    if (typeof input === "function" && input.name) {
        return ` Received function ${input.name}`;
    }
    if (typeof input === "object") {
        if (input.constructor && input.constructor.name) {
            return ` Received an instance of ${input.constructor.name}`;
        }
        return ` Received ${inspect(input, {
            depth: -1
        })}`;
    }
    let inspected = inspect(input, {
        colors: false
    });
    if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
    }
    return ` Received type ${typeof input} (${inspected})`;
}
class ERR_OUT_OF_RANGE extends RangeError {
    code = "ERR_OUT_OF_RANGE";
    constructor(str, range, input, replaceDefaultBoolean = false){
        assert(range, 'Missing "range" argument');
        let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
            received = String(input);
            if (input > 2n ** 32n || input < -(2n ** 32n)) {
                received = addNumericalSeparator(received);
            }
            received += "n";
        } else {
            received = inspect(input);
        }
        msg += ` It must be ${range}. Received ${received}`;
        super(msg);
        const { name  } = this;
        this.name = `${name} [${this.code}]`;
        this.stack;
        this.name = name;
    }
}
class ERR_AMBIGUOUS_ARGUMENT extends NodeTypeError {
    constructor(x, y){
        super("ERR_AMBIGUOUS_ARGUMENT", `The "${x}" argument is ambiguous. ${y}`);
    }
}
class ERR_ARG_NOT_ITERABLE extends NodeTypeError {
    constructor(x){
        super("ERR_ARG_NOT_ITERABLE", `${x} must be iterable`);
    }
}
class ERR_ASSERTION extends NodeError {
    constructor(x){
        super("ERR_ASSERTION", `${x}`);
    }
}
class ERR_ASYNC_CALLBACK extends NodeTypeError {
    constructor(x){
        super("ERR_ASYNC_CALLBACK", `${x} must be a function`);
    }
}
class ERR_ASYNC_TYPE extends NodeTypeError {
    constructor(x){
        super("ERR_ASYNC_TYPE", `Invalid name for async "type": ${x}`);
    }
}
class ERR_BROTLI_INVALID_PARAM extends NodeRangeError {
    constructor(x){
        super("ERR_BROTLI_INVALID_PARAM", `${x} is not a valid Brotli parameter`);
    }
}
class ERR_BUFFER_OUT_OF_BOUNDS extends NodeRangeError {
    constructor(name){
        super("ERR_BUFFER_OUT_OF_BOUNDS", name ? `"${name}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
    }
}
class ERR_BUFFER_TOO_LARGE extends NodeRangeError {
    constructor(x){
        super("ERR_BUFFER_TOO_LARGE", `Cannot create a Buffer larger than ${x} bytes`);
    }
}
class ERR_CANNOT_WATCH_SIGINT extends NodeError {
    constructor(){
        super("ERR_CANNOT_WATCH_SIGINT", "Cannot watch for SIGINT signals");
    }
}
class ERR_CHILD_CLOSED_BEFORE_REPLY extends NodeError {
    constructor(){
        super("ERR_CHILD_CLOSED_BEFORE_REPLY", "Child closed before reply received");
    }
}
class ERR_CHILD_PROCESS_IPC_REQUIRED extends NodeError {
    constructor(x){
        super("ERR_CHILD_PROCESS_IPC_REQUIRED", `Forked processes must have an IPC channel, missing value 'ipc' in ${x}`);
    }
}
class ERR_CHILD_PROCESS_STDIO_MAXBUFFER extends NodeRangeError {
    constructor(x){
        super("ERR_CHILD_PROCESS_STDIO_MAXBUFFER", `${x} maxBuffer length exceeded`);
    }
}
class ERR_CONSOLE_WRITABLE_STREAM extends NodeTypeError {
    constructor(x){
        super("ERR_CONSOLE_WRITABLE_STREAM", `Console expects a writable stream instance for ${x}`);
    }
}
class ERR_CONTEXT_NOT_INITIALIZED extends NodeError {
    constructor(){
        super("ERR_CONTEXT_NOT_INITIALIZED", "context used is not initialized");
    }
}
class ERR_CPU_USAGE extends NodeError {
    constructor(x){
        super("ERR_CPU_USAGE", `Unable to obtain cpu usage ${x}`);
    }
}
class ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED extends NodeError {
    constructor(){
        super("ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED", "Custom engines not supported by this OpenSSL");
    }
}
class ERR_CRYPTO_ECDH_INVALID_FORMAT extends NodeTypeError {
    constructor(x){
        super("ERR_CRYPTO_ECDH_INVALID_FORMAT", `Invalid ECDH format: ${x}`);
    }
}
class ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY extends NodeError {
    constructor(){
        super("ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY", "Public key is not valid for specified curve");
    }
}
class ERR_CRYPTO_ENGINE_UNKNOWN extends NodeError {
    constructor(x){
        super("ERR_CRYPTO_ENGINE_UNKNOWN", `Engine "${x}" was not found`);
    }
}
class ERR_CRYPTO_FIPS_FORCED extends NodeError {
    constructor(){
        super("ERR_CRYPTO_FIPS_FORCED", "Cannot set FIPS mode, it was forced with --force-fips at startup.");
    }
}
class ERR_CRYPTO_FIPS_UNAVAILABLE extends NodeError {
    constructor(){
        super("ERR_CRYPTO_FIPS_UNAVAILABLE", "Cannot set FIPS mode in a non-FIPS build.");
    }
}
class ERR_CRYPTO_HASH_FINALIZED extends NodeError {
    constructor(){
        super("ERR_CRYPTO_HASH_FINALIZED", "Digest already called");
    }
}
class ERR_CRYPTO_HASH_UPDATE_FAILED extends NodeError {
    constructor(){
        super("ERR_CRYPTO_HASH_UPDATE_FAILED", "Hash update failed");
    }
}
class ERR_CRYPTO_INCOMPATIBLE_KEY extends NodeError {
    constructor(x, y){
        super("ERR_CRYPTO_INCOMPATIBLE_KEY", `Incompatible ${x}: ${y}`);
    }
}
class ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS extends NodeError {
    constructor(x, y){
        super("ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS", `The selected key encoding ${x} ${y}.`);
    }
}
class ERR_CRYPTO_INVALID_DIGEST extends NodeTypeError {
    constructor(x){
        super("ERR_CRYPTO_INVALID_DIGEST", `Invalid digest: ${x}`);
    }
}
class ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE extends NodeTypeError {
    constructor(x, y){
        super("ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE", `Invalid key object type ${x}, expected ${y}.`);
    }
}
class ERR_CRYPTO_INVALID_STATE extends NodeError {
    constructor(x){
        super("ERR_CRYPTO_INVALID_STATE", `Invalid state for operation ${x}`);
    }
}
class ERR_CRYPTO_PBKDF2_ERROR extends NodeError {
    constructor(){
        super("ERR_CRYPTO_PBKDF2_ERROR", "PBKDF2 error");
    }
}
class ERR_CRYPTO_SCRYPT_INVALID_PARAMETER extends NodeError {
    constructor(){
        super("ERR_CRYPTO_SCRYPT_INVALID_PARAMETER", "Invalid scrypt parameter");
    }
}
class ERR_CRYPTO_SCRYPT_NOT_SUPPORTED extends NodeError {
    constructor(){
        super("ERR_CRYPTO_SCRYPT_NOT_SUPPORTED", "Scrypt algorithm not supported");
    }
}
class ERR_CRYPTO_SIGN_KEY_REQUIRED extends NodeError {
    constructor(){
        super("ERR_CRYPTO_SIGN_KEY_REQUIRED", "No key provided to sign");
    }
}
class ERR_DIR_CLOSED extends NodeError {
    constructor(){
        super("ERR_DIR_CLOSED", "Directory handle was closed");
    }
}
class ERR_DIR_CONCURRENT_OPERATION extends NodeError {
    constructor(){
        super("ERR_DIR_CONCURRENT_OPERATION", "Cannot do synchronous work on directory handle with concurrent asynchronous operations");
    }
}
class ERR_DNS_SET_SERVERS_FAILED extends NodeError {
    constructor(x, y){
        super("ERR_DNS_SET_SERVERS_FAILED", `c-ares failed to set servers: "${x}" [${y}]`);
    }
}
class ERR_DOMAIN_CALLBACK_NOT_AVAILABLE extends NodeError {
    constructor(){
        super("ERR_DOMAIN_CALLBACK_NOT_AVAILABLE", "A callback was registered through " + "process.setUncaughtExceptionCaptureCallback(), which is mutually " + "exclusive with using the `domain` module");
    }
}
class ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE extends NodeError {
    constructor(){
        super("ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE", "The `domain` module is in use, which is mutually exclusive with calling " + "process.setUncaughtExceptionCaptureCallback()");
    }
}
class ERR_ENCODING_INVALID_ENCODED_DATA extends NodeErrorAbstraction {
    errno;
    constructor(encoding, ret){
        super(TypeError.prototype.name, "ERR_ENCODING_INVALID_ENCODED_DATA", `The encoded data was not valid for encoding ${encoding}`);
        Object.setPrototypeOf(this, TypeError.prototype);
        this.errno = ret;
    }
}
class ERR_ENCODING_NOT_SUPPORTED extends NodeRangeError {
    constructor(x){
        super("ERR_ENCODING_NOT_SUPPORTED", `The "${x}" encoding is not supported`);
    }
}
class ERR_EVAL_ESM_CANNOT_PRINT extends NodeError {
    constructor(){
        super("ERR_EVAL_ESM_CANNOT_PRINT", `--print cannot be used with ESM input`);
    }
}
class ERR_EVENT_RECURSION extends NodeError {
    constructor(x){
        super("ERR_EVENT_RECURSION", `The event "${x}" is already being dispatched`);
    }
}
class ERR_FEATURE_UNAVAILABLE_ON_PLATFORM extends NodeTypeError {
    constructor(x){
        super("ERR_FEATURE_UNAVAILABLE_ON_PLATFORM", `The feature ${x} is unavailable on the current platform, which is being used to run Node.js`);
    }
}
class ERR_FS_FILE_TOO_LARGE extends NodeRangeError {
    constructor(x){
        super("ERR_FS_FILE_TOO_LARGE", `File size (${x}) is greater than 2 GB`);
    }
}
class ERR_FS_INVALID_SYMLINK_TYPE extends NodeError {
    constructor(x){
        super("ERR_FS_INVALID_SYMLINK_TYPE", `Symlink type must be one of "dir", "file", or "junction". Received "${x}"`);
    }
}
class ERR_HTTP2_ALTSVC_INVALID_ORIGIN extends NodeTypeError {
    constructor(){
        super("ERR_HTTP2_ALTSVC_INVALID_ORIGIN", `HTTP/2 ALTSVC frames require a valid origin`);
    }
}
class ERR_HTTP2_ALTSVC_LENGTH extends NodeTypeError {
    constructor(){
        super("ERR_HTTP2_ALTSVC_LENGTH", `HTTP/2 ALTSVC frames are limited to 16382 bytes`);
    }
}
class ERR_HTTP2_CONNECT_AUTHORITY extends NodeError {
    constructor(){
        super("ERR_HTTP2_CONNECT_AUTHORITY", `:authority header is required for CONNECT requests`);
    }
}
class ERR_HTTP2_CONNECT_PATH extends NodeError {
    constructor(){
        super("ERR_HTTP2_CONNECT_PATH", `The :path header is forbidden for CONNECT requests`);
    }
}
class ERR_HTTP2_CONNECT_SCHEME extends NodeError {
    constructor(){
        super("ERR_HTTP2_CONNECT_SCHEME", `The :scheme header is forbidden for CONNECT requests`);
    }
}
class ERR_HTTP2_GOAWAY_SESSION extends NodeError {
    constructor(){
        super("ERR_HTTP2_GOAWAY_SESSION", `New streams cannot be created after receiving a GOAWAY`);
    }
}
class ERR_HTTP2_HEADERS_AFTER_RESPOND extends NodeError {
    constructor(){
        super("ERR_HTTP2_HEADERS_AFTER_RESPOND", `Cannot specify additional headers after response initiated`);
    }
}
class ERR_HTTP2_HEADERS_SENT extends NodeError {
    constructor(){
        super("ERR_HTTP2_HEADERS_SENT", `Response has already been initiated.`);
    }
}
class ERR_HTTP2_HEADER_SINGLE_VALUE extends NodeTypeError {
    constructor(x){
        super("ERR_HTTP2_HEADER_SINGLE_VALUE", `Header field "${x}" must only have a single value`);
    }
}
class ERR_HTTP2_INFO_STATUS_NOT_ALLOWED extends NodeRangeError {
    constructor(){
        super("ERR_HTTP2_INFO_STATUS_NOT_ALLOWED", `Informational status codes cannot be used`);
    }
}
class ERR_HTTP2_INVALID_CONNECTION_HEADERS extends NodeTypeError {
    constructor(x){
        super("ERR_HTTP2_INVALID_CONNECTION_HEADERS", `HTTP/1 Connection specific headers are forbidden: "${x}"`);
    }
}
class ERR_HTTP2_INVALID_HEADER_VALUE extends NodeTypeError {
    constructor(x, y){
        super("ERR_HTTP2_INVALID_HEADER_VALUE", `Invalid value "${x}" for header "${y}"`);
    }
}
class ERR_HTTP2_INVALID_INFO_STATUS extends NodeRangeError {
    constructor(x){
        super("ERR_HTTP2_INVALID_INFO_STATUS", `Invalid informational status code: ${x}`);
    }
}
class ERR_HTTP2_INVALID_ORIGIN extends NodeTypeError {
    constructor(){
        super("ERR_HTTP2_INVALID_ORIGIN", `HTTP/2 ORIGIN frames require a valid origin`);
    }
}
class ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH extends NodeRangeError {
    constructor(){
        super("ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH", `Packed settings length must be a multiple of six`);
    }
}
class ERR_HTTP2_INVALID_PSEUDOHEADER extends NodeTypeError {
    constructor(x){
        super("ERR_HTTP2_INVALID_PSEUDOHEADER", `"${x}" is an invalid pseudoheader or is used incorrectly`);
    }
}
class ERR_HTTP2_INVALID_SESSION extends NodeError {
    constructor(){
        super("ERR_HTTP2_INVALID_SESSION", `The session has been destroyed`);
    }
}
class ERR_HTTP2_INVALID_STREAM extends NodeError {
    constructor(){
        super("ERR_HTTP2_INVALID_STREAM", `The stream has been destroyed`);
    }
}
class ERR_HTTP2_MAX_PENDING_SETTINGS_ACK extends NodeError {
    constructor(){
        super("ERR_HTTP2_MAX_PENDING_SETTINGS_ACK", `Maximum number of pending settings acknowledgements`);
    }
}
class ERR_HTTP2_NESTED_PUSH extends NodeError {
    constructor(){
        super("ERR_HTTP2_NESTED_PUSH", `A push stream cannot initiate another push stream.`);
    }
}
class ERR_HTTP2_NO_SOCKET_MANIPULATION extends NodeError {
    constructor(){
        super("ERR_HTTP2_NO_SOCKET_MANIPULATION", `HTTP/2 sockets should not be directly manipulated (e.g. read and written)`);
    }
}
class ERR_HTTP2_ORIGIN_LENGTH extends NodeTypeError {
    constructor(){
        super("ERR_HTTP2_ORIGIN_LENGTH", `HTTP/2 ORIGIN frames are limited to 16382 bytes`);
    }
}
class ERR_HTTP2_OUT_OF_STREAMS extends NodeError {
    constructor(){
        super("ERR_HTTP2_OUT_OF_STREAMS", `No stream ID is available because maximum stream ID has been reached`);
    }
}
class ERR_HTTP2_PAYLOAD_FORBIDDEN extends NodeError {
    constructor(x){
        super("ERR_HTTP2_PAYLOAD_FORBIDDEN", `Responses with ${x} status must not have a payload`);
    }
}
class ERR_HTTP2_PING_CANCEL extends NodeError {
    constructor(){
        super("ERR_HTTP2_PING_CANCEL", `HTTP2 ping cancelled`);
    }
}
class ERR_HTTP2_PING_LENGTH extends NodeRangeError {
    constructor(){
        super("ERR_HTTP2_PING_LENGTH", `HTTP2 ping payload must be 8 bytes`);
    }
}
class ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED extends NodeTypeError {
    constructor(){
        super("ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED", `Cannot set HTTP/2 pseudo-headers`);
    }
}
class ERR_HTTP2_PUSH_DISABLED extends NodeError {
    constructor(){
        super("ERR_HTTP2_PUSH_DISABLED", `HTTP/2 client has disabled push streams`);
    }
}
class ERR_HTTP2_SEND_FILE extends NodeError {
    constructor(){
        super("ERR_HTTP2_SEND_FILE", `Directories cannot be sent`);
    }
}
class ERR_HTTP2_SEND_FILE_NOSEEK extends NodeError {
    constructor(){
        super("ERR_HTTP2_SEND_FILE_NOSEEK", `Offset or length can only be specified for regular files`);
    }
}
class ERR_HTTP2_SESSION_ERROR extends NodeError {
    constructor(x){
        super("ERR_HTTP2_SESSION_ERROR", `Session closed with error code ${x}`);
    }
}
class ERR_HTTP2_SETTINGS_CANCEL extends NodeError {
    constructor(){
        super("ERR_HTTP2_SETTINGS_CANCEL", `HTTP2 session settings canceled`);
    }
}
class ERR_HTTP2_SOCKET_BOUND extends NodeError {
    constructor(){
        super("ERR_HTTP2_SOCKET_BOUND", `The socket is already bound to an Http2Session`);
    }
}
class ERR_HTTP2_SOCKET_UNBOUND extends NodeError {
    constructor(){
        super("ERR_HTTP2_SOCKET_UNBOUND", `The socket has been disconnected from the Http2Session`);
    }
}
class ERR_HTTP2_STATUS_101 extends NodeError {
    constructor(){
        super("ERR_HTTP2_STATUS_101", `HTTP status code 101 (Switching Protocols) is forbidden in HTTP/2`);
    }
}
class ERR_HTTP2_STATUS_INVALID extends NodeRangeError {
    constructor(x){
        super("ERR_HTTP2_STATUS_INVALID", `Invalid status code: ${x}`);
    }
}
class ERR_HTTP2_STREAM_ERROR extends NodeError {
    constructor(x){
        super("ERR_HTTP2_STREAM_ERROR", `Stream closed with error code ${x}`);
    }
}
class ERR_HTTP2_STREAM_SELF_DEPENDENCY extends NodeError {
    constructor(){
        super("ERR_HTTP2_STREAM_SELF_DEPENDENCY", `A stream cannot depend on itself`);
    }
}
class ERR_HTTP2_TRAILERS_ALREADY_SENT extends NodeError {
    constructor(){
        super("ERR_HTTP2_TRAILERS_ALREADY_SENT", `Trailing headers have already been sent`);
    }
}
class ERR_HTTP2_TRAILERS_NOT_READY extends NodeError {
    constructor(){
        super("ERR_HTTP2_TRAILERS_NOT_READY", `Trailing headers cannot be sent until after the wantTrailers event is emitted`);
    }
}
class ERR_HTTP2_UNSUPPORTED_PROTOCOL extends NodeError {
    constructor(x){
        super("ERR_HTTP2_UNSUPPORTED_PROTOCOL", `protocol "${x}" is unsupported.`);
    }
}
class ERR_HTTP_HEADERS_SENT extends NodeError {
    constructor(x){
        super("ERR_HTTP_HEADERS_SENT", `Cannot ${x} headers after they are sent to the client`);
    }
}
class ERR_HTTP_INVALID_HEADER_VALUE extends NodeTypeError {
    constructor(x, y){
        super("ERR_HTTP_INVALID_HEADER_VALUE", `Invalid value "${x}" for header "${y}"`);
    }
}
class ERR_HTTP_INVALID_STATUS_CODE extends NodeRangeError {
    constructor(x){
        super("ERR_HTTP_INVALID_STATUS_CODE", `Invalid status code: ${x}`);
    }
}
class ERR_HTTP_SOCKET_ENCODING extends NodeError {
    constructor(){
        super("ERR_HTTP_SOCKET_ENCODING", `Changing the socket encoding is not allowed per RFC7230 Section 3.`);
    }
}
class ERR_HTTP_TRAILER_INVALID extends NodeError {
    constructor(){
        super("ERR_HTTP_TRAILER_INVALID", `Trailers are invalid with this transfer encoding`);
    }
}
class ERR_INCOMPATIBLE_OPTION_PAIR extends NodeTypeError {
    constructor(x, y){
        super("ERR_INCOMPATIBLE_OPTION_PAIR", `Option "${x}" cannot be used in combination with option "${y}"`);
    }
}
class ERR_INPUT_TYPE_NOT_ALLOWED extends NodeError {
    constructor(){
        super("ERR_INPUT_TYPE_NOT_ALLOWED", `--input-type can only be used with string input via --eval, --print, or STDIN`);
    }
}
class ERR_INSPECTOR_ALREADY_ACTIVATED extends NodeError {
    constructor(){
        super("ERR_INSPECTOR_ALREADY_ACTIVATED", `Inspector is already activated. Close it with inspector.close() before activating it again.`);
    }
}
class ERR_INSPECTOR_ALREADY_CONNECTED extends NodeError {
    constructor(x){
        super("ERR_INSPECTOR_ALREADY_CONNECTED", `${x} is already connected`);
    }
}
class ERR_INSPECTOR_CLOSED extends NodeError {
    constructor(){
        super("ERR_INSPECTOR_CLOSED", `Session was closed`);
    }
}
class ERR_INSPECTOR_COMMAND extends NodeError {
    constructor(x, y){
        super("ERR_INSPECTOR_COMMAND", `Inspector error ${x}: ${y}`);
    }
}
class ERR_INSPECTOR_NOT_ACTIVE extends NodeError {
    constructor(){
        super("ERR_INSPECTOR_NOT_ACTIVE", `Inspector is not active`);
    }
}
class ERR_INSPECTOR_NOT_AVAILABLE extends NodeError {
    constructor(){
        super("ERR_INSPECTOR_NOT_AVAILABLE", `Inspector is not available`);
    }
}
class ERR_INSPECTOR_NOT_CONNECTED extends NodeError {
    constructor(){
        super("ERR_INSPECTOR_NOT_CONNECTED", `Session is not connected`);
    }
}
class ERR_INSPECTOR_NOT_WORKER extends NodeError {
    constructor(){
        super("ERR_INSPECTOR_NOT_WORKER", `Current thread is not a worker`);
    }
}
class ERR_INVALID_ASYNC_ID extends NodeRangeError {
    constructor(x, y){
        super("ERR_INVALID_ASYNC_ID", `Invalid ${x} value: ${y}`);
    }
}
class ERR_INVALID_BUFFER_SIZE extends NodeRangeError {
    constructor(x){
        super("ERR_INVALID_BUFFER_SIZE", `Buffer size must be a multiple of ${x}`);
    }
}
class ERR_INVALID_CURSOR_POS extends NodeTypeError {
    constructor(){
        super("ERR_INVALID_CURSOR_POS", `Cannot set cursor row without setting its column`);
    }
}
class ERR_INVALID_FD extends NodeRangeError {
    constructor(x){
        super("ERR_INVALID_FD", `"fd" must be a positive integer: ${x}`);
    }
}
class ERR_INVALID_FD_TYPE extends NodeTypeError {
    constructor(x){
        super("ERR_INVALID_FD_TYPE", `Unsupported fd type: ${x}`);
    }
}
class ERR_INVALID_FILE_URL_HOST extends NodeTypeError {
    constructor(x){
        super("ERR_INVALID_FILE_URL_HOST", `File URL host must be "localhost" or empty on ${x}`);
    }
}
class ERR_INVALID_FILE_URL_PATH extends NodeTypeError {
    constructor(x){
        super("ERR_INVALID_FILE_URL_PATH", `File URL path ${x}`);
    }
}
class ERR_INVALID_HANDLE_TYPE extends NodeTypeError {
    constructor(){
        super("ERR_INVALID_HANDLE_TYPE", `This handle type cannot be sent`);
    }
}
class ERR_INVALID_HTTP_TOKEN extends NodeTypeError {
    constructor(x, y){
        super("ERR_INVALID_HTTP_TOKEN", `${x} must be a valid HTTP token ["${y}"]`);
    }
}
class ERR_INVALID_IP_ADDRESS extends NodeTypeError {
    constructor(x){
        super("ERR_INVALID_IP_ADDRESS", `Invalid IP address: ${x}`);
    }
}
class ERR_INVALID_OPT_VALUE_ENCODING extends NodeTypeError {
    constructor(x){
        super("ERR_INVALID_OPT_VALUE_ENCODING", `The value "${x}" is invalid for option "encoding"`);
    }
}
class ERR_INVALID_PERFORMANCE_MARK extends NodeError {
    constructor(x){
        super("ERR_INVALID_PERFORMANCE_MARK", `The "${x}" performance mark has not been set`);
    }
}
class ERR_INVALID_PROTOCOL extends NodeTypeError {
    constructor(x, y){
        super("ERR_INVALID_PROTOCOL", `Protocol "${x}" not supported. Expected "${y}"`);
    }
}
class ERR_INVALID_REPL_EVAL_CONFIG extends NodeTypeError {
    constructor(){
        super("ERR_INVALID_REPL_EVAL_CONFIG", `Cannot specify both "breakEvalOnSigint" and "eval" for REPL`);
    }
}
class ERR_INVALID_REPL_INPUT extends NodeTypeError {
    constructor(x){
        super("ERR_INVALID_REPL_INPUT", `${x}`);
    }
}
class ERR_INVALID_SYNC_FORK_INPUT extends NodeTypeError {
    constructor(x){
        super("ERR_INVALID_SYNC_FORK_INPUT", `Asynchronous forks do not support Buffer, TypedArray, DataView or string input: ${x}`);
    }
}
class ERR_INVALID_THIS extends NodeTypeError {
    constructor(x){
        super("ERR_INVALID_THIS", `Value of "this" must be of type ${x}`);
    }
}
class ERR_INVALID_TUPLE extends NodeTypeError {
    constructor(x, y){
        super("ERR_INVALID_TUPLE", `${x} must be an iterable ${y} tuple`);
    }
}
class ERR_INVALID_URI extends NodeURIError {
    constructor(){
        super("ERR_INVALID_URI", `URI malformed`);
    }
}
class ERR_IPC_CHANNEL_CLOSED extends NodeError {
    constructor(){
        super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
    }
}
class ERR_IPC_DISCONNECTED extends NodeError {
    constructor(){
        super("ERR_IPC_DISCONNECTED", `IPC channel is already disconnected`);
    }
}
class ERR_IPC_ONE_PIPE extends NodeError {
    constructor(){
        super("ERR_IPC_ONE_PIPE", `Child process can have only one IPC pipe`);
    }
}
class ERR_IPC_SYNC_FORK extends NodeError {
    constructor(){
        super("ERR_IPC_SYNC_FORK", `IPC cannot be used with synchronous forks`);
    }
}
class ERR_MANIFEST_DEPENDENCY_MISSING extends NodeError {
    constructor(x, y){
        super("ERR_MANIFEST_DEPENDENCY_MISSING", `Manifest resource ${x} does not list ${y} as a dependency specifier`);
    }
}
class ERR_MANIFEST_INTEGRITY_MISMATCH extends NodeSyntaxError {
    constructor(x){
        super("ERR_MANIFEST_INTEGRITY_MISMATCH", `Manifest resource ${x} has multiple entries but integrity lists do not match`);
    }
}
class ERR_MANIFEST_INVALID_RESOURCE_FIELD extends NodeTypeError {
    constructor(x, y){
        super("ERR_MANIFEST_INVALID_RESOURCE_FIELD", `Manifest resource ${x} has invalid property value for ${y}`);
    }
}
class ERR_MANIFEST_TDZ extends NodeError {
    constructor(){
        super("ERR_MANIFEST_TDZ", `Manifest initialization has not yet run`);
    }
}
class ERR_MANIFEST_UNKNOWN_ONERROR extends NodeSyntaxError {
    constructor(x){
        super("ERR_MANIFEST_UNKNOWN_ONERROR", `Manifest specified unknown error behavior "${x}".`);
    }
}
class ERR_METHOD_NOT_IMPLEMENTED extends NodeError {
    constructor(x){
        super("ERR_METHOD_NOT_IMPLEMENTED", `The ${x} method is not implemented`);
    }
}
class ERR_MISSING_ARGS extends NodeTypeError {
    constructor(...args){
        let msg = "The ";
        const len = args.length;
        const wrap = (a)=>`"${a}"`;
        args = args.map((a)=>Array.isArray(a) ? a.map(wrap).join(" or ") : wrap(a));
        switch(len){
            case 1:
                msg += `${args[0]} argument`;
                break;
            case 2:
                msg += `${args[0]} and ${args[1]} arguments`;
                break;
            default:
                msg += args.slice(0, len - 1).join(", ");
                msg += `, and ${args[len - 1]} arguments`;
                break;
        }
        super("ERR_MISSING_ARGS", `${msg} must be specified`);
    }
}
class ERR_MISSING_OPTION extends NodeTypeError {
    constructor(x){
        super("ERR_MISSING_OPTION", `${x} is required`);
    }
}
class ERR_MULTIPLE_CALLBACK extends NodeError {
    constructor(){
        super("ERR_MULTIPLE_CALLBACK", `Callback called multiple times`);
    }
}
class ERR_NAPI_CONS_FUNCTION extends NodeTypeError {
    constructor(){
        super("ERR_NAPI_CONS_FUNCTION", `Constructor must be a function`);
    }
}
class ERR_NAPI_INVALID_DATAVIEW_ARGS extends NodeRangeError {
    constructor(){
        super("ERR_NAPI_INVALID_DATAVIEW_ARGS", `byte_offset + byte_length should be less than or equal to the size in bytes of the array passed in`);
    }
}
class ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT extends NodeRangeError {
    constructor(x, y){
        super("ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT", `start offset of ${x} should be a multiple of ${y}`);
    }
}
class ERR_NAPI_INVALID_TYPEDARRAY_LENGTH extends NodeRangeError {
    constructor(){
        super("ERR_NAPI_INVALID_TYPEDARRAY_LENGTH", `Invalid typed array length`);
    }
}
class ERR_NO_CRYPTO extends NodeError {
    constructor(){
        super("ERR_NO_CRYPTO", `Node.js is not compiled with OpenSSL crypto support`);
    }
}
class ERR_NO_ICU extends NodeTypeError {
    constructor(x){
        super("ERR_NO_ICU", `${x} is not supported on Node.js compiled without ICU`);
    }
}
class ERR_QUICCLIENTSESSION_FAILED extends NodeError {
    constructor(x){
        super("ERR_QUICCLIENTSESSION_FAILED", `Failed to create a new QuicClientSession: ${x}`);
    }
}
class ERR_QUICCLIENTSESSION_FAILED_SETSOCKET extends NodeError {
    constructor(){
        super("ERR_QUICCLIENTSESSION_FAILED_SETSOCKET", `Failed to set the QuicSocket`);
    }
}
class ERR_QUICSESSION_DESTROYED extends NodeError {
    constructor(x){
        super("ERR_QUICSESSION_DESTROYED", `Cannot call ${x} after a QuicSession has been destroyed`);
    }
}
class ERR_QUICSESSION_INVALID_DCID extends NodeError {
    constructor(x){
        super("ERR_QUICSESSION_INVALID_DCID", `Invalid DCID value: ${x}`);
    }
}
class ERR_QUICSESSION_UPDATEKEY extends NodeError {
    constructor(){
        super("ERR_QUICSESSION_UPDATEKEY", `Unable to update QuicSession keys`);
    }
}
class ERR_QUICSOCKET_DESTROYED extends NodeError {
    constructor(x){
        super("ERR_QUICSOCKET_DESTROYED", `Cannot call ${x} after a QuicSocket has been destroyed`);
    }
}
class ERR_QUICSOCKET_INVALID_STATELESS_RESET_SECRET_LENGTH extends NodeError {
    constructor(){
        super("ERR_QUICSOCKET_INVALID_STATELESS_RESET_SECRET_LENGTH", `The stateResetToken must be exactly 16-bytes in length`);
    }
}
class ERR_QUICSOCKET_LISTENING extends NodeError {
    constructor(){
        super("ERR_QUICSOCKET_LISTENING", `This QuicSocket is already listening`);
    }
}
class ERR_QUICSOCKET_UNBOUND extends NodeError {
    constructor(x){
        super("ERR_QUICSOCKET_UNBOUND", `Cannot call ${x} before a QuicSocket has been bound`);
    }
}
class ERR_QUICSTREAM_DESTROYED extends NodeError {
    constructor(x){
        super("ERR_QUICSTREAM_DESTROYED", `Cannot call ${x} after a QuicStream has been destroyed`);
    }
}
class ERR_QUICSTREAM_INVALID_PUSH extends NodeError {
    constructor(){
        super("ERR_QUICSTREAM_INVALID_PUSH", `Push streams are only supported on client-initiated, bidirectional streams`);
    }
}
class ERR_QUICSTREAM_OPEN_FAILED extends NodeError {
    constructor(){
        super("ERR_QUICSTREAM_OPEN_FAILED", `Opening a new QuicStream failed`);
    }
}
class ERR_QUICSTREAM_UNSUPPORTED_PUSH extends NodeError {
    constructor(){
        super("ERR_QUICSTREAM_UNSUPPORTED_PUSH", `Push streams are not supported on this QuicSession`);
    }
}
class ERR_QUIC_TLS13_REQUIRED extends NodeError {
    constructor(){
        super("ERR_QUIC_TLS13_REQUIRED", `QUIC requires TLS version 1.3`);
    }
}
class ERR_SCRIPT_EXECUTION_INTERRUPTED extends NodeError {
    constructor(){
        super("ERR_SCRIPT_EXECUTION_INTERRUPTED", "Script execution was interrupted by `SIGINT`");
    }
}
class ERR_SERVER_ALREADY_LISTEN extends NodeError {
    constructor(){
        super("ERR_SERVER_ALREADY_LISTEN", `Listen method has been called more than once without closing.`);
    }
}
class ERR_SERVER_NOT_RUNNING extends NodeError {
    constructor(){
        super("ERR_SERVER_NOT_RUNNING", `Server is not running.`);
    }
}
class ERR_SOCKET_ALREADY_BOUND extends NodeError {
    constructor(){
        super("ERR_SOCKET_ALREADY_BOUND", `Socket is already bound`);
    }
}
class ERR_SOCKET_BAD_BUFFER_SIZE extends NodeTypeError {
    constructor(){
        super("ERR_SOCKET_BAD_BUFFER_SIZE", `Buffer size must be a positive integer`);
    }
}
class ERR_SOCKET_BAD_PORT extends NodeRangeError {
    constructor(name, port, allowZero = true){
        assert(typeof allowZero === "boolean", "The 'allowZero' argument must be of type boolean.");
        const operator = allowZero ? ">=" : ">";
        super("ERR_SOCKET_BAD_PORT", `${name} should be ${operator} 0 and < 65536. Received ${port}.`);
    }
}
class ERR_SOCKET_BAD_TYPE extends NodeTypeError {
    constructor(){
        super("ERR_SOCKET_BAD_TYPE", `Bad socket type specified. Valid types are: udp4, udp6`);
    }
}
class ERR_SOCKET_BUFFER_SIZE extends NodeSystemError {
    constructor(ctx){
        super("ERR_SOCKET_BUFFER_SIZE", ctx, "Could not get or set buffer size");
    }
}
class ERR_SOCKET_CLOSED extends NodeError {
    constructor(){
        super("ERR_SOCKET_CLOSED", `Socket is closed`);
    }
}
class ERR_SOCKET_DGRAM_IS_CONNECTED extends NodeError {
    constructor(){
        super("ERR_SOCKET_DGRAM_IS_CONNECTED", `Already connected`);
    }
}
class ERR_SOCKET_DGRAM_NOT_CONNECTED extends NodeError {
    constructor(){
        super("ERR_SOCKET_DGRAM_NOT_CONNECTED", `Not connected`);
    }
}
class ERR_SOCKET_DGRAM_NOT_RUNNING extends NodeError {
    constructor(){
        super("ERR_SOCKET_DGRAM_NOT_RUNNING", `Not running`);
    }
}
class ERR_SRI_PARSE extends NodeSyntaxError {
    constructor(name, __char, position){
        super("ERR_SRI_PARSE", `Subresource Integrity string ${name} had an unexpected ${__char} at position ${position}`);
    }
}
class ERR_STREAM_ALREADY_FINISHED extends NodeError {
    constructor(x){
        super("ERR_STREAM_ALREADY_FINISHED", `Cannot call ${x} after a stream was finished`);
    }
}
class ERR_STREAM_CANNOT_PIPE extends NodeError {
    constructor(){
        super("ERR_STREAM_CANNOT_PIPE", `Cannot pipe, not readable`);
    }
}
class ERR_STREAM_DESTROYED extends NodeError {
    constructor(x){
        super("ERR_STREAM_DESTROYED", `Cannot call ${x} after a stream was destroyed`);
    }
}
class ERR_STREAM_NULL_VALUES extends NodeTypeError {
    constructor(){
        super("ERR_STREAM_NULL_VALUES", `May not write null values to stream`);
    }
}
class ERR_STREAM_PREMATURE_CLOSE extends NodeError {
    constructor(){
        super("ERR_STREAM_PREMATURE_CLOSE", `Premature close`);
    }
}
class ERR_STREAM_PUSH_AFTER_EOF extends NodeError {
    constructor(){
        super("ERR_STREAM_PUSH_AFTER_EOF", `stream.push() after EOF`);
    }
}
class ERR_STREAM_UNSHIFT_AFTER_END_EVENT extends NodeError {
    constructor(){
        super("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", `stream.unshift() after end event`);
    }
}
class ERR_STREAM_WRAP extends NodeError {
    constructor(){
        super("ERR_STREAM_WRAP", `Stream has StringDecoder set or is in objectMode`);
    }
}
class ERR_STREAM_WRITE_AFTER_END extends NodeError {
    constructor(){
        super("ERR_STREAM_WRITE_AFTER_END", `write after end`);
    }
}
class ERR_SYNTHETIC extends NodeError {
    constructor(){
        super("ERR_SYNTHETIC", `JavaScript Callstack`);
    }
}
class ERR_TLS_CERT_ALTNAME_INVALID extends NodeError {
    reason;
    host;
    cert;
    constructor(reason, host, cert){
        super("ERR_TLS_CERT_ALTNAME_INVALID", `Hostname/IP does not match certificate's altnames: ${reason}`);
        this.reason = reason;
        this.host = host;
        this.cert = cert;
    }
}
class ERR_TLS_DH_PARAM_SIZE extends NodeError {
    constructor(x){
        super("ERR_TLS_DH_PARAM_SIZE", `DH parameter size ${x} is less than 2048`);
    }
}
class ERR_TLS_HANDSHAKE_TIMEOUT extends NodeError {
    constructor(){
        super("ERR_TLS_HANDSHAKE_TIMEOUT", `TLS handshake timeout`);
    }
}
class ERR_TLS_INVALID_CONTEXT extends NodeTypeError {
    constructor(x){
        super("ERR_TLS_INVALID_CONTEXT", `${x} must be a SecureContext`);
    }
}
class ERR_TLS_INVALID_STATE extends NodeError {
    constructor(){
        super("ERR_TLS_INVALID_STATE", `TLS socket connection must be securely established`);
    }
}
class ERR_TLS_INVALID_PROTOCOL_VERSION extends NodeTypeError {
    constructor(protocol, x){
        super("ERR_TLS_INVALID_PROTOCOL_VERSION", `${protocol} is not a valid ${x} TLS protocol version`);
    }
}
class ERR_TLS_PROTOCOL_VERSION_CONFLICT extends NodeTypeError {
    constructor(prevProtocol, protocol){
        super("ERR_TLS_PROTOCOL_VERSION_CONFLICT", `TLS protocol version ${prevProtocol} conflicts with secureProtocol ${protocol}`);
    }
}
class ERR_TLS_RENEGOTIATION_DISABLED extends NodeError {
    constructor(){
        super("ERR_TLS_RENEGOTIATION_DISABLED", `TLS session renegotiation disabled for this socket`);
    }
}
class ERR_TLS_REQUIRED_SERVER_NAME extends NodeError {
    constructor(){
        super("ERR_TLS_REQUIRED_SERVER_NAME", `"servername" is required parameter for Server.addContext`);
    }
}
class ERR_TLS_SESSION_ATTACK extends NodeError {
    constructor(){
        super("ERR_TLS_SESSION_ATTACK", `TLS session renegotiation attack detected`);
    }
}
class ERR_TLS_SNI_FROM_SERVER extends NodeError {
    constructor(){
        super("ERR_TLS_SNI_FROM_SERVER", `Cannot issue SNI from a TLS server-side socket`);
    }
}
class ERR_TRACE_EVENTS_CATEGORY_REQUIRED extends NodeTypeError {
    constructor(){
        super("ERR_TRACE_EVENTS_CATEGORY_REQUIRED", `At least one category is required`);
    }
}
class ERR_TRACE_EVENTS_UNAVAILABLE extends NodeError {
    constructor(){
        super("ERR_TRACE_EVENTS_UNAVAILABLE", `Trace events are unavailable`);
    }
}
class ERR_UNAVAILABLE_DURING_EXIT extends NodeError {
    constructor(){
        super("ERR_UNAVAILABLE_DURING_EXIT", `Cannot call function in process exit handler`);
    }
}
class ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET extends NodeError {
    constructor(){
        super("ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET", "`process.setupUncaughtExceptionCapture()` was called while a capture callback was already active");
    }
}
class ERR_UNESCAPED_CHARACTERS extends NodeTypeError {
    constructor(x){
        super("ERR_UNESCAPED_CHARACTERS", `${x} contains unescaped characters`);
    }
}
class ERR_UNHANDLED_ERROR extends NodeError {
    constructor(x){
        super("ERR_UNHANDLED_ERROR", `Unhandled error. (${x})`);
    }
}
class ERR_UNKNOWN_BUILTIN_MODULE extends NodeError {
    constructor(x){
        super("ERR_UNKNOWN_BUILTIN_MODULE", `No such built-in module: ${x}`);
    }
}
class ERR_UNKNOWN_CREDENTIAL extends NodeError {
    constructor(x, y){
        super("ERR_UNKNOWN_CREDENTIAL", `${x} identifier does not exist: ${y}`);
    }
}
class ERR_UNKNOWN_ENCODING extends NodeTypeError {
    constructor(x){
        super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x}`);
    }
}
class ERR_UNKNOWN_FILE_EXTENSION extends NodeTypeError {
    constructor(x, y){
        super("ERR_UNKNOWN_FILE_EXTENSION", `Unknown file extension "${x}" for ${y}`);
    }
}
class ERR_UNKNOWN_MODULE_FORMAT extends NodeRangeError {
    constructor(x){
        super("ERR_UNKNOWN_MODULE_FORMAT", `Unknown module format: ${x}`);
    }
}
class ERR_UNKNOWN_SIGNAL extends NodeTypeError {
    constructor(x){
        super("ERR_UNKNOWN_SIGNAL", `Unknown signal: ${x}`);
    }
}
class ERR_UNSUPPORTED_DIR_IMPORT extends NodeError {
    constructor(x, y){
        super("ERR_UNSUPPORTED_DIR_IMPORT", `Directory import '${x}' is not supported resolving ES modules, imported from ${y}`);
    }
}
class ERR_UNSUPPORTED_ESM_URL_SCHEME extends NodeError {
    constructor(){
        super("ERR_UNSUPPORTED_ESM_URL_SCHEME", `Only file and data URLs are supported by the default ESM loader`);
    }
}
class ERR_USE_AFTER_CLOSE extends NodeError {
    constructor(x){
        super("ERR_USE_AFTER_CLOSE", `${x} was closed`);
    }
}
class ERR_V8BREAKITERATOR extends NodeError {
    constructor(){
        super("ERR_V8BREAKITERATOR", `Full ICU data not installed. See https://github.com/nodejs/node/wiki/Intl`);
    }
}
class ERR_VALID_PERFORMANCE_ENTRY_TYPE extends NodeError {
    constructor(){
        super("ERR_VALID_PERFORMANCE_ENTRY_TYPE", `At least one valid performance entry type is required`);
    }
}
class ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING extends NodeTypeError {
    constructor(){
        super("ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING", `A dynamic import callback was not specified.`);
    }
}
class ERR_VM_MODULE_ALREADY_LINKED extends NodeError {
    constructor(){
        super("ERR_VM_MODULE_ALREADY_LINKED", `Module has already been linked`);
    }
}
class ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA extends NodeError {
    constructor(){
        super("ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA", `Cached data cannot be created for a module which has been evaluated`);
    }
}
class ERR_VM_MODULE_DIFFERENT_CONTEXT extends NodeError {
    constructor(){
        super("ERR_VM_MODULE_DIFFERENT_CONTEXT", `Linked modules must use the same context`);
    }
}
class ERR_VM_MODULE_LINKING_ERRORED extends NodeError {
    constructor(){
        super("ERR_VM_MODULE_LINKING_ERRORED", `Linking has already failed for the provided module`);
    }
}
class ERR_VM_MODULE_NOT_MODULE extends NodeError {
    constructor(){
        super("ERR_VM_MODULE_NOT_MODULE", `Provided module is not an instance of Module`);
    }
}
class ERR_VM_MODULE_STATUS extends NodeError {
    constructor(x){
        super("ERR_VM_MODULE_STATUS", `Module status ${x}`);
    }
}
class ERR_WASI_ALREADY_STARTED extends NodeError {
    constructor(){
        super("ERR_WASI_ALREADY_STARTED", `WASI instance has already started`);
    }
}
class ERR_WORKER_INIT_FAILED extends NodeError {
    constructor(x){
        super("ERR_WORKER_INIT_FAILED", `Worker initialization failure: ${x}`);
    }
}
class ERR_WORKER_NOT_RUNNING extends NodeError {
    constructor(){
        super("ERR_WORKER_NOT_RUNNING", `Worker instance not running`);
    }
}
class ERR_WORKER_OUT_OF_MEMORY extends NodeError {
    constructor(x){
        super("ERR_WORKER_OUT_OF_MEMORY", `Worker terminated due to reaching memory limit: ${x}`);
    }
}
class ERR_WORKER_UNSERIALIZABLE_ERROR extends NodeError {
    constructor(){
        super("ERR_WORKER_UNSERIALIZABLE_ERROR", `Serializing an uncaught exception failed`);
    }
}
class ERR_WORKER_UNSUPPORTED_EXTENSION extends NodeTypeError {
    constructor(x){
        super("ERR_WORKER_UNSUPPORTED_EXTENSION", `The worker script extension must be ".js", ".mjs", or ".cjs". Received "${x}"`);
    }
}
class ERR_WORKER_UNSUPPORTED_OPERATION extends NodeTypeError {
    constructor(x){
        super("ERR_WORKER_UNSUPPORTED_OPERATION", `${x} is not supported in workers`);
    }
}
class ERR_ZLIB_INITIALIZATION_FAILED extends NodeError {
    constructor(){
        super("ERR_ZLIB_INITIALIZATION_FAILED", `Initialization failed`);
    }
}
class ERR_FALSY_VALUE_REJECTION extends NodeError {
    reason;
    constructor(reason){
        super("ERR_FALSY_VALUE_REJECTION", "Promise was rejected with falsy value");
        this.reason = reason;
    }
}
class ERR_HTTP2_INVALID_SETTING_VALUE extends NodeRangeError {
    actual;
    min;
    max;
    constructor(name, actual, min, max){
        super("ERR_HTTP2_INVALID_SETTING_VALUE", `Invalid value for setting "${name}": ${actual}`);
        this.actual = actual;
        if (min !== undefined) {
            this.min = min;
            this.max = max;
        }
    }
}
class ERR_HTTP2_STREAM_CANCEL extends NodeError {
    cause;
    constructor(error){
        super("ERR_HTTP2_STREAM_CANCEL", typeof error.message === "string" ? `The pending stream has been canceled (caused by: ${error.message})` : "The pending stream has been canceled");
        if (error) {
            this.cause = error;
        }
    }
}
class ERR_INVALID_ADDRESS_FAMILY extends NodeRangeError {
    host;
    port;
    constructor(addressType, host, port){
        super("ERR_INVALID_ADDRESS_FAMILY", `Invalid address family: ${addressType} ${host}:${port}`);
        this.host = host;
        this.port = port;
    }
}
class ERR_INVALID_CHAR extends NodeTypeError {
    constructor(name, field){
        super("ERR_INVALID_CHAR", field ? `Invalid character in ${name}` : `Invalid character in ${name} ["${field}"]`);
    }
}
class ERR_INVALID_OPT_VALUE extends NodeTypeError {
    constructor(name, value){
        super("ERR_INVALID_OPT_VALUE", `The value "${value}" is invalid for option "${name}"`);
    }
}
class ERR_INVALID_RETURN_PROPERTY extends NodeTypeError {
    constructor(input, name, prop, value){
        super("ERR_INVALID_RETURN_PROPERTY", `Expected a valid ${input} to be returned for the "${prop}" from the "${name}" function but got ${value}.`);
    }
}
function buildReturnPropertyType(value) {
    if (value && value.constructor && value.constructor.name) {
        return `instance of ${value.constructor.name}`;
    } else {
        return `type ${typeof value}`;
    }
}
class ERR_INVALID_RETURN_PROPERTY_VALUE extends NodeTypeError {
    constructor(input, name, prop, value){
        super("ERR_INVALID_RETURN_PROPERTY_VALUE", `Expected ${input} to be returned for the "${prop}" from the "${name}" function but got ${buildReturnPropertyType(value)}.`);
    }
}
class ERR_INVALID_RETURN_VALUE extends NodeTypeError {
    constructor(input, name, value){
        super("ERR_INVALID_RETURN_VALUE", `Expected ${input} to be returned from the "${name}" function but got ${determineSpecificType(value)}.`);
    }
}
class ERR_INVALID_URL extends NodeTypeError {
    input;
    constructor(input){
        super("ERR_INVALID_URL", `Invalid URL: ${input}`);
        this.input = input;
    }
}
class ERR_INVALID_URL_SCHEME extends NodeTypeError {
    constructor(expected){
        expected = Array.isArray(expected) ? expected : [
            expected
        ];
        const res = expected.length === 2 ? `one of scheme ${expected[0]} or ${expected[1]}` : `of scheme ${expected[0]}`;
        super("ERR_INVALID_URL_SCHEME", `The URL must be ${res}`);
    }
}
class ERR_MODULE_NOT_FOUND extends NodeError {
    constructor(path, base, type = "package"){
        super("ERR_MODULE_NOT_FOUND", `Cannot find ${type} '${path}' imported from ${base}`);
    }
}
class ERR_INVALID_PACKAGE_CONFIG extends NodeError {
    constructor(path, base, message){
        const msg = `Invalid package config ${path}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
        super("ERR_INVALID_PACKAGE_CONFIG", msg);
    }
}
class ERR_INVALID_MODULE_SPECIFIER extends NodeTypeError {
    constructor(request, reason, base){
        super("ERR_INVALID_MODULE_SPECIFIER", `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`);
    }
}
class ERR_INVALID_PACKAGE_TARGET extends NodeError {
    constructor(pkgPath, key, target, isImport, base){
        let msg;
        const relError = typeof target === "string" && !isImport && target.length && !target.startsWith("./");
        if (key === ".") {
            assert(isImport === false);
            msg = `Invalid "exports" main target ${JSON.stringify(target)} defined ` + `in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`;
        } else {
            msg = `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(target)} defined for '${key}' in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`;
        }
        super("ERR_INVALID_PACKAGE_TARGET", msg);
    }
}
class ERR_PACKAGE_IMPORT_NOT_DEFINED extends NodeTypeError {
    constructor(specifier, packagePath, base){
        const msg = `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`;
        super("ERR_PACKAGE_IMPORT_NOT_DEFINED", msg);
    }
}
class ERR_PACKAGE_PATH_NOT_EXPORTED extends NodeError {
    constructor(subpath, pkgPath, basePath){
        let msg;
        if (subpath === ".") {
            msg = `No "exports" main defined in ${pkgPath}package.json${basePath ? ` imported from ${basePath}` : ""}`;
        } else {
            msg = `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${basePath ? ` imported from ${basePath}` : ""}`;
        }
        super("ERR_PACKAGE_PATH_NOT_EXPORTED", msg);
    }
}
class ERR_INTERNAL_ASSERTION extends NodeError {
    constructor(message){
        const suffix = "This is caused by either a bug in Node.js " + "or incorrect usage of Node.js internals.\n" + "Please open an issue with this stack trace at " + "https://github.com/nodejs/node/issues\n";
        super("ERR_INTERNAL_ASSERTION", message === undefined ? suffix : `${message}\n${suffix}`);
    }
}
class ERR_FS_RMDIR_ENOTDIR extends NodeSystemError {
    constructor(path){
        const code = isWindows ? "ENOENT" : "ENOTDIR";
        const ctx = {
            message: "not a directory",
            path,
            syscall: "rmdir",
            code,
            errno: isWindows ? ENOENT : ENOTDIR
        };
        super(code, ctx, "Path is not a directory");
    }
}
function denoErrorToNodeError(e, ctx) {
    const errno = extractOsErrorNumberFromErrorMessage(e);
    if (typeof errno === "undefined") {
        return e;
    }
    const ex = uvException({
        errno: mapSysErrnoToUvErrno(errno),
        ...ctx
    });
    return ex;
}
function extractOsErrorNumberFromErrorMessage(e) {
    const match = e instanceof Error ? e.message.match(/\(os error (\d+)\)/) : false;
    if (match) {
        return +match[1];
    }
    return undefined;
}
function connResetException(msg) {
    const ex = new Error(msg);
    ex.code = "ECONNRESET";
    return ex;
}
function aggregateTwoErrors(innerError, outerError) {
    if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
            outerError.errors.push(innerError);
            return outerError;
        }
        const err = new AggregateError([
            outerError,
            innerError
        ], outerError.message);
        err.code = outerError.code;
        return err;
    }
    return innerError || outerError;
}
codes.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED;
codes.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;
codes.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE;
codes.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE;
codes.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT;
codes.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS;
codes.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING;
const genericNodeError = hideStackFrames(function genericNodeError(message, errorProperties) {
    const err = new Error(message);
    Object.assign(err, errorProperties);
    return err;
});
function determineSpecificType(value) {
    if (value == null) {
        return "" + value;
    }
    if (typeof value === "function" && value.name) {
        return `function ${value.name}`;
    }
    if (typeof value === "object") {
        if (value.constructor?.name) {
            return `an instance of ${value.constructor.name}`;
        }
        return `${inspect(value, {
            depth: -1
        })}`;
    }
    let inspected = inspect(value, {
        colors: false
    });
    if (inspected.length > 28) inspected = `${inspected.slice(0, 25)}...`;
    return `type ${typeof value} (${inspected})`;
}
const __default2 = {
    AbortError,
    ERR_AMBIGUOUS_ARGUMENT,
    ERR_ARG_NOT_ITERABLE,
    ERR_ASSERTION,
    ERR_ASYNC_CALLBACK,
    ERR_ASYNC_TYPE,
    ERR_BROTLI_INVALID_PARAM,
    ERR_BUFFER_OUT_OF_BOUNDS,
    ERR_BUFFER_TOO_LARGE,
    ERR_CANNOT_WATCH_SIGINT,
    ERR_CHILD_CLOSED_BEFORE_REPLY,
    ERR_CHILD_PROCESS_IPC_REQUIRED,
    ERR_CHILD_PROCESS_STDIO_MAXBUFFER,
    ERR_CONSOLE_WRITABLE_STREAM,
    ERR_CONTEXT_NOT_INITIALIZED,
    ERR_CPU_USAGE,
    ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED,
    ERR_CRYPTO_ECDH_INVALID_FORMAT,
    ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY,
    ERR_CRYPTO_ENGINE_UNKNOWN,
    ERR_CRYPTO_FIPS_FORCED,
    ERR_CRYPTO_FIPS_UNAVAILABLE,
    ERR_CRYPTO_HASH_FINALIZED,
    ERR_CRYPTO_HASH_UPDATE_FAILED,
    ERR_CRYPTO_INCOMPATIBLE_KEY,
    ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS,
    ERR_CRYPTO_INVALID_DIGEST,
    ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE,
    ERR_CRYPTO_INVALID_STATE,
    ERR_CRYPTO_PBKDF2_ERROR,
    ERR_CRYPTO_SCRYPT_INVALID_PARAMETER,
    ERR_CRYPTO_SCRYPT_NOT_SUPPORTED,
    ERR_CRYPTO_SIGN_KEY_REQUIRED,
    ERR_DIR_CLOSED,
    ERR_DIR_CONCURRENT_OPERATION,
    ERR_DNS_SET_SERVERS_FAILED,
    ERR_DOMAIN_CALLBACK_NOT_AVAILABLE,
    ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE,
    ERR_ENCODING_INVALID_ENCODED_DATA,
    ERR_ENCODING_NOT_SUPPORTED,
    ERR_EVAL_ESM_CANNOT_PRINT,
    ERR_EVENT_RECURSION,
    ERR_FALSY_VALUE_REJECTION,
    ERR_FEATURE_UNAVAILABLE_ON_PLATFORM,
    ERR_FS_EISDIR,
    ERR_FS_FILE_TOO_LARGE,
    ERR_FS_INVALID_SYMLINK_TYPE,
    ERR_FS_RMDIR_ENOTDIR,
    ERR_HTTP2_ALTSVC_INVALID_ORIGIN,
    ERR_HTTP2_ALTSVC_LENGTH,
    ERR_HTTP2_CONNECT_AUTHORITY,
    ERR_HTTP2_CONNECT_PATH,
    ERR_HTTP2_CONNECT_SCHEME,
    ERR_HTTP2_GOAWAY_SESSION,
    ERR_HTTP2_HEADERS_AFTER_RESPOND,
    ERR_HTTP2_HEADERS_SENT,
    ERR_HTTP2_HEADER_SINGLE_VALUE,
    ERR_HTTP2_INFO_STATUS_NOT_ALLOWED,
    ERR_HTTP2_INVALID_CONNECTION_HEADERS,
    ERR_HTTP2_INVALID_HEADER_VALUE,
    ERR_HTTP2_INVALID_INFO_STATUS,
    ERR_HTTP2_INVALID_ORIGIN,
    ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH,
    ERR_HTTP2_INVALID_PSEUDOHEADER,
    ERR_HTTP2_INVALID_SESSION,
    ERR_HTTP2_INVALID_SETTING_VALUE,
    ERR_HTTP2_INVALID_STREAM,
    ERR_HTTP2_MAX_PENDING_SETTINGS_ACK,
    ERR_HTTP2_NESTED_PUSH,
    ERR_HTTP2_NO_SOCKET_MANIPULATION,
    ERR_HTTP2_ORIGIN_LENGTH,
    ERR_HTTP2_OUT_OF_STREAMS,
    ERR_HTTP2_PAYLOAD_FORBIDDEN,
    ERR_HTTP2_PING_CANCEL,
    ERR_HTTP2_PING_LENGTH,
    ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED,
    ERR_HTTP2_PUSH_DISABLED,
    ERR_HTTP2_SEND_FILE,
    ERR_HTTP2_SEND_FILE_NOSEEK,
    ERR_HTTP2_SESSION_ERROR,
    ERR_HTTP2_SETTINGS_CANCEL,
    ERR_HTTP2_SOCKET_BOUND,
    ERR_HTTP2_SOCKET_UNBOUND,
    ERR_HTTP2_STATUS_101,
    ERR_HTTP2_STATUS_INVALID,
    ERR_HTTP2_STREAM_CANCEL,
    ERR_HTTP2_STREAM_ERROR,
    ERR_HTTP2_STREAM_SELF_DEPENDENCY,
    ERR_HTTP2_TRAILERS_ALREADY_SENT,
    ERR_HTTP2_TRAILERS_NOT_READY,
    ERR_HTTP2_UNSUPPORTED_PROTOCOL,
    ERR_HTTP_HEADERS_SENT,
    ERR_HTTP_INVALID_HEADER_VALUE,
    ERR_HTTP_INVALID_STATUS_CODE,
    ERR_HTTP_SOCKET_ENCODING,
    ERR_HTTP_TRAILER_INVALID,
    ERR_INCOMPATIBLE_OPTION_PAIR,
    ERR_INPUT_TYPE_NOT_ALLOWED,
    ERR_INSPECTOR_ALREADY_ACTIVATED,
    ERR_INSPECTOR_ALREADY_CONNECTED,
    ERR_INSPECTOR_CLOSED,
    ERR_INSPECTOR_COMMAND,
    ERR_INSPECTOR_NOT_ACTIVE,
    ERR_INSPECTOR_NOT_AVAILABLE,
    ERR_INSPECTOR_NOT_CONNECTED,
    ERR_INSPECTOR_NOT_WORKER,
    ERR_INTERNAL_ASSERTION,
    ERR_INVALID_ADDRESS_FAMILY,
    ERR_INVALID_ARG_TYPE,
    ERR_INVALID_ARG_TYPE_RANGE,
    ERR_INVALID_ARG_VALUE,
    ERR_INVALID_ARG_VALUE_RANGE,
    ERR_INVALID_ASYNC_ID,
    ERR_INVALID_BUFFER_SIZE,
    ERR_INVALID_CHAR,
    ERR_INVALID_CURSOR_POS,
    ERR_INVALID_FD,
    ERR_INVALID_FD_TYPE,
    ERR_INVALID_FILE_URL_HOST,
    ERR_INVALID_FILE_URL_PATH,
    ERR_INVALID_HANDLE_TYPE,
    ERR_INVALID_HTTP_TOKEN,
    ERR_INVALID_IP_ADDRESS,
    ERR_INVALID_MODULE_SPECIFIER,
    ERR_INVALID_OPT_VALUE,
    ERR_INVALID_OPT_VALUE_ENCODING,
    ERR_INVALID_PACKAGE_CONFIG,
    ERR_INVALID_PACKAGE_TARGET,
    ERR_INVALID_PERFORMANCE_MARK,
    ERR_INVALID_PROTOCOL,
    ERR_INVALID_REPL_EVAL_CONFIG,
    ERR_INVALID_REPL_INPUT,
    ERR_INVALID_RETURN_PROPERTY,
    ERR_INVALID_RETURN_PROPERTY_VALUE,
    ERR_INVALID_RETURN_VALUE,
    ERR_INVALID_SYNC_FORK_INPUT,
    ERR_INVALID_THIS,
    ERR_INVALID_TUPLE,
    ERR_INVALID_URI,
    ERR_INVALID_URL,
    ERR_INVALID_URL_SCHEME,
    ERR_IPC_CHANNEL_CLOSED,
    ERR_IPC_DISCONNECTED,
    ERR_IPC_ONE_PIPE,
    ERR_IPC_SYNC_FORK,
    ERR_MANIFEST_DEPENDENCY_MISSING,
    ERR_MANIFEST_INTEGRITY_MISMATCH,
    ERR_MANIFEST_INVALID_RESOURCE_FIELD,
    ERR_MANIFEST_TDZ,
    ERR_MANIFEST_UNKNOWN_ONERROR,
    ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MISSING_ARGS,
    ERR_MISSING_OPTION,
    ERR_MODULE_NOT_FOUND,
    ERR_MULTIPLE_CALLBACK,
    ERR_NAPI_CONS_FUNCTION,
    ERR_NAPI_INVALID_DATAVIEW_ARGS,
    ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT,
    ERR_NAPI_INVALID_TYPEDARRAY_LENGTH,
    ERR_NO_CRYPTO,
    ERR_NO_ICU,
    ERR_OUT_OF_RANGE,
    ERR_PACKAGE_IMPORT_NOT_DEFINED,
    ERR_PACKAGE_PATH_NOT_EXPORTED,
    ERR_QUICCLIENTSESSION_FAILED,
    ERR_QUICCLIENTSESSION_FAILED_SETSOCKET,
    ERR_QUICSESSION_DESTROYED,
    ERR_QUICSESSION_INVALID_DCID,
    ERR_QUICSESSION_UPDATEKEY,
    ERR_QUICSOCKET_DESTROYED,
    ERR_QUICSOCKET_INVALID_STATELESS_RESET_SECRET_LENGTH,
    ERR_QUICSOCKET_LISTENING,
    ERR_QUICSOCKET_UNBOUND,
    ERR_QUICSTREAM_DESTROYED,
    ERR_QUICSTREAM_INVALID_PUSH,
    ERR_QUICSTREAM_OPEN_FAILED,
    ERR_QUICSTREAM_UNSUPPORTED_PUSH,
    ERR_QUIC_TLS13_REQUIRED,
    ERR_SCRIPT_EXECUTION_INTERRUPTED,
    ERR_SERVER_ALREADY_LISTEN,
    ERR_SERVER_NOT_RUNNING,
    ERR_SOCKET_ALREADY_BOUND,
    ERR_SOCKET_BAD_BUFFER_SIZE,
    ERR_SOCKET_BAD_PORT,
    ERR_SOCKET_BAD_TYPE,
    ERR_SOCKET_BUFFER_SIZE,
    ERR_SOCKET_CLOSED,
    ERR_SOCKET_DGRAM_IS_CONNECTED,
    ERR_SOCKET_DGRAM_NOT_CONNECTED,
    ERR_SOCKET_DGRAM_NOT_RUNNING,
    ERR_SRI_PARSE,
    ERR_STREAM_ALREADY_FINISHED,
    ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES,
    ERR_STREAM_PREMATURE_CLOSE,
    ERR_STREAM_PUSH_AFTER_EOF,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT,
    ERR_STREAM_WRAP,
    ERR_STREAM_WRITE_AFTER_END,
    ERR_SYNTHETIC,
    ERR_TLS_CERT_ALTNAME_INVALID,
    ERR_TLS_DH_PARAM_SIZE,
    ERR_TLS_HANDSHAKE_TIMEOUT,
    ERR_TLS_INVALID_CONTEXT,
    ERR_TLS_INVALID_PROTOCOL_VERSION,
    ERR_TLS_INVALID_STATE,
    ERR_TLS_PROTOCOL_VERSION_CONFLICT,
    ERR_TLS_RENEGOTIATION_DISABLED,
    ERR_TLS_REQUIRED_SERVER_NAME,
    ERR_TLS_SESSION_ATTACK,
    ERR_TLS_SNI_FROM_SERVER,
    ERR_TRACE_EVENTS_CATEGORY_REQUIRED,
    ERR_TRACE_EVENTS_UNAVAILABLE,
    ERR_UNAVAILABLE_DURING_EXIT,
    ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET,
    ERR_UNESCAPED_CHARACTERS,
    ERR_UNHANDLED_ERROR,
    ERR_UNKNOWN_BUILTIN_MODULE,
    ERR_UNKNOWN_CREDENTIAL,
    ERR_UNKNOWN_ENCODING,
    ERR_UNKNOWN_FILE_EXTENSION,
    ERR_UNKNOWN_MODULE_FORMAT,
    ERR_UNKNOWN_SIGNAL,
    ERR_UNSUPPORTED_DIR_IMPORT,
    ERR_UNSUPPORTED_ESM_URL_SCHEME,
    ERR_USE_AFTER_CLOSE,
    ERR_V8BREAKITERATOR,
    ERR_VALID_PERFORMANCE_ENTRY_TYPE,
    ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING,
    ERR_VM_MODULE_ALREADY_LINKED,
    ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA,
    ERR_VM_MODULE_DIFFERENT_CONTEXT,
    ERR_VM_MODULE_LINKING_ERRORED,
    ERR_VM_MODULE_NOT_MODULE,
    ERR_VM_MODULE_STATUS,
    ERR_WASI_ALREADY_STARTED,
    ERR_WORKER_INIT_FAILED,
    ERR_WORKER_NOT_RUNNING,
    ERR_WORKER_OUT_OF_MEMORY,
    ERR_WORKER_UNSERIALIZABLE_ERROR,
    ERR_WORKER_UNSUPPORTED_EXTENSION,
    ERR_WORKER_UNSUPPORTED_OPERATION,
    ERR_ZLIB_INITIALIZATION_FAILED,
    NodeError,
    NodeErrorAbstraction,
    NodeRangeError,
    NodeSyntaxError,
    NodeTypeError,
    NodeURIError,
    aggregateTwoErrors,
    codes,
    connResetException,
    denoErrorToNodeError,
    dnsException,
    errnoException,
    errorMap,
    exceptionWithHostPort,
    genericNodeError,
    hideStackFrames,
    isStackOverflowError,
    uvException,
    uvExceptionWithHostPort
};
"use strict";
const kRejection = Symbol.for("nodejs.rejection");
const kCapture = Symbol("kCapture");
const kErrorMonitor = Symbol("events.errorMonitor");
const kMaxEventTargetListeners = Symbol("events.maxEventTargetListeners");
const kMaxEventTargetListenersWarned = Symbol("events.maxEventTargetListenersWarned");
function EventEmitter(opts) {
    EventEmitter.init.call(this, opts);
}
EventEmitter.on = on;
EventEmitter.once = once;
EventEmitter.getEventListeners = getEventListeners;
EventEmitter.setMaxListeners = setMaxListeners;
EventEmitter.listenerCount = listenerCount;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.captureRejectionSymbol = kRejection;
EventEmitter.captureRejectionSymbol;
EventEmitter.errorMonitor;
Object.defineProperty(EventEmitter, "captureRejections", {
    get () {
        return EventEmitter.prototype[kCapture];
    },
    set (value) {
        validateBoolean(value, "EventEmitter.captureRejections");
        EventEmitter.prototype[kCapture] = value;
    },
    enumerable: true
});
EventEmitter.errorMonitor = kErrorMonitor;
Object.defineProperty(EventEmitter.prototype, kCapture, {
    value: false,
    writable: true,
    enumerable: false
});
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
let defaultMaxListeners = 10;
function checkListener(listener) {
    validateFunction(listener, "listener");
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || Number.isNaN(arg)) {
            throw new ERR_OUT_OF_RANGE("defaultMaxListeners", "a non-negative number", arg);
        }
        defaultMaxListeners = arg;
    }
});
Object.defineProperties(EventEmitter, {
    kMaxEventTargetListeners: {
        value: kMaxEventTargetListeners,
        enumerable: false,
        configurable: false,
        writable: false
    },
    kMaxEventTargetListenersWarned: {
        value: kMaxEventTargetListenersWarned,
        enumerable: false,
        configurable: false,
        writable: false
    }
});
function setMaxListeners(n = defaultMaxListeners, ...eventTargets) {
    if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
    }
    if (eventTargets.length === 0) {
        defaultMaxListeners = n;
    } else {
        for(let i = 0; i < eventTargets.length; i++){
            const target = eventTargets[i];
            if (target instanceof EventTarget) {
                target[kMaxEventTargetListeners] = n;
                target[kMaxEventTargetListenersWarned] = false;
            } else if (typeof target.setMaxListeners === "function") {
                target.setMaxListeners(n);
            } else {
                throw new ERR_INVALID_ARG_TYPE("eventTargets", [
                    "EventEmitter",
                    "EventTarget"
                ], target);
            }
        }
    }
}
EventEmitter.init = function(opts) {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
    if (opts?.captureRejections) {
        validateBoolean(opts.captureRejections, "options.captureRejections");
        this[kCapture] = Boolean(opts.captureRejections);
    } else {
        this[kCapture] = EventEmitter.prototype[kCapture];
    }
};
function addCatch(that, promise, type, args) {
    if (!that[kCapture]) {
        return;
    }
    try {
        const then = promise.then;
        if (typeof then === "function") {
            then.call(promise, undefined, function(err) {
                process.nextTick(emitUnhandledRejectionOrErr, that, err, type, args);
            });
        }
    } catch (err) {
        that.emit("error", err);
    }
}
function emitUnhandledRejectionOrErr(ee, err, type, args) {
    if (typeof ee[kRejection] === "function") {
        ee[kRejection](err, type, ...args);
    } else {
        const prev = ee[kCapture];
        try {
            ee[kCapture] = false;
            ee.emit("error", err);
        } finally{
            ee[kCapture] = prev;
        }
    }
}
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
    }
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) {
        return EventEmitter.defaultMaxListeners;
    }
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type, ...args) {
    let doError = type === "error";
    const events = this._events;
    if (events !== undefined) {
        if (doError && events[kErrorMonitor] !== undefined) {
            this.emit(kErrorMonitor, ...args);
        }
        doError = doError && events.error === undefined;
    } else if (!doError) {
        return false;
    }
    if (doError) {
        let er;
        if (args.length > 0) {
            er = args[0];
        }
        if (er instanceof Error) {
            try {
                const capture = {};
                Error.captureStackTrace(capture, EventEmitter.prototype.emit);
            } catch  {}
            throw er;
        }
        let stringifiedEr;
        try {
            stringifiedEr = inspect(er);
        } catch  {
            stringifiedEr = er;
        }
        const err = new ERR_UNHANDLED_ERROR(stringifiedEr);
        err.context = er;
        throw err;
    }
    const handler = events[type];
    if (handler === undefined) {
        return false;
    }
    if (typeof handler === "function") {
        const result = handler.apply(this, args);
        if (result !== undefined && result !== null) {
            addCatch(this, result, type, args);
        }
    } else {
        const len = handler.length;
        const listeners = arrayClone(handler);
        for(let i = 0; i < len; ++i){
            const result = listeners[i].apply(this, args);
            if (result !== undefined && result !== null) {
                addCatch(this, result, type, args);
            }
        }
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    let m;
    let events;
    let existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        if (events.newListener !== undefined) {
            target.emit("newListener", type, listener.listener ?? listener);
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === "function") {
            existing = events[type] = prepend ? [
                listener,
                existing
            ] : [
                existing,
                listener
            ];
        } else if (prepend) {
            existing.unshift(listener);
        } else {
            existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            const w = new Error("Possible EventEmitter memory leak detected. " + `${existing.length} ${String(type)} listeners ` + `added to ${inspect(target, {
                depth: -1
            })}. Use ` + "emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            process.emitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) {
            return this.listener.call(this.target);
        }
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    const state = {
        fired: false,
        wrapFn: undefined,
        target,
        type,
        listener
    };
    const wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    checkListener(listener);
    const events = this._events;
    if (events === undefined) {
        return this;
    }
    const list = events[type];
    if (list === undefined) {
        return this;
    }
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) {
            this._events = Object.create(null);
        } else {
            delete events[type];
            if (events.removeListener) {
                this.emit("removeListener", type, list.listener || listener);
            }
        }
    } else if (typeof list !== "function") {
        let position = -1;
        for(let i = list.length - 1; i >= 0; i--){
            if (list[i] === listener || list[i].listener === listener) {
                position = i;
                break;
            }
        }
        if (position < 0) {
            return this;
        }
        if (position === 0) {
            list.shift();
        } else {
            spliceOne(list, position);
        }
        if (list.length === 1) {
            events[type] = list[0];
        }
        if (events.removeListener !== undefined) {
            this.emit("removeListener", type, listener);
        }
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    const events = this._events;
    if (events === undefined) {
        return this;
    }
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) {
                this._events = Object.create(null);
            } else {
                delete events[type];
            }
        }
        return this;
    }
    if (arguments.length === 0) {
        for (const key of Reflect.ownKeys(events)){
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    const listeners = events[type];
    if (typeof listeners === "function") {
        this.removeListener(type, listeners);
    } else if (listeners !== undefined) {
        for(let i = listeners.length - 1; i >= 0; i--){
            this.removeListener(type, listeners[i]);
        }
    }
    return this;
};
function _listeners(target, type, unwrap) {
    const events = target._events;
    if (events === undefined) {
        return [];
    }
    const evlistener = events[type];
    if (evlistener === undefined) {
        return [];
    }
    if (typeof evlistener === "function") {
        return unwrap ? [
            evlistener.listener || evlistener
        ] : [
            evlistener
        ];
    }
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
const _listenerCount = function listenerCount(type) {
    const events = this._events;
    if (events !== undefined) {
        const evlistener = events[type];
        if (typeof evlistener === "function") {
            return 1;
        } else if (evlistener !== undefined) {
            return evlistener.length;
        }
    }
    return 0;
};
EventEmitter.prototype.listenerCount = _listenerCount;
function listenerCount(emitter, type) {
    if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
    }
    return _listenerCount.call(emitter, type);
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function arrayClone(arr) {
    switch(arr.length){
        case 2:
            return [
                arr[0],
                arr[1]
            ];
        case 3:
            return [
                arr[0],
                arr[1],
                arr[2]
            ];
        case 4:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3]
            ];
        case 5:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4]
            ];
        case 6:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4],
                arr[5]
            ];
    }
    return arr.slice();
}
function unwrapListeners(arr) {
    const ret = arrayClone(arr);
    for(let i = 0; i < ret.length; ++i){
        const orig = ret[i].listener;
        if (typeof orig === "function") {
            ret[i] = orig;
        }
    }
    return ret;
}
function getEventListeners(emitterOrTarget, type) {
    if (typeof emitterOrTarget.listeners === "function") {
        return emitterOrTarget.listeners(type);
    }
    if (emitterOrTarget instanceof EventTarget) {
        const root = emitterOrTarget[kEvents].get(type);
        const listeners = [];
        let handler = root?.next;
        while(handler?.listener !== undefined){
            const listener = handler.listener?.deref ? handler.listener.deref() : handler.listener;
            listeners.push(listener);
            handler = handler.next;
        }
        return listeners;
    }
    throw new ERR_INVALID_ARG_TYPE("emitter", [
        "EventEmitter",
        "EventTarget"
    ], emitterOrTarget);
}
async function once(emitter, name, options = {}) {
    const signal = options?.signal;
    validateAbortSignal(signal, "options.signal");
    if (signal?.aborted) {
        throw new AbortError();
    }
    return new Promise((resolve, reject)=>{
        const errorListener = (err)=>{
            emitter.removeListener(name, resolver);
            if (signal != null) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
            }
            reject(err);
        };
        const resolver = (...args)=>{
            if (typeof emitter.removeListener === "function") {
                emitter.removeListener("error", errorListener);
            }
            if (signal != null) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
            }
            resolve(args);
        };
        eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
        });
        if (name !== "error" && typeof emitter.once === "function") {
            emitter.once("error", errorListener);
        }
        function abortListener() {
            eventTargetAgnosticRemoveListener(emitter, name, resolver);
            eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
            reject(new AbortError());
        }
        if (signal != null) {
            eventTargetAgnosticAddListener(signal, "abort", abortListener, {
                once: true
            });
        }
    });
}
const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);
function createIterResult(value, done) {
    return {
        value,
        done
    };
}
function eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {
    if (typeof emitter.removeListener === "function") {
        emitter.removeListener(name, listener);
    } else if (typeof emitter.removeEventListener === "function") {
        emitter.removeEventListener(name, listener, flags);
    } else {
        throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
    }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
        if (flags?.once) {
            emitter.once(name, listener);
        } else {
            emitter.on(name, listener);
        }
    } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, (arg)=>{
            listener(arg);
        }, flags);
    } else {
        throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
    }
}
function on(emitter, event, options) {
    const signal = options?.signal;
    validateAbortSignal(signal, "options.signal");
    if (signal?.aborted) {
        throw new AbortError();
    }
    const unconsumedEvents = [];
    const unconsumedPromises = [];
    let error = null;
    let finished = false;
    const iterator = Object.setPrototypeOf({
        next () {
            const value = unconsumedEvents.shift();
            if (value) {
                return Promise.resolve(createIterResult(value, false));
            }
            if (error) {
                const p = Promise.reject(error);
                error = null;
                return p;
            }
            if (finished) {
                return Promise.resolve(createIterResult(undefined, true));
            }
            return new Promise(function(resolve, reject) {
                unconsumedPromises.push({
                    resolve,
                    reject
                });
            });
        },
        return () {
            eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
            eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
            if (signal) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener, {
                    once: true
                });
            }
            finished = true;
            for (const promise of unconsumedPromises){
                promise.resolve(createIterResult(undefined, true));
            }
            return Promise.resolve(createIterResult(undefined, true));
        },
        throw (err) {
            if (!err || !(err instanceof Error)) {
                throw new ERR_INVALID_ARG_TYPE("EventEmitter.AsyncIterator", "Error", err);
            }
            error = err;
            eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
            eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    }, AsyncIteratorPrototype);
    eventTargetAgnosticAddListener(emitter, event, eventHandler);
    if (event !== "error" && typeof emitter.on === "function") {
        emitter.on("error", errorHandler);
    }
    if (signal) {
        eventTargetAgnosticAddListener(signal, "abort", abortListener, {
            once: true
        });
    }
    return iterator;
    function abortListener() {
        errorHandler(new AbortError());
    }
    function eventHandler(...args) {
        const promise = unconsumedPromises.shift();
        if (promise) {
            promise.resolve(createIterResult(args, false));
        } else {
            unconsumedEvents.push(args);
        }
    }
    function errorHandler(err) {
        finished = true;
        const toError = unconsumedPromises.shift();
        if (toError) {
            toError.reject(err);
        } else {
            error = err;
        }
        iterator.return();
    }
}
const { hasOwn  } = Object;
function get(obj, key) {
    if (hasOwn(obj, key)) {
        return obj[key];
    }
}
function getForce(obj, key) {
    const v = get(obj, key);
    assert(v != null);
    return v;
}
function isNumber(x) {
    if (typeof x === "number") return true;
    if (/^0x[0-9a-f]+$/i.test(String(x))) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(String(x));
}
function hasKey(obj, keys) {
    let o = obj;
    keys.slice(0, -1).forEach((key)=>{
        o = get(o, key) ?? {};
    });
    const key = keys[keys.length - 1];
    return hasOwn(o, key);
}
function parse(args, { "--": doubleDash = false , alias ={} , boolean: __boolean = false , default: defaults = {} , stopEarly =false , string =[] , collect =[] , negatable =[] , unknown =(i)=>i  } = {}) {
    const aliases = {};
    const flags = {
        bools: {},
        strings: {},
        unknownFn: unknown,
        allBools: false,
        collect: {},
        negatable: {}
    };
    if (alias !== undefined) {
        for(const key in alias){
            const val = getForce(alias, key);
            if (typeof val === "string") {
                aliases[key] = [
                    val
                ];
            } else {
                aliases[key] = val;
            }
            for (const alias of getForce(aliases, key)){
                aliases[alias] = [
                    key
                ].concat(aliases[key].filter((y)=>alias !== y));
            }
        }
    }
    if (__boolean !== undefined) {
        if (typeof __boolean === "boolean") {
            flags.allBools = !!__boolean;
        } else {
            const booleanArgs = typeof __boolean === "string" ? [
                __boolean
            ] : __boolean;
            for (const key of booleanArgs.filter(Boolean)){
                flags.bools[key] = true;
                const alias = get(aliases, key);
                if (alias) {
                    for (const al of alias){
                        flags.bools[al] = true;
                    }
                }
            }
        }
    }
    if (string !== undefined) {
        const stringArgs = typeof string === "string" ? [
            string
        ] : string;
        for (const key of stringArgs.filter(Boolean)){
            flags.strings[key] = true;
            const alias = get(aliases, key);
            if (alias) {
                for (const al of alias){
                    flags.strings[al] = true;
                }
            }
        }
    }
    if (collect !== undefined) {
        const collectArgs = typeof collect === "string" ? [
            collect
        ] : collect;
        for (const key of collectArgs.filter(Boolean)){
            flags.collect[key] = true;
            const alias = get(aliases, key);
            if (alias) {
                for (const al of alias){
                    flags.collect[al] = true;
                }
            }
        }
    }
    if (negatable !== undefined) {
        const negatableArgs = typeof negatable === "string" ? [
            negatable
        ] : negatable;
        for (const key of negatableArgs.filter(Boolean)){
            flags.negatable[key] = true;
            const alias = get(aliases, key);
            if (alias) {
                for (const al of alias){
                    flags.negatable[al] = true;
                }
            }
        }
    }
    const argv = {
        _: []
    };
    function argDefined(key, arg) {
        return flags.allBools && /^--[^=]+$/.test(arg) || get(flags.bools, key) || !!get(flags.strings, key) || !!get(aliases, key);
    }
    function setKey(obj, name, value, collect = true) {
        let o = obj;
        const keys = name.split(".");
        keys.slice(0, -1).forEach(function(key) {
            if (get(o, key) === undefined) {
                o[key] = {};
            }
            o = get(o, key);
        });
        const key = keys[keys.length - 1];
        const collectable = collect && !!get(flags.collect, name);
        if (!collectable) {
            o[key] = value;
        } else if (get(o, key) === undefined) {
            o[key] = [
                value
            ];
        } else if (Array.isArray(get(o, key))) {
            o[key].push(value);
        } else {
            o[key] = [
                get(o, key),
                value
            ];
        }
    }
    function setArg(key, val, arg = undefined, collect) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg, key, val) === false) return;
        }
        const value = !get(flags.strings, key) && isNumber(val) ? Number(val) : val;
        setKey(argv, key, value, collect);
        const alias = get(aliases, key);
        if (alias) {
            for (const x of alias){
                setKey(argv, x, value, collect);
            }
        }
    }
    function aliasIsBoolean(key) {
        return getForce(aliases, key).some((x)=>typeof get(flags.bools, x) === "boolean");
    }
    let notFlags = [];
    if (args.includes("--")) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
    }
    for(let i = 0; i < args.length; i++){
        const arg = args[i];
        if (/^--.+=/.test(arg)) {
            const m = arg.match(/^--([^=]+)=(.*)$/s);
            assert(m != null);
            const [, key, value] = m;
            if (flags.bools[key]) {
                const booleanValue = value !== "false";
                setArg(key, booleanValue, arg);
            } else {
                setArg(key, value, arg);
            }
        } else if (/^--no-.+/.test(arg) && get(flags.negatable, arg.replace(/^--no-/, ""))) {
            const m = arg.match(/^--no-(.+)/);
            assert(m != null);
            setArg(m[1], false, arg, false);
        } else if (/^--.+/.test(arg)) {
            const m = arg.match(/^--(.+)/);
            assert(m != null);
            const [, key] = m;
            const next = args[i + 1];
            if (next !== undefined && !/^-/.test(next) && !get(flags.bools, key) && !flags.allBools && (get(aliases, key) ? !aliasIsBoolean(key) : true)) {
                setArg(key, next, arg);
                i++;
            } else if (/^(true|false)$/.test(next)) {
                setArg(key, next === "true", arg);
                i++;
            } else {
                setArg(key, get(flags.strings, key) ? "" : true, arg);
            }
        } else if (/^-[^-]+/.test(arg)) {
            const letters = arg.slice(1, -1).split("");
            let broken = false;
            for(let j = 0; j < letters.length; j++){
                const next = arg.slice(j + 2);
                if (next === "-") {
                    setArg(letters[j], next, arg);
                    continue;
                }
                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
                    setArg(letters[j], next.split(/=(.+)/)[1], arg);
                    broken = true;
                    break;
                }
                if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                    setArg(letters[j], next, arg);
                    broken = true;
                    break;
                }
                if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j + 2), arg);
                    broken = true;
                    break;
                } else {
                    setArg(letters[j], get(flags.strings, letters[j]) ? "" : true, arg);
                }
            }
            const [key] = arg.slice(-1);
            if (!broken && key !== "-") {
                if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !get(flags.bools, key) && (get(aliases, key) ? !aliasIsBoolean(key) : true)) {
                    setArg(key, args[i + 1], arg);
                    i++;
                } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
                    setArg(key, args[i + 1] === "true", arg);
                    i++;
                } else {
                    setArg(key, get(flags.strings, key) ? "" : true, arg);
                }
            }
        } else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                argv._.push(flags.strings["_"] ?? !isNumber(arg) ? arg : Number(arg));
            }
            if (stopEarly) {
                argv._.push(...args.slice(i + 1));
                break;
            }
        }
    }
    for (const [key, value] of Object.entries(defaults)){
        if (!hasKey(argv, key.split("."))) {
            setKey(argv, key, value);
            if (aliases[key]) {
                for (const x of aliases[key]){
                    setKey(argv, x, value);
                }
            }
        }
    }
    for (const key of Object.keys(flags.bools)){
        if (!hasKey(argv, key.split("."))) {
            const value = get(flags.collect, key) ? [] : false;
            setKey(argv, key, value, false);
        }
    }
    for (const key of Object.keys(flags.strings)){
        if (!hasKey(argv, key.split(".")) && get(flags.collect, key)) {
            setKey(argv, key, [], false);
        }
    }
    if (doubleDash) {
        argv["--"] = [];
        for (const key of notFlags){
            argv["--"].push(key);
        }
    } else {
        for (const key of notFlags){
            argv._.push(key);
        }
    }
    return argv;
}
function getOptions() {
    const { Deno: Deno1  } = globalThis;
    const args = parse(Deno1?.args ?? []);
    const options = new Map(Object.entries(args).map(([key, value])=>[
            key,
            {
                value
            }
        ]));
    return {
        options
    };
}
let optionsMap;
function getOptionsFromBinding() {
    if (!optionsMap) {
        ({ options: optionsMap  } = getOptions());
    }
    return optionsMap;
}
function getOptionValue(optionName) {
    const options = getOptionsFromBinding();
    if (optionName.startsWith("--no-")) {
        const option = options.get("--" + optionName.slice(5));
        return option && !option.value;
    }
    return options.get(optionName)?.value;
}
const CHAR_FORWARD_SLASH = 47;
function assertPath(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator(code) {
    return code === 47;
}
function isPathSeparator(code) {
    return isPosixPathSeparator(code) || code === 92;
}
function isWindowsDeviceRoot(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (base === sep) return dir;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS[c] ?? c;
    });
}
function lastPathSegment(path, isSep, start = 0) {
    let matchedNonSeparator = false;
    let end = path.length;
    for(let i = path.length - 1; i >= start; --i){
        if (isSep(path.charCodeAt(i))) {
            if (matchedNonSeparator) {
                start = i + 1;
                break;
            }
        } else if (!matchedNonSeparator) {
            matchedNonSeparator = true;
            end = i + 1;
        }
    }
    return path.slice(start, end);
}
function stripTrailingSeparators(segment, isSep) {
    if (segment.length <= 1) {
        return segment;
    }
    let end = segment.length;
    for(let i = segment.length - 1; i > 0; i--){
        if (isSep(segment.charCodeAt(i))) {
            end = i;
        } else {
            break;
        }
    }
    return segment.slice(0, end);
}
function stripSuffix(name, suffix) {
    if (suffix.length >= name.length) {
        return name;
    }
    const lenDiff = name.length - suffix.length;
    for(let i = suffix.length - 1; i >= 0; --i){
        if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {
            return name;
        }
    }
    return name.slice(0, -suffix.length);
}
const sep = "\\";
const delimiter = ";";
function resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1  } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator(code)) {
                isAbsolute = true;
                if (isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            isAbsolute = true;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator(code)) {
        return true;
    } else if (isWindowsDeviceRoot(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join1(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert(firstPart != null);
    if (isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize(joined);
}
function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    const fromOrig = resolve(from);
    const toOrig = resolve(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator);
}
function basename(path, suffix = "") {
    assertPath(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);
    }
    let start = 0;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    const lastSegment = lastPathSegment(path, isPathSeparator, start);
    const strippedSegment = stripTrailingSeparators(lastSegment, isPathSeparator);
    return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
}
function extname(path) {
    assertPath(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format1(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("\\", pathObject);
}
function parse1(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            ret.base = "\\";
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        ret.root = ret.dir = path;
        ret.base = "\\";
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    ret.base = ret.base || "\\";
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl(path) {
    if (!isAbsolute(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod5 = {
    sep: sep,
    delimiter: delimiter,
    resolve: resolve,
    normalize: normalize,
    isAbsolute: isAbsolute,
    join: join1,
    relative: relative,
    toNamespacedPath: toNamespacedPath,
    dirname: dirname,
    basename: basename,
    extname: extname,
    format: format1,
    parse: parse1,
    fromFileUrl: fromFileUrl,
    toFileUrl: toFileUrl
};
const sep1 = "/";
const delimiter1 = ":";
function resolve1(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1  } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = isPosixPathSeparator(path.charCodeAt(0));
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize1(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const isAbsolute = isPosixPathSeparator(path.charCodeAt(0));
    const trailingSeparator = isPosixPathSeparator(path.charCodeAt(path.length - 1));
    path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute1(path) {
    assertPath(path);
    return path.length > 0 && isPosixPathSeparator(path.charCodeAt(0));
}
function join2(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize1(joined);
}
function relative1(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    from = resolve1(from);
    to = resolve1(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (!isPosixPathSeparator(from.charCodeAt(fromStart))) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (!isPosixPathSeparator(to.charCodeAt(toStart))) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (isPosixPathSeparator(to.charCodeAt(toStart + i))) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (isPosixPathSeparator(from.charCodeAt(fromStart + i))) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (isPosixPathSeparator(fromCode)) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || isPosixPathSeparator(from.charCodeAt(i))) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (isPosixPathSeparator(to.charCodeAt(toStart))) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath1(path) {
    return path;
}
function dirname1(path) {
    if (path.length === 0) return ".";
    let end = -1;
    let matchedNonSeparator = false;
    for(let i = path.length - 1; i >= 1; --i){
        if (isPosixPathSeparator(path.charCodeAt(i))) {
            if (matchedNonSeparator) {
                end = i;
                break;
            }
        } else {
            matchedNonSeparator = true;
        }
    }
    if (end === -1) {
        return isPosixPathSeparator(path.charCodeAt(0)) ? "/" : ".";
    }
    return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator);
}
function basename1(path, suffix = "") {
    assertPath(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);
    }
    const lastSegment = lastPathSegment(path, isPosixPathSeparator);
    const strippedSegment = stripTrailingSeparators(lastSegment, isPosixPathSeparator);
    return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
}
function extname1(path) {
    assertPath(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (isPosixPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format2(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("/", pathObject);
}
function parse2(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = isPosixPathSeparator(path.charCodeAt(0));
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPosixPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
        ret.base = ret.base || "/";
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) {
        ret.dir = stripTrailingSeparators(path.slice(0, startPart - 1), isPosixPathSeparator);
    } else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl1(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl1(path) {
    if (!isAbsolute1(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod6 = {
    sep: sep1,
    delimiter: delimiter1,
    resolve: resolve1,
    normalize: normalize1,
    isAbsolute: isAbsolute1,
    join: join2,
    relative: relative1,
    toNamespacedPath: toNamespacedPath1,
    dirname: dirname1,
    basename: basename1,
    extname: extname1,
    format: format2,
    parse: parse2,
    fromFileUrl: fromFileUrl1,
    toFileUrl: toFileUrl1
};
const path = isWindows ? mod5 : mod6;
const { join: join3 , normalize: normalize2  } = path;
const path1 = isWindows ? mod5 : mod6;
const { basename: basename2 , delimiter: delimiter2 , dirname: dirname2 , extname: extname2 , format: format3 , fromFileUrl: fromFileUrl2 , isAbsolute: isAbsolute2 , join: join4 , normalize: normalize3 , parse: parse3 , relative: relative2 , resolve: resolve2 , sep: sep2 , toFileUrl: toFileUrl2 , toNamespacedPath: toNamespacedPath2  } = path1;
let _exiting = false;
const kSize = 2048;
const kMask = 2048 - 1;
class FixedCircularBuffer {
    bottom;
    top;
    list;
    next;
    constructor(){
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
    }
    isEmpty() {
        return this.top === this.bottom;
    }
    isFull() {
        return (this.top + 1 & kMask) === this.bottom;
    }
    push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
    }
    shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === undefined) {
            return null;
        }
        this.list[this.bottom] = undefined;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
    }
}
class FixedQueue {
    head;
    tail;
    constructor(){
        this.head = this.tail = new FixedCircularBuffer();
    }
    isEmpty() {
        return this.head.isEmpty();
    }
    push(data) {
        if (this.head.isFull()) {
            this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
    }
    shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
            this.tail = tail.next;
        }
        return next;
    }
}
const queue = new FixedQueue();
let _nextTick;
function processTicksAndRejections() {
    let tock;
    do {
        while(tock = queue.shift()){
            try {
                const callback = tock.callback;
                if (tock.args === undefined) {
                    callback();
                } else {
                    const args = tock.args;
                    switch(args.length){
                        case 1:
                            callback(args[0]);
                            break;
                        case 2:
                            callback(args[0], args[1]);
                            break;
                        case 3:
                            callback(args[0], args[1], args[2]);
                            break;
                        case 4:
                            callback(args[0], args[1], args[2], args[3]);
                            break;
                        default:
                            callback(...args);
                    }
                }
            } finally{}
        }
        core.runMicrotasks();
    }while (!queue.isEmpty())
    core.setHasTickScheduled(false);
}
if (typeof core.setNextTickCallback !== "undefined") {
    function runNextTicks() {
        if (!core.hasTickScheduled()) {
            core.runMicrotasks();
        }
        if (!core.hasTickScheduled()) {
            return true;
        }
        processTicksAndRejections();
        return true;
    }
    core.setNextTickCallback(processTicksAndRejections);
    core.setMacrotaskCallback(runNextTicks);
    function __nextTickNative(callback, ...args) {
        validateFunction(callback, "callback");
        if (_exiting) {
            return;
        }
        let args_;
        switch(args.length){
            case 0:
                break;
            case 1:
                args_ = [
                    args[0]
                ];
                break;
            case 2:
                args_ = [
                    args[0],
                    args[1]
                ];
                break;
            case 3:
                args_ = [
                    args[0],
                    args[1],
                    args[2]
                ];
                break;
            default:
                args_ = new Array(args.length);
                for(let i = 0; i < args.length; i++){
                    args_[i] = args[i];
                }
        }
        if (queue.isEmpty()) {
            core.setHasTickScheduled(true);
        }
        const tickObject = {
            callback,
            args: args_
        };
        queue.push(tickObject);
    }
    _nextTick = __nextTickNative;
} else {
    function __nextTickQueueMicrotask(callback, ...args) {
        if (args) {
            queueMicrotask(()=>callback.call(this, ...args));
        } else {
            queueMicrotask(callback);
        }
    }
    _nextTick = __nextTickQueueMicrotask;
}
function nextTick1(callback, ...args) {
    _nextTick(callback, ...args);
}
function _arch() {
    if (Deno.build.arch == "x86_64") {
        return "x64";
    } else if (Deno.build.arch == "aarch64") {
        return "arm64";
    } else {
        throw Error("unreachable");
    }
}
const arch = _arch();
const chdir = Deno.chdir;
const cwd = Deno.cwd;
function denoEnvGet(name) {
    try {
        return Deno.env.get(name);
    } catch (e) {
        if (e instanceof TypeError) {
            return undefined;
        }
        throw e;
    }
}
const OBJECT_PROTO_PROP_NAMES = Object.getOwnPropertyNames(Object.prototype);
const env = new Proxy(Object(), {
    get: (target, prop)=>{
        if (typeof prop === "symbol") {
            return target[prop];
        }
        const envValue = denoEnvGet(prop);
        if (envValue) {
            return envValue;
        }
        if (OBJECT_PROTO_PROP_NAMES.includes(prop)) {
            return target[prop];
        }
        return envValue;
    },
    ownKeys: ()=>Reflect.ownKeys(Deno.env.toObject()),
    getOwnPropertyDescriptor: (_target, name)=>{
        const value = denoEnvGet(String(name));
        if (value) {
            return {
                enumerable: true,
                configurable: true,
                value
            };
        }
    },
    set (_target, prop, value) {
        Deno.env.set(String(prop), String(value));
        return true;
    },
    has: (_target, prop)=>typeof denoEnvGet(String(prop)) === "string"
});
const pid = Deno.pid;
const platform = isWindows ? "win32" : Deno.build.os;
const version = "v18.12.1";
const versions = {
    node: "18.12.1",
    uv: "1.43.0",
    zlib: "1.2.11",
    brotli: "1.0.9",
    ares: "1.18.1",
    modules: "108",
    nghttp2: "1.47.0",
    napi: "8",
    llhttp: "6.0.10",
    openssl: "3.0.7+quic",
    cldr: "41.0",
    icu: "71.1",
    tz: "2022b",
    unicode: "14.0",
    ngtcp2: "0.8.1",
    nghttp3: "0.7.0",
    ...Deno.version
};
var Encodings;
(function(Encodings) {
    Encodings[Encodings["ASCII"] = 0] = "ASCII";
    Encodings[Encodings["UTF8"] = 1] = "UTF8";
    Encodings[Encodings["BASE64"] = 2] = "BASE64";
    Encodings[Encodings["UCS2"] = 3] = "UCS2";
    Encodings[Encodings["BINARY"] = 4] = "BINARY";
    Encodings[Encodings["HEX"] = 5] = "HEX";
    Encodings[Encodings["BUFFER"] = 6] = "BUFFER";
    Encodings[Encodings["BASE64URL"] = 7] = "BASE64URL";
    Encodings[Encodings["LATIN1"] = 4] = "LATIN1";
})(Encodings || (Encodings = {}));
const encodings = [];
encodings[Encodings.ASCII] = "ascii";
encodings[Encodings.BASE64] = "base64";
encodings[Encodings.BASE64URL] = "base64url";
encodings[Encodings.BUFFER] = "buffer";
encodings[Encodings.HEX] = "hex";
encodings[Encodings.LATIN1] = "latin1";
encodings[Encodings.UCS2] = "utf16le";
encodings[Encodings.UTF8] = "utf8";
const __default3 = {
    encodings
};
const mod7 = {
    encodings: encodings,
    default: __default3
};
function indexOfNeedle(source, needle, start = 0) {
    if (start >= source.length) {
        return -1;
    }
    if (start < 0) {
        start = Math.max(0, source.length + start);
    }
    const s = needle[0];
    for(let i = start; i < source.length; i++){
        if (source[i] !== s) continue;
        const pin = i;
        let matched = 1;
        let j = i;
        while(matched < needle.length){
            j++;
            if (source[j] !== needle[j - pin]) {
                break;
            }
            matched++;
        }
        if (matched === needle.length) {
            return pin;
        }
    }
    return -1;
}
function numberToBytes(n) {
    if (n === 0) return new Uint8Array([
        0
    ]);
    const bytes = [];
    bytes.unshift(n & 255);
    while(n >= 256){
        n = n >>> 8;
        bytes.unshift(n & 255);
    }
    return new Uint8Array(bytes);
}
function findLastIndex(targetBuffer, buffer, offset) {
    offset = offset > targetBuffer.length ? targetBuffer.length : offset;
    const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
    const searchableBufferLastIndex = searchableBuffer.length - 1;
    const bufferLastIndex = buffer.length - 1;
    let lastMatchIndex = -1;
    let matches = 0;
    let index = -1;
    for(let x = 0; x <= searchableBufferLastIndex; x++){
        if (searchableBuffer[searchableBufferLastIndex - x] === buffer[bufferLastIndex - matches]) {
            if (lastMatchIndex === -1) {
                lastMatchIndex = x;
            }
            matches++;
        } else {
            matches = 0;
            if (lastMatchIndex !== -1) {
                x = lastMatchIndex + 1;
                lastMatchIndex = -1;
            }
            continue;
        }
        if (matches === buffer.length) {
            index = x;
            break;
        }
    }
    if (index === -1) return index;
    return searchableBufferLastIndex - index;
}
function indexOfBuffer(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
    if (!Encodings[encoding] === undefined) {
        throw new Error(`Unknown encoding code ${encoding}`);
    }
    if (!forwardDirection) {
        if (byteOffset < 0) {
            byteOffset = targetBuffer.length + byteOffset;
        }
        if (buffer.length === 0) {
            return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
        }
        return findLastIndex(targetBuffer, buffer, byteOffset);
    }
    if (buffer.length === 0) {
        return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return indexOfNeedle(targetBuffer, buffer, byteOffset);
}
function indexOfNumber(targetBuffer, number, byteOffset, forwardDirection) {
    const bytes = numberToBytes(number);
    if (bytes.length > 1) {
        throw new Error("Multi byte number search is not supported");
    }
    return indexOfBuffer(targetBuffer, numberToBytes(number), byteOffset, Encodings.UTF8, forwardDirection);
}
const __default4 = {
    indexOfBuffer,
    indexOfNumber
};
const mod8 = {
    indexOfBuffer: indexOfBuffer,
    indexOfNumber: indexOfNumber,
    numberToBytes: numberToBytes,
    default: __default4
};
const base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/"
];
function encode(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i;
    const l = uint8.length;
    for(i = 2; i < l; i += 3){
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 0x0f) << 2 | uint8[i] >> 6];
        result += base64abc[uint8[i] & 0x3f];
    }
    if (i === l + 1) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === l) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
function decode(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
function addPaddingToBase64url(base64url) {
    if (base64url.length % 4 === 2) return base64url + "==";
    if (base64url.length % 4 === 3) return base64url + "=";
    if (base64url.length % 4 === 1) {
        throw new TypeError("Illegal base64url string!");
    }
    return base64url;
}
function convertBase64urlToBase64(b64url) {
    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
        throw new TypeError("Failed to decode base64url: invalid character");
    }
    return addPaddingToBase64url(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url(b64) {
    return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode1(data) {
    return convertBase64ToBase64url(encode(data));
}
function decode1(b64url) {
    return decode(convertBase64urlToBase64(b64url));
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        byteArray.push(str.charCodeAt(i) & 255);
    }
    return new Uint8Array(byteArray);
}
function base64ToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("-", "+").replaceAll("_", "/");
    return decode(str);
}
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while(str.length % 4 !== 0){
        str = str + "=";
    }
    return str;
}
function base64UrlToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("+", "-").replaceAll("/", "_");
    return decode1(str);
}
function hexToBytes(str) {
    const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
    let i;
    for(i = 0; i < byteArray.length; i++){
        const a = Number.parseInt(str[i * 2], 16);
        const b = Number.parseInt(str[i * 2 + 1], 16);
        if (Number.isNaN(a) && Number.isNaN(b)) {
            break;
        }
        byteArray[i] = a << 4 | b;
    }
    return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) {
            break;
        }
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return new Uint8Array(byteArray);
}
function bytesToAscii(bytes) {
    let ret = "";
    for(let i = 0; i < bytes.length; ++i){
        ret += String.fromCharCode(bytes[i] & 127);
    }
    return ret;
}
function bytesToUtf16le(bytes) {
    let res = "";
    for(let i = 0; i < bytes.length - 1; i += 2){
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
}
const ArrayIsArray = Array.isArray;
const ArrayPrototypeFilter = (that, ...args)=>that.filter(...args);
const ArrayPrototypeJoin = (that, ...args)=>that.join(...args);
const ArrayPrototypePush = (that, ...args)=>that.push(...args);
const ArrayPrototypeSlice = (that, ...args)=>that.slice(...args);
const ArrayPrototypeSort = (that, ...args)=>that.sort(...args);
const ArrayPrototypeUnshift = (that, ...args)=>that.unshift(...args);
const ObjectAssign1 = Object.assign;
const ObjectCreate = Object.create;
const ObjectPrototypeHasOwnProperty = Object.hasOwn;
RegExp.prototype.exec;
String.fromCharCode;
const StringPrototypeReplace = (that, ...args)=>that.replace(...args);
const StringPrototypeSlice = (that, ...args)=>that.slice(...args);
const StringPrototypeToUpperCase = (that)=>that.toUpperCase();
const { signals  } = os;
const customInspectSymbol1 = Symbol.for("nodejs.util.inspect.custom");
const kEnumerableProperty = Object.create(null);
kEnumerableProperty.enumerable = true;
const kEmptyObject = Object.freeze(Object.create(null));
function once1(callback) {
    let called = false;
    return function(...args) {
        if (called) return;
        called = true;
        Reflect.apply(callback, this, args);
    };
}
function createDeferredPromise() {
    let resolve;
    let reject;
    const promise = new Promise((res, rej)=>{
        resolve = res;
        reject = rej;
    });
    return {
        promise,
        resolve,
        reject
    };
}
const kCustomPromisifiedSymbol = Symbol.for("nodejs.util.promisify.custom");
const kCustomPromisifyArgsSymbol = Symbol.for("nodejs.util.promisify.customArgs");
const customPromisifyArgs = kCustomPromisifyArgsSymbol;
function promisify(original) {
    validateFunction(original, "original");
    if (original[kCustomPromisifiedSymbol]) {
        const fn = original[kCustomPromisifiedSymbol];
        validateFunction(fn, "util.promisify.custom");
        return Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    const argumentNames = original[kCustomPromisifyArgsSymbol];
    function fn(...args) {
        return new Promise((resolve, reject)=>{
            args.push((err, ...values)=>{
                if (err) {
                    return reject(err);
                }
                if (argumentNames !== undefined && values.length > 1) {
                    const obj = {};
                    for(let i = 0; i < argumentNames.length; i++){
                        obj[argumentNames[i]] = values[i];
                    }
                    resolve(obj);
                } else {
                    resolve(values[0]);
                }
            });
            Reflect.apply(original, this, args);
        });
    }
    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn, Object.getOwnPropertyDescriptors(original));
}
let signalsToNamesMapping;
function getSignalsToNamesMapping() {
    if (signalsToNamesMapping !== undefined) {
        return signalsToNamesMapping;
    }
    signalsToNamesMapping = ObjectCreate(null);
    for(const key in signals){
        signalsToNamesMapping[signals[key]] = key;
    }
    return signalsToNamesMapping;
}
function convertToValidSignal(signal) {
    if (typeof signal === "number" && getSignalsToNamesMapping()[signal]) {
        return signal;
    }
    if (typeof signal === "string") {
        const signalName = signals[StringPrototypeToUpperCase(signal)];
        if (signalName) return signalName;
    }
    throw new ERR_UNKNOWN_SIGNAL(signal);
}
promisify.custom = kCustomPromisifiedSymbol;
const __default5 = {
    convertToValidSignal,
    createDeferredPromise,
    customInspectSymbol: customInspectSymbol1,
    customPromisifyArgs,
    kEmptyObject,
    kEnumerableProperty,
    normalizeEncoding: normalizeEncoding1,
    once: once1,
    promisify,
    slowCases: slowCases1
};
const utf8Encoder = new TextEncoder();
const float32Array = new Float32Array(1);
const uInt8Float32Array = new Uint8Array(float32Array.buffer);
const float64Array = new Float64Array(1);
const uInt8Float64Array = new Uint8Array(float64Array.buffer);
float32Array[0] = -1;
const bigEndian = uInt8Float32Array[3] === 0;
const kMaxLength = 2147483647;
const MAX_UINT32 = 2 ** 32;
const customInspectSymbol2 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
const INSPECT_MAX_BYTES = 50;
const constants = {
    MAX_LENGTH: 2147483647,
    MAX_STRING_LENGTH: 536870888
};
Object.defineProperty(Buffer1.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer1.isBuffer(this)) {
            return void 0;
        }
        return this.buffer;
    }
});
Object.defineProperty(Buffer1.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer1.isBuffer(this)) {
            return void 0;
        }
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > 2147483647) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer1.prototype);
    return buf;
}
function Buffer1(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("string", "string", arg);
        }
        return _allocUnsafe(arg);
    }
    return _from(arg, encodingOrOffset, length);
}
Buffer1.poolSize = 8192;
function _from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
    }
    if (typeof value === "object" && value !== null) {
        if (isAnyArrayBuffer1(value)) {
            return fromArrayBuffer(value, encodingOrOffset, length);
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
            return _from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b) {
            return b;
        }
        if (typeof value[Symbol.toPrimitive] === "function") {
            const primitive = value[Symbol.toPrimitive]("string");
            if (typeof primitive === "string") {
                return fromString(primitive, encodingOrOffset);
            }
        }
    }
    throw new codes.ERR_INVALID_ARG_TYPE("first argument", [
        "string",
        "Buffer",
        "ArrayBuffer",
        "Array",
        "Array-like Object"
    ], value);
}
Buffer1.from = function from(value, encodingOrOffset, length) {
    return _from(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer1.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer1, Uint8Array);
function assertSize(size) {
    validateNumber1(size, "size");
    if (!(size >= 0 && size <= 2147483647)) {
        throw new codes.ERR_INVALID_ARG_VALUE.RangeError("size", size);
    }
}
function _alloc(size, fill, encoding) {
    assertSize(size);
    const buffer = createBuffer(size);
    if (fill !== undefined) {
        if (encoding !== undefined && typeof encoding !== "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
        }
        return buffer.fill(fill, encoding);
    }
    return buffer;
}
Buffer1.alloc = function alloc(size, fill, encoding) {
    return _alloc(size, fill, encoding);
};
function _allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
Buffer1.allocUnsafe = function allocUnsafe(size) {
    return _allocUnsafe(size);
};
Buffer1.allocUnsafeSlow = function allocUnsafeSlow(size) {
    return _allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
    }
    if (!Buffer1.isEncoding(encoding)) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1){
        buf[i] = array[i] & 255;
    }
    return buf;
}
function fromObject(obj) {
    if (obj.length !== undefined || isAnyArrayBuffer1(obj.buffer)) {
        if (typeof obj.length !== "number") {
            return createBuffer(0);
        }
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
    }
}
function checked(length) {
    if (length >= 2147483647) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes");
    }
    return length | 0;
}
function SlowBuffer(length) {
    assertSize(length);
    return Buffer1.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer, Uint8Array);
Buffer1.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer1.prototype;
};
Buffer1.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) {
        a = Buffer1.from(a, a.offset, a.byteLength);
    }
    if (isInstance(b, Uint8Array)) {
        b = Buffer1.from(b, b.offset, b.byteLength);
    }
    if (!Buffer1.isBuffer(a) || !Buffer1.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) {
        return 0;
    }
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i){
        if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
Buffer1.isEncoding = function isEncoding(encoding) {
    return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding1(encoding) !== undefined;
};
Buffer1.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
        throw new codes.ERR_INVALID_ARG_TYPE("list", "Array", list);
    }
    if (list.length === 0) {
        return Buffer1.alloc(0);
    }
    if (length === undefined) {
        length = 0;
        for(let i = 0; i < list.length; i++){
            if (list[i].length) {
                length += list[i].length;
            }
        }
    } else {
        validateOffset(length, "length");
    }
    const buffer = Buffer1.allocUnsafe(length);
    let pos = 0;
    for(let i = 0; i < list.length; i++){
        const buf = list[i];
        if (!isUint8Array(buf)) {
            throw new codes.ERR_INVALID_ARG_TYPE(`list[${i}]`, [
                "Buffer",
                "Uint8Array"
            ], list[i]);
        }
        pos += _copyActual(buf, buffer, pos, 0, buf.length);
    }
    if (pos < length) {
        buffer.fill(0, pos, length);
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (typeof string !== "string") {
        if (isArrayBufferView(string) || isAnyArrayBuffer1(string)) {
            return string.byteLength;
        }
        throw new codes.ERR_INVALID_ARG_TYPE("string", [
            "string",
            "Buffer",
            "ArrayBuffer"
        ], string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) {
        return 0;
    }
    if (!encoding) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    return ops.byteLength(string);
}
Buffer1.byteLength = byteLength;
Buffer1.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer1.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for(let i = 0; i < len; i += 2){
        swap(this, i, i + 1);
    }
    return this;
};
Buffer1.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer1.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer1.prototype.toString = function toString(encoding, start, end) {
    if (arguments.length === 0) {
        return this.utf8Slice(0, this.length);
    }
    const len = this.length;
    if (start <= 0) {
        start = 0;
    } else if (start >= len) {
        return "";
    } else {
        start |= 0;
    }
    if (end === undefined || end > len) {
        end = len;
    } else {
        end |= 0;
    }
    if (end <= start) {
        return "";
    }
    if (encoding === undefined) {
        return this.utf8Slice(start, end);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.slice(this, start, end);
};
Buffer1.prototype.toLocaleString = Buffer1.prototype.toString;
Buffer1.prototype.equals = function equals(b) {
    if (!isUint8Array(b)) {
        throw new codes.ERR_INVALID_ARG_TYPE("otherBuffer", [
            "Buffer",
            "Uint8Array"
        ], b);
    }
    if (this === b) {
        return true;
    }
    return Buffer1.compare(this, b) === 0;
};
Buffer1.prototype.inspect = function inspect() {
    let str = "";
    const max = INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) {
        str += " ... ";
    }
    return "<Buffer " + str + ">";
};
if (customInspectSymbol2) {
    Buffer1.prototype[customInspectSymbol2] = Buffer1.prototype.inspect;
}
Buffer1.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
        target = Buffer1.from(target, target.offset, target.byteLength);
    }
    if (!Buffer1.isBuffer(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (start === undefined) {
        start = 0;
    } else {
        validateOffset(start, "targetStart", 0, kMaxLength);
    }
    if (end === undefined) {
        end = target.length;
    } else {
        validateOffset(end, "targetEnd", 0, target.length);
    }
    if (thisStart === undefined) {
        thisStart = 0;
    } else {
        validateOffset(start, "sourceStart", 0, kMaxLength);
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    } else {
        validateOffset(end, "sourceEnd", 0, this.length);
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new codes.ERR_OUT_OF_RANGE("out of range index", "range");
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) {
        return 0;
    }
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i){
        if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    validateBuffer(buffer);
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = undefined;
    } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
    }
    dir = !!dir;
    if (typeof val === "number") {
        return indexOfNumber(buffer, val >>> 0, byteOffset, dir);
    }
    let ops;
    if (encoding === undefined) {
        ops = encodingOps.utf8;
    } else {
        ops = getEncodingOps(encoding);
    }
    if (typeof val === "string") {
        if (ops === undefined) {
            throw new codes.ERR_UNKNOWN_ENCODING(encoding);
        }
        return ops.indexOf(buffer, val, byteOffset, dir);
    }
    if (isUint8Array(val)) {
        const encodingVal = ops === undefined ? encodingsMap.utf8 : ops.encodingVal;
        return indexOfBuffer(buffer, val, byteOffset, encodingVal, dir);
    }
    throw new codes.ERR_INVALID_ARG_TYPE("value", [
        "number",
        "string",
        "Buffer",
        "Uint8Array"
    ], val);
}
Buffer1.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer1.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer1.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
Buffer1.prototype.asciiSlice = function asciiSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToAscii(this);
    } else {
        return bytesToAscii(this.slice(offset, length));
    }
};
Buffer1.prototype.asciiWrite = function asciiWrite(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer1.prototype.base64Slice = function base64Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode(this);
    } else {
        return encode(this.slice(offset, length));
    }
};
Buffer1.prototype.base64Write = function base64Write(string, offset, length) {
    return blitBuffer(base64ToBytes(string), this, offset, length);
};
Buffer1.prototype.base64urlSlice = function base64urlSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode1(this);
    } else {
        return encode1(this.slice(offset, length));
    }
};
Buffer1.prototype.base64urlWrite = function base64urlWrite(string, offset, length) {
    return blitBuffer(base64UrlToBytes(string), this, offset, length);
};
Buffer1.prototype.hexWrite = function hexWrite(string, offset, length) {
    return blitBuffer(hexToBytes(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.hexSlice = function hexSlice(string, offset, length) {
    return _hexSlice(this, string, offset, length);
};
Buffer1.prototype.latin1Slice = function latin1Slice(string, offset, length) {
    return _latin1Slice(this, string, offset, length);
};
Buffer1.prototype.latin1Write = function latin1Write(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer1.prototype.ucs2Slice = function ucs2Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToUtf16le(this);
    } else {
        return bytesToUtf16le(this.slice(offset, length));
    }
};
Buffer1.prototype.ucs2Write = function ucs2Write(string, offset, length) {
    return blitBuffer(utf16leToBytes(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.utf8Slice = function utf8Slice(string, offset, length) {
    return _utf8Slice(this, string, offset, length);
};
Buffer1.prototype.utf8Write = function utf8Write(string, offset, length) {
    return blitBuffer(utf8ToBytes(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
        return this.utf8Write(string, 0, this.length);
    }
    if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    } else {
        validateOffset(offset, "offset", 0, this.length);
        const remaining = this.length - offset;
        if (length === undefined) {
            length = remaining;
        } else if (typeof length === "string") {
            encoding = length;
            length = remaining;
        } else {
            validateOffset(length, "length", 0, this.length);
            if (length > remaining) {
                length = remaining;
            }
        }
    }
    if (!encoding) {
        return this.utf8Write(string, offset, length);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.write(this, string, offset, length);
};
Buffer1.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function fromArrayBuffer(obj, byteOffset, length) {
    if (byteOffset === undefined) {
        byteOffset = 0;
    } else {
        byteOffset = +byteOffset;
        if (Number.isNaN(byteOffset)) {
            byteOffset = 0;
        }
    }
    const maxLength = obj.byteLength - byteOffset;
    if (maxLength < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("offset");
    }
    if (length === undefined) {
        length = maxLength;
    } else {
        length = +length;
        if (length > 0) {
            if (length > maxLength) {
                throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("length");
            }
        } else {
            length = 0;
        }
    }
    const buffer = new Uint8Array(obj, byteOffset, length);
    Object.setPrototypeOf(buffer, Buffer1.prototype);
    return buffer;
}
const decoder = new TextDecoder();
function _utf8Slice(buf, start, end) {
    return decoder.decode(buf.slice(start, end));
}
function _latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i){
        ret += String.fromCharCode(buf[i]);
    }
    return ret;
}
function _hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) {
        start = 0;
    }
    if (!end || end < 0 || end > len) {
        end = len;
    }
    let out = "";
    for(let i = start; i < end; ++i){
        out += hexSliceLookupTable[buf[i]];
    }
    return out;
}
Buffer1.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) {
            start = 0;
        }
    } else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0) {
            end = 0;
        }
    } else if (end > len) {
        end = len;
    }
    if (end < start) {
        end = start;
    }
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer1.prototype);
    return newBuf;
};
Buffer1.prototype.readUintLE = Buffer1.prototype.readUIntLE = function readUIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48LE(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40LE(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24LE(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.readUintBE = Buffer1.prototype.readUIntBE = function readUIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48BE(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40BE(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24BE(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.readUint8 = Buffer1.prototype.readUInt8 = function readUInt8(offset = 0) {
    validateNumber1(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val;
};
Buffer1.prototype.readUint16BE = Buffer1.prototype.readUInt16BE = readUInt16BE;
Buffer1.prototype.readUint16LE = Buffer1.prototype.readUInt16LE = function readUInt16LE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first + last * 2 ** 8;
};
Buffer1.prototype.readUint32LE = Buffer1.prototype.readUInt32LE = function readUInt32LE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer1.prototype.readUint32BE = Buffer1.prototype.readUInt32BE = readUInt32BE;
Buffer1.prototype.readBigUint64LE = Buffer1.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer1.prototype.readBigUint64BE = Buffer1.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer1.prototype.readIntLE = function readIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48LE(this, offset);
    }
    if (byteLength === 5) {
        return readInt40LE(this, offset);
    }
    if (byteLength === 3) {
        return readInt24LE(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.readIntBE = function readIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48BE(this, offset);
    }
    if (byteLength === 5) {
        return readInt40BE(this, offset);
    }
    if (byteLength === 3) {
        return readInt24BE(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.readInt8 = function readInt8(offset = 0) {
    validateNumber1(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val | (val & 2 ** 7) * 0x1fffffe;
};
Buffer1.prototype.readInt16LE = function readInt16LE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first + last * 2 ** 8;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer1.prototype.readInt16BE = function readInt16BE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first * 2 ** 8 + last;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer1.prototype.readInt32LE = function readInt32LE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer1.prototype.readInt32BE = function readInt32BE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer1.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer1.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer1.prototype.readFloatLE = function readFloatLE(offset) {
    return bigEndian ? readFloatBackwards(this, offset) : readFloatForwards(this, offset);
};
Buffer1.prototype.readFloatBE = function readFloatBE(offset) {
    return bigEndian ? readFloatForwards(this, offset) : readFloatBackwards(this, offset);
};
Buffer1.prototype.readDoubleLE = function readDoubleLE(offset) {
    return bigEndian ? readDoubleBackwards(this, offset) : readDoubleForwards(this, offset);
};
Buffer1.prototype.readDoubleBE = function readDoubleBE(offset) {
    return bigEndian ? readDoubleForwards(this, offset) : readDoubleBackwards(this, offset);
};
Buffer1.prototype.writeUintLE = Buffer1.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, 0, 0xff);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.writeUintBE = Buffer1.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, 0, 0xff);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.writeUint8 = Buffer1.prototype.writeUInt8 = function writeUInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, 0, 0xff);
};
Buffer1.prototype.writeUint16LE = Buffer1.prototype.writeUInt16LE = function writeUInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, 0, 0xffff);
};
Buffer1.prototype.writeUint16BE = Buffer1.prototype.writeUInt16BE = function writeUInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, 0, 0xffff);
};
Buffer1.prototype.writeUint32LE = Buffer1.prototype.writeUInt32LE = function writeUInt32LE(value, offset = 0) {
    return _writeUInt32LE(this, value, offset, 0, 0xffffffff);
};
Buffer1.prototype.writeUint32BE = Buffer1.prototype.writeUInt32BE = function writeUInt32BE(value, offset = 0) {
    return _writeUInt32BE(this, value, offset, 0, 0xffffffff);
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer1.prototype.writeBigUint64LE = Buffer1.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer1.prototype.writeBigUint64BE = Buffer1.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer1.prototype.writeIntLE = function writeIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, -0x80, 0x7f);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.writeIntBE = function writeIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, -0x80, 0x7f);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer1.prototype.writeInt8 = function writeInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, -0x80, 0x7f);
};
Buffer1.prototype.writeInt16LE = function writeInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);
};
Buffer1.prototype.writeInt16BE = function writeInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);
};
Buffer1.prototype.writeInt32LE = function writeInt32LE(value, offset = 0) {
    return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer1.prototype.writeInt32BE = function writeInt32BE(value, offset = 0) {
    return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer1.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer1.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer1.prototype.writeFloatLE = function writeFloatLE(value, offset) {
    return bigEndian ? writeFloatBackwards(this, value, offset) : writeFloatForwards(this, value, offset);
};
Buffer1.prototype.writeFloatBE = function writeFloatBE(value, offset) {
    return bigEndian ? writeFloatForwards(this, value, offset) : writeFloatBackwards(this, value, offset);
};
Buffer1.prototype.writeDoubleLE = function writeDoubleLE(value, offset) {
    return bigEndian ? writeDoubleBackwards(this, value, offset) : writeDoubleForwards(this, value, offset);
};
Buffer1.prototype.writeDoubleBE = function writeDoubleBE(value, offset) {
    return bigEndian ? writeDoubleForwards(this, value, offset) : writeDoubleBackwards(this, value, offset);
};
Buffer1.prototype.copy = function copy(target, targetStart, sourceStart, sourceEnd) {
    if (!isUint8Array(this)) {
        throw new codes.ERR_INVALID_ARG_TYPE("source", [
            "Buffer",
            "Uint8Array"
        ], this);
    }
    if (!isUint8Array(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (targetStart === undefined) {
        targetStart = 0;
    } else {
        targetStart = toInteger(targetStart, 0);
        if (targetStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
        }
    }
    if (sourceStart === undefined) {
        sourceStart = 0;
    } else {
        sourceStart = toInteger(sourceStart, 0);
        if (sourceStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
        }
        if (sourceStart >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT32}`, sourceStart);
        }
    }
    if (sourceEnd === undefined) {
        sourceEnd = this.length;
    } else {
        sourceEnd = toInteger(sourceEnd, 0);
        if (sourceEnd < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
        }
        if (sourceEnd >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT32}`, sourceEnd);
        }
    }
    if (targetStart >= target.length) {
        return 0;
    }
    if (sourceEnd > 0 && sourceEnd < sourceStart) {
        sourceEnd = sourceStart;
    }
    if (sourceEnd === sourceStart) {
        return 0;
    }
    if (target.length === 0 || this.length === 0) {
        return 0;
    }
    if (sourceEnd > this.length) {
        sourceEnd = this.length;
    }
    if (target.length - targetStart < sourceEnd - sourceStart) {
        sourceEnd = target.length - targetStart + sourceStart;
    }
    const len = sourceEnd - sourceStart;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, sourceStart, sourceEnd);
    } else {
        Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
    }
    return len;
};
Buffer1.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer1.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                val = code;
            }
        }
    } else if (typeof val === "number") {
        val = val & 255;
    } else if (typeof val === "boolean") {
        val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) {
        val = 0;
    }
    let i;
    if (typeof val === "number") {
        for(i = start; i < end; ++i){
            this[i] = val;
        }
    } else {
        const bytes = Buffer1.isBuffer(val) ? val : Buffer1.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
            throw new codes.ERR_INVALID_ARG_VALUE("value", val);
        }
        for(i = 0; i < end - start; ++i){
            this[i + start] = bytes[i % len];
        }
    }
    return this;
};
function checkBounds(buf, offset, byteLength2) {
    validateNumber1(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
    }
}
function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
                if (codePoint > 56319) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                } else if (i + 1 === length) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                }
                leadSurrogate = codePoint;
                continue;
            }
            if (codePoint < 56320) {
                if ((units -= 3) > -1) {
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = codePoint;
                continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
            if ((units -= 3) > -1) {
                bytes.push(239, 191, 189);
            }
        }
        leadSurrogate = null;
        if (codePoint < 128) {
            if ((units -= 1) < 0) {
                break;
            }
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) {
                break;
            }
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) {
                break;
            }
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) {
                break;
            }
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
            throw new Error("Invalid code point");
        }
    }
    return bytes;
}
function blitBuffer(src, dst, offset, byteLength) {
    let i;
    const length = byteLength === undefined ? src.length : byteLength;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) {
            break;
        }
        dst[i + offset] = src[i];
    }
    return i;
}
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j){
            table[i16 + j] = alphabet[i] + alphabet[j];
        }
    }
    return table;
}();
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}
const atob1 = globalThis.atob;
const Blob1 = globalThis.Blob;
const btoa = globalThis.btoa;
function readUInt48LE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first * 2 ** 8 + last;
}
function readUInt32BE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards(buffer, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 8);
    }
    uInt8Float64Array[7] = first;
    uInt8Float64Array[6] = buffer[++offset];
    uInt8Float64Array[5] = buffer[++offset];
    uInt8Float64Array[4] = buffer[++offset];
    uInt8Float64Array[3] = buffer[++offset];
    uInt8Float64Array[2] = buffer[++offset];
    uInt8Float64Array[1] = buffer[++offset];
    uInt8Float64Array[0] = last;
    return float64Array[0];
}
function readDoubleForwards(buffer, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 8);
    }
    uInt8Float64Array[0] = first;
    uInt8Float64Array[1] = buffer[++offset];
    uInt8Float64Array[2] = buffer[++offset];
    uInt8Float64Array[3] = buffer[++offset];
    uInt8Float64Array[4] = buffer[++offset];
    uInt8Float64Array[5] = buffer[++offset];
    uInt8Float64Array[6] = buffer[++offset];
    uInt8Float64Array[7] = last;
    return float64Array[0];
}
function writeDoubleForwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 7);
    float64Array[0] = val;
    buffer[offset++] = uInt8Float64Array[0];
    buffer[offset++] = uInt8Float64Array[1];
    buffer[offset++] = uInt8Float64Array[2];
    buffer[offset++] = uInt8Float64Array[3];
    buffer[offset++] = uInt8Float64Array[4];
    buffer[offset++] = uInt8Float64Array[5];
    buffer[offset++] = uInt8Float64Array[6];
    buffer[offset++] = uInt8Float64Array[7];
    return offset;
}
function writeDoubleBackwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 7);
    float64Array[0] = val;
    buffer[offset++] = uInt8Float64Array[7];
    buffer[offset++] = uInt8Float64Array[6];
    buffer[offset++] = uInt8Float64Array[5];
    buffer[offset++] = uInt8Float64Array[4];
    buffer[offset++] = uInt8Float64Array[3];
    buffer[offset++] = uInt8Float64Array[2];
    buffer[offset++] = uInt8Float64Array[1];
    buffer[offset++] = uInt8Float64Array[0];
    return offset;
}
function readFloatBackwards(buffer, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 4);
    }
    uInt8Float32Array[3] = first;
    uInt8Float32Array[2] = buffer[++offset];
    uInt8Float32Array[1] = buffer[++offset];
    uInt8Float32Array[0] = last;
    return float32Array[0];
}
function readFloatForwards(buffer, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 4);
    }
    uInt8Float32Array[0] = first;
    uInt8Float32Array[1] = buffer[++offset];
    uInt8Float32Array[2] = buffer[++offset];
    uInt8Float32Array[3] = last;
    return float32Array[0];
}
function writeFloatForwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 3);
    float32Array[0] = val;
    buffer[offset++] = uInt8Float32Array[0];
    buffer[offset++] = uInt8Float32Array[1];
    buffer[offset++] = uInt8Float32Array[2];
    buffer[offset++] = uInt8Float32Array[3];
    return offset;
}
function writeFloatBackwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 3);
    float32Array[0] = val;
    buffer[offset++] = uInt8Float32Array[3];
    buffer[offset++] = uInt8Float32Array[2];
    buffer[offset++] = uInt8Float32Array[1];
    buffer[offset++] = uInt8Float32Array[0];
    return offset;
}
function readInt24LE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt40LE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[offset + 4] + last * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt48BE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[++offset] + first * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf8(str) {
    return utf8Encoder.encode(str).length;
}
function base64ByteLength(str, bytes) {
    if (str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    if (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    return bytes * 3 >>> 2;
}
const encodingsMap = Object.create(null);
for(let i = 0; i < encodings.length; ++i){
    encodingsMap[encodings[i]] = i;
}
const encodingOps = {
    ascii: {
        byteLength: (string)=>string.length,
        encoding: "ascii",
        encodingVal: encodingsMap.ascii,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.ascii, dir),
        slice: (buf, start, end)=>buf.asciiSlice(start, end),
        write: (buf, string, offset, len)=>buf.asciiWrite(string, offset, len)
    },
    base64: {
        byteLength: (string)=>base64ByteLength(string, string.length),
        encoding: "base64",
        encodingVal: encodingsMap.base64,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64ToBytes(val), byteOffset, encodingsMap.base64, dir),
        slice: (buf, start, end)=>buf.base64Slice(start, end),
        write: (buf, string, offset, len)=>buf.base64Write(string, offset, len)
    },
    base64url: {
        byteLength: (string)=>base64ByteLength(string, string.length),
        encoding: "base64url",
        encodingVal: encodingsMap.base64url,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64UrlToBytes(val), byteOffset, encodingsMap.base64url, dir),
        slice: (buf, start, end)=>buf.base64urlSlice(start, end),
        write: (buf, string, offset, len)=>buf.base64urlWrite(string, offset, len)
    },
    hex: {
        byteLength: (string)=>string.length >>> 1,
        encoding: "hex",
        encodingVal: encodingsMap.hex,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, hexToBytes(val), byteOffset, encodingsMap.hex, dir),
        slice: (buf, start, end)=>buf.hexSlice(start, end),
        write: (buf, string, offset, len)=>buf.hexWrite(string, offset, len)
    },
    latin1: {
        byteLength: (string)=>string.length,
        encoding: "latin1",
        encodingVal: encodingsMap.latin1,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.latin1, dir),
        slice: (buf, start, end)=>buf.latin1Slice(start, end),
        write: (buf, string, offset, len)=>buf.latin1Write(string, offset, len)
    },
    ucs2: {
        byteLength: (string)=>string.length * 2,
        encoding: "ucs2",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    },
    utf8: {
        byteLength: byteLengthUtf8,
        encoding: "utf8",
        encodingVal: encodingsMap.utf8,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf8Encoder.encode(val), byteOffset, encodingsMap.utf8, dir),
        slice: (buf, start, end)=>buf.utf8Slice(start, end),
        write: (buf, string, offset, len)=>buf.utf8Write(string, offset, len)
    },
    utf16le: {
        byteLength: (string)=>string.length * 2,
        encoding: "utf16le",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    }
};
function getEncodingOps(encoding) {
    encoding = String(encoding).toLowerCase();
    switch(encoding.length){
        case 4:
            if (encoding === "utf8") return encodingOps.utf8;
            if (encoding === "ucs2") return encodingOps.ucs2;
            break;
        case 5:
            if (encoding === "utf-8") return encodingOps.utf8;
            if (encoding === "ascii") return encodingOps.ascii;
            if (encoding === "ucs-2") return encodingOps.ucs2;
            break;
        case 7:
            if (encoding === "utf16le") {
                return encodingOps.utf16le;
            }
            break;
        case 8:
            if (encoding === "utf-16le") {
                return encodingOps.utf16le;
            }
            break;
        case 6:
            if (encoding === "latin1" || encoding === "binary") {
                return encodingOps.latin1;
            }
            if (encoding === "base64") return encodingOps.base64;
        case 3:
            if (encoding === "hex") {
                return encodingOps.hex;
            }
            break;
        case 9:
            if (encoding === "base64url") {
                return encodingOps.base64url;
            }
            break;
    }
}
function _copyActual(source, target, targetStart, sourceStart, sourceEnd) {
    if (sourceEnd - sourceStart > target.length - targetStart) {
        sourceEnd = sourceStart + target.length - targetStart;
    }
    let nb = sourceEnd - sourceStart;
    const sourceLen = source.length - sourceStart;
    if (nb > sourceLen) {
        nb = sourceLen;
    }
    if (sourceStart !== 0 || sourceEnd < source.length) {
        source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
    }
    target.set(source, targetStart);
    return nb;
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber1(value, type);
        throw new codes.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new codes.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber1(value, name) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
}
function checkInt(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === 0n) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` + `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function toInteger(n, defaultVal) {
    n = +n;
    if (!Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) {
        return n % 1 === 0 ? n : Math.floor(n);
    }
    return defaultVal;
}
function writeU_Int8(buf, value, offset, min, max) {
    value = +value;
    validateNumber1(offset, "offset");
    if (value > max || value < min) {
        throw new codes.ERR_OUT_OF_RANGE("value", `>= ${min} and <= ${max}`, value);
    }
    if (buf[offset] === undefined) {
        boundsError(offset, buf.length - 1);
    }
    buf[offset] = value;
    return offset + 1;
}
function writeU_Int16BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 1);
    buf[offset++] = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function _writeUInt32LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int16LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 1);
    buf[offset++] = value;
    buf[offset++] = value >>> 8;
    return offset;
}
function _writeUInt32BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int48BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = newVal >>> 8;
    buf[offset++] = newVal;
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int40BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 4);
    buf[offset++] = Math.floor(value * 2 ** -32);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int32BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int24BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 2);
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 3;
}
function validateOffset(value, name, min = 0, max = Number.MAX_SAFE_INTEGER) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
}
function writeU_Int48LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = newVal;
    buf[offset++] = newVal >>> 8;
    return offset;
}
function writeU_Int40LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 4);
    const newVal = value;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = Math.floor(newVal * 2 ** -32);
    return offset;
}
function writeU_Int32LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int24LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 2);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
const __default6 = {
    atob: atob1,
    btoa,
    Blob: Blob1,
    Buffer: Buffer1,
    constants,
    kMaxLength: 2147483647,
    kStringMaxLength: 536870888,
    SlowBuffer
};
"use strict";
const kEscape = "\x1b";
const kSubstringSearch = Symbol("kSubstringSearch");
function CSI(strings, ...args) {
    let ret = `${kEscape}[`;
    for(let n = 0; n < strings.length; n++){
        ret += strings[n];
        if (n < args.length) {
            ret += args[n];
        }
    }
    return ret;
}
CSI.kEscape = kEscape;
CSI.kClearToLineBeginning = CSI`1K`;
CSI.kClearToLineEnd = CSI`0K`;
CSI.kClearLine = CSI`2K`;
CSI.kClearScreenDown = CSI`0J`;
function charLengthLeft(str, i) {
    if (i <= 0) {
        return 0;
    }
    if (i > 1 && str.codePointAt(i - 2) >= 0x10000 || str.codePointAt(i - 1) >= 0x10000) {
        return 2;
    }
    return 1;
}
function charLengthAt(str, i) {
    if (str.length <= i) {
        return 1;
    }
    return str.codePointAt(i) >= 0x10000 ? 2 : 1;
}
function* emitKeys(stream) {
    while(true){
        let ch = yield;
        let s = ch;
        let escaped = false;
        const key = {
            sequence: null,
            name: undefined,
            ctrl: false,
            meta: false,
            shift: false
        };
        if (ch === kEscape) {
            escaped = true;
            s += ch = yield;
            if (ch === kEscape) {
                s += ch = yield;
            }
        }
        if (escaped && (ch === "O" || ch === "[")) {
            let code = ch;
            let modifier = 0;
            if (ch === "O") {
                s += ch = yield;
                if (ch >= "0" && ch <= "9") {
                    modifier = (ch >> 0) - 1;
                    s += ch = yield;
                }
                code += ch;
            } else if (ch === "[") {
                s += ch = yield;
                if (ch === "[") {
                    code += ch;
                    s += ch = yield;
                }
                const cmdStart = s.length - 1;
                if (ch >= "0" && ch <= "9") {
                    s += ch = yield;
                    if (ch >= "0" && ch <= "9") {
                        s += ch = yield;
                    }
                }
                if (ch === ";") {
                    s += ch = yield;
                    if (ch >= "0" && ch <= "9") {
                        s += yield;
                    }
                }
                const cmd = s.slice(cmdStart);
                let match;
                if (match = cmd.match(/^(\d\d?)(;(\d))?([~^$])$/)) {
                    code += match[1] + match[4];
                    modifier = (match[3] || 1) - 1;
                } else if (match = cmd.match(/^((\d;)?(\d))?([A-Za-z])$/)) {
                    code += match[4];
                    modifier = (match[3] || 1) - 1;
                } else {
                    code += cmd;
                }
            }
            key.ctrl = !!(modifier & 4);
            key.meta = !!(modifier & 10);
            key.shift = !!(modifier & 1);
            key.code = code;
            switch(code){
                case "[P":
                    key.name = "f1";
                    break;
                case "[Q":
                    key.name = "f2";
                    break;
                case "[R":
                    key.name = "f3";
                    break;
                case "[S":
                    key.name = "f4";
                    break;
                case "OP":
                    key.name = "f1";
                    break;
                case "OQ":
                    key.name = "f2";
                    break;
                case "OR":
                    key.name = "f3";
                    break;
                case "OS":
                    key.name = "f4";
                    break;
                case "[11~":
                    key.name = "f1";
                    break;
                case "[12~":
                    key.name = "f2";
                    break;
                case "[13~":
                    key.name = "f3";
                    break;
                case "[14~":
                    key.name = "f4";
                    break;
                case "[[A":
                    key.name = "f1";
                    break;
                case "[[B":
                    key.name = "f2";
                    break;
                case "[[C":
                    key.name = "f3";
                    break;
                case "[[D":
                    key.name = "f4";
                    break;
                case "[[E":
                    key.name = "f5";
                    break;
                case "[15~":
                    key.name = "f5";
                    break;
                case "[17~":
                    key.name = "f6";
                    break;
                case "[18~":
                    key.name = "f7";
                    break;
                case "[19~":
                    key.name = "f8";
                    break;
                case "[20~":
                    key.name = "f9";
                    break;
                case "[21~":
                    key.name = "f10";
                    break;
                case "[23~":
                    key.name = "f11";
                    break;
                case "[24~":
                    key.name = "f12";
                    break;
                case "[A":
                    key.name = "up";
                    break;
                case "[B":
                    key.name = "down";
                    break;
                case "[C":
                    key.name = "right";
                    break;
                case "[D":
                    key.name = "left";
                    break;
                case "[E":
                    key.name = "clear";
                    break;
                case "[F":
                    key.name = "end";
                    break;
                case "[H":
                    key.name = "home";
                    break;
                case "OA":
                    key.name = "up";
                    break;
                case "OB":
                    key.name = "down";
                    break;
                case "OC":
                    key.name = "right";
                    break;
                case "OD":
                    key.name = "left";
                    break;
                case "OE":
                    key.name = "clear";
                    break;
                case "OF":
                    key.name = "end";
                    break;
                case "OH":
                    key.name = "home";
                    break;
                case "[1~":
                    key.name = "home";
                    break;
                case "[2~":
                    key.name = "insert";
                    break;
                case "[3~":
                    key.name = "delete";
                    break;
                case "[4~":
                    key.name = "end";
                    break;
                case "[5~":
                    key.name = "pageup";
                    break;
                case "[6~":
                    key.name = "pagedown";
                    break;
                case "[[5~":
                    key.name = "pageup";
                    break;
                case "[[6~":
                    key.name = "pagedown";
                    break;
                case "[7~":
                    key.name = "home";
                    break;
                case "[8~":
                    key.name = "end";
                    break;
                case "[a":
                    key.name = "up";
                    key.shift = true;
                    break;
                case "[b":
                    key.name = "down";
                    key.shift = true;
                    break;
                case "[c":
                    key.name = "right";
                    key.shift = true;
                    break;
                case "[d":
                    key.name = "left";
                    key.shift = true;
                    break;
                case "[e":
                    key.name = "clear";
                    key.shift = true;
                    break;
                case "[2$":
                    key.name = "insert";
                    key.shift = true;
                    break;
                case "[3$":
                    key.name = "delete";
                    key.shift = true;
                    break;
                case "[5$":
                    key.name = "pageup";
                    key.shift = true;
                    break;
                case "[6$":
                    key.name = "pagedown";
                    key.shift = true;
                    break;
                case "[7$":
                    key.name = "home";
                    key.shift = true;
                    break;
                case "[8$":
                    key.name = "end";
                    key.shift = true;
                    break;
                case "Oa":
                    key.name = "up";
                    key.ctrl = true;
                    break;
                case "Ob":
                    key.name = "down";
                    key.ctrl = true;
                    break;
                case "Oc":
                    key.name = "right";
                    key.ctrl = true;
                    break;
                case "Od":
                    key.name = "left";
                    key.ctrl = true;
                    break;
                case "Oe":
                    key.name = "clear";
                    key.ctrl = true;
                    break;
                case "[2^":
                    key.name = "insert";
                    key.ctrl = true;
                    break;
                case "[3^":
                    key.name = "delete";
                    key.ctrl = true;
                    break;
                case "[5^":
                    key.name = "pageup";
                    key.ctrl = true;
                    break;
                case "[6^":
                    key.name = "pagedown";
                    key.ctrl = true;
                    break;
                case "[7^":
                    key.name = "home";
                    key.ctrl = true;
                    break;
                case "[8^":
                    key.name = "end";
                    key.ctrl = true;
                    break;
                case "[Z":
                    key.name = "tab";
                    key.shift = true;
                    break;
                default:
                    key.name = "undefined";
                    break;
            }
        } else if (ch === "\r") {
            key.name = "return";
            key.meta = escaped;
        } else if (ch === "\n") {
            key.name = "enter";
            key.meta = escaped;
        } else if (ch === "\t") {
            key.name = "tab";
            key.meta = escaped;
        } else if (ch === "\b" || ch === "\x7f") {
            key.name = "backspace";
            key.meta = escaped;
        } else if (ch === kEscape) {
            key.name = "escape";
            key.meta = escaped;
        } else if (ch === " ") {
            key.name = "space";
            key.meta = escaped;
        } else if (!escaped && ch <= "\x1a") {
            key.name = String.fromCharCode(ch.charCodeAt() + "a".charCodeAt() - 1);
            key.ctrl = true;
        } else if (/^[0-9A-Za-z]$/.test(ch)) {
            key.name = ch.toLowerCase();
            key.shift = /^[A-Z]$/.test(ch);
            key.meta = escaped;
        } else if (escaped) {
            key.name = ch.length ? undefined : "escape";
            key.meta = true;
        }
        key.sequence = s;
        if (s.length !== 0 && (key.name !== undefined || escaped)) {
            stream.emit("keypress", escaped ? undefined : s, key);
        } else if (charLengthAt(s, 0) === s.length) {
            stream.emit("keypress", s, key);
        }
    }
}
function commonPrefix(strings) {
    if (strings.length === 1) {
        return strings[0];
    }
    const sorted = strings.slice().sort();
    const min = sorted[0];
    const max = sorted[sorted.length - 1];
    for(let i = 0; i < min.length; i++){
        if (min[i] !== max[i]) {
            return min.slice(0, i);
        }
    }
    return min;
}
const __default7 = {
    CSI,
    charLengthAt,
    charLengthLeft,
    emitKeys,
    commonPrefix,
    kSubstringSearch
};
"use strict";
const { kClearLine , kClearScreenDown , kClearToLineBeginning , kClearToLineEnd  } = CSI;
function cursorTo(stream, x, y, callback) {
    if (callback !== undefined) {
        validateFunction(callback, "callback");
    }
    if (typeof y === "function") {
        callback = y;
        y = undefined;
    }
    if (Number.isNaN(x)) throw new ERR_INVALID_ARG_VALUE("x", x);
    if (Number.isNaN(y)) throw new ERR_INVALID_ARG_VALUE("y", y);
    if (stream == null || typeof x !== "number" && typeof y !== "number") {
        if (typeof callback === "function") process.nextTick(callback, null);
        return true;
    }
    if (typeof x !== "number") throw new ERR_INVALID_CURSOR_POS();
    const data = typeof y !== "number" ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;
    return stream.write(data, callback);
}
function moveCursor(stream, dx, dy, callback) {
    if (callback !== undefined) {
        validateFunction(callback, "callback");
    }
    if (stream == null || !(dx || dy)) {
        if (typeof callback === "function") process.nextTick(callback, null);
        return true;
    }
    let data = "";
    if (dx < 0) {
        data += CSI`${-dx}D`;
    } else if (dx > 0) {
        data += CSI`${dx}C`;
    }
    if (dy < 0) {
        data += CSI`${-dy}A`;
    } else if (dy > 0) {
        data += CSI`${dy}B`;
    }
    return stream.write(data, callback);
}
function clearLine(stream, dir, callback) {
    if (callback !== undefined) {
        validateFunction(callback, "callback");
    }
    if (stream === null || stream === undefined) {
        if (typeof callback === "function") process.nextTick(callback, null);
        return true;
    }
    const type = dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;
    return stream.write(type, callback);
}
function clearScreenDown(stream, callback) {
    if (callback !== undefined) {
        validateFunction(callback, "callback");
    }
    if (stream === null || stream === undefined) {
        if (typeof callback === "function") process.nextTick(callback, null);
        return true;
    }
    return stream.write(kClearScreenDown, callback);
}
const stdio = {};
var NotImplemented;
(function(NotImplemented) {
    NotImplemented[NotImplemented["ascii"] = 0] = "ascii";
    NotImplemented[NotImplemented["latin1"] = 1] = "latin1";
    NotImplemented[NotImplemented["utf16le"] = 2] = "utf16le";
})(NotImplemented || (NotImplemented = {}));
function normalizeEncoding2(enc) {
    const encoding = normalizeEncoding(enc ?? null);
    if (encoding && encoding in NotImplemented) notImplemented(encoding);
    if (!encoding && typeof enc === "string" && enc.toLowerCase() !== "raw") {
        throw new Error(`Unknown encoding: ${enc}`);
    }
    return String(encoding);
}
function isBufferType(buf) {
    return buf instanceof ArrayBuffer && buf.BYTES_PER_ELEMENT;
}
function utf8CheckByte(__byte) {
    if (__byte <= 0x7f) return 0;
    else if (__byte >> 5 === 0x06) return 2;
    else if (__byte >> 4 === 0x0e) return 3;
    else if (__byte >> 3 === 0x1e) return 4;
    return __byte >> 6 === 0x02 ? -1 : -2;
}
function utf8CheckIncomplete(self, buf, i) {
    let j = buf.length - 1;
    if (j < i) return 0;
    let nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
function utf8CheckExtraBytes(self, buf) {
    if ((buf[0] & 0xc0) !== 0x80) {
        self.lastNeed = 0;
        return "\ufffd";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xc0) !== 0x80) {
            self.lastNeed = 1;
            return "\ufffd";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xc0) !== 0x80) {
                self.lastNeed = 2;
                return "\ufffd";
            }
        }
    }
}
function utf8FillLastComplete(buf) {
    const p = this.lastTotal - this.lastNeed;
    const r = utf8CheckExtraBytes(this, buf);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8FillLastIncomplete(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8Text(buf, i) {
    const total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    const end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
}
function utf8End(buf) {
    const r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "\ufffd";
    return r;
}
function utf8Write(buf) {
    if (typeof buf === "string") {
        return buf;
    }
    if (buf.length === 0) return "";
    let r;
    let i;
    const normalizedBuffer = isBufferType(buf) ? buf : Buffer1.from(buf);
    if (this.lastNeed) {
        r = this.fillLast(normalizedBuffer);
        if (r === undefined) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i = 0;
    }
    if (i < buf.length) {
        return r ? r + this.text(normalizedBuffer, i) : this.text(normalizedBuffer, i);
    }
    return r || "";
}
function base64Text(buf, i) {
    const n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
}
function base64End(buf) {
    const r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    }
    return r;
}
function simpleWrite(buf) {
    if (typeof buf === "string") {
        return buf;
    }
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}
class StringDecoderBase {
    lastChar;
    lastNeed;
    lastTotal;
    constructor(encoding, nb){
        this.encoding = encoding;
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer1.allocUnsafe(nb);
    }
    encoding;
}
class Base64Decoder extends StringDecoderBase {
    end = base64End;
    fillLast = utf8FillLastIncomplete;
    text = base64Text;
    write = utf8Write;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 3);
    }
}
class GenericDecoder extends StringDecoderBase {
    end = simpleEnd;
    fillLast = undefined;
    text = utf8Text;
    write = simpleWrite;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 4);
    }
}
class Utf8Decoder extends StringDecoderBase {
    end = utf8End;
    fillLast = utf8FillLastComplete;
    text = utf8Text;
    write = utf8Write;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 4);
    }
}
class StringDecoder {
    encoding;
    end;
    fillLast;
    lastChar;
    lastNeed;
    lastTotal;
    text;
    write;
    constructor(encoding){
        const normalizedEncoding = normalizeEncoding2(encoding);
        let decoder;
        switch(normalizedEncoding){
            case "utf8":
                decoder = new Utf8Decoder(encoding);
                break;
            case "base64":
                decoder = new Base64Decoder(encoding);
                break;
            default:
                decoder = new GenericDecoder(encoding);
        }
        this.encoding = decoder.encoding;
        this.end = decoder.end;
        this.fillLast = decoder.fillLast;
        this.lastChar = decoder.lastChar;
        this.lastNeed = decoder.lastNeed;
        this.lastTotal = decoder.lastTotal;
        this.text = decoder.text;
        this.write = decoder.write;
    }
}
const PStringDecoder = new Proxy(StringDecoder, {
    apply (_target, thisArg, args) {
        return Object.assign(thisArg, new StringDecoder(...args));
    }
});
const __default8 = {
    StringDecoder: PStringDecoder
};
const kDestroy = Symbol("kDestroy");
Symbol("kConstruct");
function checkError(err, w, r) {
    if (err) {
        err.stack;
        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
    }
}
function destroy(err, cb) {
    const r = this._readableState;
    const w = this._writableState;
    const s = w || r;
    if (w && w.destroyed || r && r.destroyed) {
        if (typeof cb === "function") {
            cb();
        }
        return this;
    }
    checkError(err, w, r);
    if (w) {
        w.destroyed = true;
    }
    if (r) {
        r.destroyed = true;
    }
    if (!s.constructed) {
        this.once(kDestroy, function(er) {
            _destroy(this, aggregateTwoErrors(er, err), cb);
        });
    } else {
        _destroy(this, err, cb);
    }
    return this;
}
function _destroy(self, err, cb) {
    let called = false;
    function onDestroy(err) {
        if (called) {
            return;
        }
        called = true;
        const r = self._readableState;
        const w = self._writableState;
        checkError(err, w, r);
        if (w) {
            w.closed = true;
        }
        if (r) {
            r.closed = true;
        }
        if (typeof cb === "function") {
            cb(err);
        }
        if (err) {
            nextTick1(emitErrorCloseNT, self, err);
        } else {
            nextTick1(emitCloseNT, self);
        }
    }
    try {
        const result = self._destroy(err || null, onDestroy);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick1(onDestroy, null);
                }, function(err) {
                    nextTick1(onDestroy, err);
                });
            }
        }
    } catch (err) {
        onDestroy(err);
    }
}
function emitErrorCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
}
function emitCloseNT(self) {
    const r = self._readableState;
    const w = self._writableState;
    if (w) {
        w.closeEmitted = true;
    }
    if (r) {
        r.closeEmitted = true;
    }
    if (w && w.emitClose || r && r.emitClose) {
        self.emit("close");
    }
}
function emitErrorNT(self, err) {
    const r = self._readableState;
    const w = self._writableState;
    if (w && w.errorEmitted || r && r.errorEmitted) {
        return;
    }
    if (w) {
        w.errorEmitted = true;
    }
    if (r) {
        r.errorEmitted = true;
    }
    self.emit("error", err);
}
function errorOrDestroy(stream, err, sync) {
    const r = stream._readableState;
    const w = stream._writableState;
    if (w && w.destroyed || r && r.destroyed) {
        return this;
    }
    if (r && r.autoDestroy || w && w.autoDestroy) {
        stream.destroy(err);
    } else if (err) {
        err.stack;
        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
        if (sync) {
            nextTick1(emitErrorNT, stream, err);
        } else {
            emitErrorNT(stream, err);
        }
    }
}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function isServerResponse(stream) {
    return typeof stream._sent100 === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean" && typeof stream._removedTE === "boolean" && typeof stream._closed === "boolean";
}
function isReadable(stream) {
    return typeof stream.readable === "boolean" || typeof stream.readableEnded === "boolean" || !!stream._readableState;
}
function isWritable(stream) {
    return typeof stream.writable === "boolean" || typeof stream.writableEnded === "boolean" || !!stream._writableState;
}
function isWritableFinished(stream) {
    if (stream.writableFinished) return true;
    const wState = stream._writableState;
    if (!wState || wState.errored) return false;
    return wState.finished || wState.ended && wState.length === 0;
}
const nop = ()=>{};
function isReadableEnded(stream) {
    if (stream.readableEnded) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    return rState.endEmitted || rState.ended && rState.length === 0;
}
function eos(stream, options, callback) {
    if (arguments.length === 2) {
        callback = options;
        options = {};
    } else if (options == null) {
        options = {};
    } else {
        validateObject(options, "options");
    }
    validateFunction(callback, "callback");
    validateAbortSignal(options.signal, "options.signal");
    callback = once1(callback);
    const readable = options.readable || options.readable !== false && isReadable(stream);
    const writable = options.writable || options.writable !== false && isWritable(stream);
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    const onlegacyfinish = ()=>{
        if (!stream.writable) onfinish();
    };
    let willEmitClose = isServerResponse(stream) || state && state.autoDestroy && state.emitClose && state.closed === false && isReadable(stream) === readable && isWritable(stream) === writable;
    let writableFinished = stream.writableFinished || wState && wState.finished;
    const onfinish = ()=>{
        writableFinished = true;
        if (stream.destroyed) willEmitClose = false;
        if (willEmitClose && (!stream.readable || readable)) return;
        if (!readable || readableEnded) callback.call(stream);
    };
    let readableEnded = stream.readableEnded || rState && rState.endEmitted;
    const onend = ()=>{
        readableEnded = true;
        if (stream.destroyed) willEmitClose = false;
        if (willEmitClose && (!stream.writable || writable)) return;
        if (!writable || writableFinished) callback.call(stream);
    };
    const onerror = (err)=>{
        callback.call(stream, err);
    };
    const onclose = ()=>{
        if (readable && !readableEnded) {
            if (!isReadableEnded(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        if (writable && !writableFinished) {
            if (!isWritableFinished(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        callback.call(stream);
    };
    const onrequest = ()=>{
        stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
            stream.on("abort", onclose);
        }
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
    } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
    }
    if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (options.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    const closed = !wState && !rState && stream._closed === true || wState && wState.closed || rState && rState.closed || wState && wState.errorEmitted || rState && rState.errorEmitted || rState && stream.req && stream.aborted || (!wState || !willEmitClose || typeof wState.closed !== "boolean") && (!rState || !willEmitClose || typeof rState.closed !== "boolean") && (!writable || wState && wState.finished) && (!readable || rState && rState.endEmitted);
    if (closed) {
        nextTick1(()=>{
            callback();
        });
    }
    const cleanup = ()=>{
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
    };
    if (options.signal && !closed) {
        const abort = ()=>{
            const endCallback = callback;
            cleanup();
            endCallback.call(stream, new AbortError());
        };
        if (options.signal.aborted) {
            nextTick1(abort);
        } else {
            const originalCallback = callback;
            callback = once1((...args)=>{
                options.signal.removeEventListener("abort", abort);
                originalCallback.apply(stream, args);
            });
            options.signal.addEventListener("abort", abort);
        }
    }
    return cleanup;
}
Symbol("kIsDisturbed");
function isReadableNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!obj._writableState || obj._readableState?.readable !== false) && (!obj._writableState || obj._readableState));
}
function isWritableNodeStream(obj) {
    return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || obj._writableState?.writable !== false));
}
function isNodeStream(obj) {
    return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
}
function isDestroyed(stream) {
    if (!isNodeStream(stream)) return null;
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    return !!(stream.destroyed || state?.destroyed);
}
function isWritableEnded(stream) {
    if (!isWritableNodeStream(stream)) return null;
    if (stream.writableEnded === true) return true;
    const wState = stream._writableState;
    if (wState?.errored) return false;
    if (typeof wState?.ended !== "boolean") return null;
    return wState.ended;
}
function isReadableEnded1(stream) {
    if (!isReadableNodeStream(stream)) return null;
    if (stream.readableEnded === true) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    if (typeof rState?.ended !== "boolean") return null;
    return rState.ended;
}
function isReadableFinished(stream, strict) {
    if (!isReadableNodeStream(stream)) return null;
    const rState = stream._readableState;
    if (rState?.errored) return false;
    if (typeof rState?.endEmitted !== "boolean") return null;
    return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
}
function isReadable1(stream) {
    const r = isReadableNodeStream(stream);
    if (r === null || typeof stream?.readable !== "boolean") return null;
    if (isDestroyed(stream)) return false;
    return r && stream.readable && !isReadableFinished(stream);
}
function isWritable1(stream) {
    const r = isWritableNodeStream(stream);
    if (r === null || typeof stream?.writable !== "boolean") return null;
    if (isDestroyed(stream)) return false;
    return r && stream.writable && !isWritableEnded(stream);
}
const __process$ = {
    nextTick: nextTick1,
    stdio
};
var pi = Object.create;
var Bt = Object.defineProperty;
var wi = Object.getOwnPropertyDescriptor;
var yi = Object.getOwnPropertyNames;
var gi = Object.getPrototypeOf, Si = Object.prototype.hasOwnProperty;
((e)=>typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(e, {
        get: (t, n)=>(typeof require < "u" ? require : t)[n]
    }) : e)(function(e) {
    if (typeof require < "u") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var g = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports);
var Ei = (e, t, n, r)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let i of yi(t))!Si.call(e, i) && i !== n && Bt(e, i, {
        get: ()=>t[i],
        enumerable: !(r = wi(t, i)) || r.enumerable
    });
    return e;
};
var Ri = (e, t, n)=>(n = e != null ? pi(gi(e)) : {}, Ei(t || !e || !e.__esModule ? Bt(n, "default", {
        value: e,
        enumerable: !0
    }) : n, e));
var m = g((Yf, Gt)=>{
    "use strict";
    Gt.exports = {
        ArrayIsArray (e) {
            return Array.isArray(e);
        },
        ArrayPrototypeIncludes (e, t) {
            return e.includes(t);
        },
        ArrayPrototypeIndexOf (e, t) {
            return e.indexOf(t);
        },
        ArrayPrototypeJoin (e, t) {
            return e.join(t);
        },
        ArrayPrototypeMap (e, t) {
            return e.map(t);
        },
        ArrayPrototypePop (e, t) {
            return e.pop(t);
        },
        ArrayPrototypePush (e, t) {
            return e.push(t);
        },
        ArrayPrototypeSlice (e, t, n) {
            return e.slice(t, n);
        },
        Error,
        FunctionPrototypeCall (e, t, ...n) {
            return e.call(t, ...n);
        },
        FunctionPrototypeSymbolHasInstance (e, t) {
            return Function.prototype[Symbol.hasInstance].call(e, t);
        },
        MathFloor: Math.floor,
        Number,
        NumberIsInteger: Number.isInteger,
        NumberIsNaN: Number.isNaN,
        NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
        NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
        NumberParseInt: Number.parseInt,
        ObjectDefineProperties (e, t) {
            return Object.defineProperties(e, t);
        },
        ObjectDefineProperty (e, t, n) {
            return Object.defineProperty(e, t, n);
        },
        ObjectGetOwnPropertyDescriptor (e, t) {
            return Object.getOwnPropertyDescriptor(e, t);
        },
        ObjectKeys (e) {
            return Object.keys(e);
        },
        ObjectSetPrototypeOf (e, t) {
            return Object.setPrototypeOf(e, t);
        },
        Promise,
        PromisePrototypeCatch (e, t) {
            return e.catch(t);
        },
        PromisePrototypeThen (e, t, n) {
            return e.then(t, n);
        },
        PromiseReject (e) {
            return Promise.reject(e);
        },
        ReflectApply: Reflect.apply,
        RegExpPrototypeTest (e, t) {
            return e.test(t);
        },
        SafeSet: Set,
        String,
        StringPrototypeSlice (e, t, n) {
            return e.slice(t, n);
        },
        StringPrototypeToLowerCase (e) {
            return e.toLowerCase();
        },
        StringPrototypeToUpperCase (e) {
            return e.toUpperCase();
        },
        StringPrototypeTrim (e) {
            return e.trim();
        },
        Symbol,
        SymbolAsyncIterator: Symbol.asyncIterator,
        SymbolHasInstance: Symbol.hasInstance,
        SymbolIterator: Symbol.iterator,
        TypedArrayPrototypeSet (e, t, n) {
            return e.set(t, n);
        },
        Uint8Array
    };
});
var j = g((Kf, Je)=>{
    "use strict";
    var Ai = __default6, mi = Object.getPrototypeOf(async function() {}).constructor, Ht = globalThis.Blob || Ai.Blob, Ti = typeof Ht < "u" ? function(t) {
        return t instanceof Ht;
    } : function(t) {
        return !1;
    }, Xe = class extends Error {
        constructor(t){
            if (!Array.isArray(t)) throw new TypeError(`Expected input to be an Array, got ${typeof t}`);
            let n = "";
            for(let r = 0; r < t.length; r++)n += `    ${t[r].stack}
`;
            super(n), this.name = "AggregateError", this.errors = t;
        }
    };
    Je.exports = {
        AggregateError: Xe,
        kEmptyObject: Object.freeze({}),
        once (e) {
            let t = !1;
            return function(...n) {
                t || (t = !0, e.apply(this, n));
            };
        },
        createDeferredPromise: function() {
            let e, t;
            return {
                promise: new Promise((r, i)=>{
                    e = r, t = i;
                }),
                resolve: e,
                reject: t
            };
        },
        promisify (e) {
            return new Promise((t, n)=>{
                e((r, ...i)=>r ? n(r) : t(...i));
            });
        },
        debuglog () {
            return function() {};
        },
        format (e, ...t) {
            return e.replace(/%([sdifj])/g, function(...[n, r]) {
                let i = t.shift();
                return r === "f" ? i.toFixed(6) : r === "j" ? JSON.stringify(i) : r === "s" && typeof i == "object" ? `${i.constructor !== Object ? i.constructor.name : ""} {}`.trim() : i.toString();
            });
        },
        inspect (e) {
            switch(typeof e){
                case "string":
                    if (e.includes("'")) if (e.includes('"')) {
                        if (!e.includes("`") && !e.includes("${")) return `\`${e}\``;
                    } else return `"${e}"`;
                    return `'${e}'`;
                case "number":
                    return isNaN(e) ? "NaN" : Object.is(e, -0) ? String(e) : e;
                case "bigint":
                    return `${String(e)}n`;
                case "boolean":
                case "undefined":
                    return String(e);
                case "object":
                    return "{}";
            }
        },
        types: {
            isAsyncFunction (e) {
                return e instanceof mi;
            },
            isArrayBufferView (e) {
                return ArrayBuffer.isView(e);
            }
        },
        isBlob: Ti
    };
    Je.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
});
var O = g((zf, Kt)=>{
    "use strict";
    var { format: Ii , inspect: Re , AggregateError: Mi  } = j(), Ni = globalThis.AggregateError || Mi, Di = Symbol("kIsNodeError"), Oi = [
        "string",
        "function",
        "number",
        "object",
        "Function",
        "Object",
        "boolean",
        "bigint",
        "symbol"
    ], qi = /^([A-Z][a-z0-9]*)+$/, xi = "__node_internal_", Ae = {};
    function X(e, t) {
        if (!e) throw new Ae.ERR_INTERNAL_ASSERTION(t);
    }
    function Vt(e) {
        let t = "", n = e.length, r = e[0] === "-" ? 1 : 0;
        for(; n >= r + 4; n -= 3)t = `_${e.slice(n - 3, n)}${t}`;
        return `${e.slice(0, n)}${t}`;
    }
    function Li(e, t, n) {
        if (typeof t == "function") return X(t.length <= n.length, `Code: ${e}; The provided arguments length (${n.length}) does not match the required ones (${t.length}).`), t(...n);
        let r = (t.match(/%[dfijoOs]/g) || []).length;
        return X(r === n.length, `Code: ${e}; The provided arguments length (${n.length}) does not match the required ones (${r}).`), n.length === 0 ? t : Ii(t, ...n);
    }
    function N(e, t, n) {
        n || (n = Error);
        class r extends n {
            constructor(...o){
                super(Li(e, t, o));
            }
            toString() {
                return `${this.name} [${e}]: ${this.message}`;
            }
        }
        Object.defineProperties(r.prototype, {
            name: {
                value: n.name,
                writable: !0,
                enumerable: !1,
                configurable: !0
            },
            toString: {
                value () {
                    return `${this.name} [${e}]: ${this.message}`;
                },
                writable: !0,
                enumerable: !1,
                configurable: !0
            }
        }), r.prototype.code = e, r.prototype[Di] = !0, Ae[e] = r;
    }
    function Yt(e) {
        let t = xi + e.name;
        return Object.defineProperty(e, "name", {
            value: t
        }), e;
    }
    function Pi(e, t) {
        if (e && t && e !== t) {
            if (Array.isArray(t.errors)) return t.errors.push(e), t;
            let n = new Ni([
                t,
                e
            ], t.message);
            return n.code = t.code, n;
        }
        return e || t;
    }
    var Qe = class extends Error {
        constructor(t = "The operation was aborted", n = void 0){
            if (n !== void 0 && typeof n != "object") throw new Ae.ERR_INVALID_ARG_TYPE("options", "Object", n);
            super(t, n), this.code = "ABORT_ERR", this.name = "AbortError";
        }
    };
    N("ERR_ASSERTION", "%s", Error);
    N("ERR_INVALID_ARG_TYPE", (e, t, n)=>{
        X(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [
            t
        ]);
        let r = "The ";
        e.endsWith(" argument") ? r += `${e} ` : r += `"${e}" ${e.includes(".") ? "property" : "argument"} `, r += "must be ";
        let i = [], o = [], l = [];
        for (let f of t)X(typeof f == "string", "All expected entries have to be of type string"), Oi.includes(f) ? i.push(f.toLowerCase()) : qi.test(f) ? o.push(f) : (X(f !== "object", 'The value "object" should be written as "Object"'), l.push(f));
        if (o.length > 0) {
            let f = i.indexOf("object");
            f !== -1 && (i.splice(i, f, 1), o.push("Object"));
        }
        if (i.length > 0) {
            switch(i.length){
                case 1:
                    r += `of type ${i[0]}`;
                    break;
                case 2:
                    r += `one of type ${i[0]} or ${i[1]}`;
                    break;
                default:
                    {
                        let f = i.pop();
                        r += `one of type ${i.join(", ")}, or ${f}`;
                    }
            }
            (o.length > 0 || l.length > 0) && (r += " or ");
        }
        if (o.length > 0) {
            switch(o.length){
                case 1:
                    r += `an instance of ${o[0]}`;
                    break;
                case 2:
                    r += `an instance of ${o[0]} or ${o[1]}`;
                    break;
                default:
                    {
                        let f = o.pop();
                        r += `an instance of ${o.join(", ")}, or ${f}`;
                    }
            }
            l.length > 0 && (r += " or ");
        }
        switch(l.length){
            case 0:
                break;
            case 1:
                l[0].toLowerCase() !== l[0] && (r += "an "), r += `${l[0]}`;
                break;
            case 2:
                r += `one of ${l[0]} or ${l[1]}`;
                break;
            default:
                {
                    let f = l.pop();
                    r += `one of ${l.join(", ")}, or ${f}`;
                }
        }
        if (n == null) r += `. Received ${n}`;
        else if (typeof n == "function" && n.name) r += `. Received function ${n.name}`;
        else if (typeof n == "object") {
            var u;
            (u = n.constructor) !== null && u !== void 0 && u.name ? r += `. Received an instance of ${n.constructor.name}` : r += `. Received ${Re(n, {
                depth: -1
            })}`;
        } else {
            let f = Re(n, {
                colors: !1
            });
            f.length > 25 && (f = `${f.slice(0, 25)}...`), r += `. Received type ${typeof n} (${f})`;
        }
        return r;
    }, TypeError);
    N("ERR_INVALID_ARG_VALUE", (e, t, n = "is invalid")=>{
        let r = Re(t);
        return r.length > 128 && (r = r.slice(0, 128) + "..."), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${n}. Received ${r}`;
    }, TypeError);
    N("ERR_INVALID_RETURN_VALUE", (e, t, n)=>{
        var r;
        let i = n != null && (r = n.constructor) !== null && r !== void 0 && r.name ? `instance of ${n.constructor.name}` : `type ${typeof n}`;
        return `Expected ${e} to be returned from the "${t}" function but got ${i}.`;
    }, TypeError);
    N("ERR_MISSING_ARGS", (...e)=>{
        X(e.length > 0, "At least one arg needs to be specified");
        let t, n = e.length;
        switch(e = (Array.isArray(e) ? e : [
            e
        ]).map((r)=>`"${r}"`).join(" or "), n){
            case 1:
                t += `The ${e[0]} argument`;
                break;
            case 2:
                t += `The ${e[0]} and ${e[1]} arguments`;
                break;
            default:
                {
                    let r = e.pop();
                    t += `The ${e.join(", ")}, and ${r} arguments`;
                }
                break;
        }
        return `${t} must be specified`;
    }, TypeError);
    N("ERR_OUT_OF_RANGE", (e, t, n)=>{
        X(t, 'Missing "range" argument');
        let r;
        return Number.isInteger(n) && Math.abs(n) > 2 ** 32 ? r = Vt(String(n)) : typeof n == "bigint" ? (r = String(n), (n > 2n ** 32n || n < -(2n ** 32n)) && (r = Vt(r)), r += "n") : r = Re(n), `The value of "${e}" is out of range. It must be ${t}. Received ${r}`;
    }, RangeError);
    N("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    N("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    N("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    N("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    N("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    N("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    N("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    N("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    N("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    N("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    N("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    Kt.exports = {
        AbortError: Qe,
        aggregateTwoErrors: Yt(Pi),
        hideStackFrames: Yt,
        codes: Ae
    };
});
var _e = g((Xf, nn)=>{
    "use strict";
    var { ArrayIsArray: Jt , ArrayPrototypeIncludes: Qt , ArrayPrototypeJoin: Zt , ArrayPrototypeMap: ki , NumberIsInteger: et , NumberIsNaN: Wi , NumberMAX_SAFE_INTEGER: Ci , NumberMIN_SAFE_INTEGER: ji , NumberParseInt: $i , ObjectPrototypeHasOwnProperty: vi , RegExpPrototypeExec: Fi , String: Ui , StringPrototypeToUpperCase: Bi , StringPrototypeTrim: Gi  } = m(), { hideStackFrames: k , codes: { ERR_SOCKET_BAD_PORT: Hi , ERR_INVALID_ARG_TYPE: q , ERR_INVALID_ARG_VALUE: me , ERR_OUT_OF_RANGE: J , ERR_UNKNOWN_SIGNAL: zt  }  } = O(), { normalizeEncoding: Vi  } = j(), { isAsyncFunction: Yi , isArrayBufferView: Ki  } = j().types, Xt = {};
    function zi(e) {
        return e === (e | 0);
    }
    function Xi(e) {
        return e === e >>> 0;
    }
    var Ji = /^[0-7]+$/, Qi = "must be a 32-bit unsigned integer or an octal string";
    function Zi(e, t, n) {
        if (typeof e > "u" && (e = n), typeof e == "string") {
            if (Fi(Ji, e) === null) throw new me(t, e, Qi);
            e = $i(e, 8);
        }
        return en(e, t), e;
    }
    var eo = k((e, t, n = ji, r = Ci)=>{
        if (typeof e != "number") throw new q(t, "number", e);
        if (!et(e)) throw new J(t, "an integer", e);
        if (e < n || e > r) throw new J(t, `>= ${n} && <= ${r}`, e);
    }), to = k((e, t, n = -2147483648, r = 2147483647)=>{
        if (typeof e != "number") throw new q(t, "number", e);
        if (!et(e)) throw new J(t, "an integer", e);
        if (e < n || e > r) throw new J(t, `>= ${n} && <= ${r}`, e);
    }), en = k((e, t, n = !1)=>{
        if (typeof e != "number") throw new q(t, "number", e);
        if (!et(e)) throw new J(t, "an integer", e);
        let r = n ? 1 : 0, i = 4294967295;
        if (e < r || e > i) throw new J(t, `>= ${r} && <= ${i}`, e);
    });
    function tn(e, t) {
        if (typeof e != "string") throw new q(t, "string", e);
    }
    function no(e, t, n = void 0, r) {
        if (typeof e != "number") throw new q(t, "number", e);
        if (n != null && e < n || r != null && e > r || (n != null || r != null) && Wi(e)) throw new J(t, `${n != null ? `>= ${n}` : ""}${n != null && r != null ? " && " : ""}${r != null ? `<= ${r}` : ""}`, e);
    }
    var ro = k((e, t, n)=>{
        if (!Qt(n, e)) {
            let r = Zt(ki(n, (o)=>typeof o == "string" ? `'${o}'` : Ui(o)), ", "), i = "must be one of: " + r;
            throw new me(t, e, i);
        }
    });
    function io(e, t) {
        if (typeof e != "boolean") throw new q(t, "boolean", e);
    }
    function Ze(e, t, n) {
        return e == null || !vi(e, t) ? n : e[t];
    }
    var oo = k((e, t, n = null)=>{
        let r = Ze(n, "allowArray", !1), i = Ze(n, "allowFunction", !1);
        if (!Ze(n, "nullable", !1) && e === null || !r && Jt(e) || typeof e != "object" && (!i || typeof e != "function")) throw new q(t, "Object", e);
    }), lo = k((e, t, n = 0)=>{
        if (!Jt(e)) throw new q(t, "Array", e);
        if (e.length < n) {
            let r = `must be longer than ${n}`;
            throw new me(t, e, r);
        }
    });
    function ao(e, t = "signal") {
        if (tn(e, t), Xt[e] === void 0) throw Xt[Bi(e)] !== void 0 ? new zt(e + " (signals must use all capital letters)") : new zt(e);
    }
    var fo = k((e, t = "buffer")=>{
        if (!Ki(e)) throw new q(t, [
            "Buffer",
            "TypedArray",
            "DataView"
        ], e);
    });
    function uo(e, t) {
        let n = Vi(t), r = e.length;
        if (n === "hex" && r % 2 !== 0) throw new me("encoding", t, `is invalid for data of length ${r}`);
    }
    function so(e, t = "Port", n = !0) {
        if (typeof e != "number" && typeof e != "string" || typeof e == "string" && Gi(e).length === 0 || +e !== +e >>> 0 || e > 65535 || e === 0 && !n) throw new Hi(t, e, n);
        return e | 0;
    }
    var co = k((e, t)=>{
        if (e !== void 0 && (e === null || typeof e != "object" || !("aborted" in e))) throw new q(t, "AbortSignal", e);
    }), ho = k((e, t)=>{
        if (typeof e != "function") throw new q(t, "Function", e);
    }), bo = k((e, t)=>{
        if (typeof e != "function" || Yi(e)) throw new q(t, "Function", e);
    }), _o = k((e, t)=>{
        if (e !== void 0) throw new q(t, "undefined", e);
    });
    function po(e, t, n) {
        if (!Qt(n, e)) throw new q(t, `('${Zt(n, "|")}')`, e);
    }
    nn.exports = {
        isInt32: zi,
        isUint32: Xi,
        parseFileMode: Zi,
        validateArray: lo,
        validateBoolean: io,
        validateBuffer: fo,
        validateEncoding: uo,
        validateFunction: ho,
        validateInt32: to,
        validateInteger: eo,
        validateNumber: no,
        validateObject: oo,
        validateOneOf: ro,
        validatePlainFunction: bo,
        validatePort: so,
        validateSignalName: ao,
        validateString: tn,
        validateUint32: en,
        validateUndefined: _o,
        validateUnion: po,
        validateAbortSignal: co
    };
});
var V = g((Jf, _n)=>{
    "use strict";
    var { Symbol: Te , SymbolAsyncIterator: rn , SymbolIterator: on  } = m(), ln = Te("kDestroyed"), an = Te("kIsErrored"), tt = Te("kIsReadable"), fn = Te("kIsDisturbed");
    function Ie(e, t = !1) {
        var n;
        return !!(e && typeof e.pipe == "function" && typeof e.on == "function" && (!t || typeof e.pause == "function" && typeof e.resume == "function") && (!e._writableState || ((n = e._readableState) === null || n === void 0 ? void 0 : n.readable) !== !1) && (!e._writableState || e._readableState));
    }
    function Me(e) {
        var t;
        return !!(e && typeof e.write == "function" && typeof e.on == "function" && (!e._readableState || ((t = e._writableState) === null || t === void 0 ? void 0 : t.writable) !== !1));
    }
    function wo(e) {
        return !!(e && typeof e.pipe == "function" && e._readableState && typeof e.on == "function" && typeof e.write == "function");
    }
    function Q(e) {
        return e && (e._readableState || e._writableState || typeof e.write == "function" && typeof e.on == "function" || typeof e.pipe == "function" && typeof e.on == "function");
    }
    function yo(e, t) {
        return e == null ? !1 : t === !0 ? typeof e[rn] == "function" : t === !1 ? typeof e[on] == "function" : typeof e[rn] == "function" || typeof e[on] == "function";
    }
    function Ne(e) {
        if (!Q(e)) return null;
        let t = e._writableState, n = e._readableState, r = t || n;
        return !!(e.destroyed || e[ln] || r != null && r.destroyed);
    }
    function un(e) {
        if (!Me(e)) return null;
        if (e.writableEnded === !0) return !0;
        let t = e._writableState;
        return t != null && t.errored ? !1 : typeof t?.ended != "boolean" ? null : t.ended;
    }
    function go(e, t) {
        if (!Me(e)) return null;
        if (e.writableFinished === !0) return !0;
        let n = e._writableState;
        return n != null && n.errored ? !1 : typeof n?.finished != "boolean" ? null : !!(n.finished || t === !1 && n.ended === !0 && n.length === 0);
    }
    function So(e) {
        if (!Ie(e)) return null;
        if (e.readableEnded === !0) return !0;
        let t = e._readableState;
        return !t || t.errored ? !1 : typeof t?.ended != "boolean" ? null : t.ended;
    }
    function sn(e, t) {
        if (!Ie(e)) return null;
        let n = e._readableState;
        return n != null && n.errored ? !1 : typeof n?.endEmitted != "boolean" ? null : !!(n.endEmitted || t === !1 && n.ended === !0 && n.length === 0);
    }
    function dn(e) {
        return e && e[tt] != null ? e[tt] : typeof e?.readable != "boolean" ? null : Ne(e) ? !1 : Ie(e) && e.readable && !sn(e);
    }
    function cn(e) {
        return typeof e?.writable != "boolean" ? null : Ne(e) ? !1 : Me(e) && e.writable && !un(e);
    }
    function Eo(e, t) {
        return Q(e) ? Ne(e) ? !0 : !(t?.readable !== !1 && dn(e) || t?.writable !== !1 && cn(e)) : null;
    }
    function Ro(e) {
        var t, n;
        return Q(e) ? e.writableErrored ? e.writableErrored : (t = (n = e._writableState) === null || n === void 0 ? void 0 : n.errored) !== null && t !== void 0 ? t : null : null;
    }
    function Ao(e) {
        var t, n;
        return Q(e) ? e.readableErrored ? e.readableErrored : (t = (n = e._readableState) === null || n === void 0 ? void 0 : n.errored) !== null && t !== void 0 ? t : null : null;
    }
    function mo(e) {
        if (!Q(e)) return null;
        if (typeof e.closed == "boolean") return e.closed;
        let t = e._writableState, n = e._readableState;
        return typeof t?.closed == "boolean" || typeof n?.closed == "boolean" ? t?.closed || n?.closed : typeof e._closed == "boolean" && hn(e) ? e._closed : null;
    }
    function hn(e) {
        return typeof e._closed == "boolean" && typeof e._defaultKeepAlive == "boolean" && typeof e._removedConnection == "boolean" && typeof e._removedContLen == "boolean";
    }
    function bn(e) {
        return typeof e._sent100 == "boolean" && hn(e);
    }
    function To(e) {
        var t;
        return typeof e._consuming == "boolean" && typeof e._dumped == "boolean" && ((t = e.req) === null || t === void 0 ? void 0 : t.upgradeOrConnect) === void 0;
    }
    function Io(e) {
        if (!Q(e)) return null;
        let t = e._writableState, n = e._readableState, r = t || n;
        return !r && bn(e) || !!(r && r.autoDestroy && r.emitClose && r.closed === !1);
    }
    function Mo(e) {
        var t;
        return !!(e && ((t = e[fn]) !== null && t !== void 0 ? t : e.readableDidRead || e.readableAborted));
    }
    function No(e) {
        var t, n, r, i, o, l, u, f, a, c;
        return !!(e && ((t = (n = (r = (i = (o = (l = e[an]) !== null && l !== void 0 ? l : e.readableErrored) !== null && o !== void 0 ? o : e.writableErrored) !== null && i !== void 0 ? i : (u = e._readableState) === null || u === void 0 ? void 0 : u.errorEmitted) !== null && r !== void 0 ? r : (f = e._writableState) === null || f === void 0 ? void 0 : f.errorEmitted) !== null && n !== void 0 ? n : (a = e._readableState) === null || a === void 0 ? void 0 : a.errored) !== null && t !== void 0 ? t : (c = e._writableState) === null || c === void 0 ? void 0 : c.errored));
    }
    _n.exports = {
        kDestroyed: ln,
        isDisturbed: Mo,
        kIsDisturbed: fn,
        isErrored: No,
        kIsErrored: an,
        isReadable: dn,
        kIsReadable: tt,
        isClosed: mo,
        isDestroyed: Ne,
        isDuplexNodeStream: wo,
        isFinished: Eo,
        isIterable: yo,
        isReadableNodeStream: Ie,
        isReadableEnded: So,
        isReadableFinished: sn,
        isReadableErrored: Ao,
        isNodeStream: Q,
        isWritable: cn,
        isWritableNodeStream: Me,
        isWritableEnded: un,
        isWritableFinished: go,
        isWritableErrored: Ro,
        isServerRequest: To,
        isServerResponse: bn,
        willEmitClose: Io
    };
});
var Y = g((Qf, rt)=>{
    var oe = __process$, { AbortError: Do , codes: Oo  } = O(), { ERR_INVALID_ARG_TYPE: qo , ERR_STREAM_PREMATURE_CLOSE: pn  } = Oo, { kEmptyObject: wn , once: yn  } = j(), { validateAbortSignal: xo , validateFunction: Lo , validateObject: Po  } = _e(), { Promise: ko  } = m(), { isClosed: Wo , isReadable: gn , isReadableNodeStream: nt , isReadableFinished: Sn , isReadableErrored: Co , isWritable: En , isWritableNodeStream: Rn , isWritableFinished: An , isWritableErrored: jo , isNodeStream: $o , willEmitClose: vo  } = V();
    function Fo(e) {
        return e.setHeader && typeof e.abort == "function";
    }
    var Uo = ()=>{};
    function mn(e, t, n) {
        var r, i;
        arguments.length === 2 ? (n = t, t = wn) : t == null ? t = wn : Po(t, "options"), Lo(n, "callback"), xo(t.signal, "options.signal"), n = yn(n);
        let o = (r = t.readable) !== null && r !== void 0 ? r : nt(e), l = (i = t.writable) !== null && i !== void 0 ? i : Rn(e);
        if (!$o(e)) throw new qo("stream", "Stream", e);
        let u = e._writableState, f = e._readableState, a = ()=>{
            e.writable || b();
        }, c = vo(e) && nt(e) === o && Rn(e) === l, s = An(e, !1), b = ()=>{
            s = !0, e.destroyed && (c = !1), !(c && (!e.readable || o)) && (!o || d) && n.call(e);
        }, d = Sn(e, !1), h = ()=>{
            d = !0, e.destroyed && (c = !1), !(c && (!e.writable || l)) && (!l || s) && n.call(e);
        }, D = (M)=>{
            n.call(e, M);
        }, L = Wo(e), _ = ()=>{
            L = !0;
            let M = jo(e) || Co(e);
            if (M && typeof M != "boolean") return n.call(e, M);
            if (o && !d && nt(e, !0) && !Sn(e, !1)) return n.call(e, new pn);
            if (l && !s && !An(e, !1)) return n.call(e, new pn);
            n.call(e);
        }, p = ()=>{
            e.req.on("finish", b);
        };
        Fo(e) ? (e.on("complete", b), c || e.on("abort", _), e.req ? p() : e.on("request", p)) : l && !u && (e.on("end", a), e.on("close", a)), !c && typeof e.aborted == "boolean" && e.on("aborted", _), e.on("end", h), e.on("finish", b), t.error !== !1 && e.on("error", D), e.on("close", _), L ? oe.nextTick(_) : u != null && u.errorEmitted || f != null && f.errorEmitted ? c || oe.nextTick(_) : (!o && (!c || gn(e)) && (s || En(e) === !1) || !l && (!c || En(e)) && (d || gn(e) === !1) || f && e.req && e.aborted) && oe.nextTick(_);
        let I = ()=>{
            n = Uo, e.removeListener("aborted", _), e.removeListener("complete", b), e.removeListener("abort", _), e.removeListener("request", p), e.req && e.req.removeListener("finish", b), e.removeListener("end", a), e.removeListener("close", a), e.removeListener("finish", b), e.removeListener("end", h), e.removeListener("error", D), e.removeListener("close", _);
        };
        if (t.signal && !L) {
            let M = ()=>{
                let F = n;
                I(), F.call(e, new Do(void 0, {
                    cause: t.signal.reason
                }));
            };
            if (t.signal.aborted) oe.nextTick(M);
            else {
                let F = n;
                n = yn((...re)=>{
                    t.signal.removeEventListener("abort", M), F.apply(e, re);
                }), t.signal.addEventListener("abort", M);
            }
        }
        return I;
    }
    function Bo(e, t) {
        return new ko((n, r)=>{
            mn(e, t, (i)=>{
                i ? r(i) : n();
            });
        });
    }
    rt.exports = mn;
    rt.exports.finished = Bo;
});
var xn = g((Zf, lt)=>{
    "use strict";
    var Nn = globalThis.AbortController, { codes: { ERR_INVALID_ARG_TYPE: pe , ERR_MISSING_ARGS: Go , ERR_OUT_OF_RANGE: Ho  } , AbortError: $  } = O(), { validateAbortSignal: le , validateInteger: Vo , validateObject: ae  } = _e(), Yo = m().Symbol("kWeak"), { finished: Ko  } = Y(), { ArrayPrototypePush: zo , MathFloor: Xo , Number: Jo , NumberIsNaN: Qo , Promise: Tn , PromiseReject: In , PromisePrototypeThen: Zo , Symbol: Dn  } = m(), De = Dn("kEmpty"), Mn = Dn("kEof");
    function Oe(e, t) {
        if (typeof e != "function") throw new pe("fn", [
            "Function",
            "AsyncFunction"
        ], e);
        t != null && ae(t, "options"), t?.signal != null && le(t.signal, "options.signal");
        let n = 1;
        return t?.concurrency != null && (n = Xo(t.concurrency)), Vo(n, "concurrency", 1), (async function*() {
            var i, o;
            let l = new Nn, u = this, f = [], a = l.signal, c = {
                signal: a
            }, s = ()=>l.abort();
            t != null && (i = t.signal) !== null && i !== void 0 && i.aborted && s(), t == null || (o = t.signal) === null || o === void 0 || o.addEventListener("abort", s);
            let b, d, h = !1;
            function D() {
                h = !0;
            }
            async function L() {
                try {
                    for await (let I of u){
                        var _;
                        if (h) return;
                        if (a.aborted) throw new $;
                        try {
                            I = e(I, c);
                        } catch (M) {
                            I = In(M);
                        }
                        I !== De && (typeof ((_ = I) === null || _ === void 0 ? void 0 : _.catch) == "function" && I.catch(D), f.push(I), b && (b(), b = null), !h && f.length && f.length >= n && await new Tn((M)=>{
                            d = M;
                        }));
                    }
                    f.push(Mn);
                } catch (I) {
                    let M = In(I);
                    Zo(M, void 0, D), f.push(M);
                } finally{
                    var p;
                    h = !0, b && (b(), b = null), t == null || (p = t.signal) === null || p === void 0 || p.removeEventListener("abort", s);
                }
            }
            L();
            try {
                for(;;){
                    for(; f.length > 0;){
                        let _ = await f[0];
                        if (_ === Mn) return;
                        if (a.aborted) throw new $;
                        _ !== De && (yield _), f.shift(), d && (d(), d = null);
                    }
                    await new Tn((_)=>{
                        b = _;
                    });
                }
            } finally{
                l.abort(), h = !0, d && (d(), d = null);
            }
        }).call(this);
    }
    function el(e = void 0) {
        return e != null && ae(e, "options"), e?.signal != null && le(e.signal, "options.signal"), (async function*() {
            let n = 0;
            for await (let i of this){
                var r;
                if (e != null && (r = e.signal) !== null && r !== void 0 && r.aborted) throw new $({
                    cause: e.signal.reason
                });
                yield [
                    n++,
                    i
                ];
            }
        }).call(this);
    }
    async function On(e, t = void 0) {
        for await (let n of ot.call(this, e, t))return !0;
        return !1;
    }
    async function tl(e, t = void 0) {
        if (typeof e != "function") throw new pe("fn", [
            "Function",
            "AsyncFunction"
        ], e);
        return !await On.call(this, async (...n)=>!await e(...n), t);
    }
    async function nl(e, t) {
        for await (let n of ot.call(this, e, t))return n;
    }
    async function rl(e, t) {
        if (typeof e != "function") throw new pe("fn", [
            "Function",
            "AsyncFunction"
        ], e);
        async function n(r, i) {
            return await e(r, i), De;
        }
        for await (let r of Oe.call(this, n, t));
    }
    function ot(e, t) {
        if (typeof e != "function") throw new pe("fn", [
            "Function",
            "AsyncFunction"
        ], e);
        async function n(r, i) {
            return await e(r, i) ? r : De;
        }
        return Oe.call(this, n, t);
    }
    var it = class extends Go {
        constructor(){
            super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
        }
    };
    async function il(e, t, n) {
        var r;
        if (typeof e != "function") throw new pe("reducer", [
            "Function",
            "AsyncFunction"
        ], e);
        n != null && ae(n, "options"), n?.signal != null && le(n.signal, "options.signal");
        let i = arguments.length > 1;
        if (n != null && (r = n.signal) !== null && r !== void 0 && r.aborted) {
            let a = new $(void 0, {
                cause: n.signal.reason
            });
            throw this.once("error", ()=>{}), await Ko(this.destroy(a)), a;
        }
        let o = new Nn, l = o.signal;
        if (n != null && n.signal) {
            let a = {
                once: !0,
                [Yo]: this
            };
            n.signal.addEventListener("abort", ()=>o.abort(), a);
        }
        let u = !1;
        try {
            for await (let a of this){
                var f;
                if (u = !0, n != null && (f = n.signal) !== null && f !== void 0 && f.aborted) throw new $;
                i ? t = await e(t, a, {
                    signal: l
                }) : (t = a, i = !0);
            }
            if (!u && !i) throw new it;
        } finally{
            o.abort();
        }
        return t;
    }
    async function ol(e) {
        e != null && ae(e, "options"), e?.signal != null && le(e.signal, "options.signal");
        let t = [];
        for await (let r of this){
            var n;
            if (e != null && (n = e.signal) !== null && n !== void 0 && n.aborted) throw new $(void 0, {
                cause: e.signal.reason
            });
            zo(t, r);
        }
        return t;
    }
    function ll(e, t) {
        let n = Oe.call(this, e, t);
        return (async function*() {
            for await (let i of n)yield* i;
        }).call(this);
    }
    function qn(e) {
        if (e = Jo(e), Qo(e)) return 0;
        if (e < 0) throw new Ho("number", ">= 0", e);
        return e;
    }
    function al(e, t = void 0) {
        return t != null && ae(t, "options"), t?.signal != null && le(t.signal, "options.signal"), e = qn(e), (async function*() {
            var r;
            if (t != null && (r = t.signal) !== null && r !== void 0 && r.aborted) throw new $;
            for await (let o of this){
                var i;
                if (t != null && (i = t.signal) !== null && i !== void 0 && i.aborted) throw new $;
                e-- <= 0 && (yield o);
            }
        }).call(this);
    }
    function fl(e, t = void 0) {
        return t != null && ae(t, "options"), t?.signal != null && le(t.signal, "options.signal"), e = qn(e), (async function*() {
            var r;
            if (t != null && (r = t.signal) !== null && r !== void 0 && r.aborted) throw new $;
            for await (let o of this){
                var i;
                if (t != null && (i = t.signal) !== null && i !== void 0 && i.aborted) throw new $;
                if (e-- > 0) yield o;
                else return;
            }
        }).call(this);
    }
    lt.exports.streamReturningOperators = {
        asIndexedPairs: el,
        drop: al,
        filter: ot,
        flatMap: ll,
        map: Oe,
        take: fl
    };
    lt.exports.promiseReturningOperators = {
        every: tl,
        forEach: rl,
        reduce: il,
        toArray: ol,
        some: On,
        find: nl
    };
});
var Z = g((eu, vn)=>{
    "use strict";
    var K = __process$, { aggregateTwoErrors: ul , codes: { ERR_MULTIPLE_CALLBACK: sl  } , AbortError: dl  } = O(), { Symbol: kn  } = m(), { kDestroyed: cl , isDestroyed: hl , isFinished: bl , isServerRequest: _l  } = V(), Wn = kn("kDestroy"), at = kn("kConstruct");
    function Cn(e, t, n) {
        e && (e.stack, t && !t.errored && (t.errored = e), n && !n.errored && (n.errored = e));
    }
    function pl(e, t) {
        let n = this._readableState, r = this._writableState, i = r || n;
        return r && r.destroyed || n && n.destroyed ? (typeof t == "function" && t(), this) : (Cn(e, r, n), r && (r.destroyed = !0), n && (n.destroyed = !0), i.constructed ? Ln(this, e, t) : this.once(Wn, function(o) {
            Ln(this, ul(o, e), t);
        }), this);
    }
    function Ln(e, t, n) {
        let r = !1;
        function i(o) {
            if (r) return;
            r = !0;
            let l = e._readableState, u = e._writableState;
            Cn(o, u, l), u && (u.closed = !0), l && (l.closed = !0), typeof n == "function" && n(o), o ? K.nextTick(wl, e, o) : K.nextTick(jn, e);
        }
        try {
            e._destroy(t || null, i);
        } catch (o) {
            i(o);
        }
    }
    function wl(e, t) {
        ft(e, t), jn(e);
    }
    function jn(e) {
        let t = e._readableState, n = e._writableState;
        n && (n.closeEmitted = !0), t && (t.closeEmitted = !0), (n && n.emitClose || t && t.emitClose) && e.emit("close");
    }
    function ft(e, t) {
        let n = e._readableState, r = e._writableState;
        r && r.errorEmitted || n && n.errorEmitted || (r && (r.errorEmitted = !0), n && (n.errorEmitted = !0), e.emit("error", t));
    }
    function yl() {
        let e = this._readableState, t = this._writableState;
        e && (e.constructed = !0, e.closed = !1, e.closeEmitted = !1, e.destroyed = !1, e.errored = null, e.errorEmitted = !1, e.reading = !1, e.ended = e.readable === !1, e.endEmitted = e.readable === !1), t && (t.constructed = !0, t.destroyed = !1, t.closed = !1, t.closeEmitted = !1, t.errored = null, t.errorEmitted = !1, t.finalCalled = !1, t.prefinished = !1, t.ended = t.writable === !1, t.ending = t.writable === !1, t.finished = t.writable === !1);
    }
    function ut(e, t, n) {
        let r = e._readableState, i = e._writableState;
        if (i && i.destroyed || r && r.destroyed) return this;
        r && r.autoDestroy || i && i.autoDestroy ? e.destroy(t) : t && (t.stack, i && !i.errored && (i.errored = t), r && !r.errored && (r.errored = t), n ? K.nextTick(ft, e, t) : ft(e, t));
    }
    function gl(e, t) {
        if (typeof e._construct != "function") return;
        let n = e._readableState, r = e._writableState;
        n && (n.constructed = !1), r && (r.constructed = !1), e.once(at, t), !(e.listenerCount(at) > 1) && K.nextTick(Sl, e);
    }
    function Sl(e) {
        let t = !1;
        function n(r) {
            if (t) {
                ut(e, r ?? new sl);
                return;
            }
            t = !0;
            let i = e._readableState, o = e._writableState, l = o || i;
            i && (i.constructed = !0), o && (o.constructed = !0), l.destroyed ? e.emit(Wn, r) : r ? ut(e, r, !0) : K.nextTick(El, e);
        }
        try {
            e._construct(n);
        } catch (r) {
            n(r);
        }
    }
    function El(e) {
        e.emit(at);
    }
    function Pn(e) {
        return e && e.setHeader && typeof e.abort == "function";
    }
    function $n(e) {
        e.emit("close");
    }
    function Rl(e, t) {
        e.emit("error", t), K.nextTick($n, e);
    }
    function Al(e, t) {
        !e || hl(e) || (!t && !bl(e) && (t = new dl), _l(e) ? (e.socket = null, e.destroy(t)) : Pn(e) ? e.abort() : Pn(e.req) ? e.req.abort() : typeof e.destroy == "function" ? e.destroy(t) : typeof e.close == "function" ? e.close() : t ? K.nextTick(Rl, e, t) : K.nextTick($n, e), e.destroyed || (e[cl] = !0));
    }
    vn.exports = {
        construct: gl,
        destroyer: Al,
        destroy: pl,
        undestroy: yl,
        errorOrDestroy: ut
    };
});
var Le = g((tu, Un)=>{
    "use strict";
    var { ArrayIsArray: ml , ObjectSetPrototypeOf: Fn  } = m(), { EventEmitter: qe  } = EventEmitter;
    function xe(e) {
        qe.call(this, e);
    }
    Fn(xe.prototype, qe.prototype);
    Fn(xe, qe);
    xe.prototype.pipe = function(e, t) {
        let n = this;
        function r(c) {
            e.writable && e.write(c) === !1 && n.pause && n.pause();
        }
        n.on("data", r);
        function i() {
            n.readable && n.resume && n.resume();
        }
        e.on("drain", i), !e._isStdio && (!t || t.end !== !1) && (n.on("end", l), n.on("close", u));
        let o = !1;
        function l() {
            o || (o = !0, e.end());
        }
        function u() {
            o || (o = !0, typeof e.destroy == "function" && e.destroy());
        }
        function f(c) {
            a(), qe.listenerCount(this, "error") === 0 && this.emit("error", c);
        }
        st(n, "error", f), st(e, "error", f);
        function a() {
            n.removeListener("data", r), e.removeListener("drain", i), n.removeListener("end", l), n.removeListener("close", u), n.removeListener("error", f), e.removeListener("error", f), n.removeListener("end", a), n.removeListener("close", a), e.removeListener("close", a);
        }
        return n.on("end", a), n.on("close", a), e.on("close", a), e.emit("pipe", n), e;
    };
    function st(e, t, n) {
        if (typeof e.prependListener == "function") return e.prependListener(t, n);
        !e._events || !e._events[t] ? e.on(t, n) : ml(e._events[t]) ? e._events[t].unshift(n) : e._events[t] = [
            n,
            e._events[t]
        ];
    }
    Un.exports = {
        Stream: xe,
        prependListener: st
    };
});
var ke = g((nu, Pe)=>{
    "use strict";
    var { AbortError: Tl , codes: Il  } = O(), Ml = Y(), { ERR_INVALID_ARG_TYPE: Bn  } = Il, Nl = (e, t)=>{
        if (typeof e != "object" || !("aborted" in e)) throw new Bn(t, "AbortSignal", e);
    };
    function Dl(e) {
        return !!(e && typeof e.pipe == "function");
    }
    Pe.exports.addAbortSignal = function(t, n) {
        if (Nl(t, "signal"), !Dl(n)) throw new Bn("stream", "stream.Stream", n);
        return Pe.exports.addAbortSignalNoValidate(t, n);
    };
    Pe.exports.addAbortSignalNoValidate = function(e, t) {
        if (typeof e != "object" || !("aborted" in e)) return t;
        let n = ()=>{
            t.destroy(new Tl(void 0, {
                cause: e.reason
            }));
        };
        return e.aborted ? n() : (e.addEventListener("abort", n), Ml(t, ()=>e.removeEventListener("abort", n))), t;
    };
});
var Vn = g((iu, Hn)=>{
    "use strict";
    var { StringPrototypeSlice: Gn , SymbolIterator: Ol , TypedArrayPrototypeSet: We , Uint8Array: ql  } = m(), { Buffer: dt  } = __default6, { inspect: xl  } = j();
    Hn.exports = class {
        constructor(){
            this.head = null, this.tail = null, this.length = 0;
        }
        push(t) {
            let n = {
                data: t,
                next: null
            };
            this.length > 0 ? this.tail.next = n : this.head = n, this.tail = n, ++this.length;
        }
        unshift(t) {
            let n = {
                data: t,
                next: this.head
            };
            this.length === 0 && (this.tail = n), this.head = n, ++this.length;
        }
        shift() {
            if (this.length === 0) return;
            let t = this.head.data;
            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
        }
        clear() {
            this.head = this.tail = null, this.length = 0;
        }
        join(t) {
            if (this.length === 0) return "";
            let n = this.head, r = "" + n.data;
            for(; (n = n.next) !== null;)r += t + n.data;
            return r;
        }
        concat(t) {
            if (this.length === 0) return dt.alloc(0);
            let n = dt.allocUnsafe(t >>> 0), r = this.head, i = 0;
            for(; r;)We(n, r.data, i), i += r.data.length, r = r.next;
            return n;
        }
        consume(t, n) {
            let r = this.head.data;
            if (t < r.length) {
                let i = r.slice(0, t);
                return this.head.data = r.slice(t), i;
            }
            return t === r.length ? this.shift() : n ? this._getString(t) : this._getBuffer(t);
        }
        first() {
            return this.head.data;
        }
        *[Ol]() {
            for(let t = this.head; t; t = t.next)yield t.data;
        }
        _getString(t) {
            let n = "", r = this.head, i = 0;
            do {
                let o = r.data;
                if (t > o.length) n += o, t -= o.length;
                else {
                    t === o.length ? (n += o, ++i, r.next ? this.head = r.next : this.head = this.tail = null) : (n += Gn(o, 0, t), this.head = r, r.data = Gn(o, t));
                    break;
                }
                ++i;
            }while ((r = r.next) !== null)
            return this.length -= i, n;
        }
        _getBuffer(t) {
            let n = dt.allocUnsafe(t), r = t, i = this.head, o = 0;
            do {
                let l = i.data;
                if (t > l.length) We(n, l, r - t), t -= l.length;
                else {
                    t === l.length ? (We(n, l, r - t), ++o, i.next ? this.head = i.next : this.head = this.tail = null) : (We(n, new ql(l.buffer, l.byteOffset, t), r - t), this.head = i, i.data = l.slice(t));
                    break;
                }
                ++o;
            }while ((i = i.next) !== null)
            return this.length -= o, n;
        }
        [Symbol.for("nodejs.util.inspect.custom")](t, n) {
            return xl(this, {
                ...n,
                depth: 0,
                customInspect: !1
            });
        }
    };
});
var Ce = g((ou, Kn)=>{
    "use strict";
    var { MathFloor: Ll , NumberIsInteger: Pl  } = m(), { ERR_INVALID_ARG_VALUE: kl  } = O().codes;
    function Wl(e, t, n) {
        return e.highWaterMark != null ? e.highWaterMark : t ? e[n] : null;
    }
    function Yn(e) {
        return e ? 16 : 16 * 1024;
    }
    function Cl(e, t, n, r) {
        let i = Wl(t, r, n);
        if (i != null) {
            if (!Pl(i) || i < 0) {
                let o = r ? `options.${n}` : "options.highWaterMark";
                throw new kl(o, i);
            }
            return Ll(i);
        }
        return Yn(e.objectMode);
    }
    Kn.exports = {
        getHighWaterMark: Cl,
        getDefaultHighWaterMark: Yn
    };
});
var ct = g((lu, Qn)=>{
    "use strict";
    var zn = __process$, { PromisePrototypeThen: jl , SymbolAsyncIterator: Xn , SymbolIterator: Jn  } = m(), { Buffer: $l  } = __default6, { ERR_INVALID_ARG_TYPE: vl , ERR_STREAM_NULL_VALUES: Fl  } = O().codes;
    function Ul(e, t, n) {
        let r;
        if (typeof t == "string" || t instanceof $l) return new e({
            objectMode: !0,
            ...n,
            read () {
                this.push(t), this.push(null);
            }
        });
        let i;
        if (t && t[Xn]) i = !0, r = t[Xn]();
        else if (t && t[Jn]) i = !1, r = t[Jn]();
        else throw new vl("iterable", [
            "Iterable"
        ], t);
        let o = new e({
            objectMode: !0,
            highWaterMark: 1,
            ...n
        }), l = !1;
        o._read = function() {
            l || (l = !0, f());
        }, o._destroy = function(a, c) {
            jl(u(a), ()=>zn.nextTick(c, a), (s)=>zn.nextTick(c, s || a));
        };
        async function u(a) {
            let c = a != null, s = typeof r.throw == "function";
            if (c && s) {
                let { value: b , done: d  } = await r.throw(a);
                if (await b, d) return;
            }
            if (typeof r.return == "function") {
                let { value: b  } = await r.return();
                await b;
            }
        }
        async function f() {
            for(;;){
                try {
                    let { value: a , done: c  } = i ? await r.next() : r.next();
                    if (c) o.push(null);
                    else {
                        let s = a && typeof a.then == "function" ? await a : a;
                        if (s === null) throw l = !1, new Fl;
                        if (o.push(s)) continue;
                        l = !1;
                    }
                } catch (a) {
                    o.destroy(a);
                }
                break;
            }
        }
        return o;
    }
    Qn.exports = Ul;
});
var we = g((au, dr)=>{
    var W = __process$, { ArrayPrototypeIndexOf: Bl , NumberIsInteger: Gl , NumberIsNaN: Hl , NumberParseInt: Vl , ObjectDefineProperties: tr , ObjectKeys: Yl , ObjectSetPrototypeOf: nr , Promise: Kl , SafeSet: zl , SymbolAsyncIterator: Xl , Symbol: Jl  } = m();
    dr.exports = w;
    w.ReadableState = yt;
    var { EventEmitter: Ql  } = EventEmitter, { Stream: z , prependListener: Zl  } = Le(), { Buffer: ht  } = __default6, { addAbortSignal: ea  } = ke(), ta = Y(), y = j().debuglog("stream", (e)=>{
        y = e;
    }), na = Vn(), ue = Z(), { getHighWaterMark: ra , getDefaultHighWaterMark: ia  } = Ce(), { aggregateTwoErrors: Zn , codes: { ERR_INVALID_ARG_TYPE: oa , ERR_METHOD_NOT_IMPLEMENTED: la , ERR_OUT_OF_RANGE: aa , ERR_STREAM_PUSH_AFTER_EOF: fa , ERR_STREAM_UNSHIFT_AFTER_END_EVENT: ua  }  } = O(), { validateObject: sa  } = _e(), ee = Jl("kPaused"), { StringDecoder: rr  } = __default8, da = ct();
    nr(w.prototype, z.prototype);
    nr(w, z);
    var bt = ()=>{}, { errorOrDestroy: fe  } = ue;
    function yt(e, t, n) {
        typeof n != "boolean" && (n = t instanceof v()), this.objectMode = !!(e && e.objectMode), n && (this.objectMode = this.objectMode || !!(e && e.readableObjectMode)), this.highWaterMark = e ? ra(this, e, "readableHighWaterMark", n) : ia(!1), this.buffer = new na, this.length = 0, this.pipes = [], this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.constructed = !0, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this[ee] = null, this.errorEmitted = !1, this.emitClose = !e || e.emitClose !== !1, this.autoDestroy = !e || e.autoDestroy !== !1, this.destroyed = !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this.defaultEncoding = e && e.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = !1, this.readingMore = !1, this.dataEmitted = !1, this.decoder = null, this.encoding = null, e && e.encoding && (this.decoder = new rr(e.encoding), this.encoding = e.encoding);
    }
    function w(e) {
        if (!(this instanceof w)) return new w(e);
        let t = this instanceof v();
        this._readableState = new yt(e, this, t), e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.construct == "function" && (this._construct = e.construct), e.signal && !t && ea(e.signal, this)), z.call(this, e), ue.construct(this, ()=>{
            this._readableState.needReadable && je(this, this._readableState);
        });
    }
    w.prototype.destroy = ue.destroy;
    w.prototype._undestroy = ue.undestroy;
    w.prototype._destroy = function(e, t) {
        t(e);
    };
    w.prototype[Ql.captureRejectionSymbol] = function(e) {
        this.destroy(e);
    };
    w.prototype.push = function(e, t) {
        return ir(this, e, t, !1);
    };
    w.prototype.unshift = function(e, t) {
        return ir(this, e, t, !0);
    };
    function ir(e, t, n, r) {
        y("readableAddChunk", t);
        let i = e._readableState, o;
        if (i.objectMode || (typeof t == "string" ? (n = n || i.defaultEncoding, i.encoding !== n && (r && i.encoding ? t = ht.from(t, n).toString(i.encoding) : (t = ht.from(t, n), n = ""))) : t instanceof ht ? n = "" : z._isUint8Array(t) ? (t = z._uint8ArrayToBuffer(t), n = "") : t != null && (o = new oa("chunk", [
            "string",
            "Buffer",
            "Uint8Array"
        ], t))), o) fe(e, o);
        else if (t === null) i.reading = !1, ba(e, i);
        else if (i.objectMode || t && t.length > 0) if (r) if (i.endEmitted) fe(e, new ua);
        else {
            if (i.destroyed || i.errored) return !1;
            _t(e, i, t, !0);
        }
        else if (i.ended) fe(e, new fa);
        else {
            if (i.destroyed || i.errored) return !1;
            i.reading = !1, i.decoder && !n ? (t = i.decoder.write(t), i.objectMode || t.length !== 0 ? _t(e, i, t, !1) : je(e, i)) : _t(e, i, t, !1);
        }
        else r || (i.reading = !1, je(e, i));
        return !i.ended && (i.length < i.highWaterMark || i.length === 0);
    }
    function _t(e, t, n, r) {
        t.flowing && t.length === 0 && !t.sync && e.listenerCount("data") > 0 ? (t.multiAwaitDrain ? t.awaitDrainWriters.clear() : t.awaitDrainWriters = null, t.dataEmitted = !0, e.emit("data", n)) : (t.length += t.objectMode ? 1 : n.length, r ? t.buffer.unshift(n) : t.buffer.push(n), t.needReadable && $e(e)), je(e, t);
    }
    w.prototype.isPaused = function() {
        let e = this._readableState;
        return e[ee] === !0 || e.flowing === !1;
    };
    w.prototype.setEncoding = function(e) {
        let t = new rr(e);
        this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
        let n = this._readableState.buffer, r = "";
        for (let i of n)r += t.write(i);
        return n.clear(), r !== "" && n.push(r), this._readableState.length = r.length, this;
    };
    var ca = 1073741824;
    function ha(e) {
        if (e > ca) throw new aa("size", "<= 1GiB", e);
        return e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++, e;
    }
    function er(e, t) {
        return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : Hl(e) ? t.flowing && t.length ? t.buffer.first().length : t.length : e <= t.length ? e : t.ended ? t.length : 0;
    }
    w.prototype.read = function(e) {
        y("read", e), e === void 0 ? e = NaN : Gl(e) || (e = Vl(e, 10));
        let t = this._readableState, n = e;
        if (e > t.highWaterMark && (t.highWaterMark = ha(e)), e !== 0 && (t.emittedReadable = !1), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return y("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? pt(this) : $e(this), null;
        if (e = er(e, t), e === 0 && t.ended) return t.length === 0 && pt(this), null;
        let r = t.needReadable;
        if (y("need readable", r), (t.length === 0 || t.length - e < t.highWaterMark) && (r = !0, y("length less than watermark", r)), t.ended || t.reading || t.destroyed || t.errored || !t.constructed) r = !1, y("reading, ended or constructing", r);
        else if (r) {
            y("do read"), t.reading = !0, t.sync = !0, t.length === 0 && (t.needReadable = !0);
            try {
                this._read(t.highWaterMark);
            } catch (o) {
                fe(this, o);
            }
            t.sync = !1, t.reading || (e = er(n, t));
        }
        let i;
        return e > 0 ? i = ur(e, t) : i = null, i === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.multiAwaitDrain ? t.awaitDrainWriters.clear() : t.awaitDrainWriters = null), t.length === 0 && (t.ended || (t.needReadable = !0), n !== e && t.ended && pt(this)), i !== null && !t.errorEmitted && !t.closeEmitted && (t.dataEmitted = !0, this.emit("data", i)), i;
    };
    function ba(e, t) {
        if (y("onEofChunk"), !t.ended) {
            if (t.decoder) {
                let n = t.decoder.end();
                n && n.length && (t.buffer.push(n), t.length += t.objectMode ? 1 : n.length);
            }
            t.ended = !0, t.sync ? $e(e) : (t.needReadable = !1, t.emittedReadable = !0, or(e));
        }
    }
    function $e(e) {
        let t = e._readableState;
        y("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (y("emitReadable", t.flowing), t.emittedReadable = !0, W.nextTick(or, e));
    }
    function or(e) {
        let t = e._readableState;
        y("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && !t.errored && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, ar(e);
    }
    function je(e, t) {
        !t.readingMore && t.constructed && (t.readingMore = !0, W.nextTick(_a, e, t));
    }
    function _a(e, t) {
        for(; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0);){
            let n = t.length;
            if (y("maybeReadMore read 0"), e.read(0), n === t.length) break;
        }
        t.readingMore = !1;
    }
    w.prototype._read = function(e) {
        throw new la("_read()");
    };
    w.prototype.pipe = function(e, t) {
        let n = this, r = this._readableState;
        r.pipes.length === 1 && (r.multiAwaitDrain || (r.multiAwaitDrain = !0, r.awaitDrainWriters = new zl(r.awaitDrainWriters ? [
            r.awaitDrainWriters
        ] : []))), r.pipes.push(e), y("pipe count=%d opts=%j", r.pipes.length, t);
        let o = (!t || t.end !== !1) && e !== W.stdout && e !== W.stderr ? u : L;
        r.endEmitted ? W.nextTick(o) : n.once("end", o), e.on("unpipe", l);
        function l(_, p) {
            y("onunpipe"), _ === n && p && p.hasUnpiped === !1 && (p.hasUnpiped = !0, c());
        }
        function u() {
            y("onend"), e.end();
        }
        let f, a = !1;
        function c() {
            y("cleanup"), e.removeListener("close", h), e.removeListener("finish", D), f && e.removeListener("drain", f), e.removeListener("error", d), e.removeListener("unpipe", l), n.removeListener("end", u), n.removeListener("end", L), n.removeListener("data", b), a = !0, f && r.awaitDrainWriters && (!e._writableState || e._writableState.needDrain) && f();
        }
        function s() {
            a || (r.pipes.length === 1 && r.pipes[0] === e ? (y("false write response, pause", 0), r.awaitDrainWriters = e, r.multiAwaitDrain = !1) : r.pipes.length > 1 && r.pipes.includes(e) && (y("false write response, pause", r.awaitDrainWriters.size), r.awaitDrainWriters.add(e)), n.pause()), f || (f = pa(n, e), e.on("drain", f));
        }
        n.on("data", b);
        function b(_) {
            y("ondata");
            let p = e.write(_);
            y("dest.write", p), p === !1 && s();
        }
        function d(_) {
            if (y("onerror", _), L(), e.removeListener("error", d), e.listenerCount("error") === 0) {
                let p = e._writableState || e._readableState;
                p && !p.errorEmitted ? fe(e, _) : e.emit("error", _);
            }
        }
        Zl(e, "error", d);
        function h() {
            e.removeListener("finish", D), L();
        }
        e.once("close", h);
        function D() {
            y("onfinish"), e.removeListener("close", h), L();
        }
        e.once("finish", D);
        function L() {
            y("unpipe"), n.unpipe(e);
        }
        return e.emit("pipe", n), e.writableNeedDrain === !0 ? r.flowing && s() : r.flowing || (y("pipe resume"), n.resume()), e;
    };
    function pa(e, t) {
        return function() {
            let r = e._readableState;
            r.awaitDrainWriters === t ? (y("pipeOnDrain", 1), r.awaitDrainWriters = null) : r.multiAwaitDrain && (y("pipeOnDrain", r.awaitDrainWriters.size), r.awaitDrainWriters.delete(t)), (!r.awaitDrainWriters || r.awaitDrainWriters.size === 0) && e.listenerCount("data") && e.resume();
        };
    }
    w.prototype.unpipe = function(e) {
        let t = this._readableState, n = {
            hasUnpiped: !1
        };
        if (t.pipes.length === 0) return this;
        if (!e) {
            let i = t.pipes;
            t.pipes = [], this.pause();
            for(let o = 0; o < i.length; o++)i[o].emit("unpipe", this, {
                hasUnpiped: !1
            });
            return this;
        }
        let r = Bl(t.pipes, e);
        return r === -1 ? this : (t.pipes.splice(r, 1), t.pipes.length === 0 && this.pause(), e.emit("unpipe", this, n), this);
    };
    w.prototype.on = function(e, t) {
        let n = z.prototype.on.call(this, e, t), r = this._readableState;
        return e === "data" ? (r.readableListening = this.listenerCount("readable") > 0, r.flowing !== !1 && this.resume()) : e === "readable" && !r.endEmitted && !r.readableListening && (r.readableListening = r.needReadable = !0, r.flowing = !1, r.emittedReadable = !1, y("on readable", r.length, r.reading), r.length ? $e(this) : r.reading || W.nextTick(wa, this)), n;
    };
    w.prototype.addListener = w.prototype.on;
    w.prototype.removeListener = function(e, t) {
        let n = z.prototype.removeListener.call(this, e, t);
        return e === "readable" && W.nextTick(lr, this), n;
    };
    w.prototype.off = w.prototype.removeListener;
    w.prototype.removeAllListeners = function(e) {
        let t = z.prototype.removeAllListeners.apply(this, arguments);
        return (e === "readable" || e === void 0) && W.nextTick(lr, this), t;
    };
    function lr(e) {
        let t = e._readableState;
        t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && t[ee] === !1 ? t.flowing = !0 : e.listenerCount("data") > 0 ? e.resume() : t.readableListening || (t.flowing = null);
    }
    function wa(e) {
        y("readable nexttick read 0"), e.read(0);
    }
    w.prototype.resume = function() {
        let e = this._readableState;
        return e.flowing || (y("resume"), e.flowing = !e.readableListening, ya(this, e)), e[ee] = !1, this;
    };
    function ya(e, t) {
        t.resumeScheduled || (t.resumeScheduled = !0, W.nextTick(ga, e, t));
    }
    function ga(e, t) {
        y("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), ar(e), t.flowing && !t.reading && e.read(0);
    }
    w.prototype.pause = function() {
        return y("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (y("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState[ee] = !0, this;
    };
    function ar(e) {
        let t = e._readableState;
        for(y("flow", t.flowing); t.flowing && e.read() !== null;);
    }
    w.prototype.wrap = function(e) {
        let t = !1;
        e.on("data", (r)=>{
            !this.push(r) && e.pause && (t = !0, e.pause());
        }), e.on("end", ()=>{
            this.push(null);
        }), e.on("error", (r)=>{
            fe(this, r);
        }), e.on("close", ()=>{
            this.destroy();
        }), e.on("destroy", ()=>{
            this.destroy();
        }), this._read = ()=>{
            t && e.resume && (t = !1, e.resume());
        };
        let n = Yl(e);
        for(let r = 1; r < n.length; r++){
            let i = n[r];
            this[i] === void 0 && typeof e[i] == "function" && (this[i] = e[i].bind(e));
        }
        return this;
    };
    w.prototype[Xl] = function() {
        return fr(this);
    };
    w.prototype.iterator = function(e) {
        return e !== void 0 && sa(e, "options"), fr(this, e);
    };
    function fr(e, t) {
        typeof e.read != "function" && (e = w.wrap(e, {
            objectMode: !0
        }));
        let n = Sa(e, t);
        return n.stream = e, n;
    }
    async function* Sa(e, t) {
        let n = bt;
        function r(l) {
            this === e ? (n(), n = bt) : n = l;
        }
        e.on("readable", r);
        let i, o = ta(e, {
            writable: !1
        }, (l)=>{
            i = l ? Zn(i, l) : null, n(), n = bt;
        });
        try {
            for(;;){
                let l = e.destroyed ? null : e.read();
                if (l !== null) yield l;
                else {
                    if (i) throw i;
                    if (i === null) return;
                    await new Kl(r);
                }
            }
        } catch (l) {
            throw i = Zn(i, l), i;
        } finally{
            (i || t?.destroyOnReturn !== !1) && (i === void 0 || e._readableState.autoDestroy) ? ue.destroyer(e, null) : (e.off("readable", r), o());
        }
    }
    tr(w.prototype, {
        readable: {
            __proto__: null,
            get () {
                let e = this._readableState;
                return !!e && e.readable !== !1 && !e.destroyed && !e.errorEmitted && !e.endEmitted;
            },
            set (e) {
                this._readableState && (this._readableState.readable = !!e);
            }
        },
        readableDidRead: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return this._readableState.dataEmitted;
            }
        },
        readableAborted: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
            }
        },
        readableHighWaterMark: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return this._readableState.highWaterMark;
            }
        },
        readableBuffer: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return this._readableState && this._readableState.buffer;
            }
        },
        readableFlowing: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return this._readableState.flowing;
            },
            set: function(e) {
                this._readableState && (this._readableState.flowing = e);
            }
        },
        readableLength: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._readableState.length;
            }
        },
        readableObjectMode: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._readableState ? this._readableState.objectMode : !1;
            }
        },
        readableEncoding: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._readableState ? this._readableState.encoding : null;
            }
        },
        errored: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._readableState ? this._readableState.errored : null;
            }
        },
        closed: {
            __proto__: null,
            get () {
                return this._readableState ? this._readableState.closed : !1;
            }
        },
        destroyed: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._readableState ? this._readableState.destroyed : !1;
            },
            set (e) {
                !this._readableState || (this._readableState.destroyed = e);
            }
        },
        readableEnded: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._readableState ? this._readableState.endEmitted : !1;
            }
        }
    });
    tr(yt.prototype, {
        pipesCount: {
            __proto__: null,
            get () {
                return this.pipes.length;
            }
        },
        paused: {
            __proto__: null,
            get () {
                return this[ee] !== !1;
            },
            set (e) {
                this[ee] = !!e;
            }
        }
    });
    w._fromList = ur;
    function ur(e, t) {
        if (t.length === 0) return null;
        let n;
        return t.objectMode ? n = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? n = t.buffer.join("") : t.buffer.length === 1 ? n = t.buffer.first() : n = t.buffer.concat(t.length), t.buffer.clear()) : n = t.buffer.consume(e, t.decoder), n;
    }
    function pt(e) {
        let t = e._readableState;
        y("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, W.nextTick(Ea, t, e));
    }
    function Ea(e, t) {
        if (y("endReadableNT", e.endEmitted, e.length), !e.errored && !e.closeEmitted && !e.endEmitted && e.length === 0) {
            if (e.endEmitted = !0, t.emit("end"), t.writable && t.allowHalfOpen === !1) W.nextTick(Ra, t);
            else if (e.autoDestroy) {
                let n = t._writableState;
                (!n || n.autoDestroy && (n.finished || n.writable === !1)) && t.destroy();
            }
        }
    }
    function Ra(e) {
        e.writable && !e.writableEnded && !e.destroyed && e.end();
    }
    w.from = function(e, t) {
        return da(w, e, t);
    };
    var wt;
    function sr() {
        return wt === void 0 && (wt = {}), wt;
    }
    w.fromWeb = function(e, t) {
        return sr().newStreamReadableFromReadableStream(e, t);
    };
    w.toWeb = function(e, t) {
        return sr().newReadableStreamFromStreamReadable(e, t);
    };
    w.wrap = function(e, t) {
        var n, r;
        return new w({
            objectMode: (n = (r = e.readableObjectMode) !== null && r !== void 0 ? r : e.objectMode) !== null && n !== void 0 ? n : !0,
            ...t,
            destroy (i, o) {
                ue.destroyer(e, i), o(i);
            }
        }).wrap(e);
    };
});
var Tt = g((fu, Ar)=>{
    var te = __process$, { ArrayPrototypeSlice: br , Error: Aa , FunctionPrototypeSymbolHasInstance: _r , ObjectDefineProperty: pr , ObjectDefineProperties: ma , ObjectSetPrototypeOf: wr , StringPrototypeToLowerCase: Ta , Symbol: Ia , SymbolHasInstance: Ma  } = m();
    Ar.exports = S;
    S.WritableState = Se;
    var { EventEmitter: Na  } = EventEmitter, ye = Le().Stream, { Buffer: ve  } = __default6, Be = Z(), { addAbortSignal: Da  } = ke(), { getHighWaterMark: Oa , getDefaultHighWaterMark: qa  } = Ce(), { ERR_INVALID_ARG_TYPE: xa , ERR_METHOD_NOT_IMPLEMENTED: La , ERR_MULTIPLE_CALLBACK: yr , ERR_STREAM_CANNOT_PIPE: Pa , ERR_STREAM_DESTROYED: ge , ERR_STREAM_ALREADY_FINISHED: ka , ERR_STREAM_NULL_VALUES: Wa , ERR_STREAM_WRITE_AFTER_END: Ca , ERR_UNKNOWN_ENCODING: gr  } = O().codes, { errorOrDestroy: se  } = Be;
    wr(S.prototype, ye.prototype);
    wr(S, ye);
    function Et() {}
    var de = Ia("kOnFinished");
    function Se(e, t, n) {
        typeof n != "boolean" && (n = t instanceof v()), this.objectMode = !!(e && e.objectMode), n && (this.objectMode = this.objectMode || !!(e && e.writableObjectMode)), this.highWaterMark = e ? Oa(this, e, "writableHighWaterMark", n) : qa(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        let r = !!(e && e.decodeStrings === !1);
        this.decodeStrings = !r, this.defaultEncoding = e && e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = $a.bind(void 0, t), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, Ue(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !e || e.emitClose !== !1, this.autoDestroy = !e || e.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[de] = [];
    }
    function Ue(e) {
        e.buffered = [], e.bufferedIndex = 0, e.allBuffers = !0, e.allNoop = !0;
    }
    Se.prototype.getBuffer = function() {
        return br(this.buffered, this.bufferedIndex);
    };
    pr(Se.prototype, "bufferedRequestCount", {
        __proto__: null,
        get () {
            return this.buffered.length - this.bufferedIndex;
        }
    });
    function S(e) {
        let t = this instanceof v();
        if (!t && !_r(S, this)) return new S(e);
        this._writableState = new Se(e, this, t), e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final), typeof e.construct == "function" && (this._construct = e.construct), e.signal && Da(e.signal, this)), ye.call(this, e), Be.construct(this, ()=>{
            let n = this._writableState;
            n.writing || At(this, n), mt(this, n);
        });
    }
    pr(S, Ma, {
        __proto__: null,
        value: function(e) {
            return _r(this, e) ? !0 : this !== S ? !1 : e && e._writableState instanceof Se;
        }
    });
    S.prototype.pipe = function() {
        se(this, new Pa);
    };
    function Sr(e, t, n, r) {
        let i = e._writableState;
        if (typeof n == "function") r = n, n = i.defaultEncoding;
        else {
            if (!n) n = i.defaultEncoding;
            else if (n !== "buffer" && !ve.isEncoding(n)) throw new gr(n);
            typeof r != "function" && (r = Et);
        }
        if (t === null) throw new Wa;
        if (!i.objectMode) if (typeof t == "string") i.decodeStrings !== !1 && (t = ve.from(t, n), n = "buffer");
        else if (t instanceof ve) n = "buffer";
        else if (ye._isUint8Array(t)) t = ye._uint8ArrayToBuffer(t), n = "buffer";
        else throw new xa("chunk", [
            "string",
            "Buffer",
            "Uint8Array"
        ], t);
        let o;
        return i.ending ? o = new Ca : i.destroyed && (o = new ge("write")), o ? (te.nextTick(r, o), se(e, o, !0), o) : (i.pendingcb++, ja(e, i, t, n, r));
    }
    S.prototype.write = function(e, t, n) {
        return Sr(this, e, t, n) === !0;
    };
    S.prototype.cork = function() {
        this._writableState.corked++;
    };
    S.prototype.uncork = function() {
        let e = this._writableState;
        e.corked && (e.corked--, e.writing || At(this, e));
    };
    S.prototype.setDefaultEncoding = function(t) {
        if (typeof t == "string" && (t = Ta(t)), !ve.isEncoding(t)) throw new gr(t);
        return this._writableState.defaultEncoding = t, this;
    };
    function ja(e, t, n, r, i) {
        let o = t.objectMode ? 1 : n.length;
        t.length += o;
        let l = t.length < t.highWaterMark;
        return l || (t.needDrain = !0), t.writing || t.corked || t.errored || !t.constructed ? (t.buffered.push({
            chunk: n,
            encoding: r,
            callback: i
        }), t.allBuffers && r !== "buffer" && (t.allBuffers = !1), t.allNoop && i !== Et && (t.allNoop = !1)) : (t.writelen = o, t.writecb = i, t.writing = !0, t.sync = !0, e._write(n, r, t.onwrite), t.sync = !1), l && !t.errored && !t.destroyed;
    }
    function cr(e, t, n, r, i, o, l) {
        t.writelen = r, t.writecb = l, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new ge("write")) : n ? e._writev(i, t.onwrite) : e._write(i, o, t.onwrite), t.sync = !1;
    }
    function hr(e, t, n, r) {
        --t.pendingcb, r(n), Rt(t), se(e, n);
    }
    function $a(e, t) {
        let n = e._writableState, r = n.sync, i = n.writecb;
        if (typeof i != "function") {
            se(e, new yr);
            return;
        }
        n.writing = !1, n.writecb = null, n.length -= n.writelen, n.writelen = 0, t ? (t.stack, n.errored || (n.errored = t), e._readableState && !e._readableState.errored && (e._readableState.errored = t), r ? te.nextTick(hr, e, n, t, i) : hr(e, n, t, i)) : (n.buffered.length > n.bufferedIndex && At(e, n), r ? n.afterWriteTickInfo !== null && n.afterWriteTickInfo.cb === i ? n.afterWriteTickInfo.count++ : (n.afterWriteTickInfo = {
            count: 1,
            cb: i,
            stream: e,
            state: n
        }, te.nextTick(va, n.afterWriteTickInfo)) : Er(e, n, 1, i));
    }
    function va({ stream: e , state: t , count: n , cb: r  }) {
        return t.afterWriteTickInfo = null, Er(e, t, n, r);
    }
    function Er(e, t, n, r) {
        for(!t.ending && !e.destroyed && t.length === 0 && t.needDrain && (t.needDrain = !1, e.emit("drain")); n-- > 0;)t.pendingcb--, r();
        t.destroyed && Rt(t), mt(e, t);
    }
    function Rt(e) {
        if (e.writing) return;
        for(let i = e.bufferedIndex; i < e.buffered.length; ++i){
            var t;
            let { chunk: o , callback: l  } = e.buffered[i], u = e.objectMode ? 1 : o.length;
            e.length -= u, l((t = e.errored) !== null && t !== void 0 ? t : new ge("write"));
        }
        let n = e[de].splice(0);
        for(let i = 0; i < n.length; i++){
            var r;
            n[i]((r = e.errored) !== null && r !== void 0 ? r : new ge("end"));
        }
        Ue(e);
    }
    function At(e, t) {
        if (t.corked || t.bufferProcessing || t.destroyed || !t.constructed) return;
        let { buffered: n , bufferedIndex: r , objectMode: i  } = t, o = n.length - r;
        if (!o) return;
        let l = r;
        if (t.bufferProcessing = !0, o > 1 && e._writev) {
            t.pendingcb -= o - 1;
            let u = t.allNoop ? Et : (a)=>{
                for(let c = l; c < n.length; ++c)n[c].callback(a);
            }, f = t.allNoop && l === 0 ? n : br(n, l);
            f.allBuffers = t.allBuffers, cr(e, t, !0, t.length, f, "", u), Ue(t);
        } else {
            do {
                let { chunk: u , encoding: f , callback: a  } = n[l];
                n[l++] = null;
                let c = i ? 1 : u.length;
                cr(e, t, !1, c, u, f, a);
            }while (l < n.length && !t.writing)
            l === n.length ? Ue(t) : l > 256 ? (n.splice(0, l), t.bufferedIndex = 0) : t.bufferedIndex = l;
        }
        t.bufferProcessing = !1;
    }
    S.prototype._write = function(e, t, n) {
        if (this._writev) this._writev([
            {
                chunk: e,
                encoding: t
            }
        ], n);
        else throw new La("_write()");
    };
    S.prototype._writev = null;
    S.prototype.end = function(e, t, n) {
        let r = this._writableState;
        typeof e == "function" ? (n = e, e = null, t = null) : typeof t == "function" && (n = t, t = null);
        let i;
        if (e != null) {
            let o = Sr(this, e, t);
            o instanceof Aa && (i = o);
        }
        return r.corked && (r.corked = 1, this.uncork()), i || (!r.errored && !r.ending ? (r.ending = !0, mt(this, r, !0), r.ended = !0) : r.finished ? i = new ka("end") : r.destroyed && (i = new ge("end"))), typeof n == "function" && (i || r.finished ? te.nextTick(n, i) : r[de].push(n)), this;
    };
    function Fe(e) {
        return e.ending && !e.destroyed && e.constructed && e.length === 0 && !e.errored && e.buffered.length === 0 && !e.finished && !e.writing && !e.errorEmitted && !e.closeEmitted;
    }
    function Fa(e, t) {
        let n = !1;
        function r(i) {
            if (n) {
                se(e, i ?? yr());
                return;
            }
            if (n = !0, t.pendingcb--, i) {
                let o = t[de].splice(0);
                for(let l = 0; l < o.length; l++)o[l](i);
                se(e, i, t.sync);
            } else Fe(t) && (t.prefinished = !0, e.emit("prefinish"), t.pendingcb++, te.nextTick(St, e, t));
        }
        t.sync = !0, t.pendingcb++;
        try {
            e._final(r);
        } catch (i) {
            r(i);
        }
        t.sync = !1;
    }
    function Ua(e, t) {
        !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.finalCalled = !0, Fa(e, t)) : (t.prefinished = !0, e.emit("prefinish")));
    }
    function mt(e, t, n) {
        Fe(t) && (Ua(e, t), t.pendingcb === 0 && (n ? (t.pendingcb++, te.nextTick((r, i)=>{
            Fe(i) ? St(r, i) : i.pendingcb--;
        }, e, t)) : Fe(t) && (t.pendingcb++, St(e, t))));
    }
    function St(e, t) {
        t.pendingcb--, t.finished = !0;
        let n = t[de].splice(0);
        for(let r = 0; r < n.length; r++)n[r]();
        if (e.emit("finish"), t.autoDestroy) {
            let r = e._readableState;
            (!r || r.autoDestroy && (r.endEmitted || r.readable === !1)) && e.destroy();
        }
    }
    ma(S.prototype, {
        closed: {
            __proto__: null,
            get () {
                return this._writableState ? this._writableState.closed : !1;
            }
        },
        destroyed: {
            __proto__: null,
            get () {
                return this._writableState ? this._writableState.destroyed : !1;
            },
            set (e) {
                this._writableState && (this._writableState.destroyed = e);
            }
        },
        writable: {
            __proto__: null,
            get () {
                let e = this._writableState;
                return !!e && e.writable !== !1 && !e.destroyed && !e.errored && !e.ending && !e.ended;
            },
            set (e) {
                this._writableState && (this._writableState.writable = !!e);
            }
        },
        writableFinished: {
            __proto__: null,
            get () {
                return this._writableState ? this._writableState.finished : !1;
            }
        },
        writableObjectMode: {
            __proto__: null,
            get () {
                return this._writableState ? this._writableState.objectMode : !1;
            }
        },
        writableBuffer: {
            __proto__: null,
            get () {
                return this._writableState && this._writableState.getBuffer();
            }
        },
        writableEnded: {
            __proto__: null,
            get () {
                return this._writableState ? this._writableState.ending : !1;
            }
        },
        writableNeedDrain: {
            __proto__: null,
            get () {
                let e = this._writableState;
                return e ? !e.destroyed && !e.ending && e.needDrain : !1;
            }
        },
        writableHighWaterMark: {
            __proto__: null,
            get () {
                return this._writableState && this._writableState.highWaterMark;
            }
        },
        writableCorked: {
            __proto__: null,
            get () {
                return this._writableState ? this._writableState.corked : 0;
            }
        },
        writableLength: {
            __proto__: null,
            get () {
                return this._writableState && this._writableState.length;
            }
        },
        errored: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._writableState ? this._writableState.errored : null;
            }
        },
        writableAborted: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
            }
        }
    });
    var Ba = Be.destroy;
    S.prototype.destroy = function(e, t) {
        let n = this._writableState;
        return !n.destroyed && (n.bufferedIndex < n.buffered.length || n[de].length) && te.nextTick(Rt, n), Ba.call(this, e, t), this;
    };
    S.prototype._undestroy = Be.undestroy;
    S.prototype._destroy = function(e, t) {
        t(e);
    };
    S.prototype[Na.captureRejectionSymbol] = function(e) {
        this.destroy(e);
    };
    var gt;
    function Rr() {
        return gt === void 0 && (gt = {}), gt;
    }
    S.fromWeb = function(e, t) {
        return Rr().newStreamWritableFromWritableStream(e, t);
    };
    S.toWeb = function(e) {
        return Rr().newWritableStreamFromStreamWritable(e);
    };
});
var kr = g((uu, Pr)=>{
    var It = __process$, Ga = __default6, { isReadable: Ha , isWritable: Va , isIterable: mr , isNodeStream: Ya , isReadableNodeStream: Tr , isWritableNodeStream: Ir , isDuplexNodeStream: Ka  } = V(), Mr = Y(), { AbortError: Lr , codes: { ERR_INVALID_ARG_TYPE: za , ERR_INVALID_RETURN_VALUE: Nr  }  } = O(), { destroyer: ce  } = Z(), Xa = v(), Ja = we(), { createDeferredPromise: Dr  } = j(), Or = ct(), qr = globalThis.Blob || Ga.Blob, Qa = typeof qr < "u" ? function(t) {
        return t instanceof qr;
    } : function(t) {
        return !1;
    }, Za = globalThis.AbortController, { FunctionPrototypeCall: xr  } = m(), ne = class extends Xa {
        constructor(t){
            super(t), t?.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), t?.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0);
        }
    };
    Pr.exports = function e(t, n) {
        if (Ka(t)) return t;
        if (Tr(t)) return Ge({
            readable: t
        });
        if (Ir(t)) return Ge({
            writable: t
        });
        if (Ya(t)) return Ge({
            writable: !1,
            readable: !1
        });
        if (typeof t == "function") {
            let { value: i , write: o , final: l , destroy: u  } = ef(t);
            if (mr(i)) return Or(ne, i, {
                objectMode: !0,
                write: o,
                final: l,
                destroy: u
            });
            let f = i?.then;
            if (typeof f == "function") {
                let a, c = xr(f, i, (s)=>{
                    if (s != null) throw new Nr("nully", "body", s);
                }, (s)=>{
                    ce(a, s);
                });
                return a = new ne({
                    objectMode: !0,
                    readable: !1,
                    write: o,
                    final (s) {
                        l(async ()=>{
                            try {
                                await c, It.nextTick(s, null);
                            } catch (b) {
                                It.nextTick(s, b);
                            }
                        });
                    },
                    destroy: u
                });
            }
            throw new Nr("Iterable, AsyncIterable or AsyncFunction", n, i);
        }
        if (Qa(t)) return e(t.arrayBuffer());
        if (mr(t)) return Or(ne, t, {
            objectMode: !0,
            writable: !1
        });
        if (typeof t?.writable == "object" || typeof t?.readable == "object") {
            let i = t != null && t.readable ? Tr(t?.readable) ? t?.readable : e(t.readable) : void 0, o = t != null && t.writable ? Ir(t?.writable) ? t?.writable : e(t.writable) : void 0;
            return Ge({
                readable: i,
                writable: o
            });
        }
        let r = t?.then;
        if (typeof r == "function") {
            let i;
            return xr(r, t, (o)=>{
                o != null && i.push(o), i.push(null);
            }, (o)=>{
                ce(i, o);
            }), i = new ne({
                objectMode: !0,
                writable: !1,
                read () {}
            });
        }
        throw new za(n, [
            "Blob",
            "ReadableStream",
            "WritableStream",
            "Stream",
            "Iterable",
            "AsyncIterable",
            "Function",
            "{ readable, writable } pair",
            "Promise"
        ], t);
    };
    function ef(e) {
        let { promise: t , resolve: n  } = Dr(), r = new Za, i = r.signal;
        return {
            value: e(async function*() {
                for(;;){
                    let l = t;
                    t = null;
                    let { chunk: u , done: f , cb: a  } = await l;
                    if (It.nextTick(a), f) return;
                    if (i.aborted) throw new Lr(void 0, {
                        cause: i.reason
                    });
                    ({ promise: t , resolve: n  } = Dr()), yield u;
                }
            }(), {
                signal: i
            }),
            write (l, u, f) {
                let a = n;
                n = null, a({
                    chunk: l,
                    done: !1,
                    cb: f
                });
            },
            final (l) {
                let u = n;
                n = null, u({
                    done: !0,
                    cb: l
                });
            },
            destroy (l, u) {
                r.abort(), u(l);
            }
        };
    }
    function Ge(e) {
        let t = e.readable && typeof e.readable.read != "function" ? Ja.wrap(e.readable) : e.readable, n = e.writable, r = !!Ha(t), i = !!Va(n), o, l, u, f, a;
        function c(s) {
            let b = f;
            f = null, b ? b(s) : s ? a.destroy(s) : !r && !i && a.destroy();
        }
        return a = new ne({
            readableObjectMode: !!(t != null && t.readableObjectMode),
            writableObjectMode: !!(n != null && n.writableObjectMode),
            readable: r,
            writable: i
        }), i && (Mr(n, (s)=>{
            i = !1, s && ce(t, s), c(s);
        }), a._write = function(s, b, d) {
            n.write(s, b) ? d() : o = d;
        }, a._final = function(s) {
            n.end(), l = s;
        }, n.on("drain", function() {
            if (o) {
                let s = o;
                o = null, s();
            }
        }), n.on("finish", function() {
            if (l) {
                let s = l;
                l = null, s();
            }
        })), r && (Mr(t, (s)=>{
            r = !1, s && ce(t, s), c(s);
        }), t.on("readable", function() {
            if (u) {
                let s = u;
                u = null, s();
            }
        }), t.on("end", function() {
            a.push(null);
        }), a._read = function() {
            for(;;){
                let s = t.read();
                if (s === null) {
                    u = a._read;
                    return;
                }
                if (!a.push(s)) return;
            }
        }), a._destroy = function(s, b) {
            !s && f !== null && (s = new Lr), u = null, o = null, l = null, f === null ? b(s) : (f = b, ce(n, s), ce(t, s));
        }, a;
    }
});
var v = g((su, jr)=>{
    "use strict";
    var { ObjectDefineProperties: tf , ObjectGetOwnPropertyDescriptor: B , ObjectKeys: nf , ObjectSetPrototypeOf: Wr  } = m();
    jr.exports = C;
    var Dt = we(), x = Tt();
    Wr(C.prototype, Dt.prototype);
    Wr(C, Dt);
    {
        let e = nf(x.prototype);
        for(let t = 0; t < e.length; t++){
            let n = e[t];
            C.prototype[n] || (C.prototype[n] = x.prototype[n]);
        }
    }
    function C(e) {
        if (!(this instanceof C)) return new C(e);
        Dt.call(this, e), x.call(this, e), e ? (this.allowHalfOpen = e.allowHalfOpen !== !1, e.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), e.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0)) : this.allowHalfOpen = !0;
    }
    tf(C.prototype, {
        writable: {
            __proto__: null,
            ...B(x.prototype, "writable")
        },
        writableHighWaterMark: {
            __proto__: null,
            ...B(x.prototype, "writableHighWaterMark")
        },
        writableObjectMode: {
            __proto__: null,
            ...B(x.prototype, "writableObjectMode")
        },
        writableBuffer: {
            __proto__: null,
            ...B(x.prototype, "writableBuffer")
        },
        writableLength: {
            __proto__: null,
            ...B(x.prototype, "writableLength")
        },
        writableFinished: {
            __proto__: null,
            ...B(x.prototype, "writableFinished")
        },
        writableCorked: {
            __proto__: null,
            ...B(x.prototype, "writableCorked")
        },
        writableEnded: {
            __proto__: null,
            ...B(x.prototype, "writableEnded")
        },
        writableNeedDrain: {
            __proto__: null,
            ...B(x.prototype, "writableNeedDrain")
        },
        destroyed: {
            __proto__: null,
            get () {
                return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
            },
            set (e) {
                this._readableState && this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e);
            }
        }
    });
    var Mt;
    function Cr() {
        return Mt === void 0 && (Mt = {}), Mt;
    }
    C.fromWeb = function(e, t) {
        return Cr().newStreamDuplexFromReadableWritablePair(e, t);
    };
    C.toWeb = function(e) {
        return Cr().newReadableWritablePairFromDuplex(e);
    };
    var Nt;
    C.from = function(e) {
        return Nt || (Nt = kr()), Nt(e, "body");
    };
});
var xt = g((du, vr)=>{
    "use strict";
    var { ObjectSetPrototypeOf: $r , Symbol: rf  } = m();
    vr.exports = G;
    var { ERR_METHOD_NOT_IMPLEMENTED: of  } = O().codes, qt = v(), { getHighWaterMark: lf  } = Ce();
    $r(G.prototype, qt.prototype);
    $r(G, qt);
    var Ee = rf("kCallback");
    function G(e) {
        if (!(this instanceof G)) return new G(e);
        let t = e ? lf(this, e, "readableHighWaterMark", !0) : null;
        t === 0 && (e = {
            ...e,
            highWaterMark: null,
            readableHighWaterMark: t,
            writableHighWaterMark: e.writableHighWaterMark || 0
        }), qt.call(this, e), this._readableState.sync = !1, this[Ee] = null, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", af);
    }
    function Ot(e) {
        typeof this._flush == "function" && !this.destroyed ? this._flush((t, n)=>{
            if (t) {
                e ? e(t) : this.destroy(t);
                return;
            }
            n != null && this.push(n), this.push(null), e && e();
        }) : (this.push(null), e && e());
    }
    function af() {
        this._final !== Ot && Ot.call(this);
    }
    G.prototype._final = Ot;
    G.prototype._transform = function(e, t, n) {
        throw new of("_transform()");
    };
    G.prototype._write = function(e, t, n) {
        let r = this._readableState, i = this._writableState, o = r.length;
        this._transform(e, t, (l, u)=>{
            if (l) {
                n(l);
                return;
            }
            u != null && this.push(u), i.ended || o === r.length || r.length < r.highWaterMark ? n() : this[Ee] = n;
        });
    };
    G.prototype._read = function() {
        if (this[Ee]) {
            let e = this[Ee];
            this[Ee] = null, e();
        }
    };
});
var Pt = g((cu, Ur)=>{
    "use strict";
    var { ObjectSetPrototypeOf: Fr  } = m();
    Ur.exports = he;
    var Lt = xt();
    Fr(he.prototype, Lt.prototype);
    Fr(he, Lt);
    function he(e) {
        if (!(this instanceof he)) return new he(e);
        Lt.call(this, e);
    }
    he.prototype._transform = function(e, t, n) {
        n(null, e);
    };
});
var Ye = g((hu, zr)=>{
    var He = __process$, { ArrayIsArray: ff , Promise: uf , SymbolAsyncIterator: sf  } = m(), Ve = Y(), { once: df  } = j(), cf = Z(), Br = v(), { aggregateTwoErrors: hf , codes: { ERR_INVALID_ARG_TYPE: Yr , ERR_INVALID_RETURN_VALUE: kt , ERR_MISSING_ARGS: bf , ERR_STREAM_DESTROYED: _f , ERR_STREAM_PREMATURE_CLOSE: pf  } , AbortError: wf  } = O(), { validateFunction: yf , validateAbortSignal: gf  } = _e(), { isIterable: be , isReadable: Wt , isReadableNodeStream: $t , isNodeStream: Gr  } = V(), Sf = globalThis.AbortController, Ct, jt;
    function Hr(e, t, n) {
        let r = !1;
        e.on("close", ()=>{
            r = !0;
        });
        let i = Ve(e, {
            readable: t,
            writable: n
        }, (o)=>{
            r = !o;
        });
        return {
            destroy: (o)=>{
                r || (r = !0, cf.destroyer(e, o || new _f("pipe")));
            },
            cleanup: i
        };
    }
    function Ef(e) {
        return yf(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
    }
    function Rf(e) {
        if (be(e)) return e;
        if ($t(e)) return Af(e);
        throw new Yr("val", [
            "Readable",
            "Iterable",
            "AsyncIterable"
        ], e);
    }
    async function* Af(e) {
        jt || (jt = we()), yield* jt.prototype[sf].call(e);
    }
    async function Vr(e, t, n, { end: r  }) {
        let i, o = null, l = (a)=>{
            if (a && (i = a), o) {
                let c = o;
                o = null, c();
            }
        }, u = ()=>new uf((a, c)=>{
                i ? c(i) : o = ()=>{
                    i ? c(i) : a();
                };
            });
        t.on("drain", l);
        let f = Ve(t, {
            readable: !1
        }, l);
        try {
            t.writableNeedDrain && await u();
            for await (let a of e)t.write(a) || await u();
            r && t.end(), await u(), n();
        } catch (a) {
            n(i !== a ? hf(i, a) : a);
        } finally{
            f(), t.off("drain", l);
        }
    }
    function mf(...e) {
        return Kr(e, df(Ef(e)));
    }
    function Kr(e, t, n) {
        if (e.length === 1 && ff(e[0]) && (e = e[0]), e.length < 2) throw new bf("streams");
        let r = new Sf, i = r.signal, o = n?.signal, l = [];
        gf(o, "options.signal");
        function u() {
            d(new wf);
        }
        o?.addEventListener("abort", u);
        let f, a, c = [], s = 0;
        function b(_) {
            d(_, --s === 0);
        }
        function d(_, p) {
            if (_ && (!f || f.code === "ERR_STREAM_PREMATURE_CLOSE") && (f = _), !(!f && !p)) {
                for(; c.length;)c.shift()(f);
                o?.removeEventListener("abort", u), r.abort(), p && (f || l.forEach((I)=>I()), He.nextTick(t, f, a));
            }
        }
        let h;
        for(let _ = 0; _ < e.length; _++){
            let p = e[_], I = _ < e.length - 1, M = _ > 0, F = I || n?.end !== !1, re = _ === e.length - 1;
            if (Gr(p)) {
                let P = function(U) {
                    U && U.name !== "AbortError" && U.code !== "ERR_STREAM_PREMATURE_CLOSE" && b(U);
                };
                if (F) {
                    let { destroy: U , cleanup: ze  } = Hr(p, I, M);
                    c.push(U), Wt(p) && re && l.push(ze);
                }
                p.on("error", P), Wt(p) && re && l.push(()=>{
                    p.removeListener("error", P);
                });
            }
            if (_ === 0) if (typeof p == "function") {
                if (h = p({
                    signal: i
                }), !be(h)) throw new kt("Iterable, AsyncIterable or Stream", "source", h);
            } else be(p) || $t(p) ? h = p : h = Br.from(p);
            else if (typeof p == "function") if (h = Rf(h), h = p(h, {
                signal: i
            }), I) {
                if (!be(h, !0)) throw new kt("AsyncIterable", `transform[${_ - 1}]`, h);
            } else {
                var D;
                Ct || (Ct = Pt());
                let P = new Ct({
                    objectMode: !0
                }), U = (D = h) === null || D === void 0 ? void 0 : D.then;
                if (typeof U == "function") s++, U.call(h, (ie)=>{
                    a = ie, ie != null && P.write(ie), F && P.end(), He.nextTick(b);
                }, (ie)=>{
                    P.destroy(ie), He.nextTick(b, ie);
                });
                else if (be(h, !0)) s++, Vr(h, P, b, {
                    end: F
                });
                else throw new kt("AsyncIterable or Promise", "destination", h);
                h = P;
                let { destroy: ze , cleanup: _i  } = Hr(h, !1, !0);
                c.push(ze), re && l.push(_i);
            }
            else if (Gr(p)) {
                if ($t(h)) {
                    s += 2;
                    let P = Tf(h, p, b, {
                        end: F
                    });
                    Wt(p) && re && l.push(P);
                } else if (be(h)) s++, Vr(h, p, b, {
                    end: F
                });
                else throw new Yr("val", [
                    "Readable",
                    "Iterable",
                    "AsyncIterable"
                ], h);
                h = p;
            } else h = Br.from(p);
        }
        return (i != null && i.aborted || o != null && o.aborted) && He.nextTick(u), h;
    }
    function Tf(e, t, n, { end: r  }) {
        let i = !1;
        return t.on("close", ()=>{
            i || n(new pf);
        }), e.pipe(t, {
            end: r
        }), r ? e.once("end", ()=>{
            i = !0, t.end();
        }) : n(), Ve(e, {
            readable: !0,
            writable: !1
        }, (o)=>{
            let l = e._readableState;
            o && o.code === "ERR_STREAM_PREMATURE_CLOSE" && l && l.ended && !l.errored && !l.errorEmitted ? e.once("end", n).once("error", n) : n(o);
        }), Ve(t, {
            readable: !1,
            writable: !0
        }, n);
    }
    zr.exports = {
        pipelineImpl: Kr,
        pipeline: mf
    };
});
var ei = g((bu, Zr)=>{
    "use strict";
    var { pipeline: If  } = Ye(), Ke = v(), { destroyer: Mf  } = Z(), { isNodeStream: Nf , isReadable: Xr , isWritable: Jr  } = V(), { AbortError: Df , codes: { ERR_INVALID_ARG_VALUE: Qr , ERR_MISSING_ARGS: Of  }  } = O();
    Zr.exports = function(...t) {
        if (t.length === 0) throw new Of("streams");
        if (t.length === 1) return Ke.from(t[0]);
        let n = [
            ...t
        ];
        if (typeof t[0] == "function" && (t[0] = Ke.from(t[0])), typeof t[t.length - 1] == "function") {
            let d = t.length - 1;
            t[d] = Ke.from(t[d]);
        }
        for(let d = 0; d < t.length; ++d)if (!!Nf(t[d])) {
            if (d < t.length - 1 && !Xr(t[d])) throw new Qr(`streams[${d}]`, n[d], "must be readable");
            if (d > 0 && !Jr(t[d])) throw new Qr(`streams[${d}]`, n[d], "must be writable");
        }
        let r, i, o, l, u;
        function f(d) {
            let h = l;
            l = null, h ? h(d) : d ? u.destroy(d) : !b && !s && u.destroy();
        }
        let a = t[0], c = If(t, f), s = !!Jr(a), b = !!Xr(c);
        return u = new Ke({
            writableObjectMode: !!(a != null && a.writableObjectMode),
            readableObjectMode: !!(c != null && c.writableObjectMode),
            writable: s,
            readable: b
        }), s && (u._write = function(d, h, D) {
            a.write(d, h) ? D() : r = D;
        }, u._final = function(d) {
            a.end(), i = d;
        }, a.on("drain", function() {
            if (r) {
                let d = r;
                r = null, d();
            }
        }), c.on("finish", function() {
            if (i) {
                let d = i;
                i = null, d();
            }
        })), b && (c.on("readable", function() {
            if (o) {
                let d = o;
                o = null, d();
            }
        }), c.on("end", function() {
            u.push(null);
        }), u._read = function() {
            for(;;){
                let d = c.read();
                if (d === null) {
                    o = u._read;
                    return;
                }
                if (!u.push(d)) return;
            }
        }), u._destroy = function(d, h) {
            !d && l !== null && (d = new Df), o = null, r = null, i = null, l === null ? h(d) : (l = h, Mf(c, d));
        }, u;
    };
});
var vt = g((_u, ti)=>{
    "use strict";
    var { ArrayPrototypePop: qf , Promise: xf  } = m(), { isIterable: Lf , isNodeStream: Pf  } = V(), { pipelineImpl: kf  } = Ye(), { finished: Wf  } = Y();
    function Cf(...e) {
        return new xf((t, n)=>{
            let r, i, o = e[e.length - 1];
            if (o && typeof o == "object" && !Pf(o) && !Lf(o)) {
                let l = qf(e);
                r = l.signal, i = l.end;
            }
            kf(e, (l, u)=>{
                l ? n(l) : t(u);
            }, {
                signal: r,
                end: i
            });
        });
    }
    ti.exports = {
        finished: Wf,
        pipeline: Cf
    };
});
var di = g((pu, si)=>{
    var { Buffer: jf  } = __default6, { ObjectDefineProperty: H , ObjectKeys: ii , ReflectApply: oi  } = m(), { promisify: { custom: li  }  } = j(), { streamReturningOperators: ni , promiseReturningOperators: ri  } = xn(), { codes: { ERR_ILLEGAL_CONSTRUCTOR: ai  }  } = O(), $f = ei(), { pipeline: fi  } = Ye(), { destroyer: vf  } = Z(), ui = Y(), Ft = vt(), Ut = V(), R = si.exports = Le().Stream;
    R.isDisturbed = Ut.isDisturbed;
    R.isErrored = Ut.isErrored;
    R.isReadable = Ut.isReadable;
    R.Readable = we();
    for (let e of ii(ni)){
        let n = function(...r) {
            if (new.target) throw ai();
            return R.Readable.from(oi(t, this, r));
        };
        n;
        let t = ni[e];
        H(n, "name", {
            __proto__: null,
            value: t.name
        }), H(n, "length", {
            __proto__: null,
            value: t.length
        }), H(R.Readable.prototype, e, {
            __proto__: null,
            value: n,
            enumerable: !1,
            configurable: !0,
            writable: !0
        });
    }
    for (let e of ii(ri)){
        let n = function(...i) {
            if (new.target) throw ai();
            return oi(t, this, i);
        };
        n;
        let t = ri[e];
        H(n, "name", {
            __proto__: null,
            value: t.name
        }), H(n, "length", {
            __proto__: null,
            value: t.length
        }), H(R.Readable.prototype, e, {
            __proto__: null,
            value: n,
            enumerable: !1,
            configurable: !0,
            writable: !0
        });
    }
    R.Writable = Tt();
    R.Duplex = v();
    R.Transform = xt();
    R.PassThrough = Pt();
    R.pipeline = fi;
    var { addAbortSignal: Ff  } = ke();
    R.addAbortSignal = Ff;
    R.finished = ui;
    R.destroy = vf;
    R.compose = $f;
    H(R, "promises", {
        __proto__: null,
        configurable: !0,
        enumerable: !0,
        get () {
            return Ft;
        }
    });
    H(fi, li, {
        __proto__: null,
        enumerable: !0,
        get () {
            return Ft.pipeline;
        }
    });
    H(ui, li, {
        __proto__: null,
        enumerable: !0,
        get () {
            return Ft.finished;
        }
    });
    R.Stream = R;
    R._isUint8Array = function(t) {
        return t instanceof Uint8Array;
    };
    R._uint8ArrayToBuffer = function(t) {
        return jf.from(t.buffer, t.byteOffset, t.byteLength);
    };
});
var ci = g((wu, A)=>{
    "use strict";
    var T = di(), Bf = vt(), Gf = T.Readable.destroy;
    A.exports = T.Readable;
    A.exports._uint8ArrayToBuffer = T._uint8ArrayToBuffer;
    A.exports._isUint8Array = T._isUint8Array;
    A.exports.isDisturbed = T.isDisturbed;
    A.exports.isErrored = T.isErrored;
    A.exports.isReadable = T.isReadable;
    A.exports.Readable = T.Readable;
    A.exports.Writable = T.Writable;
    A.exports.Duplex = T.Duplex;
    A.exports.Transform = T.Transform;
    A.exports.PassThrough = T.PassThrough;
    A.exports.addAbortSignal = T.addAbortSignal;
    A.exports.finished = T.finished;
    A.exports.destroy = T.destroy;
    A.exports.destroy = Gf;
    A.exports.pipeline = T.pipeline;
    A.exports.compose = T.compose;
    Object.defineProperty(T, "promises", {
        configurable: !0,
        enumerable: !0,
        get () {
            return Bf;
        }
    });
    A.exports.Stream = T.Stream;
    A.exports.default = A.exports;
});
var bi = Ri(ci()), { _uint8ArrayToBuffer: yu , _isUint8Array: gu , isDisturbed: Su , isErrored: Eu , isReadable: Ru , Readable: Au , Writable: mu , Duplex: Tu , Transform: Iu , PassThrough: Mu , addAbortSignal: Nu , finished: Du , destroy: Ou , pipeline: qu , compose: xu , Stream: Lu  } = bi, { default: hi , ...Hf } = bi, Pu = hi !== void 0 ? hi : Hf;
const process1 = __process$;
const { Buffer: Buffer2  } = __default6;
const Readable = Au;
const Writable = mu;
const Duplex = Tu;
function isReadableStream(object) {
    return object instanceof ReadableStream;
}
function isWritableStream(object) {
    return object instanceof WritableStream;
}
Readable.fromWeb = function(readableStream, options = kEmptyObject) {
    if (!isReadableStream(readableStream)) {
        throw new ERR_INVALID_ARG_TYPE("readableStream", "ReadableStream", readableStream);
    }
    validateObject(options, "options");
    const { highWaterMark , encoding , objectMode =false , signal  } = options;
    if (encoding !== undefined && !Buffer2.isEncoding(encoding)) {
        throw new ERR_INVALID_ARG_VALUE(encoding, "options.encoding");
    }
    validateBoolean(objectMode, "options.objectMode");
    const reader = readableStream.getReader();
    let closed = false;
    const readable = new Readable({
        objectMode,
        highWaterMark,
        encoding,
        signal,
        read () {
            reader.read().then((chunk)=>{
                if (chunk.done) {
                    readable.push(null);
                } else {
                    readable.push(chunk.value);
                }
            }, (error)=>destroy.call(readable, error));
        },
        destroy (error, callback) {
            function done() {
                try {
                    callback(error);
                } catch (error) {
                    process1.nextTick(()=>{
                        throw error;
                    });
                }
            }
            if (!closed) {
                reader.cancel(error).then(done, done);
                return;
            }
            done();
        }
    });
    reader.closed.then(()=>{
        closed = true;
        if (!isReadableEnded1(readable)) {
            readable.push(null);
        }
    }, (error)=>{
        closed = true;
        destroy.call(readable, error);
    });
    return readable;
};
Writable.fromWeb = function(writableStream, options = kEmptyObject) {
    if (!isWritableStream(writableStream)) {
        throw new ERR_INVALID_ARG_TYPE("writableStream", "WritableStream", writableStream);
    }
    validateObject(options, "options");
    const { highWaterMark , decodeStrings =true , objectMode =false , signal  } = options;
    validateBoolean(objectMode, "options.objectMode");
    validateBoolean(decodeStrings, "options.decodeStrings");
    const writer = writableStream.getWriter();
    let closed = false;
    const writable = new Writable({
        highWaterMark,
        objectMode,
        decodeStrings,
        signal,
        writev (chunks, callback) {
            function done(error) {
                error = error.filter((e)=>e);
                try {
                    callback(error.length === 0 ? undefined : error);
                } catch (error) {
                    process1.nextTick(()=>destroy.call(writable, error));
                }
            }
            writer.ready.then(()=>Promise.all(chunks.map((data)=>writer.write(data.chunk))).then(done, done), done);
        },
        write (chunk, encoding, callback) {
            if (typeof chunk === "string" && decodeStrings && !objectMode) {
                chunk = Buffer2.from(chunk, encoding);
                chunk = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }
            function done(error) {
                try {
                    callback(error);
                } catch (error) {
                    destroy(this, duplex, error);
                }
            }
            writer.ready.then(()=>writer.write(chunk).then(done, done), done);
        },
        destroy (error, callback) {
            function done() {
                try {
                    callback(error);
                } catch (error) {
                    process1.nextTick(()=>{
                        throw error;
                    });
                }
            }
            if (!closed) {
                if (error != null) {
                    writer.abort(error).then(done, done);
                } else {
                    writer.close().then(done, done);
                }
                return;
            }
            done();
        },
        final (callback) {
            function done(error) {
                try {
                    callback(error);
                } catch (error) {
                    process1.nextTick(()=>destroy.call(writable, error));
                }
            }
            if (!closed) {
                writer.close().then(done, done);
            }
        }
    });
    writer.closed.then(()=>{
        closed = true;
        if (!isWritableEnded(writable)) {
            destroy.call(writable, new ERR_STREAM_PREMATURE_CLOSE());
        }
    }, (error)=>{
        closed = true;
        destroy.call(writable, error);
    });
    return writable;
};
Duplex.fromWeb = function(pair, options = kEmptyObject) {
    validateObject(pair, "pair");
    const { readable: readableStream , writable: writableStream  } = pair;
    if (!isReadableStream(readableStream)) {
        throw new ERR_INVALID_ARG_TYPE("pair.readable", "ReadableStream", readableStream);
    }
    if (!isWritableStream(writableStream)) {
        throw new ERR_INVALID_ARG_TYPE("pair.writable", "WritableStream", writableStream);
    }
    validateObject(options, "options");
    const { allowHalfOpen =false , objectMode =false , encoding , decodeStrings =true , highWaterMark , signal  } = options;
    validateBoolean(objectMode, "options.objectMode");
    if (encoding !== undefined && !Buffer2.isEncoding(encoding)) {
        throw new ERR_INVALID_ARG_VALUE(encoding, "options.encoding");
    }
    const writer = writableStream.getWriter();
    const reader = readableStream.getReader();
    let writableClosed = false;
    let readableClosed = false;
    const duplex1 = new Duplex({
        allowHalfOpen,
        highWaterMark,
        objectMode,
        encoding,
        decodeStrings,
        signal,
        writev (chunks, callback) {
            function done(error) {
                error = error.filter((e)=>e);
                try {
                    callback(error.length === 0 ? undefined : error);
                } catch (error) {
                    process1.nextTick(()=>destroy(duplex1, error));
                }
            }
            writer.ready.then(()=>Promise.all(chunks.map((data)=>writer.write(data.chunk))).then(done, done), done);
        },
        write (chunk, encoding, callback) {
            if (typeof chunk === "string" && decodeStrings && !objectMode) {
                chunk = Buffer2.from(chunk, encoding);
                chunk = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }
            function done(error) {
                try {
                    callback(error);
                } catch (error) {
                    destroy(duplex1, error);
                }
            }
            writer.ready.then(()=>writer.write(chunk).then(done, done), done);
        },
        final (callback) {
            function done(error) {
                try {
                    callback(error);
                } catch (error) {
                    process1.nextTick(()=>destroy(duplex1, error));
                }
            }
            if (!writableClosed) {
                writer.close().then(done, done);
            }
        },
        read () {
            reader.read().then((chunk)=>{
                if (chunk.done) {
                    duplex1.push(null);
                } else {
                    duplex1.push(chunk.value);
                }
            }, (error)=>destroy(duplex1, error));
        },
        destroy (error, callback) {
            function done() {
                try {
                    callback(error);
                } catch (error) {
                    process1.nextTick(()=>{
                        throw error;
                    });
                }
            }
            async function closeWriter() {
                if (!writableClosed) {
                    await writer.abort(error);
                }
            }
            async function closeReader() {
                if (!readableClosed) {
                    await reader.cancel(error);
                }
            }
            if (!writableClosed || !readableClosed) {
                Promise.all([
                    closeWriter(),
                    closeReader()
                ]).then(done, done);
                return;
            }
            done();
        }
    });
    writer.closed.then(()=>{
        writableClosed = true;
        if (!isWritableEnded(duplex1)) {
            destroy(duplex1, new ERR_STREAM_PREMATURE_CLOSE());
        }
    }, (error)=>{
        writableClosed = true;
        readableClosed = true;
        destroy(duplex1, error);
    });
    reader.closed.then(()=>{
        readableClosed = true;
        if (!isReadableEnded1(duplex1)) {
            duplex1.push(null);
        }
    }, (error)=>{
        writableClosed = true;
        readableClosed = true;
        destroy(duplex1, error);
    });
    return duplex1;
};
delete Readable.Duplex;
delete Readable.PassThrough;
delete Readable.Readable;
delete Readable.Stream;
delete Readable.Transform;
delete Readable.Writable;
delete Readable._isUint8Array;
delete Readable._uint8ArrayToBuffer;
delete Readable.addAbortSignal;
delete Readable.compose;
delete Readable.destroy;
delete Readable.finished;
delete Readable.isDisturbed;
delete Readable.isErrored;
delete Readable.isReadable;
delete Readable.pipeline;
function newReadableStreamFromStreamReadable(streamReadable, options = kEmptyObject) {
    if (typeof streamReadable?._readableState !== "object") {
        throw new ERR_INVALID_ARG_TYPE("streamReadable", "stream.Readable", streamReadable);
    }
    if (isDestroyed(streamReadable) || !isReadable1(streamReadable)) {
        const readable = new ReadableStream();
        readable.cancel();
        return readable;
    }
    const objectMode = streamReadable.readableObjectMode;
    const highWaterMark = streamReadable.readableHighWaterMark;
    const evaluateStrategyOrFallback = (strategy)=>{
        if (strategy) {
            return strategy;
        }
        if (objectMode) {
            return new CountQueuingStrategy({
                highWaterMark
            });
        }
        return {
            highWaterMark
        };
    };
    const strategy = evaluateStrategyOrFallback(options?.strategy);
    let controller;
    function onData(chunk) {
        if (Buffer2.isBuffer(chunk) && !objectMode) {
            chunk = new Uint8Array(chunk);
        }
        controller.enqueue(chunk);
        if (controller.desiredSize <= 0) {
            streamReadable.pause();
        }
    }
    streamReadable.pause();
    const cleanup = eos(streamReadable, (error)=>{
        if (error?.code === "ERR_STREAM_PREMATURE_CLOSE") {
            const err = new AbortError(undefined, {
                cause: error
            });
            error = err;
        }
        cleanup();
        streamReadable.on("error", ()=>{});
        if (error) {
            return controller.error(error);
        }
        controller.close();
    });
    streamReadable.on("data", onData);
    return new ReadableStream({
        start (c) {
            controller = c;
        },
        pull () {
            streamReadable.resume();
        },
        cancel (reason) {
            destroy(streamReadable, reason);
        }
    }, strategy);
}
function newWritableStreamFromStreamWritable(streamWritable) {
    if (typeof streamWritable?._writableState !== "object") {
        throw new ERR_INVALID_ARG_TYPE("streamWritable", "stream.Writable", streamWritable);
    }
    if (isDestroyed(streamWritable) || !isWritable1(streamWritable)) {
        const writable = new WritableStream();
        writable.close();
        return writable;
    }
    const highWaterMark = streamWritable.writableHighWaterMark;
    const strategy = streamWritable.writableObjectMode ? new CountQueuingStrategy({
        highWaterMark
    }) : {
        highWaterMark
    };
    let controller;
    let backpressurePromise;
    let closed;
    function onDrain() {
        if (backpressurePromise !== undefined) {
            backpressurePromise.resolve();
        }
    }
    const cleanup = eos(streamWritable, (error)=>{
        if (error?.code === "ERR_STREAM_PREMATURE_CLOSE") {
            const err = new AbortError(undefined, {
                cause: error
            });
            error = err;
        }
        cleanup();
        streamWritable.on("error", ()=>{});
        if (error != null) {
            if (backpressurePromise !== undefined) {
                backpressurePromise.reject(error);
            }
            if (closed !== undefined) {
                closed.reject(error);
                closed = undefined;
            }
            controller.error(error);
            controller = undefined;
            return;
        }
        if (closed !== undefined) {
            closed.resolve();
            closed = undefined;
            return;
        }
        controller.error(new AbortError());
        controller = undefined;
    });
    streamWritable.on("drain", onDrain);
    return new WritableStream({
        start (c) {
            controller = c;
        },
        async write (chunk) {
            if (streamWritable.writableNeedDrain || !streamWritable.write(chunk)) {
                backpressurePromise = createDeferredPromise();
                return backpressurePromise.promise.finally(()=>{
                    backpressurePromise = undefined;
                });
            }
        },
        abort (reason) {
            destroy(streamWritable, reason);
        },
        close () {
            if (closed === undefined && !isWritableEnded(streamWritable)) {
                closed = createDeferredPromise();
                streamWritable.end();
                return closed.promise;
            }
            controller = undefined;
            return Promise.resolve();
        }
    }, strategy);
}
function newReadableWritablePairFromDuplex(duplex1) {
    if (typeof duplex1?._writableState !== "object" || typeof duplex1?._readableState !== "object") {
        throw new ERR_INVALID_ARG_TYPE("duplex", "stream.Duplex", duplex1);
    }
    if (isDestroyed(duplex1)) {
        const writable = new WritableStream();
        const readable = new ReadableStream();
        writable.close();
        readable.cancel();
        return {
            readable,
            writable
        };
    }
    const writable = isWritable1(duplex1) ? newWritableStreamFromStreamWritable(duplex1) : new WritableStream();
    if (!isWritable1(duplex1)) {
        writable.close();
    }
    const readable = isReadable1(duplex1) ? newReadableStreamFromStreamReadable(duplex1) : new ReadableStream();
    if (!isReadable1(duplex1)) {
        readable.cancel();
    }
    return {
        writable,
        readable
    };
}
Readable.toWeb = newReadableStreamFromStreamReadable;
Writable.toWeb = newWritableStreamFromStreamWritable;
Duplex.toWeb = newReadableWritablePairFromDuplex;
function createWritableStdioStream(writer, name) {
    const stream = new mu({
        write (buf, enc, cb) {
            if (!writer) {
                this.destroy(new Error(`Deno.${name} is not available in this environment`));
                return;
            }
            writer.writeSync(buf instanceof Uint8Array ? buf : Buffer1.from(buf, enc));
            cb();
        },
        destroy (err, cb) {
            cb(err);
            this._undestroy();
            if (!this._writableState.emitClose) {
                nextTick(()=>this.emit("close"));
            }
        }
    });
    stream.fd = writer?.rid ?? -1;
    stream.destroySoon = stream.destroy;
    stream._isStdio = true;
    stream.once("close", ()=>writer?.close());
    Object.defineProperties(stream, {
        columns: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.().columns : undefined
        },
        rows: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.().rows : undefined
        },
        isTTY: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid)
        },
        getWindowSize: {
            enumerable: true,
            configurable: true,
            value: ()=>Deno.isatty?.(writer?.rid) ? Object.values(Deno.consoleSize?.()) : undefined
        }
    });
    if (Deno.isatty?.(writer?.rid)) {
        stream.cursorTo = function(x, y, callback) {
            return cursorTo(this, x, y, callback);
        };
        stream.moveCursor = function(dx, dy, callback) {
            return moveCursor(this, dx, dy, callback);
        };
        stream.clearLine = function(dir, callback) {
            return clearLine(this, dir, callback);
        };
        stream.clearScreenDown = function(callback) {
            return clearScreenDown(this, callback);
        };
    }
    return stream;
}
const stderr = stdio.stderr = createWritableStdioStream(Deno.stderr, "stderr");
const stdout = stdio.stdout = createWritableStdioStream(Deno.stdout, "stdout");
const stdin = stdio.stdin = new Au({
    highWaterMark: 0,
    emitClose: false,
    read (size) {
        const p = Buffer1.alloc(size || 16 * 1024);
        if (!Deno.stdin) {
            this.destroy(new Error("Deno.stdin is not available in this environment"));
            return;
        }
        Deno.stdin.read(p).then((length)=>{
            this.push(length === null ? null : p.slice(0, length));
        }, (error)=>{
            this.destroy(error);
        });
    }
});
stdin.on("close", ()=>Deno.stdin?.close());
stdin.fd = Deno.stdin?.rid ?? -1;
Object.defineProperty(stdin, "isTTY", {
    enumerable: true,
    configurable: true,
    get () {
        return Deno.isatty?.(Deno.stdin.rid);
    }
});
stdin._isRawMode = false;
stdin.setRawMode = (enable)=>{
    Deno.stdin?.setRaw?.(enable);
    stdin._isRawMode = enable;
    return stdin;
};
Object.defineProperty(stdin, "isRaw", {
    enumerable: true,
    configurable: true,
    get () {
        return stdin._isRawMode;
    }
});
function registerDestroyHook(_target, _asyncId, _prop) {}
var constants1;
(function(constants) {
    constants[constants["kInit"] = 0] = "kInit";
    constants[constants["kBefore"] = 1] = "kBefore";
    constants[constants["kAfter"] = 2] = "kAfter";
    constants[constants["kDestroy"] = 3] = "kDestroy";
    constants[constants["kPromiseResolve"] = 4] = "kPromiseResolve";
    constants[constants["kTotals"] = 5] = "kTotals";
    constants[constants["kCheck"] = 6] = "kCheck";
    constants[constants["kExecutionAsyncId"] = 7] = "kExecutionAsyncId";
    constants[constants["kTriggerAsyncId"] = 8] = "kTriggerAsyncId";
    constants[constants["kAsyncIdCounter"] = 9] = "kAsyncIdCounter";
    constants[constants["kDefaultTriggerAsyncId"] = 10] = "kDefaultTriggerAsyncId";
    constants[constants["kUsesExecutionAsyncResource"] = 11] = "kUsesExecutionAsyncResource";
    constants[constants["kStackLength"] = 12] = "kStackLength";
})(constants1 || (constants1 = {}));
const asyncHookFields = new Uint32Array(Object.keys(constants1).length);
function newAsyncId() {
    return ++asyncIdFields[constants1.kAsyncIdCounter];
}
var UidFields;
(function(UidFields) {
    UidFields[UidFields["kExecutionAsyncId"] = 0] = "kExecutionAsyncId";
    UidFields[UidFields["kTriggerAsyncId"] = 1] = "kTriggerAsyncId";
    UidFields[UidFields["kAsyncIdCounter"] = 2] = "kAsyncIdCounter";
    UidFields[UidFields["kDefaultTriggerAsyncId"] = 3] = "kDefaultTriggerAsyncId";
    UidFields[UidFields["kUidFieldsCount"] = 4] = "kUidFieldsCount";
})(UidFields || (UidFields = {}));
const asyncIdFields = new Float64Array(Object.keys(UidFields).length);
asyncIdFields[UidFields.kAsyncIdCounter] = 1;
asyncIdFields[UidFields.kDefaultTriggerAsyncId] = -1;
var providerType;
(function(providerType) {
    providerType[providerType["NONE"] = 0] = "NONE";
    providerType[providerType["DIRHANDLE"] = 1] = "DIRHANDLE";
    providerType[providerType["DNSCHANNEL"] = 2] = "DNSCHANNEL";
    providerType[providerType["ELDHISTOGRAM"] = 3] = "ELDHISTOGRAM";
    providerType[providerType["FILEHANDLE"] = 4] = "FILEHANDLE";
    providerType[providerType["FILEHANDLECLOSEREQ"] = 5] = "FILEHANDLECLOSEREQ";
    providerType[providerType["FIXEDSIZEBLOBCOPY"] = 6] = "FIXEDSIZEBLOBCOPY";
    providerType[providerType["FSEVENTWRAP"] = 7] = "FSEVENTWRAP";
    providerType[providerType["FSREQCALLBACK"] = 8] = "FSREQCALLBACK";
    providerType[providerType["FSREQPROMISE"] = 9] = "FSREQPROMISE";
    providerType[providerType["GETADDRINFOREQWRAP"] = 10] = "GETADDRINFOREQWRAP";
    providerType[providerType["GETNAMEINFOREQWRAP"] = 11] = "GETNAMEINFOREQWRAP";
    providerType[providerType["HEAPSNAPSHOT"] = 12] = "HEAPSNAPSHOT";
    providerType[providerType["HTTP2SESSION"] = 13] = "HTTP2SESSION";
    providerType[providerType["HTTP2STREAM"] = 14] = "HTTP2STREAM";
    providerType[providerType["HTTP2PING"] = 15] = "HTTP2PING";
    providerType[providerType["HTTP2SETTINGS"] = 16] = "HTTP2SETTINGS";
    providerType[providerType["HTTPINCOMINGMESSAGE"] = 17] = "HTTPINCOMINGMESSAGE";
    providerType[providerType["HTTPCLIENTREQUEST"] = 18] = "HTTPCLIENTREQUEST";
    providerType[providerType["JSSTREAM"] = 19] = "JSSTREAM";
    providerType[providerType["JSUDPWRAP"] = 20] = "JSUDPWRAP";
    providerType[providerType["MESSAGEPORT"] = 21] = "MESSAGEPORT";
    providerType[providerType["PIPECONNECTWRAP"] = 22] = "PIPECONNECTWRAP";
    providerType[providerType["PIPESERVERWRAP"] = 23] = "PIPESERVERWRAP";
    providerType[providerType["PIPEWRAP"] = 24] = "PIPEWRAP";
    providerType[providerType["PROCESSWRAP"] = 25] = "PROCESSWRAP";
    providerType[providerType["PROMISE"] = 26] = "PROMISE";
    providerType[providerType["QUERYWRAP"] = 27] = "QUERYWRAP";
    providerType[providerType["SHUTDOWNWRAP"] = 28] = "SHUTDOWNWRAP";
    providerType[providerType["SIGNALWRAP"] = 29] = "SIGNALWRAP";
    providerType[providerType["STATWATCHER"] = 30] = "STATWATCHER";
    providerType[providerType["STREAMPIPE"] = 31] = "STREAMPIPE";
    providerType[providerType["TCPCONNECTWRAP"] = 32] = "TCPCONNECTWRAP";
    providerType[providerType["TCPSERVERWRAP"] = 33] = "TCPSERVERWRAP";
    providerType[providerType["TCPWRAP"] = 34] = "TCPWRAP";
    providerType[providerType["TTYWRAP"] = 35] = "TTYWRAP";
    providerType[providerType["UDPSENDWRAP"] = 36] = "UDPSENDWRAP";
    providerType[providerType["UDPWRAP"] = 37] = "UDPWRAP";
    providerType[providerType["SIGINTWATCHDOG"] = 38] = "SIGINTWATCHDOG";
    providerType[providerType["WORKER"] = 39] = "WORKER";
    providerType[providerType["WORKERHEAPSNAPSHOT"] = 40] = "WORKERHEAPSNAPSHOT";
    providerType[providerType["WRITEWRAP"] = 41] = "WRITEWRAP";
    providerType[providerType["ZLIB"] = 42] = "ZLIB";
})(providerType || (providerType = {}));
const kInvalidAsyncId = -1;
class AsyncWrap {
    provider = providerType.NONE;
    asyncId = kInvalidAsyncId;
    constructor(provider){
        this.provider = provider;
        this.getAsyncId();
    }
    getAsyncId() {
        this.asyncId = this.asyncId === kInvalidAsyncId ? newAsyncId() : this.asyncId;
        return this.asyncId;
    }
    getProviderType() {
        return this.provider;
    }
}
const mod9 = {
    async_hook_fields: asyncHookFields,
    asyncIdFields: asyncIdFields,
    registerDestroyHook: registerDestroyHook,
    constants: constants1,
    newAsyncId: newAsyncId,
    UidFields: UidFields,
    providerType: providerType,
    AsyncWrap: AsyncWrap
};
const mod10 = {};
const v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
const v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
const IPv4Reg = new RegExp(`^${v4Str}$`);
const v6Seg = "(?:[0-9a-fA-F]{1,4})";
const IPv6Reg = new RegExp("^(" + `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` + `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` + `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|` + `(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|` + `(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|` + `(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|` + `(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|` + `(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:))` + ")(%[0-9a-zA-Z-.:]{1,})?$");
function isIPv4(ip) {
    return RegExp.prototype.test.call(IPv4Reg, ip);
}
function isIPv6(ip) {
    return RegExp.prototype.test.call(IPv6Reg, ip);
}
function isIP(ip) {
    if (isIPv4(ip)) {
        return 4;
    }
    if (isIPv6(ip)) {
        return 6;
    }
    return 0;
}
const normalizedArgsSymbol = Symbol("normalizedArgs");
const AI_V4MAPPED = 1 << 4;
const AI_ALL = 1 << 5;
const AI_ADDRCONFIG = 1 << 6;
function ares_strerror(code) {
    const errorText = [
        "Successful completion",
        "DNS server returned answer with no data",
        "DNS server claims query was misformatted",
        "DNS server returned general failure",
        "Domain name not found",
        "DNS server does not implement requested operation",
        "DNS server refused query",
        "Misformatted DNS query",
        "Misformatted domain name",
        "Unsupported address family",
        "Misformatted DNS reply",
        "Could not contact DNS servers",
        "Timeout while contacting DNS servers",
        "End of file",
        "Error reading file",
        "Out of memory",
        "Channel is being destroyed",
        "Misformatted string",
        "Illegal flags specified",
        "Given hostname is not numeric",
        "Illegal hints flags specified",
        "c-ares library initialization not yet performed",
        "Error loading iphlpapi.dll",
        "Could not find GetNetworkParams function",
        "DNS query cancelled"
    ];
    if (code >= 0 && code < errorText.length) {
        return errorText[code];
    } else {
        return "unknown";
    }
}
class GetAddrInfoReqWrap extends AsyncWrap {
    family;
    hostname;
    callback;
    resolve;
    reject;
    oncomplete;
    constructor(){
        super(providerType.GETADDRINFOREQWRAP);
    }
}
function getaddrinfo(req, hostname, family, _hints, verbatim) {
    let addresses = [];
    const recordTypes = [];
    if (family === 0 || family === 4) {
        recordTypes.push("A");
    }
    if (family === 0 || family === 6) {
        recordTypes.push("AAAA");
    }
    (async ()=>{
        await Promise.allSettled(recordTypes.map((recordType)=>Deno.resolveDns(hostname, recordType).then((records)=>{
                records.forEach((record)=>addresses.push(record));
            })));
        const error = addresses.length ? 0 : codeMap.get("EAI_NODATA");
        if (!verbatim) {
            addresses.sort((a, b)=>{
                if (isIPv4(a)) {
                    return -1;
                } else if (isIPv4(b)) {
                    return 1;
                }
                return 0;
            });
        }
        if (isWindows && hostname === "localhost") {
            addresses = addresses.filter((address)=>isIPv4(address));
        }
        req.oncomplete(error, addresses);
    })();
    return 0;
}
class QueryReqWrap extends AsyncWrap {
    bindingName;
    hostname;
    ttl;
    callback;
    resolve;
    reject;
    oncomplete;
    constructor(){
        super(providerType.QUERYWRAP);
    }
}
function fqdnToHostname(fqdn) {
    return fqdn.replace(/\.$/, "");
}
function compressIPv6(address) {
    const formatted = address.replace(/\b(?:0+:){2,}/, ":");
    const finalAddress = formatted.split(":").map((octet)=>{
        if (octet.match(/^\d+\.\d+\.\d+\.\d+$/)) {
            return Number(octet.replaceAll(".", "")).toString(16);
        }
        return octet.replace(/\b0+/g, "");
    }).join(":");
    return finalAddress;
}
class ChannelWrap extends AsyncWrap {
    #servers = [];
    #timeout;
    #tries;
    constructor(timeout, tries){
        super(providerType.DNSCHANNEL);
        this.#timeout = timeout;
        this.#tries = tries;
    }
    async #query(query, recordType) {
        let code;
        let ret;
        if (this.#servers.length) {
            for (const [ipAddr, port] of this.#servers){
                const resolveOptions = {
                    nameServer: {
                        ipAddr,
                        port
                    }
                };
                ({ code , ret  } = await this.#resolve(query, recordType, resolveOptions));
                if (code === 0 || code === codeMap.get("EAI_NODATA")) {
                    break;
                }
            }
        } else {
            ({ code , ret  } = await this.#resolve(query, recordType));
        }
        return {
            code: code,
            ret: ret
        };
    }
    async #resolve(query1, recordType1, resolveOptions) {
        let ret = [];
        let code = 0;
        try {
            ret = await Deno.resolveDns(query1, recordType1, resolveOptions);
        } catch (e) {
            if (e instanceof Deno.errors.NotFound) {
                code = codeMap.get("EAI_NODATA");
            } else {
                code = codeMap.get("UNKNOWN");
            }
        }
        return {
            code,
            ret
        };
    }
    queryAny(req, name) {
        (async ()=>{
            const records = [];
            await Promise.allSettled([
                this.#query(name, "A").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "A",
                            address: record
                        }));
                }),
                this.#query(name, "AAAA").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "AAAA",
                            address: compressIPv6(record)
                        }));
                }),
                this.#query(name, "CAA").then(({ ret  })=>{
                    ret.forEach(({ critical , tag , value  })=>records.push({
                            type: "CAA",
                            [tag]: value,
                            critical: +critical && 128
                        }));
                }),
                this.#query(name, "CNAME").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "CNAME",
                            value: record
                        }));
                }),
                this.#query(name, "MX").then(({ ret  })=>{
                    ret.forEach(({ preference , exchange  })=>records.push({
                            type: "MX",
                            priority: preference,
                            exchange: fqdnToHostname(exchange)
                        }));
                }),
                this.#query(name, "NAPTR").then(({ ret  })=>{
                    ret.forEach(({ order , preference , flags , services , regexp , replacement  })=>records.push({
                            type: "NAPTR",
                            order,
                            preference,
                            flags,
                            service: services,
                            regexp,
                            replacement
                        }));
                }),
                this.#query(name, "NS").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "NS",
                            value: fqdnToHostname(record)
                        }));
                }),
                this.#query(name, "PTR").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "PTR",
                            value: fqdnToHostname(record)
                        }));
                }),
                this.#query(name, "SOA").then(({ ret  })=>{
                    ret.forEach(({ mname , rname , serial , refresh , retry , expire , minimum  })=>records.push({
                            type: "SOA",
                            nsname: fqdnToHostname(mname),
                            hostmaster: fqdnToHostname(rname),
                            serial,
                            refresh,
                            retry,
                            expire,
                            minttl: minimum
                        }));
                }),
                this.#query(name, "SRV").then(({ ret  })=>{
                    ret.forEach(({ priority , weight , port , target  })=>records.push({
                            type: "SRV",
                            priority,
                            weight,
                            port,
                            name: target
                        }));
                }),
                this.#query(name, "TXT").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "TXT",
                            entries: record
                        }));
                })
            ]);
            const err = records.length ? 0 : codeMap.get("EAI_NODATA");
            req.oncomplete(err, records);
        })();
        return 0;
    }
    queryA(req, name) {
        this.#query(name, "A").then(({ code , ret  })=>{
            req.oncomplete(code, ret);
        });
        return 0;
    }
    queryAaaa(req, name) {
        this.#query(name, "AAAA").then(({ code , ret  })=>{
            const records = ret.map((record)=>compressIPv6(record));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryCaa(req, name) {
        this.#query(name, "CAA").then(({ code , ret  })=>{
            const records = ret.map(({ critical , tag , value  })=>({
                    [tag]: value,
                    critical: +critical && 128
                }));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryCname(req, name) {
        this.#query(name, "CNAME").then(({ code , ret  })=>{
            req.oncomplete(code, ret);
        });
        return 0;
    }
    queryMx(req, name) {
        this.#query(name, "MX").then(({ code , ret  })=>{
            const records = ret.map(({ preference , exchange  })=>({
                    priority: preference,
                    exchange: fqdnToHostname(exchange)
                }));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryNaptr(req, name) {
        this.#query(name, "NAPTR").then(({ code , ret  })=>{
            const records = ret.map(({ order , preference , flags , services , regexp , replacement  })=>({
                    flags,
                    service: services,
                    regexp,
                    replacement,
                    order,
                    preference
                }));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryNs(req, name) {
        this.#query(name, "NS").then(({ code , ret  })=>{
            const records = ret.map((record)=>fqdnToHostname(record));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryPtr(req, name) {
        this.#query(name, "PTR").then(({ code , ret  })=>{
            const records = ret.map((record)=>fqdnToHostname(record));
            req.oncomplete(code, records);
        });
        return 0;
    }
    querySoa(req, name) {
        this.#query(name, "SOA").then(({ code , ret  })=>{
            let record = {};
            if (ret.length) {
                const { mname , rname , serial , refresh , retry , expire , minimum  } = ret[0];
                record = {
                    nsname: fqdnToHostname(mname),
                    hostmaster: fqdnToHostname(rname),
                    serial,
                    refresh,
                    retry,
                    expire,
                    minttl: minimum
                };
            }
            req.oncomplete(code, record);
        });
        return 0;
    }
    querySrv(req, name) {
        this.#query(name, "SRV").then(({ code , ret  })=>{
            const records = ret.map(({ priority , weight , port , target  })=>({
                    priority,
                    weight,
                    port,
                    name: target
                }));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryTxt(req, name) {
        this.#query(name, "TXT").then(({ code , ret  })=>{
            req.oncomplete(code, ret);
        });
        return 0;
    }
    getHostByAddr(_req, _name) {
        notImplemented("cares.ChannelWrap.prototype.getHostByAddr");
    }
    getServers() {
        return this.#servers;
    }
    setServers(servers) {
        if (typeof servers === "string") {
            const tuples = [];
            for(let i = 0; i < servers.length; i += 2){
                tuples.push([
                    servers[i],
                    parseInt(servers[i + 1])
                ]);
            }
            this.#servers = tuples;
        } else {
            this.#servers = servers.map(([_ipVersion, ip, port])=>[
                    ip,
                    port
                ]);
        }
        return 0;
    }
    setLocalAddress(_addr0, _addr1) {
        notImplemented("cares.ChannelWrap.prototype.setLocalAddress");
    }
    cancel() {
        notImplemented("cares.ChannelWrap.prototype.cancel");
    }
}
const DNS_ESETSRVPENDING = -1000;
const EMSG_ESETSRVPENDING = "There are pending queries.";
function strerror(code) {
    return code === DNS_ESETSRVPENDING ? EMSG_ESETSRVPENDING : ares_strerror(code);
}
const mod11 = {
    GetAddrInfoReqWrap: GetAddrInfoReqWrap,
    getaddrinfo: getaddrinfo,
    QueryReqWrap: QueryReqWrap,
    ChannelWrap: ChannelWrap,
    strerror: strerror
};
const mod12 = {};
function timingSafeEqual(a, b) {
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    if (!(a instanceof DataView)) {
        a = new DataView(ArrayBuffer.isView(a) ? a.buffer : a);
    }
    if (!(b instanceof DataView)) {
        b = new DataView(ArrayBuffer.isView(b) ? b.buffer : b);
    }
    assert(a instanceof DataView);
    assert(b instanceof DataView);
    const length = a.byteLength;
    let out = 0;
    let i = -1;
    while(++i < length){
        out |= a.getUint8(i) ^ b.getUint8(i);
    }
    return out === 0;
}
const timingSafeEqual1 = (a, b)=>{
    if (a instanceof Buffer1) a = new DataView(a.buffer);
    if (a instanceof Buffer1) b = new DataView(a.buffer);
    return timingSafeEqual(a, b);
};
function getFipsCrypto() {
    notImplemented("crypto.getFipsCrypto");
}
function setFipsCrypto(_fips) {
    notImplemented("crypto.setFipsCrypto");
}
const mod13 = {
    timingSafeEqual: timingSafeEqual1,
    getFipsCrypto: getFipsCrypto,
    setFipsCrypto: setFipsCrypto
};
const mod14 = {};
const mod15 = {};
const mod16 = {};
const mod17 = {};
const mod18 = {};
const mod19 = {};
const mod20 = {};
const mod21 = {};
const mod22 = {};
const mod23 = {};
const mod24 = {};
const mod25 = {};
const mod26 = {};
const mod27 = {};
const mod28 = {};
const mod29 = {};
class HandleWrap extends AsyncWrap {
    constructor(provider){
        super(provider);
    }
    close(cb = ()=>{}) {
        this._onClose();
        queueMicrotask(cb);
    }
    ref() {
        unreachable();
    }
    unref() {
        unreachable();
    }
    _onClose() {}
}
async function writeAll(w, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += await w.write(arr.subarray(nwritten));
    }
}
function writeAllSync(w, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += w.writeSync(arr.subarray(nwritten));
    }
}
var StreamBaseStateFields;
(function(StreamBaseStateFields) {
    StreamBaseStateFields[StreamBaseStateFields["kReadBytesOrError"] = 0] = "kReadBytesOrError";
    StreamBaseStateFields[StreamBaseStateFields["kArrayBufferOffset"] = 1] = "kArrayBufferOffset";
    StreamBaseStateFields[StreamBaseStateFields["kBytesWritten"] = 2] = "kBytesWritten";
    StreamBaseStateFields[StreamBaseStateFields["kLastWriteWasAsync"] = 3] = "kLastWriteWasAsync";
    StreamBaseStateFields[StreamBaseStateFields["kNumStreamBaseStateFields"] = 4] = "kNumStreamBaseStateFields";
})(StreamBaseStateFields || (StreamBaseStateFields = {}));
const kReadBytesOrError = StreamBaseStateFields.kReadBytesOrError;
const kArrayBufferOffset = StreamBaseStateFields.kArrayBufferOffset;
const kBytesWritten = StreamBaseStateFields.kBytesWritten;
const kLastWriteWasAsync = StreamBaseStateFields.kLastWriteWasAsync;
const kNumStreamBaseStateFields = StreamBaseStateFields.kNumStreamBaseStateFields;
const streamBaseState = new Uint8Array(5);
streamBaseState[kLastWriteWasAsync] = 1;
class WriteWrap extends AsyncWrap {
    handle;
    oncomplete;
    async;
    bytes;
    buffer;
    callback;
    _chunks;
    constructor(){
        super(providerType.WRITEWRAP);
    }
}
class ShutdownWrap extends AsyncWrap {
    handle;
    oncomplete;
    callback;
    constructor(){
        super(providerType.SHUTDOWNWRAP);
    }
}
const kStreamBaseField = Symbol("kStreamBaseField");
const SUGGESTED_SIZE = 64 * 1024;
class LibuvStreamWrap extends HandleWrap {
    [kStreamBaseField];
    reading;
    #reading = false;
    destroyed = false;
    writeQueueSize = 0;
    bytesRead = 0;
    bytesWritten = 0;
    onread;
    constructor(provider, stream){
        super(provider);
        this.#attachToObject(stream);
    }
    readStart() {
        if (!this.#reading) {
            this.#reading = true;
            this.#read();
        }
        return 0;
    }
    readStop() {
        this.#reading = false;
        return 0;
    }
    shutdown(req) {
        const status = this._onClose();
        try {
            req.oncomplete(status);
        } catch  {}
        return 0;
    }
    useUserBuffer(_userBuf) {
        notImplemented("LibuvStreamWrap.prototype.useUserBuffer");
    }
    writeBuffer(req, data) {
        this.#write(req, data);
        return 0;
    }
    writev(req, chunks, allBuffers) {
        const count = allBuffers ? chunks.length : chunks.length >> 1;
        const buffers = new Array(count);
        if (!allBuffers) {
            for(let i = 0; i < count; i++){
                const chunk = chunks[i * 2];
                if (Buffer1.isBuffer(chunk)) {
                    buffers[i] = chunk;
                }
                const encoding = chunks[i * 2 + 1];
                buffers[i] = Buffer1.from(chunk, encoding);
            }
        } else {
            for(let i = 0; i < count; i++){
                buffers[i] = chunks[i];
            }
        }
        return this.writeBuffer(req, Buffer1.concat(buffers));
    }
    writeAsciiString(req, data) {
        const buffer = new TextEncoder().encode(data);
        return this.writeBuffer(req, buffer);
    }
    writeUtf8String(req, data) {
        const buffer = new TextEncoder().encode(data);
        return this.writeBuffer(req, buffer);
    }
    writeUcs2String(_req, _data) {
        notImplemented("LibuvStreamWrap.prototype.writeUcs2String");
    }
    writeLatin1String(req, data) {
        const buffer = Buffer1.from(data, "latin1");
        return this.writeBuffer(req, buffer);
    }
    _onClose() {
        let status = 0;
        this.#reading = false;
        try {
            this[kStreamBaseField]?.close();
        } catch  {
            status = codeMap.get("ENOTCONN");
        }
        return status;
    }
    #attachToObject(stream) {
        this[kStreamBaseField] = stream;
    }
    async #read() {
        let buf = new Uint8Array(SUGGESTED_SIZE);
        let nread;
        try {
            nread = await this[kStreamBaseField].read(buf);
        } catch (e) {
            if (e instanceof Deno.errors.Interrupted || e instanceof Deno.errors.BadResource) {
                nread = codeMap.get("EOF");
            } else if (e instanceof Deno.errors.ConnectionReset || e instanceof Deno.errors.ConnectionAborted) {
                nread = codeMap.get("ECONNRESET");
            } else {
                nread = codeMap.get("UNKNOWN");
            }
            buf = new Uint8Array(0);
        }
        nread ??= codeMap.get("EOF");
        streamBaseState[kReadBytesOrError] = nread;
        if (nread > 0) {
            this.bytesRead += nread;
        }
        buf = buf.slice(0, nread);
        streamBaseState[kArrayBufferOffset] = 0;
        try {
            this.onread(buf, nread);
        } catch  {}
        if (nread >= 0 && this.#reading) {
            this.#read();
        }
    }
    async #write(req, data) {
        const { byteLength  } = data;
        try {
            await writeAll(this[kStreamBaseField], data);
        } catch (e) {
            let status;
            if (e instanceof Deno.errors.BadResource || e instanceof Deno.errors.BrokenPipe) {
                status = codeMap.get("EBADF");
            } else {
                status = codeMap.get("UNKNOWN");
            }
            try {
                req.oncomplete(status);
            } catch  {}
            return;
        }
        streamBaseState[kBytesWritten] = byteLength;
        this.bytesWritten += byteLength;
        try {
            req.oncomplete(0);
        } catch  {}
        return;
    }
}
const mod30 = {
    kReadBytesOrError: kReadBytesOrError,
    kArrayBufferOffset: kArrayBufferOffset,
    kBytesWritten: kBytesWritten,
    kLastWriteWasAsync: kLastWriteWasAsync,
    kNumStreamBaseStateFields: kNumStreamBaseStateFields,
    streamBaseState: streamBaseState,
    WriteWrap: WriteWrap,
    ShutdownWrap: ShutdownWrap,
    kStreamBaseField: kStreamBaseField,
    LibuvStreamWrap: LibuvStreamWrap
};
class ConnectionWrap extends LibuvStreamWrap {
    onconnection = null;
    constructor(provider, object){
        super(provider, object);
    }
    afterConnect(req, status) {
        const isSuccessStatus = !status;
        const readable = isSuccessStatus;
        const writable = isSuccessStatus;
        try {
            req.oncomplete(status, this, req, readable, writable);
        } catch  {}
        return;
    }
}
function deferred() {
    let methods;
    let state = "pending";
    const promise = new Promise((resolve, reject)=>{
        methods = {
            async resolve (value) {
                await value;
                state = "fulfilled";
                resolve(value);
            },
            reject (reason) {
                state = "rejected";
                reject(reason);
            }
        };
    });
    Object.defineProperty(promise, "state", {
        get: ()=>state
    });
    return Object.assign(promise, methods);
}
function delay(ms, options = {}) {
    const { signal , persistent  } = options;
    if (signal?.aborted) {
        return Promise.reject(new DOMException("Delay was aborted.", "AbortError"));
    }
    return new Promise((resolve, reject)=>{
        const abort = ()=>{
            clearTimeout(i);
            reject(new DOMException("Delay was aborted.", "AbortError"));
        };
        const done = ()=>{
            signal?.removeEventListener("abort", abort);
            resolve();
        };
        const i = setTimeout(done, ms);
        signal?.addEventListener("abort", abort, {
            once: true
        });
        if (persistent === false) {
            try {
                Deno.unrefTimer(i);
            } catch (error) {
                if (!(error instanceof ReferenceError)) {
                    throw error;
                }
                console.error("`persistent` option is only available in Deno");
            }
        }
    });
}
class MuxAsyncIterator {
    #iteratorCount = 0;
    #yields = [];
    #throws = [];
    #signal = deferred();
    add(iterable) {
        ++this.#iteratorCount;
        this.#callIteratorNext(iterable[Symbol.asyncIterator]());
    }
    async #callIteratorNext(iterator) {
        try {
            const { value , done  } = await iterator.next();
            if (done) {
                --this.#iteratorCount;
            } else {
                this.#yields.push({
                    iterator,
                    value
                });
            }
        } catch (e) {
            this.#throws.push(e);
        }
        this.#signal.resolve();
    }
    async *iterate() {
        while(this.#iteratorCount > 0){
            await this.#signal;
            for(let i = 0; i < this.#yields.length; i++){
                const { iterator , value  } = this.#yields[i];
                yield value;
                this.#callIteratorNext(iterator);
            }
            if (this.#throws.length) {
                for (const e of this.#throws){
                    throw e;
                }
                this.#throws.length = 0;
            }
            this.#yields.length = 0;
            this.#signal = deferred();
        }
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
}
function ceilPowOf2(n) {
    const roundPowOf2 = 1 << 31 - Math.clz32(n);
    return roundPowOf2 < n ? roundPowOf2 * 2 : roundPowOf2;
}
const INITIAL_ACCEPT_BACKOFF_DELAY = 5;
const MAX_ACCEPT_BACKOFF_DELAY = 1000;
var socketType;
(function(socketType) {
    socketType[socketType["SOCKET"] = 0] = "SOCKET";
    socketType[socketType["SERVER"] = 1] = "SERVER";
    socketType[socketType["IPC"] = 2] = "IPC";
})(socketType || (socketType = {}));
class Pipe extends ConnectionWrap {
    reading = false;
    ipc;
    #pendingInstances = 4;
    #address;
    #backlog;
    #listener;
    #connections = 0;
    #closed = false;
    #acceptBackoffDelay;
    constructor(type, conn){
        let provider;
        let ipc;
        switch(type){
            case socketType.SOCKET:
                {
                    provider = providerType.PIPEWRAP;
                    ipc = false;
                    break;
                }
            case socketType.SERVER:
                {
                    provider = providerType.PIPESERVERWRAP;
                    ipc = false;
                    break;
                }
            case socketType.IPC:
                {
                    provider = providerType.PIPEWRAP;
                    ipc = true;
                    break;
                }
            default:
                {
                    unreachable();
                }
        }
        super(provider, conn);
        this.ipc = ipc;
        if (conn && provider === providerType.PIPEWRAP) {
            const localAddr = conn.localAddr;
            this.#address = localAddr.path;
        }
    }
    open(_fd) {
        notImplemented("Pipe.prototype.open");
    }
    bind(name) {
        this.#address = name;
        return 0;
    }
    connect(req, address) {
        if (isWindows) {
            notImplemented("Pipe.prototype.connect - Windows");
        }
        const connectOptions = {
            path: address,
            transport: "unix"
        };
        Deno.connect(connectOptions).then((conn)=>{
            const localAddr = conn.localAddr;
            this.#address = req.address = localAddr.path;
            this[kStreamBaseField] = conn;
            try {
                this.afterConnect(req, 0);
            } catch  {}
        }, (e)=>{
            let code;
            if (e instanceof Deno.errors.NotFound) {
                code = codeMap.get("ENOENT");
            } else if (e instanceof Deno.errors.PermissionDenied) {
                code = codeMap.get("EACCES");
            } else {
                code = codeMap.get("ECONNREFUSED");
            }
            try {
                this.afterConnect(req, code);
            } catch  {}
        });
        return 0;
    }
    listen(backlog) {
        if (isWindows) {
            notImplemented("Pipe.prototype.listen - Windows");
        }
        this.#backlog = isWindows ? this.#pendingInstances : ceilPowOf2(backlog + 1);
        const listenOptions = {
            path: this.#address,
            transport: "unix"
        };
        let listener;
        try {
            listener = Deno.listen(listenOptions);
        } catch (e) {
            if (e instanceof Deno.errors.AddrInUse) {
                return codeMap.get("EADDRINUSE");
            } else if (e instanceof Deno.errors.AddrNotAvailable) {
                return codeMap.get("EADDRNOTAVAIL");
            } else if (e instanceof Deno.errors.PermissionDenied) {
                throw e;
            }
            return codeMap.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.path;
        this.#listener = listener;
        this.#accept();
        return 0;
    }
    ref() {
        if (this.#listener) {
            this.#listener.ref();
        }
    }
    unref() {
        if (this.#listener) {
            this.#listener.unref();
        }
    }
    setPendingInstances(instances) {
        this.#pendingInstances = instances;
    }
    fchmod(mode) {
        if (mode != constants2.UV_READABLE && mode != constants2.UV_WRITABLE && mode != (constants2.UV_WRITABLE | constants2.UV_READABLE)) {
            return codeMap.get("EINVAL");
        }
        let desired_mode = 0;
        if (mode & constants2.UV_READABLE) {
            desired_mode |= fs.S_IRUSR | fs.S_IRGRP | fs.S_IROTH;
        }
        if (mode & constants2.UV_WRITABLE) {
            desired_mode |= fs.S_IWUSR | fs.S_IWGRP | fs.S_IWOTH;
        }
        try {
            Deno.chmodSync(this.#address, desired_mode);
        } catch  {
            return codeMap.get("UNKNOWN");
        }
        return 0;
    }
    async #acceptBackoff() {
        if (!this.#acceptBackoffDelay) {
            this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
        } else {
            this.#acceptBackoffDelay *= 2;
        }
        if (this.#acceptBackoffDelay >= 1000) {
            this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
        }
        await delay(this.#acceptBackoffDelay);
        this.#accept();
    }
    async #accept() {
        if (this.#closed) {
            return;
        }
        if (this.#connections > this.#backlog) {
            this.#acceptBackoff();
            return;
        }
        let connection;
        try {
            connection = await this.#listener.accept();
        } catch (e) {
            if (e instanceof Deno.errors.BadResource && this.#closed) {
                return;
            }
            try {
                this.onconnection(codeMap.get("UNKNOWN"), undefined);
            } catch  {}
            this.#acceptBackoff();
            return;
        }
        this.#acceptBackoffDelay = undefined;
        const connectionHandle = new Pipe(socketType.SOCKET, connection);
        this.#connections++;
        try {
            this.onconnection(0, connectionHandle);
        } catch  {}
        return this.#accept();
    }
    _onClose() {
        this.#closed = true;
        this.reading = false;
        this.#address = undefined;
        this.#backlog = undefined;
        this.#connections = 0;
        this.#acceptBackoffDelay = undefined;
        if (this.provider === providerType.PIPESERVERWRAP) {
            try {
                this.#listener.close();
            } catch  {}
        }
        return LibuvStreamWrap.prototype._onClose.call(this);
    }
}
class PipeConnectWrap extends AsyncWrap {
    oncomplete;
    address;
    constructor(){
        super(providerType.PIPECONNECTWRAP);
    }
}
var constants2;
(function(constants) {
    constants[constants["SOCKET"] = socketType.SOCKET] = "SOCKET";
    constants[constants["SERVER"] = socketType.SERVER] = "SERVER";
    constants[constants["IPC"] = socketType.IPC] = "IPC";
    constants[constants["UV_READABLE"] = 1] = "UV_READABLE";
    constants[constants["UV_WRITABLE"] = 2] = "UV_WRITABLE";
})(constants2 || (constants2 = {}));
const mod31 = {
    socketType: socketType,
    Pipe: Pipe,
    PipeConnectWrap: PipeConnectWrap,
    constants: constants2
};
const mod32 = {};
const mod33 = {};
const mod34 = {};
const mod35 = {};
const mod36 = {};
const mod37 = {};
const asyncIdSymbol = Symbol("asyncIdSymbol");
const ownerSymbol = Symbol("ownerSymbol");
const mod38 = {
    asyncIdSymbol: asyncIdSymbol,
    ownerSymbol: ownerSymbol
};
const mod39 = {};
var socketType1;
(function(socketType) {
    socketType[socketType["SOCKET"] = 0] = "SOCKET";
    socketType[socketType["SERVER"] = 1] = "SERVER";
})(socketType1 || (socketType1 = {}));
class TCPConnectWrap extends AsyncWrap {
    oncomplete;
    address;
    port;
    localAddress;
    localPort;
    constructor(){
        super(providerType.TCPCONNECTWRAP);
    }
}
var constants3;
(function(constants) {
    constants[constants["SOCKET"] = socketType1.SOCKET] = "SOCKET";
    constants[constants["SERVER"] = socketType1.SERVER] = "SERVER";
    constants[constants["UV_TCP_IPV6ONLY"] = 0] = "UV_TCP_IPV6ONLY";
})(constants3 || (constants3 = {}));
class TCP extends ConnectionWrap {
    [ownerSymbol] = null;
    reading = false;
    #address;
    #port;
    #remoteAddress;
    #remoteFamily;
    #remotePort;
    #backlog;
    #listener;
    #connections = 0;
    #closed = false;
    #acceptBackoffDelay;
    constructor(type, conn){
        let provider;
        switch(type){
            case socketType1.SOCKET:
                {
                    provider = providerType.TCPWRAP;
                    break;
                }
            case socketType1.SERVER:
                {
                    provider = providerType.TCPSERVERWRAP;
                    break;
                }
            default:
                {
                    unreachable();
                }
        }
        super(provider, conn);
        if (conn && provider === providerType.TCPWRAP) {
            const localAddr = conn.localAddr;
            this.#address = localAddr.hostname;
            this.#port = localAddr.port;
            const remoteAddr = conn.remoteAddr;
            this.#remoteAddress = remoteAddr.hostname;
            this.#remotePort = remoteAddr.port;
            this.#remoteFamily = isIP(remoteAddr.hostname);
        }
    }
    open(_fd) {
        notImplemented("TCP.prototype.open");
    }
    bind(address, port) {
        return this.#bind(address, port, 0);
    }
    bind6(address, port, flags) {
        return this.#bind(address, port, flags);
    }
    connect(req, address, port) {
        return this.#connect(req, address, port);
    }
    connect6(req, address, port) {
        return this.#connect(req, address, port);
    }
    listen(backlog) {
        this.#backlog = ceilPowOf2(backlog + 1);
        const listenOptions = {
            hostname: this.#address,
            port: this.#port,
            transport: "tcp"
        };
        let listener;
        try {
            listener = Deno.listen(listenOptions);
        } catch (e) {
            if (e instanceof Deno.errors.AddrInUse) {
                return codeMap.get("EADDRINUSE");
            } else if (e instanceof Deno.errors.AddrNotAvailable) {
                return codeMap.get("EADDRNOTAVAIL");
            } else if (e instanceof Deno.errors.PermissionDenied) {
                throw e;
            }
            return codeMap.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.hostname;
        this.#port = address.port;
        this.#listener = listener;
        this.#accept();
        return 0;
    }
    ref() {
        if (this.#listener) {
            this.#listener.ref();
        }
        if (this[kStreamBaseField]) {
            this[kStreamBaseField].ref();
        }
    }
    unref() {
        if (this.#listener) {
            this.#listener.unref();
        }
        if (this[kStreamBaseField]) {
            this[kStreamBaseField].unref();
        }
    }
    getsockname(sockname) {
        if (typeof this.#address === "undefined" || typeof this.#port === "undefined") {
            return codeMap.get("EADDRNOTAVAIL");
        }
        sockname.address = this.#address;
        sockname.port = this.#port;
        sockname.family = isIP(this.#address);
        return 0;
    }
    getpeername(peername) {
        if (typeof this.#remoteAddress === "undefined" || typeof this.#remotePort === "undefined") {
            return codeMap.get("EADDRNOTAVAIL");
        }
        peername.address = this.#remoteAddress;
        peername.port = this.#remotePort;
        peername.family = this.#remoteFamily;
        return 0;
    }
    setNoDelay(_noDelay) {
        return 0;
    }
    setKeepAlive(_enable, _initialDelay) {
        return 0;
    }
    setSimultaneousAccepts(_enable) {
        notImplemented("TCP.prototype.setSimultaneousAccepts");
    }
    #bind(address, port, _flags) {
        this.#address = address;
        this.#port = port;
        return 0;
    }
    #connect(req1, address1, port1) {
        this.#remoteAddress = address1;
        this.#remotePort = port1;
        this.#remoteFamily = isIP(address1);
        const connectOptions = {
            hostname: address1,
            port: port1,
            transport: "tcp"
        };
        Deno.connect(connectOptions).then((conn)=>{
            const localAddr = conn.localAddr;
            this.#address = req1.localAddress = localAddr.hostname;
            this.#port = req1.localPort = localAddr.port;
            this[kStreamBaseField] = conn;
            try {
                this.afterConnect(req1, 0);
            } catch  {}
        }, ()=>{
            try {
                this.afterConnect(req1, codeMap.get("ECONNREFUSED"));
            } catch  {}
        });
        return 0;
    }
    async #acceptBackoff() {
        if (!this.#acceptBackoffDelay) {
            this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
        } else {
            this.#acceptBackoffDelay *= 2;
        }
        if (this.#acceptBackoffDelay >= 1000) {
            this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
        }
        await delay(this.#acceptBackoffDelay);
        this.#accept();
    }
    async #accept() {
        if (this.#closed) {
            return;
        }
        if (this.#connections > this.#backlog) {
            this.#acceptBackoff();
            return;
        }
        let connection;
        try {
            connection = await this.#listener.accept();
        } catch (e) {
            if (e instanceof Deno.errors.BadResource && this.#closed) {
                return;
            }
            try {
                this.onconnection(codeMap.get("UNKNOWN"), undefined);
            } catch  {}
            this.#acceptBackoff();
            return;
        }
        this.#acceptBackoffDelay = undefined;
        const connectionHandle = new TCP(socketType1.SOCKET, connection);
        this.#connections++;
        try {
            this.onconnection(0, connectionHandle);
        } catch  {}
        return this.#accept();
    }
    _onClose() {
        this.#closed = true;
        this.reading = false;
        this.#address = undefined;
        this.#port = undefined;
        this.#remoteAddress = undefined;
        this.#remoteFamily = undefined;
        this.#remotePort = undefined;
        this.#backlog = undefined;
        this.#connections = 0;
        this.#acceptBackoffDelay = undefined;
        if (this.provider === providerType.TCPSERVERWRAP) {
            try {
                this.#listener.close();
            } catch  {}
        }
        return LibuvStreamWrap.prototype._onClose.call(this);
    }
}
const mod40 = {
    TCPConnectWrap: TCPConnectWrap,
    constants: constants3,
    TCP: TCP
};
const mod41 = {};
const mod42 = {};
const mod43 = {};
const mod44 = {};
const DenoListenDatagram = Deno[Deno.internal]?.nodeUnstable?.listenDatagram || Deno.listenDatagram;
const AF_INET6 = 10;
const UDP_DGRAM_MAXSIZE = 64 * 1024;
class SendWrap extends AsyncWrap {
    list;
    address;
    port;
    callback;
    oncomplete;
    constructor(){
        super(providerType.UDPSENDWRAP);
    }
}
class UDP extends HandleWrap {
    [ownerSymbol] = null;
    #address;
    #family;
    #port;
    #remoteAddress;
    #remoteFamily;
    #remotePort;
    #listener;
    #receiving = false;
    #recvBufferSize = UDP_DGRAM_MAXSIZE;
    #sendBufferSize = UDP_DGRAM_MAXSIZE;
    onmessage;
    lookup;
    constructor(){
        super(providerType.UDPWRAP);
    }
    addMembership(_multicastAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.addMembership");
    }
    addSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.addSourceSpecificMembership");
    }
    bind(ip, port, flags) {
        return this.#doBind(ip, port, flags, 2);
    }
    bind6(ip, port, flags) {
        return this.#doBind(ip, port, flags, 10);
    }
    bufferSize(size, buffer, ctx) {
        let err;
        if (size > UDP_DGRAM_MAXSIZE) {
            err = "EINVAL";
        } else if (!this.#address) {
            err = isWindows ? "ENOTSOCK" : "EBADF";
        }
        if (err) {
            ctx.errno = codeMap.get(err);
            ctx.code = err;
            ctx.message = errorMap.get(ctx.errno)[1];
            ctx.syscall = buffer ? "uv_recv_buffer_size" : "uv_send_buffer_size";
            return;
        }
        if (size !== 0) {
            size = isLinux ? size * 2 : size;
            if (buffer) {
                return this.#recvBufferSize = size;
            }
            return this.#sendBufferSize = size;
        }
        return buffer ? this.#recvBufferSize : this.#sendBufferSize;
    }
    connect(ip, port) {
        return this.#doConnect(ip, port, 2);
    }
    connect6(ip, port) {
        return this.#doConnect(ip, port, 10);
    }
    disconnect() {
        this.#remoteAddress = undefined;
        this.#remotePort = undefined;
        this.#remoteFamily = undefined;
        return 0;
    }
    dropMembership(_multicastAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.dropMembership");
    }
    dropSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.dropSourceSpecificMembership");
    }
    getpeername(peername) {
        if (this.#remoteAddress === undefined) {
            return codeMap.get("EBADF");
        }
        peername.address = this.#remoteAddress;
        peername.port = this.#remotePort;
        peername.family = this.#remoteFamily;
        return 0;
    }
    getsockname(sockname) {
        if (this.#address === undefined) {
            return codeMap.get("EBADF");
        }
        sockname.address = this.#address;
        sockname.port = this.#port;
        sockname.family = this.#family;
        return 0;
    }
    open(_fd) {
        notImplemented("udp.UDP.prototype.open");
    }
    recvStart() {
        if (!this.#receiving) {
            this.#receiving = true;
            this.#receive();
        }
        return 0;
    }
    recvStop() {
        this.#receiving = false;
        return 0;
    }
    ref() {
        notImplemented("udp.UDP.prototype.ref");
    }
    send(req, bufs, count, ...args) {
        return this.#doSend(req, bufs, count, args, 2);
    }
    send6(req, bufs, count, ...args) {
        return this.#doSend(req, bufs, count, args, 10);
    }
    setBroadcast(_bool) {
        notImplemented("udp.UDP.prototype.setBroadcast");
    }
    setMulticastInterface(_interfaceAddress) {
        notImplemented("udp.UDP.prototype.setMulticastInterface");
    }
    setMulticastLoopback(_bool) {
        notImplemented("udp.UDP.prototype.setMulticastLoopback");
    }
    setMulticastTTL(_ttl) {
        notImplemented("udp.UDP.prototype.setMulticastTTL");
    }
    setTTL(_ttl) {
        notImplemented("udp.UDP.prototype.setTTL");
    }
    unref() {
        notImplemented("udp.UDP.prototype.unref");
    }
    #doBind(ip, port2, _flags1, family) {
        const listenOptions = {
            port: port2,
            hostname: ip,
            transport: "udp"
        };
        let listener;
        try {
            listener = DenoListenDatagram(listenOptions);
        } catch (e) {
            if (e instanceof Deno.errors.AddrInUse) {
                return codeMap.get("EADDRINUSE");
            } else if (e instanceof Deno.errors.AddrNotAvailable) {
                return codeMap.get("EADDRNOTAVAIL");
            } else if (e instanceof Deno.errors.PermissionDenied) {
                throw e;
            }
            return codeMap.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.hostname;
        this.#port = address.port;
        this.#family = family === AF_INET6 ? "IPv6" : "IPv4";
        this.#listener = listener;
        return 0;
    }
    #doConnect(ip1, port11, family1) {
        this.#remoteAddress = ip1;
        this.#remotePort = port11;
        this.#remoteFamily = family1 === AF_INET6 ? "IPv6" : "IPv4";
        return 0;
    }
    #doSend(req2, bufs, _count, args, _family) {
        let hasCallback;
        if (args.length === 3) {
            this.#remotePort = args[0];
            this.#remoteAddress = args[1];
            hasCallback = args[2];
        } else {
            hasCallback = args[0];
        }
        const addr = {
            hostname: this.#remoteAddress,
            port: this.#remotePort,
            transport: "udp"
        };
        const payload = new Uint8Array(Buffer1.concat(bufs.map((buf)=>{
            if (typeof buf === "string") {
                return Buffer1.from(buf);
            }
            return Buffer1.from(buf.buffer, buf.byteOffset, buf.byteLength);
        })));
        (async ()=>{
            let sent;
            let err = null;
            try {
                sent = await this.#listener.send(payload, addr);
            } catch (e) {
                if (e instanceof Deno.errors.BadResource) {
                    err = codeMap.get("EBADF");
                } else if (e instanceof Error && e.message.match(/os error (40|90|10040)/)) {
                    err = codeMap.get("EMSGSIZE");
                } else {
                    err = codeMap.get("UNKNOWN");
                }
                sent = 0;
            }
            if (hasCallback) {
                try {
                    req2.oncomplete(err, sent);
                } catch  {}
            }
        })();
        return 0;
    }
    async #receive() {
        if (!this.#receiving) {
            return;
        }
        const p = new Uint8Array(this.#recvBufferSize);
        let buf;
        let remoteAddr;
        let nread;
        try {
            [buf, remoteAddr] = await this.#listener.receive(p);
            nread = buf.length;
        } catch (e) {
            if (e instanceof Deno.errors.Interrupted || e instanceof Deno.errors.BadResource) {
                nread = 0;
            } else {
                nread = codeMap.get("UNKNOWN");
            }
            buf = new Uint8Array(0);
            remoteAddr = null;
        }
        nread ??= 0;
        const rinfo = remoteAddr ? {
            address: remoteAddr.hostname,
            port: remoteAddr.port,
            family: isIP(remoteAddr.hostname) === 6 ? "IPv6" : "IPv4"
        } : undefined;
        try {
            this.onmessage(nread, this, Buffer1.from(buf), rinfo);
        } catch  {}
        this.#receive();
    }
    _onClose() {
        this.#receiving = false;
        this.#address = undefined;
        this.#port = undefined;
        this.#family = undefined;
        try {
            this.#listener.close();
        } catch  {}
        this.#listener = undefined;
        return 0;
    }
}
const mod45 = {
    SendWrap: SendWrap,
    UDP: UDP
};
const mod46 = {};
const mod47 = {};
const mod48 = {};
const mod49 = {};
const modules = {
    "async_wrap": mod9,
    buffer: mod8,
    "cares_wrap": mod11,
    config: mod10,
    constants: mod4,
    contextify: mod12,
    credentials: mod14,
    crypto: mod13,
    errors: mod15,
    fs: mod16,
    "fs_dir": mod17,
    "fs_event_wrap": mod18,
    "heap_utils": mod19,
    "http_parser": mod20,
    icu: mod21,
    inspector: mod22,
    "js_stream": mod23,
    messaging: mod24,
    "module_wrap": mod25,
    "native_module": mod26,
    natives: mod27,
    options: mod28,
    os: mod29,
    performance: mod32,
    "pipe_wrap": mod31,
    "process_methods": mod33,
    report: mod34,
    serdes: mod35,
    "signal_wrap": mod36,
    "spawn_sync": mod37,
    "stream_wrap": mod30,
    "string_decoder": mod7,
    symbols: mod38,
    "task_queue": mod39,
    "tcp_wrap": mod40,
    timers: mod41,
    "tls_wrap": mod42,
    "trace_events": mod43,
    "tty_wrap": mod44,
    types: mod1,
    "udp_wrap": mod45,
    url: mod46,
    util: mod3,
    uv: mod,
    v8: mod47,
    worker: mod48,
    zlib: mod49
};
function getBinding(name) {
    const mod = modules[name];
    if (!mod) {
        throw new Error(`No such module: ${name}`);
    }
    return mod;
}
const kInternal = Symbol("internal properties");
const replaceUnderscoresRegex = /_/g;
const leadingDashesRegex = /^--?/;
const trailingValuesRegex = /=.*$/;
function buildAllowedFlags() {
    const allowedNodeEnvironmentFlags = [
        "--track-heap-objects",
        "--no-track-heap-objects",
        "--node-snapshot",
        "--no-node-snapshot",
        "--require",
        "--max-old-space-size",
        "--trace-exit",
        "--no-trace-exit",
        "--disallow-code-generation-from-strings",
        "--experimental-json-modules",
        "--no-experimental-json-modules",
        "--interpreted-frames-native-stack",
        "--inspect-brk",
        "--no-inspect-brk",
        "--trace-tls",
        "--no-trace-tls",
        "--stack-trace-limit",
        "--experimental-repl-await",
        "--no-experimental-repl-await",
        "--preserve-symlinks",
        "--no-preserve-symlinks",
        "--report-uncaught-exception",
        "--no-report-uncaught-exception",
        "--experimental-modules",
        "--no-experimental-modules",
        "--report-signal",
        "--jitless",
        "--inspect-port",
        "--heapsnapshot-near-heap-limit",
        "--tls-keylog",
        "--force-context-aware",
        "--no-force-context-aware",
        "--napi-modules",
        "--abort-on-uncaught-exception",
        "--diagnostic-dir",
        "--verify-base-objects",
        "--no-verify-base-objects",
        "--unhandled-rejections",
        "--perf-basic-prof",
        "--trace-atomics-wait",
        "--no-trace-atomics-wait",
        "--deprecation",
        "--no-deprecation",
        "--perf-basic-prof-only-functions",
        "--perf-prof",
        "--max-http-header-size",
        "--report-on-signal",
        "--no-report-on-signal",
        "--throw-deprecation",
        "--no-throw-deprecation",
        "--warnings",
        "--no-warnings",
        "--force-fips",
        "--no-force-fips",
        "--pending-deprecation",
        "--no-pending-deprecation",
        "--input-type",
        "--tls-max-v1.3",
        "--no-tls-max-v1.3",
        "--tls-min-v1.2",
        "--no-tls-min-v1.2",
        "--inspect",
        "--no-inspect",
        "--heapsnapshot-signal",
        "--trace-warnings",
        "--no-trace-warnings",
        "--trace-event-categories",
        "--experimental-worker",
        "--tls-max-v1.2",
        "--no-tls-max-v1.2",
        "--perf-prof-unwinding-info",
        "--preserve-symlinks-main",
        "--no-preserve-symlinks-main",
        "--policy-integrity",
        "--experimental-wasm-modules",
        "--no-experimental-wasm-modules",
        "--node-memory-debug",
        "--inspect-publish-uid",
        "--tls-min-v1.3",
        "--no-tls-min-v1.3",
        "--experimental-specifier-resolution",
        "--secure-heap",
        "--tls-min-v1.0",
        "--no-tls-min-v1.0",
        "--redirect-warnings",
        "--experimental-report",
        "--trace-event-file-pattern",
        "--trace-uncaught",
        "--no-trace-uncaught",
        "--experimental-loader",
        "--http-parser",
        "--dns-result-order",
        "--trace-sigint",
        "--no-trace-sigint",
        "--secure-heap-min",
        "--enable-fips",
        "--no-enable-fips",
        "--enable-source-maps",
        "--no-enable-source-maps",
        "--insecure-http-parser",
        "--no-insecure-http-parser",
        "--use-openssl-ca",
        "--no-use-openssl-ca",
        "--tls-cipher-list",
        "--experimental-top-level-await",
        "--no-experimental-top-level-await",
        "--openssl-config",
        "--icu-data-dir",
        "--v8-pool-size",
        "--report-on-fatalerror",
        "--no-report-on-fatalerror",
        "--title",
        "--tls-min-v1.1",
        "--no-tls-min-v1.1",
        "--report-filename",
        "--trace-deprecation",
        "--no-trace-deprecation",
        "--report-compact",
        "--no-report-compact",
        "--experimental-policy",
        "--experimental-import-meta-resolve",
        "--no-experimental-import-meta-resolve",
        "--zero-fill-buffers",
        "--no-zero-fill-buffers",
        "--report-dir",
        "--use-bundled-ca",
        "--no-use-bundled-ca",
        "--experimental-vm-modules",
        "--no-experimental-vm-modules",
        "--force-async-hooks-checks",
        "--no-force-async-hooks-checks",
        "--frozen-intrinsics",
        "--no-frozen-intrinsics",
        "--huge-max-old-generation-size",
        "--disable-proto",
        "--debug-arraybuffer-allocations",
        "--no-debug-arraybuffer-allocations",
        "--conditions",
        "--experimental-wasi-unstable-preview1",
        "--no-experimental-wasi-unstable-preview1",
        "--trace-sync-io",
        "--no-trace-sync-io",
        "--use-largepages",
        "--experimental-abortcontroller",
        "--debug-port",
        "--es-module-specifier-resolution",
        "--prof-process",
        "-C",
        "--loader",
        "--report-directory",
        "-r",
        "--trace-events-enabled"
    ];
    const trimLeadingDashes = (flag)=>flag.replace(leadingDashesRegex, "");
    const nodeFlags = allowedNodeEnvironmentFlags.map(trimLeadingDashes);
    class NodeEnvironmentFlagsSet extends Set {
        constructor(array){
            super();
            this[kInternal] = {
                array
            };
        }
        add() {
            return this;
        }
        delete() {
            return false;
        }
        clear() {}
        has(key) {
            if (typeof key === "string") {
                key = key.replace(replaceUnderscoresRegex, "-");
                if (leadingDashesRegex.test(key)) {
                    key = key.replace(trailingValuesRegex, "");
                    return this[kInternal].array.includes(key);
                }
                return nodeFlags.includes(key);
            }
            return false;
        }
        entries() {
            this[kInternal].set ??= new Set(this[kInternal].array);
            return this[kInternal].set.entries();
        }
        forEach(callback, thisArg = undefined) {
            this[kInternal].array.forEach((v)=>Reflect.apply(callback, thisArg, [
                    v,
                    v,
                    this
                ]));
        }
        get size() {
            return this[kInternal].array.length;
        }
        values() {
            this[kInternal].set ??= new Set(this[kInternal].array);
            return this[kInternal].set.values();
        }
    }
    NodeEnvironmentFlagsSet.prototype.keys = NodeEnvironmentFlagsSet.prototype[Symbol.iterator] = NodeEnvironmentFlagsSet.prototype.values;
    Object.freeze(NodeEnvironmentFlagsSet.prototype.constructor);
    Object.freeze(NodeEnvironmentFlagsSet.prototype);
    return Object.freeze(new NodeEnvironmentFlagsSet(allowedNodeEnvironmentFlags));
}
const DenoCommand = Deno[Deno.internal]?.nodeUnstable?.Command || Deno.Command;
const notImplementedEvents = [
    "disconnect",
    "message",
    "multipleResolves",
    "rejectionHandled",
    "worker"
];
const argv = [
    "",
    "",
    ...Deno.args
];
Object.defineProperty(argv, "0", {
    get: Deno.execPath
});
Object.defineProperty(argv, "1", {
    get: ()=>{
        if (Deno.mainModule.startsWith("file:")) {
            return fromFileUrl2(Deno.mainModule);
        } else {
            return join4(Deno.cwd(), "$deno$node.js");
        }
    }
});
const exit = (code)=>{
    if (code || code === 0) {
        if (typeof code === "string") {
            const parsedCode = parseInt(code);
            process2.exitCode = isNaN(parsedCode) ? undefined : parsedCode;
        } else {
            process2.exitCode = code;
        }
    }
    if (!process2._exiting) {
        process2._exiting = true;
        process2.emit("exit", process2.exitCode || 0);
    }
    Deno.exit(process2.exitCode || 0);
};
function addReadOnlyProcessAlias(name, option, enumerable = true) {
    const value = getOptionValue(option);
    if (value) {
        Object.defineProperty(process2, name, {
            writable: false,
            configurable: true,
            enumerable,
            value
        });
    }
}
function createWarningObject(warning, type, code, ctor, detail) {
    assert(typeof warning === "string");
    const warningErr = new Error(warning);
    warningErr.name = String(type || "Warning");
    if (code !== undefined) {
        warningErr.code = code;
    }
    if (detail !== undefined) {
        warningErr.detail = detail;
    }
    Error.captureStackTrace(warningErr, ctor || process2.emitWarning);
    return warningErr;
}
function doEmitWarning(warning) {
    process2.emit("warning", warning);
}
function emitWarning1(warning, type, code, ctor) {
    let detail;
    if (type !== null && typeof type === "object" && !Array.isArray(type)) {
        ctor = type.ctor;
        code = type.code;
        if (typeof type.detail === "string") {
            detail = type.detail;
        }
        type = type.type || "Warning";
    } else if (typeof type === "function") {
        ctor = type;
        code = undefined;
        type = "Warning";
    }
    if (type !== undefined) {
        validateString(type, "type");
    }
    if (typeof code === "function") {
        ctor = code;
        code = undefined;
    } else if (code !== undefined) {
        validateString(code, "code");
    }
    if (typeof warning === "string") {
        warning = createWarningObject(warning, type, code, ctor, detail);
    } else if (!(warning instanceof Error)) {
        throw new ERR_INVALID_ARG_TYPE("warning", [
            "Error",
            "string"
        ], warning);
    }
    if (warning.name === "DeprecationWarning") {
        if (process2.noDeprecation) {
            return;
        }
        if (process2.throwDeprecation) {
            return process2.nextTick(()=>{
                throw warning;
            });
        }
    }
    process2.nextTick(doEmitWarning, warning);
}
function hrtime(time) {
    const milli = performance.now();
    const sec = Math.floor(milli / 1000);
    const nano = Math.floor(milli * 1_000_000 - sec * 1_000_000_000);
    if (!time) {
        return [
            sec,
            nano
        ];
    }
    const [prevSec, prevNano] = time;
    return [
        sec - prevSec,
        nano - prevNano
    ];
}
hrtime.bigint = function() {
    const [sec, nano] = hrtime();
    return BigInt(sec) * 1_000_000_000n + BigInt(nano);
};
function memoryUsage() {
    return {
        ...Deno.memoryUsage(),
        arrayBuffers: 0
    };
}
memoryUsage.rss = function() {
    return memoryUsage().rss;
};
function _kill(pid, sig) {
    let errCode;
    if (sig === 0) {
        let status;
        if (Deno.build.os === "windows") {
            status = new DenoCommand("powershell.exe", {
                args: [
                    "Get-Process",
                    "-pid",
                    pid
                ]
            }).outputSync();
        } else {
            status = new DenoCommand("kill", {
                args: [
                    "-0",
                    pid
                ]
            }).outputSync();
        }
        if (!status.success) {
            errCode = codeMap.get("ESRCH");
        }
    } else {
        const maybeSignal = Object.entries(os.signals).find(([_, numericCode])=>numericCode === sig);
        if (!maybeSignal) {
            errCode = codeMap.get("EINVAL");
        } else {
            try {
                Deno.kill(pid, maybeSignal[0]);
            } catch (e) {
                if (e instanceof TypeError) {
                    throw notImplemented(maybeSignal[0]);
                }
                throw e;
            }
        }
    }
    if (!errCode) {
        return 0;
    } else {
        return errCode;
    }
}
function kill(pid, sig = "SIGTERM") {
    if (pid != (pid | 0)) {
        throw new ERR_INVALID_ARG_TYPE("pid", "number", pid);
    }
    let err;
    if (typeof sig === "number") {
        err = process2._kill(pid, sig);
    } else {
        if (sig in os.signals) {
            err = process2._kill(pid, os.signals[sig]);
        } else {
            throw new ERR_UNKNOWN_SIGNAL(sig);
        }
    }
    if (err) {
        throw errnoException(err, "kill");
    }
    return true;
}
function uncaughtExceptionHandler(err, origin) {
    process2.emit("uncaughtExceptionMonitor", err, origin);
    process2.emit("uncaughtException", err, origin);
}
let execPath = null;
class Process extends EventEmitter {
    constructor(){
        super();
        globalThis.addEventListener("unhandledrejection", (event)=>{
            if (process2.listenerCount("unhandledRejection") === 0) {
                if (process2.listenerCount("uncaughtException") === 0) {
                    throw event.reason;
                }
                event.preventDefault();
                uncaughtExceptionHandler(event.reason, "unhandledRejection");
                return;
            }
            event.preventDefault();
            process2.emit("unhandledRejection", event.reason, event.promise);
        });
        globalThis.addEventListener("error", (event)=>{
            if (process2.listenerCount("uncaughtException") > 0) {
                event.preventDefault();
            }
            uncaughtExceptionHandler(event.error, "uncaughtException");
        });
        globalThis.addEventListener("beforeunload", (e)=>{
            super.emit("beforeExit", process2.exitCode || 0);
            processTicksAndRejections();
            if (core.eventLoopHasMoreWork()) {
                e.preventDefault();
            }
        });
        globalThis.addEventListener("unload", ()=>{
            if (!process2._exiting) {
                process2._exiting = true;
                super.emit("exit", process2.exitCode || 0);
            }
        });
    }
    arch = arch;
    argv = argv;
    chdir = chdir;
    config = {
        target_defaults: {},
        variables: {}
    };
    cwd = cwd;
    env = env;
    execArgv = [];
    exit = exit;
    _exiting = _exiting;
    exitCode = undefined;
    mainModule = undefined;
    nextTick = nextTick1;
    on(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.on("${event}")`);
            super.on(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else if (event === "SIGTERM" && Deno.build.os === "windows") {} else {
                Deno.addSignalListener(event, listener);
            }
        } else {
            super.on(event, listener);
        }
        return this;
    }
    off(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.off("${event}")`);
            super.off(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else if (event === "SIGTERM" && Deno.build.os === "windows") {} else {
                Deno.removeSignalListener(event, listener);
            }
        } else {
            super.off(event, listener);
        }
        return this;
    }
    emit(event, ...args) {
        if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                Deno.kill(Deno.pid, event);
            }
        } else {
            return super.emit(event, ...args);
        }
        return true;
    }
    prependListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.prependListener("${event}")`);
            super.prependListener(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                Deno.addSignalListener(event, listener);
            }
        } else {
            super.prependListener(event, listener);
        }
        return this;
    }
    pid = pid;
    platform = platform;
    addListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.addListener("${event}")`);
        }
        return this.on(event, listener);
    }
    removeListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.removeListener("${event}")`);
        }
        return this.off(event, listener);
    }
    hrtime = hrtime;
    _kill = _kill;
    kill = kill;
    memoryUsage = memoryUsage;
    stderr = stderr;
    stdin = stdin;
    stdout = stdout;
    version = version;
    versions = versions;
    emitWarning = emitWarning1;
    binding(name) {
        return getBinding(name);
    }
    umask() {
        return 0o22;
    }
    getgid() {
        return Deno.gid();
    }
    getuid() {
        return Deno.uid();
    }
    _eval = undefined;
    get execPath() {
        if (execPath) {
            return execPath;
        }
        execPath = Deno.execPath();
        return execPath;
    }
    set execPath(path) {
        execPath = path;
    }
    #startTime = Date.now();
    uptime() {
        return (Date.now() - this.#startTime) / 1000;
    }
    #allowedFlags = buildAllowedFlags();
    get allowedNodeEnvironmentFlags() {
        return this.#allowedFlags;
    }
    features = {
        inspector: false
    };
    noDeprecation = false;
}
if (Deno.build.os === "windows") {
    delete Process.prototype.getgid;
    delete Process.prototype.getuid;
}
const process2 = new Process();
Object.defineProperty(process2, Symbol.toStringTag, {
    enumerable: false,
    writable: true,
    configurable: false,
    value: "process"
});
addReadOnlyProcessAlias("noDeprecation", "--no-deprecation");
addReadOnlyProcessAlias("throwDeprecation", "--throw-deprecation");
process2.removeListener;
process2.removeAllListeners;
const setTimeout_ = globalThis.setTimeout;
const clearTimeout_ = globalThis.clearTimeout;
const setInterval_ = globalThis.setInterval;
const TIMEOUT_MAX = 2 ** 31 - 1;
const kTimerId = Symbol("timerId");
const kTimeout = Symbol("timeout");
const kRefed = Symbol("refed");
const createTimer = Symbol("createTimer");
function Timeout(callback, after, args, isRepeat, isRefed) {
    if (typeof after === "number" && after > TIMEOUT_MAX) {
        after = 1;
    }
    this._idleTimeout = after;
    this._onTimeout = callback;
    this._timerArgs = args;
    this._isRepeat = isRepeat;
    this[kRefed] = isRefed;
    this[kTimerId] = this[createTimer]();
}
Timeout.prototype[createTimer] = function() {
    const callback = this._onTimeout;
    const cb = (...args)=>callback.bind(this)(...args);
    const id = this._isRepeat ? setInterval_(cb, this._idleTimeout, ...this._timerArgs) : setTimeout_(cb, this._idleTimeout, ...this._timerArgs);
    if (!this[kRefed]) {
        Deno.unrefTimer(id);
    }
    return id;
};
Timeout.prototype[inspect.custom] = function(_, options) {
    return inspect(this, {
        ...options,
        depth: 0,
        customInspect: false
    });
};
Timeout.prototype.refresh = function() {
    clearTimeout_(this[kTimerId]);
    this[kTimerId] = this[createTimer]();
    return this;
};
Timeout.prototype.unref = function() {
    if (this[kRefed]) {
        this[kRefed] = false;
        Deno.unrefTimer(this[kTimerId]);
    }
    return this;
};
Timeout.prototype.ref = function() {
    if (!this[kRefed]) {
        this[kRefed] = true;
        Deno.refTimer(this[kTimerId]);
    }
    return this;
};
Timeout.prototype.hasRef = function() {
    return this[kRefed];
};
Timeout.prototype[Symbol.toPrimitive] = function() {
    return this[kTimerId];
};
function getTimerDuration(msecs, name) {
    validateNumber(msecs, name);
    if (msecs < 0 || !Number.isFinite(msecs)) {
        throw new ERR_OUT_OF_RANGE(name, "a non-negative finite number", msecs);
    }
    if (msecs > TIMEOUT_MAX) {
        emitWarning1(`${msecs} does not fit into a 32-bit signed integer.` + `\nTimer duration was truncated to ${TIMEOUT_MAX}.`, "TimeoutOverflowWarning");
        return TIMEOUT_MAX;
    }
    return msecs;
}
function setUnrefTimeout(callback, timeout, ...args) {
    validateFunction(callback, "callback");
    return new Timeout(callback, timeout, args, false, false);
}
const __default9 = {
    getTimerDuration,
    kTimerId,
    kTimeout,
    setUnrefTimeout,
    Timeout,
    TIMEOUT_MAX
};
const clearTimeout_1 = globalThis.clearTimeout;
const clearInterval_ = globalThis.clearInterval;
function setTimeout1(callback, timeout, ...args) {
    validateFunction(callback, "callback");
    return new Timeout(callback, timeout, args, false, true);
}
Object.defineProperty(setTimeout1, promisify.custom, {
    value: (timeout, ...args)=>{
        return new Promise((cb)=>setTimeout1(cb, timeout, ...args));
    },
    enumerable: true
});
function clearTimeout1(timeout) {
    if (timeout == null) {
        return;
    }
    clearTimeout_1(+timeout);
}
function setInterval(callback, timeout, ...args) {
    validateFunction(callback, "callback");
    return new Timeout(callback, timeout, args, true, true);
}
function clearInterval(timeout) {
    if (timeout == null) {
        return;
    }
    clearInterval_(+timeout);
}
const setImmediate = (cb, ...args)=>setTimeout1(cb, 0, ...args);
const clearImmediate = clearTimeout1;
const __default10 = {
    setTimeout: setTimeout1,
    clearTimeout: clearTimeout1,
    setInterval,
    clearInterval,
    setImmediate,
    setUnrefTimeout,
    clearImmediate
};
Object.defineProperty(globalThis, "global", {
    value: new Proxy(globalThis, {
        get (target, prop, receiver) {
            switch(prop){
                case "setInterval":
                    return setInterval;
                case "setTimeout":
                    return setTimeout1;
                case "clearInterval":
                    return clearInterval;
                case "clearTimeout":
                    return clearTimeout1;
                default:
                    return Reflect.get(target, prop, receiver);
            }
        }
    }),
    writable: false,
    enumerable: false,
    configurable: true
});
Object.defineProperty(globalThis, "process", {
    value: process2,
    enumerable: false,
    writable: true,
    configurable: true
});
Object.defineProperty(globalThis, "Buffer", {
    value: Buffer1,
    enumerable: false,
    writable: true,
    configurable: true
});
Object.defineProperty(globalThis, "setImmediate", {
    value: __default10.setImmediate,
    enumerable: true,
    writable: true,
    configurable: true
});
Object.defineProperty(globalThis, "clearImmediate", {
    value: __default10.clearImmediate,
    enumerable: true,
    writable: true,
    configurable: true
});
const active_hooks = {
    array: [],
    call_depth: 0,
    tmp_array: null,
    tmp_fields: null
};
mod9.registerDestroyHook;
const { async_hook_fields , asyncIdFields: async_id_fields , newAsyncId: newAsyncId1 , constants: constants4  } = mod9;
const { kInit , kBefore , kAfter , kDestroy: kDestroy1 , kPromiseResolve , kTotals , kCheck , kDefaultTriggerAsyncId , kStackLength  } = constants4;
Symbol("resource");
const async_id_symbol = Symbol("trigger_async_id");
const trigger_async_id_symbol = Symbol("trigger_async_id");
const init_symbol = Symbol("init");
const before_symbol = Symbol("before");
const after_symbol = Symbol("after");
const destroy_symbol = Symbol("destroy");
const promise_resolve_symbol = Symbol("promiseResolve");
const symbols = {
    async_id_symbol,
    trigger_async_id_symbol,
    init_symbol,
    before_symbol,
    after_symbol,
    destroy_symbol,
    promise_resolve_symbol
};
function getHookArrays() {
    if (active_hooks.call_depth === 0) {
        return [
            active_hooks.array,
            async_hook_fields
        ];
    }
    if (active_hooks.tmp_array === null) {
        storeActiveHooks();
    }
    return [
        active_hooks.tmp_array,
        active_hooks.tmp_fields
    ];
}
function storeActiveHooks() {
    active_hooks.tmp_array = active_hooks.array.slice();
    active_hooks.tmp_fields = [];
    copyHooks(active_hooks.tmp_fields, async_hook_fields);
}
function copyHooks(destination, source) {
    destination[kInit] = source[kInit];
    destination[kBefore] = source[kBefore];
    destination[kAfter] = source[kAfter];
    destination[kDestroy1] = source[kDestroy1];
    destination[kPromiseResolve] = source[kPromiseResolve];
}
function enableHooks() {
    async_hook_fields[kCheck] += 1;
}
function disableHooks() {
    async_hook_fields[kCheck] -= 1;
    false;
}
function defaultTriggerAsyncIdScope(triggerAsyncId, block, ...args) {
    if (triggerAsyncId === undefined) {
        return block.apply(null, args);
    }
    const oldDefaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];
    async_id_fields[kDefaultTriggerAsyncId] = triggerAsyncId;
    try {
        return block.apply(null, args);
    } finally{
        async_id_fields[kDefaultTriggerAsyncId] = oldDefaultTriggerAsyncId;
    }
}
class AsyncHook {
    [init_symbol];
    [before_symbol];
    [after_symbol];
    [destroy_symbol];
    [promise_resolve_symbol];
    constructor({ init , before , after , destroy , promiseResolve  }){
        if (init !== undefined && typeof init !== "function") {
            throw new ERR_ASYNC_CALLBACK("hook.init");
        }
        if (before !== undefined && typeof before !== "function") {
            throw new ERR_ASYNC_CALLBACK("hook.before");
        }
        if (after !== undefined && typeof after !== "function") {
            throw new ERR_ASYNC_CALLBACK("hook.after");
        }
        if (destroy !== undefined && typeof destroy !== "function") {
            throw new ERR_ASYNC_CALLBACK("hook.destroy");
        }
        if (promiseResolve !== undefined && typeof promiseResolve !== "function") {
            throw new ERR_ASYNC_CALLBACK("hook.promiseResolve");
        }
        this[init_symbol] = init;
        this[before_symbol] = before;
        this[after_symbol] = after;
        this[destroy_symbol] = destroy;
        this[promise_resolve_symbol] = promiseResolve;
    }
    enable() {
        const { 0: hooks_array , 1: hook_fields  } = getHookArrays();
        if (hooks_array.includes(this)) {
            return this;
        }
        const prev_kTotals = hook_fields[kTotals];
        hook_fields[kTotals] = hook_fields[kInit] += +!!this[init_symbol];
        hook_fields[kTotals] += hook_fields[kBefore] += +!!this[before_symbol];
        hook_fields[kTotals] += hook_fields[kAfter] += +!!this[after_symbol];
        hook_fields[kTotals] += hook_fields[kDestroy1] += +!!this[destroy_symbol];
        hook_fields[kTotals] += hook_fields[kPromiseResolve] += +!!this[promise_resolve_symbol];
        hooks_array.push(this);
        if (prev_kTotals === 0 && hook_fields[kTotals] > 0) {
            enableHooks();
        }
        return this;
    }
    disable() {
        const { 0: hooks_array , 1: hook_fields  } = getHookArrays();
        const index = hooks_array.indexOf(this);
        if (index === -1) {
            return this;
        }
        const prev_kTotals = hook_fields[kTotals];
        hook_fields[kTotals] = hook_fields[kInit] -= +!!this[init_symbol];
        hook_fields[kTotals] += hook_fields[kBefore] -= +!!this[before_symbol];
        hook_fields[kTotals] += hook_fields[kAfter] -= +!!this[after_symbol];
        hook_fields[kTotals] += hook_fields[kDestroy1] -= +!!this[destroy_symbol];
        hook_fields[kTotals] += hook_fields[kPromiseResolve] -= +!!this[promise_resolve_symbol];
        hooks_array.splice(index, 1);
        if (prev_kTotals > 0 && hook_fields[kTotals] === 0) {
            disableHooks();
        }
        return this;
    }
}
const kMaybeDestroy = Symbol("kMaybeDestroy");
const kUpdateTimer = Symbol("kUpdateTimer");
const kAfterAsyncWrite = Symbol("kAfterAsyncWrite");
const kHandle1 = Symbol("kHandle");
const kSession = Symbol("kSession");
const kBuffer = Symbol("kBuffer");
const kBufferGen = Symbol("kBufferGen");
const kBufferCb = Symbol("kBufferCb");
function handleWriteReq(req, data, encoding) {
    const { handle  } = req;
    switch(encoding){
        case "buffer":
            {
                const ret = handle.writeBuffer(req, data);
                if (streamBaseState[kLastWriteWasAsync]) {
                    req.buffer = data;
                }
                return ret;
            }
        case "latin1":
        case "binary":
            return handle.writeLatin1String(req, data);
        case "utf8":
        case "utf-8":
            return handle.writeUtf8String(req, data);
        case "ascii":
            return handle.writeAsciiString(req, data);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return handle.writeUcs2String(req, data);
        default:
            {
                const buffer = Buffer1.from(data, encoding);
                const ret = handle.writeBuffer(req, buffer);
                if (streamBaseState[kLastWriteWasAsync]) {
                    req.buffer = buffer;
                }
                return ret;
            }
    }
}
function onWriteComplete(status) {
    let stream = this.handle[ownerSymbol];
    if (stream.constructor.name === "ReusedHandle") {
        stream = stream.handle;
    }
    if (stream.destroyed) {
        if (typeof this.callback === "function") {
            this.callback(null);
        }
        return;
    }
    if (status < 0) {
        const ex = errnoException(status, "write", this.error);
        if (typeof this.callback === "function") {
            this.callback(ex);
        } else {
            stream.destroy(ex);
        }
        return;
    }
    stream[kUpdateTimer]();
    stream[kAfterAsyncWrite](this);
    if (typeof this.callback === "function") {
        this.callback(null);
    }
}
function createWriteWrap(handle, callback) {
    const req = new WriteWrap();
    req.handle = handle;
    req.oncomplete = onWriteComplete;
    req.async = false;
    req.bytes = 0;
    req.buffer = null;
    req.callback = callback;
    return req;
}
function writevGeneric(owner, data, cb) {
    const req = createWriteWrap(owner[kHandle1], cb);
    const allBuffers = data.allBuffers;
    let chunks;
    if (allBuffers) {
        chunks = data;
        for(let i = 0; i < data.length; i++){
            data[i] = data[i].chunk;
        }
    } else {
        chunks = new Array(data.length << 1);
        for(let i = 0; i < data.length; i++){
            const entry = data[i];
            chunks[i * 2] = entry.chunk;
            chunks[i * 2 + 1] = entry.encoding;
        }
    }
    const err = req.handle.writev(req, chunks, allBuffers);
    if (err === 0) {
        req._chunks = chunks;
    }
    afterWriteDispatched(req, err, cb);
    return req;
}
function writeGeneric(owner, data, encoding, cb) {
    const req = createWriteWrap(owner[kHandle1], cb);
    const err = handleWriteReq(req, data, encoding);
    afterWriteDispatched(req, err, cb);
    return req;
}
function afterWriteDispatched(req, err, cb) {
    req.bytes = streamBaseState[kBytesWritten];
    req.async = !!streamBaseState[kLastWriteWasAsync];
    if (err !== 0) {
        return cb(errnoException(err, "write", req.error));
    }
    if (!req.async && typeof req.callback === "function") {
        req.callback();
    }
}
function onStreamRead(arrayBuffer, nread) {
    const handle = this;
    let stream = this[ownerSymbol];
    if (stream.constructor.name === "ReusedHandle") {
        stream = stream.handle;
    }
    stream[kUpdateTimer]();
    if (nread > 0 && !stream.destroyed) {
        let ret;
        let result;
        const userBuf = stream[kBuffer];
        if (userBuf) {
            result = stream[kBufferCb](nread, userBuf) !== false;
            const bufGen = stream[kBufferGen];
            if (bufGen !== null) {
                const nextBuf = bufGen();
                if (isUint8Array(nextBuf)) {
                    stream[kBuffer] = ret = nextBuf;
                }
            }
        } else {
            const offset = streamBaseState[kArrayBufferOffset];
            const buf = Buffer1.from(arrayBuffer, offset, nread);
            result = stream.push(buf);
        }
        if (!result) {
            handle.reading = false;
            if (!stream.destroyed) {
                const err = handle.readStop();
                if (err) {
                    stream.destroy(errnoException(err, "read"));
                }
            }
        }
        return ret;
    }
    if (nread === 0) {
        return;
    }
    if (nread !== codeMap.get("EOF")) {
        stream.destroy(errnoException(nread, "read"));
        return;
    }
    if (stream._readableState.endEmitted) {
        if (stream[kMaybeDestroy]) {
            stream[kMaybeDestroy]();
        }
    } else {
        if (stream[kMaybeDestroy]) {
            stream.on("end", stream[kMaybeDestroy]);
        }
        if (handle.readStop) {
            const err = handle.readStop();
            if (err) {
                stream.destroy(errnoException(err, "read"));
                return;
            }
        }
        stream.push(null);
        stream.read(0);
    }
}
function setStreamTimeout(msecs, callback) {
    if (this.destroyed) {
        return this;
    }
    this.timeout = msecs;
    msecs = getTimerDuration(msecs, "msecs");
    clearTimeout(this[kTimeout]);
    if (msecs === 0) {
        if (callback !== undefined) {
            validateFunction(callback, "callback");
            this.removeListener("timeout", callback);
        }
    } else {
        this[kTimeout] = setUnrefTimeout(this._onTimeout.bind(this), msecs);
        if (this[kSession]) {
            this[kSession][kUpdateTimer]();
        }
        if (callback !== undefined) {
            validateFunction(callback, "callback");
            this.once("timeout", callback);
        }
    }
    return this;
}
const { DTRACE_HTTP_CLIENT_REQUEST =(..._args)=>{} , DTRACE_HTTP_CLIENT_RESPONSE =(..._args)=>{} , DTRACE_HTTP_SERVER_REQUEST =(..._args)=>{} , DTRACE_HTTP_SERVER_RESPONSE =(..._args)=>{} , DTRACE_NET_SERVER_CONNECTION =(..._args)=>{} , DTRACE_NET_STREAM_END =(..._args)=>{}  } = {};
function isLookupOptions(options) {
    return typeof options === "object" || typeof options === "undefined";
}
function isLookupCallback(options) {
    return typeof options === "function";
}
function isFamily(options) {
    return typeof options === "number";
}
function isResolveCallback(callback) {
    return typeof callback === "function";
}
const IPv6RE = /^\[([^[\]]*)\]/;
const addrSplitRE = /(^.+?)(?::(\d+))?$/;
function validateTimeout(options) {
    const { timeout =-1  } = {
        ...options
    };
    validateInt32(timeout, "options.timeout", -1, 2 ** 31 - 1);
    return timeout;
}
function validateTries(options) {
    const { tries =4  } = {
        ...options
    };
    validateInt32(tries, "options.tries", 1, 2 ** 31 - 1);
    return tries;
}
class Resolver {
    _handle;
    constructor(options){
        const timeout = validateTimeout(options);
        const tries = validateTries(options);
        this._handle = new ChannelWrap(timeout, tries);
    }
    cancel() {
        this._handle.cancel();
    }
    getServers() {
        return this._handle.getServers().map((val)=>{
            if (!val[1] || val[1] === 53) {
                return val[0];
            }
            const host = isIP(val[0]) === 6 ? `[${val[0]}]` : val[0];
            return `${host}:${val[1]}`;
        });
    }
    setServers(servers) {
        validateArray(servers, "servers");
        const orig = this._handle.getServers();
        const newSet = [];
        servers.forEach((serv, index)=>{
            validateString(serv, `servers[${index}]`);
            let ipVersion = isIP(serv);
            if (ipVersion !== 0) {
                return newSet.push([
                    ipVersion,
                    serv,
                    53
                ]);
            }
            const match = serv.match(IPv6RE);
            if (match) {
                ipVersion = isIP(match[1]);
                if (ipVersion !== 0) {
                    const port = Number.parseInt(serv.replace(addrSplitRE, "$2")) || 53;
                    return newSet.push([
                        ipVersion,
                        match[1],
                        port
                    ]);
                }
            }
            const addrSplitMatch = serv.match(addrSplitRE);
            if (addrSplitMatch) {
                const hostIP = addrSplitMatch[1];
                const port = addrSplitMatch[2] || `${53}`;
                ipVersion = isIP(hostIP);
                if (ipVersion !== 0) {
                    return newSet.push([
                        ipVersion,
                        hostIP,
                        Number.parseInt(port)
                    ]);
                }
            }
            throw new ERR_INVALID_IP_ADDRESS(serv);
        });
        const errorNumber = this._handle.setServers(newSet);
        if (errorNumber !== 0) {
            this._handle.setServers(orig.join(","));
            const err = strerror(errorNumber);
            throw new ERR_DNS_SET_SERVERS_FAILED(err, servers.toString());
        }
    }
    setLocalAddress(ipv4, ipv6) {
        validateString(ipv4, "ipv4");
        if (ipv6 !== undefined) {
            validateString(ipv6, "ipv6");
        }
        this._handle.setLocalAddress(ipv4, ipv6);
    }
}
let defaultResolver = new Resolver();
function getDefaultResolver() {
    return defaultResolver;
}
function setDefaultResolver(resolver) {
    defaultResolver = resolver;
}
function validateHints(hints) {
    if ((hints & ~(AI_ADDRCONFIG | AI_ALL | AI_V4MAPPED)) !== 0) {
        throw new ERR_INVALID_ARG_VALUE("hints", hints, "is invalid");
    }
}
let invalidHostnameWarningEmitted = false;
function emitInvalidHostnameWarning(hostname) {
    if (invalidHostnameWarningEmitted) {
        return;
    }
    invalidHostnameWarningEmitted = true;
    emitWarning1(`The provided hostname "${hostname}" is not a valid ` + "hostname, and is supported in the dns module solely for compatibility.", "DeprecationWarning", "DEP0118");
}
let dnsOrder = getOptionValue("--dns-result-order") || "ipv4first";
function getDefaultVerbatim() {
    switch(dnsOrder){
        case "verbatim":
            {
                return true;
            }
        case "ipv4first":
            {
                return false;
            }
        default:
            {
                return false;
            }
    }
}
function setDefaultResultOrder(order) {
    validateOneOf(order, "dnsOrder", [
        "verbatim",
        "ipv4first"
    ]);
    dnsOrder = order;
}
"use strict";
const base = 36;
const damp = 700;
const delimiter3 = "-";
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7E]/;
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
const errors = {
    "overflow": "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
};
const baseMinusTMin = 36 - 1;
const floor = Math.floor;
function error(type) {
    throw new RangeError(errors[type]);
}
function mapDomain(str, fn) {
    const parts = str.split("@");
    let result = "";
    if (parts.length > 1) {
        result = parts[0] + "@";
        str = parts[1];
    }
    str = str.replace(regexSeparators, "\x2E");
    const labels = str.split(".");
    const encoded = labels.map(fn).join(".");
    return result + encoded;
}
function ucs2decode(str) {
    const output = [];
    let counter = 0;
    const length = str.length;
    while(counter < length){
        const value = str.charCodeAt(counter++);
        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
            const extra = str.charCodeAt(counter++);
            if ((extra & 0xFC00) == 0xDC00) {
                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
            } else {
                output.push(value);
                counter--;
            }
        } else {
            output.push(value);
        }
    }
    return output;
}
function ucs2encode(array) {
    return String.fromCodePoint(...array);
}
const ucs2 = {
    decode: ucs2decode,
    encode: ucs2encode
};
function basicToDigit(codePoint) {
    if (codePoint - 0x30 < 0x0A) {
        return codePoint - 0x16;
    }
    if (codePoint - 0x41 < 0x1A) {
        return codePoint - 0x41;
    }
    if (codePoint - 0x61 < 0x1A) {
        return codePoint - 0x61;
    }
    return 36;
}
function digitToBasic(digit, flag) {
    return digit + 22 + 75 * Number(digit < 26) - (Number(flag != 0) << 5);
}
function adapt(delta, numPoints, firstTime) {
    let k = 0;
    delta = firstTime ? Math.floor(delta / damp) : delta >> 1;
    delta += Math.floor(delta / numPoints);
    for(; delta > baseMinusTMin * 26 >> 1; k += base){
        delta = Math.floor(delta / baseMinusTMin);
    }
    return Math.floor(k + (baseMinusTMin + 1) * delta / (delta + 38));
}
function decode2(input) {
    const output = [];
    const inputLength = input.length;
    let i = 0;
    let n = 128;
    let bias = 72;
    let basic = input.lastIndexOf(delimiter3);
    if (basic < 0) {
        basic = 0;
    }
    for(let j = 0; j < basic; ++j){
        if (input.charCodeAt(j) >= 0x80) {
            error("not-basic");
        }
        output.push(input.charCodeAt(j));
    }
    for(let index = basic > 0 ? basic + 1 : 0; index < inputLength;){
        const oldi = i;
        for(let w = 1, k = 36;; k += base){
            if (index >= inputLength) {
                error("invalid-input");
            }
            const digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= 36 || digit > floor((2147483647 - i) / w)) {
                error("overflow");
            }
            i += digit * w;
            const t = k <= bias ? 1 : k >= bias + 26 ? 26 : k - bias;
            if (digit < t) {
                break;
            }
            const baseMinusT = 36 - t;
            if (w > floor(2147483647 / baseMinusT)) {
                error("overflow");
            }
            w *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > 2147483647 - n) {
            error("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
    }
    return String.fromCodePoint(...output);
}
function encode2(str) {
    const output = [];
    const input = ucs2decode(str);
    const inputLength = input.length;
    let n = 128;
    let delta = 0;
    let bias = 72;
    for (const currentValue of input){
        if (currentValue < 0x80) {
            output.push(String.fromCharCode(currentValue));
        }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
        output.push(delimiter3);
    }
    while(handledCPCount < inputLength){
        let m = 2147483647;
        for (const currentValue of input){
            if (currentValue >= n && currentValue < m) {
                m = currentValue;
            }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > Math.floor((2147483647 - delta) / handledCPCountPlusOne)) {
            error("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (const currentValue of input){
            if (currentValue < n && ++delta > 2147483647) {
                error("overflow");
            }
            if (currentValue == n) {
                let q = delta;
                for(let k = 36;; k += base){
                    const t = k <= bias ? 1 : k >= bias + 26 ? 26 : k - bias;
                    if (q < t) {
                        break;
                    }
                    const qMinusT = q - t;
                    const baseMinusT = 36 - t;
                    output.push(String.fromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                    q = Math.floor(qMinusT / baseMinusT);
                }
                output.push(String.fromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
            }
        }
        ++delta;
        ++n;
    }
    return output.join("");
}
function toUnicode(input) {
    return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
    });
}
function toASCII(input) {
    return mapDomain(input, function(str) {
        return regexNonASCII.test(str) ? "xn--" + encode2(str) : str;
    });
}
function onlookup(err, addresses) {
    if (err) {
        this.reject(dnsException(err, "getaddrinfo", this.hostname));
        return;
    }
    const family = this.family || isIP(addresses[0]);
    this.resolve({
        address: addresses[0],
        family
    });
}
function onlookupall(err, addresses) {
    if (err) {
        this.reject(dnsException(err, "getaddrinfo", this.hostname));
        return;
    }
    const family = this.family;
    const parsedAddresses = [];
    for(let i = 0; i < addresses.length; i++){
        const address = addresses[i];
        parsedAddresses[i] = {
            address,
            family: family ? family : isIP(address)
        };
    }
    this.resolve(parsedAddresses);
}
function createLookupPromise(family, hostname, all, hints, verbatim) {
    return new Promise((resolve, reject)=>{
        if (!hostname) {
            emitInvalidHostnameWarning(hostname);
            resolve(all ? [] : {
                address: null,
                family: family === 6 ? 6 : 4
            });
            return;
        }
        const matchedFamily = isIP(hostname);
        if (matchedFamily !== 0) {
            const result = {
                address: hostname,
                family: matchedFamily
            };
            resolve(all ? [
                result
            ] : result);
            return;
        }
        const req = new GetAddrInfoReqWrap();
        req.family = family;
        req.hostname = hostname;
        req.oncomplete = all ? onlookupall : onlookup;
        req.resolve = resolve;
        req.reject = reject;
        const err = getaddrinfo(req, toASCII(hostname), family, hints, verbatim);
        if (err) {
            reject(dnsException(err, "getaddrinfo", hostname));
        }
    });
}
const validFamilies = [
    0,
    4,
    6
];
function lookup(hostname, options) {
    let hints = 0;
    let family = 0;
    let all = false;
    let verbatim = getDefaultVerbatim();
    if (hostname) {
        validateString(hostname, "hostname");
    }
    if (isFamily(options)) {
        validateOneOf(options, "family", validFamilies);
        family = options;
    } else if (!isLookupOptions(options)) {
        throw new ERR_INVALID_ARG_TYPE("options", [
            "integer",
            "object"
        ], options);
    } else {
        if (options?.hints != null) {
            validateNumber(options.hints, "options.hints");
            hints = options.hints >>> 0;
            validateHints(hints);
        }
        if (options?.family != null) {
            validateOneOf(options.family, "options.family", validFamilies);
            family = options.family;
        }
        if (options?.all != null) {
            validateBoolean(options.all, "options.all");
            all = options.all;
        }
        if (options?.verbatim != null) {
            validateBoolean(options.verbatim, "options.verbatim");
            verbatim = options.verbatim;
        }
    }
    return createLookupPromise(family, hostname, all, hints, verbatim);
}
function onresolve(err, records, ttls) {
    if (err) {
        this.reject(dnsException(err, this.bindingName, this.hostname));
        return;
    }
    const parsedRecords = ttls && this.ttl ? records.map((address, index)=>({
            address,
            ttl: ttls[index]
        })) : records;
    this.resolve(parsedRecords);
}
function createResolverPromise(resolver, bindingName, hostname, ttl) {
    return new Promise((resolve, reject)=>{
        const req = new QueryReqWrap();
        req.bindingName = bindingName;
        req.hostname = hostname;
        req.oncomplete = onresolve;
        req.resolve = resolve;
        req.reject = reject;
        req.ttl = ttl;
        const err = resolver._handle[bindingName](req, toASCII(hostname));
        if (err) {
            reject(dnsException(err, bindingName, hostname));
        }
    });
}
function resolver(bindingName) {
    function query(name, options) {
        validateString(name, "name");
        const ttl = !!(options && options.ttl);
        return createResolverPromise(this, bindingName, name, ttl);
    }
    Object.defineProperty(query, "name", {
        value: bindingName
    });
    return query;
}
const resolveMap = Object.create(null);
class Resolver1 extends Resolver {
}
Resolver1.prototype.resolveAny = resolveMap.ANY = resolver("queryAny");
Resolver1.prototype.resolve4 = resolveMap.A = resolver("queryA");
Resolver1.prototype.resolve6 = resolveMap.AAAA = resolver("queryAaaa");
Resolver1.prototype.resolveCaa = resolveMap.CAA = resolver("queryCaa");
Resolver1.prototype.resolveCname = resolveMap.CNAME = resolver("queryCname");
Resolver1.prototype.resolveMx = resolveMap.MX = resolver("queryMx");
Resolver1.prototype.resolveNs = resolveMap.NS = resolver("queryNs");
Resolver1.prototype.resolveTxt = resolveMap.TXT = resolver("queryTxt");
Resolver1.prototype.resolveSrv = resolveMap.SRV = resolver("querySrv");
Resolver1.prototype.resolvePtr = resolveMap.PTR = resolver("queryPtr");
Resolver1.prototype.resolveNaptr = resolveMap.NAPTR = resolver("queryNaptr");
Resolver1.prototype.resolveSoa = resolveMap.SOA = resolver("querySoa");
Resolver1.prototype.reverse = resolver("getHostByAddr");
Resolver1.prototype.resolve = _resolve;
function _resolve(hostname, rrtype) {
    let resolver;
    if (typeof hostname !== "string") {
        throw new ERR_INVALID_ARG_TYPE("name", "string", hostname);
    }
    if (rrtype !== undefined) {
        validateString(rrtype, "rrtype");
        resolver = resolveMap[rrtype];
        if (typeof resolver !== "function") {
            throw new ERR_INVALID_ARG_VALUE("rrtype", rrtype);
        }
    } else {
        resolver = resolveMap.A;
    }
    return Reflect.apply(resolver, this, [
        hostname
    ]);
}
function getServers() {
    return Resolver1.prototype.getServers.bind(getDefaultResolver())();
}
function resolveAny(hostname) {
    return Resolver1.prototype.resolveAny.bind(getDefaultResolver())(hostname);
}
function resolve4(hostname, options) {
    return Resolver1.prototype.resolve4.bind(getDefaultResolver())(hostname, options);
}
function resolve6(hostname, options) {
    return Resolver1.prototype.resolve6.bind(getDefaultResolver())(hostname, options);
}
function resolveCaa(hostname) {
    return Resolver1.prototype.resolveCaa.bind(getDefaultResolver())(hostname);
}
function resolveCname(hostname) {
    return Resolver1.prototype.resolveCname.bind(getDefaultResolver())(hostname);
}
function resolveMx(hostname) {
    return Resolver1.prototype.resolveMx.bind(getDefaultResolver())(hostname);
}
function resolveNs(hostname) {
    return Resolver1.prototype.resolveNs.bind(getDefaultResolver())(hostname);
}
function resolveTxt(hostname) {
    return Resolver1.prototype.resolveTxt.bind(getDefaultResolver())(hostname);
}
function resolveSrv(hostname) {
    return Resolver1.prototype.resolveSrv.bind(getDefaultResolver())(hostname);
}
function resolvePtr(hostname) {
    return Resolver1.prototype.resolvePtr.bind(getDefaultResolver())(hostname);
}
function resolveNaptr(hostname) {
    return Resolver1.prototype.resolveNaptr.bind(getDefaultResolver())(hostname);
}
function resolveSoa(hostname) {
    return Resolver1.prototype.resolveSoa.bind(getDefaultResolver())(hostname);
}
function reverse(ip) {
    return Resolver1.prototype.reverse.bind(getDefaultResolver())(ip);
}
function resolve3(hostname, rrtype) {
    return Resolver1.prototype.resolve.bind(getDefaultResolver())(hostname, rrtype);
}
const __default11 = {
    lookup,
    Resolver: Resolver1,
    getServers,
    resolveAny,
    resolve4,
    resolve6,
    resolveCaa,
    resolveCname,
    resolveMx,
    resolveNs,
    resolveTxt,
    resolveSrv,
    resolvePtr,
    resolveNaptr,
    resolveSoa,
    resolve: resolve3,
    reverse
};
function onlookup1(err, addresses) {
    if (err) {
        return this.callback(dnsException(err, "getaddrinfo", this.hostname));
    }
    this.callback(null, addresses[0], this.family || isIP(addresses[0]));
}
function onlookupall1(err, addresses) {
    if (err) {
        return this.callback(dnsException(err, "getaddrinfo", this.hostname));
    }
    const family = this.family;
    const parsedAddresses = [];
    for(let i = 0; i < addresses.length; i++){
        const addr = addresses[i];
        parsedAddresses[i] = {
            address: addr,
            family: family || isIP(addr)
        };
    }
    this.callback(null, parsedAddresses);
}
const validFamilies1 = [
    0,
    4,
    6
];
function lookup1(hostname, options, callback) {
    let hints = 0;
    let family = 0;
    let all = false;
    let verbatim = getDefaultVerbatim();
    if (hostname) {
        validateString(hostname, "hostname");
    }
    if (isLookupCallback(options)) {
        callback = options;
        family = 0;
    } else if (isFamily(options)) {
        validateFunction(callback, "callback");
        validateOneOf(options, "family", validFamilies1);
        family = options;
    } else if (!isLookupOptions(options)) {
        validateFunction(arguments.length === 2 ? options : callback, "callback");
        throw new ERR_INVALID_ARG_TYPE("options", [
            "integer",
            "object"
        ], options);
    } else {
        validateFunction(callback, "callback");
        if (options?.hints != null) {
            validateNumber(options.hints, "options.hints");
            hints = options.hints >>> 0;
            validateHints(hints);
        }
        if (options?.family != null) {
            validateOneOf(options.family, "options.family", validFamilies1);
            family = options.family;
        }
        if (options?.all != null) {
            validateBoolean(options.all, "options.all");
            all = options.all;
        }
        if (options?.verbatim != null) {
            validateBoolean(options.verbatim, "options.verbatim");
            verbatim = options.verbatim;
        }
    }
    if (!hostname) {
        emitInvalidHostnameWarning(hostname);
        if (all) {
            nextTick1(callback, null, []);
        } else {
            nextTick1(callback, null, null, family === 6 ? 6 : 4);
        }
        return {};
    }
    const matchedFamily = isIP(hostname);
    if (matchedFamily) {
        if (all) {
            nextTick1(callback, null, [
                {
                    address: hostname,
                    family: matchedFamily
                }
            ]);
        } else {
            nextTick1(callback, null, hostname, matchedFamily);
        }
        return {};
    }
    const req = new GetAddrInfoReqWrap();
    req.callback = callback;
    req.family = family;
    req.hostname = hostname;
    req.oncomplete = all ? onlookupall1 : onlookup1;
    const err = getaddrinfo(req, toASCII(hostname), family, hints, verbatim);
    if (err) {
        nextTick1(callback, dnsException(err, "getaddrinfo", hostname));
        return {};
    }
    return req;
}
Object.defineProperty(lookup1, customPromisifyArgs, {
    value: [
        "address",
        "family"
    ],
    enumerable: false
});
function onresolve1(err, records, ttls) {
    if (err) {
        this.callback(dnsException(err, this.bindingName, this.hostname));
        return;
    }
    const parsedRecords = ttls && this.ttl ? records.map((address, index)=>({
            address,
            ttl: ttls[index]
        })) : records;
    this.callback(null, parsedRecords);
}
function resolver1(bindingName) {
    function query(name, options, callback) {
        if (isResolveCallback(options)) {
            callback = options;
            options = {};
        }
        validateString(name, "name");
        validateFunction(callback, "callback");
        const req = new QueryReqWrap();
        req.bindingName = bindingName;
        req.callback = callback;
        req.hostname = name;
        req.oncomplete = onresolve1;
        if (options && options.ttl) {
            notImplemented("dns.resolve* with ttl option");
        }
        req.ttl = !!(options && options.ttl);
        const err = this._handle[bindingName](req, toASCII(name));
        if (err) {
            throw dnsException(err, bindingName, name);
        }
        return req;
    }
    Object.defineProperty(query, "name", {
        value: bindingName
    });
    return query;
}
const resolveMap1 = Object.create(null);
class Resolver2 extends Resolver {
    constructor(options){
        super(options);
    }
}
Resolver2.prototype.resolveAny = resolveMap1.ANY = resolver1("queryAny");
Resolver2.prototype.resolve4 = resolveMap1.A = resolver1("queryA");
Resolver2.prototype.resolve6 = resolveMap1.AAAA = resolver1("queryAaaa");
Resolver2.prototype.resolveCaa = resolveMap1.CAA = resolver1("queryCaa");
Resolver2.prototype.resolveCname = resolveMap1.CNAME = resolver1("queryCname");
Resolver2.prototype.resolveMx = resolveMap1.MX = resolver1("queryMx");
Resolver2.prototype.resolveNs = resolveMap1.NS = resolver1("queryNs");
Resolver2.prototype.resolveTxt = resolveMap1.TXT = resolver1("queryTxt");
Resolver2.prototype.resolveSrv = resolveMap1.SRV = resolver1("querySrv");
Resolver2.prototype.resolvePtr = resolveMap1.PTR = resolver1("queryPtr");
Resolver2.prototype.resolveNaptr = resolveMap1.NAPTR = resolver1("queryNaptr");
Resolver2.prototype.resolveSoa = resolveMap1.SOA = resolver1("querySoa");
Resolver2.prototype.reverse = resolver1("getHostByAddr");
Resolver2.prototype.resolve = _resolve1;
function _resolve1(hostname, rrtype, callback) {
    let resolver;
    if (typeof hostname !== "string") {
        throw new ERR_INVALID_ARG_TYPE("name", "string", hostname);
    }
    if (typeof rrtype === "string") {
        resolver = resolveMap1[rrtype];
    } else if (typeof rrtype === "function") {
        resolver = resolveMap1.A;
        callback = rrtype;
    } else {
        throw new ERR_INVALID_ARG_TYPE("rrtype", "string", rrtype);
    }
    if (typeof resolver === "function") {
        return Reflect.apply(resolver, this, [
            hostname,
            callback
        ]);
    }
    throw new ERR_INVALID_ARG_VALUE("rrtype", rrtype);
}
function setServers(servers) {
    const resolver = new Resolver2();
    resolver.setServers(servers);
    setDefaultResolver(resolver);
}
function getServers1() {
    return Resolver2.prototype.getServers.bind(getDefaultResolver())();
}
function resolveAny1(...args) {
    return Resolver2.prototype.resolveAny.bind(getDefaultResolver())(...args);
}
function resolve41(hostname, options, callback) {
    return Resolver2.prototype.resolve4.bind(getDefaultResolver())(hostname, options, callback);
}
function resolve61(hostname, options, callback) {
    return Resolver2.prototype.resolve6.bind(getDefaultResolver())(hostname, options, callback);
}
function resolveCaa1(...args) {
    return Resolver2.prototype.resolveCaa.bind(getDefaultResolver())(...args);
}
function resolveCname1(...args) {
    return Resolver2.prototype.resolveCname.bind(getDefaultResolver())(...args);
}
function resolveMx1(...args) {
    return Resolver2.prototype.resolveMx.bind(getDefaultResolver())(...args);
}
function resolveNs1(...args) {
    return Resolver2.prototype.resolveNs.bind(getDefaultResolver())(...args);
}
function resolveTxt1(...args) {
    return Resolver2.prototype.resolveTxt.bind(getDefaultResolver())(...args);
}
function resolveSrv1(...args) {
    return Resolver2.prototype.resolveSrv.bind(getDefaultResolver())(...args);
}
function resolvePtr1(...args) {
    return Resolver2.prototype.resolvePtr.bind(getDefaultResolver())(...args);
}
function resolveNaptr1(...args) {
    return Resolver2.prototype.resolveNaptr.bind(getDefaultResolver())(...args);
}
function resolveSoa1(...args) {
    return Resolver2.prototype.resolveSoa.bind(getDefaultResolver())(...args);
}
function reverse1(...args) {
    return Resolver2.prototype.reverse.bind(getDefaultResolver())(...args);
}
function resolve5(hostname, rrtype, callback) {
    return Resolver2.prototype.resolve.bind(getDefaultResolver())(hostname, rrtype, callback);
}
const NODATA = "ENODATA";
const FORMERR = "EFORMERR";
const SERVFAIL = "ESERVFAIL";
const NOTFOUND = "ENOTFOUND";
const NOTIMP = "ENOTIMP";
const REFUSED = "EREFUSED";
const BADQUERY = "EBADQUERY";
const BADNAME = "EBADNAME";
const BADFAMILY = "EBADFAMILY";
const BADRESP = "EBADRESP";
const CONNREFUSED = "ECONNREFUSED";
const TIMEOUT = "ETIMEOUT";
const EOF = "EOF";
const FILE = "EFILE";
const NOMEM = "ENOMEM";
const DESTRUCTION = "EDESTRUCTION";
const BADSTR = "EBADSTR";
const BADFLAGS = "EBADFLAGS";
const NONAME = "ENONAME";
const BADHINTS = "EBADHINTS";
const NOTINITIALIZED = "ENOTINITIALIZED";
const LOADIPHLPAPI = "ELOADIPHLPAPI";
const ADDRGETNETWORKPARAMS = "EADDRGETNETWORKPARAMS";
const CANCELLED = "ECANCELLED";
const promises = {
    ...__default11,
    setDefaultResultOrder,
    setServers,
    NODATA,
    FORMERR,
    SERVFAIL,
    NOTFOUND,
    NOTIMP,
    REFUSED,
    BADQUERY,
    BADNAME,
    BADFAMILY,
    BADRESP,
    CONNREFUSED,
    TIMEOUT,
    EOF,
    FILE,
    NOMEM,
    DESTRUCTION,
    BADSTR,
    BADFLAGS,
    NONAME,
    BADHINTS,
    NOTINITIALIZED,
    LOADIPHLPAPI,
    ADDRGETNETWORKPARAMS,
    CANCELLED
};
const __default12 = {
    ADDRCONFIG: AI_ADDRCONFIG,
    ALL: AI_ALL,
    V4MAPPED: AI_V4MAPPED,
    lookup: lookup1,
    getServers: getServers1,
    resolveAny: resolveAny1,
    resolve4: resolve41,
    resolve6: resolve61,
    resolveCaa: resolveCaa1,
    resolveCname: resolveCname1,
    resolveMx: resolveMx1,
    resolveNs: resolveNs1,
    resolveTxt: resolveTxt1,
    resolveSrv: resolveSrv1,
    resolvePtr: resolvePtr1,
    resolveNaptr: resolveNaptr1,
    resolveSoa: resolveSoa1,
    resolve: resolve5,
    Resolver: Resolver2,
    reverse: reverse1,
    setServers,
    setDefaultResultOrder,
    promises,
    NODATA,
    FORMERR,
    SERVFAIL,
    NOTFOUND,
    NOTIMP,
    REFUSED,
    BADQUERY,
    BADNAME,
    BADFAMILY,
    BADRESP,
    CONNREFUSED,
    TIMEOUT,
    EOF,
    FILE,
    NOMEM,
    DESTRUCTION,
    BADSTR,
    BADFLAGS,
    NONAME,
    BADHINTS,
    NOTINITIALIZED,
    LOADIPHLPAPI,
    ADDRGETNETWORKPARAMS,
    CANCELLED
};
var State;
(function(State) {
    State[State["PASSTHROUGH"] = 0] = "PASSTHROUGH";
    State[State["PERCENT"] = 1] = "PERCENT";
    State[State["POSITIONAL"] = 2] = "POSITIONAL";
    State[State["PRECISION"] = 3] = "PRECISION";
    State[State["WIDTH"] = 4] = "WIDTH";
})(State || (State = {}));
var WorP;
(function(WorP) {
    WorP[WorP["WIDTH"] = 0] = "WIDTH";
    WorP[WorP["PRECISION"] = 1] = "PRECISION";
})(WorP || (WorP = {}));
class Flags {
    plus;
    dash;
    sharp;
    space;
    zero;
    lessthan;
    width = -1;
    precision = -1;
}
const min = Math.min;
const UNICODE_REPLACEMENT_CHARACTER = "\ufffd";
const FLOAT_REGEXP = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var F;
(function(F) {
    F[F["sign"] = 1] = "sign";
    F[F["mantissa"] = 2] = "mantissa";
    F[F["fractional"] = 3] = "fractional";
    F[F["esign"] = 4] = "esign";
    F[F["exponent"] = 5] = "exponent";
})(F || (F = {}));
class Printf {
    format;
    args;
    i;
    state = State.PASSTHROUGH;
    verb = "";
    buf = "";
    argNum = 0;
    flags = new Flags();
    haveSeen;
    tmpError;
    constructor(format, ...args){
        this.format = format;
        this.args = args;
        this.haveSeen = Array.from({
            length: args.length
        });
        this.i = 0;
    }
    doPrintf() {
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State.PASSTHROUGH:
                    if (c === "%") {
                        this.state = State.PERCENT;
                    } else {
                        this.buf += c;
                    }
                    break;
                case State.PERCENT:
                    if (c === "%") {
                        this.buf += c;
                        this.state = State.PASSTHROUGH;
                    } else {
                        this.handleFormat();
                    }
                    break;
                default:
                    throw Error("Should be unreachable, certainly a bug in the lib.");
            }
        }
        let extras = false;
        let err = "%!(EXTRA";
        for(let i = 0; i !== this.haveSeen.length; ++i){
            if (!this.haveSeen[i]) {
                extras = true;
                err += ` '${Deno.inspect(this.args[i])}'`;
            }
        }
        err += ")";
        if (extras) {
            this.buf += err;
        }
        return this.buf;
    }
    handleFormat() {
        this.flags = new Flags();
        const flags = this.flags;
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State.PERCENT:
                    switch(c){
                        case "[":
                            this.handlePositional();
                            this.state = State.POSITIONAL;
                            break;
                        case "+":
                            flags.plus = true;
                            break;
                        case "<":
                            flags.lessthan = true;
                            break;
                        case "-":
                            flags.dash = true;
                            flags.zero = false;
                            break;
                        case "#":
                            flags.sharp = true;
                            break;
                        case " ":
                            flags.space = true;
                            break;
                        case "0":
                            flags.zero = !flags.dash;
                            break;
                        default:
                            if ("1" <= c && c <= "9" || c === "." || c === "*") {
                                if (c === ".") {
                                    this.flags.precision = 0;
                                    this.state = State.PRECISION;
                                    this.i++;
                                } else {
                                    this.state = State.WIDTH;
                                }
                                this.handleWidthAndPrecision(flags);
                            } else {
                                this.handleVerb();
                                return;
                            }
                    }
                    break;
                case State.POSITIONAL:
                    if (c === "*") {
                        const worp = this.flags.precision === -1 ? WorP.WIDTH : WorP.PRECISION;
                        this.handleWidthOrPrecisionRef(worp);
                        this.state = State.PERCENT;
                        break;
                    } else {
                        this.handleVerb();
                        return;
                    }
                default:
                    throw new Error(`Should not be here ${this.state}, library bug!`);
            }
        }
    }
    handleWidthOrPrecisionRef(wOrP) {
        if (this.argNum >= this.args.length) {
            return;
        }
        const arg = this.args[this.argNum];
        this.haveSeen[this.argNum] = true;
        if (typeof arg === "number") {
            switch(wOrP){
                case WorP.WIDTH:
                    this.flags.width = arg;
                    break;
                default:
                    this.flags.precision = arg;
            }
        } else {
            const tmp = wOrP === WorP.WIDTH ? "WIDTH" : "PREC";
            this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
        }
        this.argNum++;
    }
    handleWidthAndPrecision(flags) {
        const fmt = this.format;
        for(; this.i !== this.format.length; ++this.i){
            const c = fmt[this.i];
            switch(this.state){
                case State.WIDTH:
                    switch(c){
                        case ".":
                            this.flags.precision = 0;
                            this.state = State.PRECISION;
                            break;
                        case "*":
                            this.handleWidthOrPrecisionRef(WorP.WIDTH);
                            break;
                        default:
                            {
                                const val = parseInt(c);
                                if (isNaN(val)) {
                                    this.i--;
                                    this.state = State.PERCENT;
                                    return;
                                }
                                flags.width = flags.width == -1 ? 0 : flags.width;
                                flags.width *= 10;
                                flags.width += val;
                            }
                    }
                    break;
                case State.PRECISION:
                    {
                        if (c === "*") {
                            this.handleWidthOrPrecisionRef(WorP.PRECISION);
                            break;
                        }
                        const val = parseInt(c);
                        if (isNaN(val)) {
                            this.i--;
                            this.state = State.PERCENT;
                            return;
                        }
                        flags.precision *= 10;
                        flags.precision += val;
                        break;
                    }
                default:
                    throw new Error("can't be here. bug.");
            }
        }
    }
    handlePositional() {
        if (this.format[this.i] !== "[") {
            throw new Error("Can't happen? Bug.");
        }
        let positional = 0;
        const format = this.format;
        this.i++;
        let err = false;
        for(; this.i !== this.format.length; ++this.i){
            if (format[this.i] === "]") {
                break;
            }
            positional *= 10;
            const val = parseInt(format[this.i]);
            if (isNaN(val)) {
                this.tmpError = "%!(BAD INDEX)";
                err = true;
            }
            positional += val;
        }
        if (positional - 1 >= this.args.length) {
            this.tmpError = "%!(BAD INDEX)";
            err = true;
        }
        this.argNum = err ? this.argNum : positional - 1;
    }
    handleLessThan() {
        const arg = this.args[this.argNum];
        if ((arg || {}).constructor.name !== "Array") {
            throw new Error(`arg ${arg} is not an array. Todo better error handling`);
        }
        let str = "[ ";
        for(let i = 0; i !== arg.length; ++i){
            if (i !== 0) str += ", ";
            str += this._handleVerb(arg[i]);
        }
        return str + " ]";
    }
    handleVerb() {
        const verb = this.format[this.i];
        this.verb = verb;
        if (this.tmpError) {
            this.buf += this.tmpError;
            this.tmpError = undefined;
            if (this.argNum < this.haveSeen.length) {
                this.haveSeen[this.argNum] = true;
            }
        } else if (this.args.length <= this.argNum) {
            this.buf += `%!(MISSING '${verb}')`;
        } else {
            const arg = this.args[this.argNum];
            this.haveSeen[this.argNum] = true;
            if (this.flags.lessthan) {
                this.buf += this.handleLessThan();
            } else {
                this.buf += this._handleVerb(arg);
            }
        }
        this.argNum++;
        this.state = State.PASSTHROUGH;
    }
    _handleVerb(arg) {
        switch(this.verb){
            case "t":
                return this.pad(arg.toString());
            case "b":
                return this.fmtNumber(arg, 2);
            case "c":
                return this.fmtNumberCodePoint(arg);
            case "d":
                return this.fmtNumber(arg, 10);
            case "o":
                return this.fmtNumber(arg, 8);
            case "x":
                return this.fmtHex(arg);
            case "X":
                return this.fmtHex(arg, true);
            case "e":
                return this.fmtFloatE(arg);
            case "E":
                return this.fmtFloatE(arg, true);
            case "f":
            case "F":
                return this.fmtFloatF(arg);
            case "g":
                return this.fmtFloatG(arg);
            case "G":
                return this.fmtFloatG(arg, true);
            case "s":
                return this.fmtString(arg);
            case "T":
                return this.fmtString(typeof arg);
            case "v":
                return this.fmtV(arg);
            case "j":
                return this.fmtJ(arg);
            case "i":
                return this.fmtI(arg, false);
            case "I":
                return this.fmtI(arg, true);
            default:
                return `%!(BAD VERB '${this.verb}')`;
        }
    }
    pad(s) {
        const padding = this.flags.zero ? "0" : " ";
        if (this.flags.dash) {
            return s.padEnd(this.flags.width, padding);
        }
        return s.padStart(this.flags.width, padding);
    }
    padNum(nStr, neg) {
        let sign;
        if (neg) {
            sign = "-";
        } else if (this.flags.plus || this.flags.space) {
            sign = this.flags.plus ? "+" : " ";
        } else {
            sign = "";
        }
        const zero = this.flags.zero;
        if (!zero) {
            nStr = sign + nStr;
        }
        const pad = zero ? "0" : " ";
        const len = zero ? this.flags.width - sign.length : this.flags.width;
        if (this.flags.dash) {
            nStr = nStr.padEnd(len, pad);
        } else {
            nStr = nStr.padStart(len, pad);
        }
        if (zero) {
            nStr = sign + nStr;
        }
        return nStr;
    }
    fmtNumber(n, radix, upcase = false) {
        let num = Math.abs(n).toString(radix);
        const prec = this.flags.precision;
        if (prec !== -1) {
            this.flags.zero = false;
            num = n === 0 && prec === 0 ? "" : num;
            while(num.length < prec){
                num = "0" + num;
            }
        }
        let prefix = "";
        if (this.flags.sharp) {
            switch(radix){
                case 2:
                    prefix += "0b";
                    break;
                case 8:
                    prefix += num.startsWith("0") ? "" : "0";
                    break;
                case 16:
                    prefix += "0x";
                    break;
                default:
                    throw new Error("cannot handle base: " + radix);
            }
        }
        num = num.length === 0 ? num : prefix + num;
        if (upcase) {
            num = num.toUpperCase();
        }
        return this.padNum(num, n < 0);
    }
    fmtNumberCodePoint(n) {
        let s = "";
        try {
            s = String.fromCodePoint(n);
        } catch  {
            s = UNICODE_REPLACEMENT_CHARACTER;
        }
        return this.pad(s);
    }
    fmtFloatSpecial(n) {
        if (isNaN(n)) {
            this.flags.zero = false;
            return this.padNum("NaN", false);
        }
        if (n === Number.POSITIVE_INFINITY) {
            this.flags.zero = false;
            this.flags.plus = true;
            return this.padNum("Inf", false);
        }
        if (n === Number.NEGATIVE_INFINITY) {
            this.flags.zero = false;
            return this.padNum("Inf", true);
        }
        return "";
    }
    roundFractionToPrecision(fractional, precision) {
        let round = false;
        if (fractional.length > precision) {
            fractional = "1" + fractional;
            let tmp = parseInt(fractional.slice(0, precision + 2)) / 10;
            tmp = Math.round(tmp);
            fractional = Math.floor(tmp).toString();
            round = fractional[0] === "2";
            fractional = fractional.slice(1);
        } else {
            while(fractional.length < precision){
                fractional += "0";
            }
        }
        return [
            fractional,
            round
        ];
    }
    fmtFloatE(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error("can't happen, bug");
        }
        let fractional = m[F.fractional];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let rounding = false;
        [fractional, rounding] = this.roundFractionToPrecision(fractional, precision);
        let e = m[F.exponent];
        let esign = m[F.esign];
        let mantissa = parseInt(m[F.mantissa]);
        if (rounding) {
            mantissa += 1;
            if (10 <= mantissa) {
                mantissa = 1;
                const r = parseInt(esign + e) + 1;
                e = r.toString();
                esign = r < 0 ? "-" : "+";
            }
        }
        e = e.length == 1 ? "0" + e : e;
        const val = `${mantissa}.${fractional}${upcase ? "E" : "e"}${esign}${e}`;
        return this.padNum(val, n < 0);
    }
    fmtFloatF(n) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        function expandNumber(n) {
            if (Number.isSafeInteger(n)) {
                return n.toString() + ".";
            }
            const t = n.toExponential().split("e");
            let m = t[0].replace(".", "");
            const e = parseInt(t[1]);
            if (e < 0) {
                let nStr = "0.";
                for(let i = 0; i !== Math.abs(e) - 1; ++i){
                    nStr += "0";
                }
                return nStr += m;
            } else {
                const splIdx = e + 1;
                while(m.length < splIdx){
                    m += "0";
                }
                return m.slice(0, splIdx) + "." + m.slice(splIdx);
            }
        }
        const val = expandNumber(Math.abs(n));
        const arr = val.split(".");
        let dig = arr[0];
        let fractional = arr[1];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let round = false;
        [fractional, round] = this.roundFractionToPrecision(fractional, precision);
        if (round) {
            dig = (parseInt(dig) + 1).toString();
        }
        return this.padNum(`${dig}.${fractional}`, n < 0);
    }
    fmtFloatG(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        let P = this.flags.precision !== -1 ? this.flags.precision : 6;
        P = P === 0 ? 1 : P;
        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error("can't happen");
        }
        const X = parseInt(m[F.exponent]) * (m[F.esign] === "-" ? -1 : 1);
        let nStr = "";
        if (P > X && X >= -4) {
            this.flags.precision = P - (X + 1);
            nStr = this.fmtFloatF(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*$/, "");
            }
        } else {
            this.flags.precision = P - 1;
            nStr = this.fmtFloatE(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
            }
        }
        return nStr;
    }
    fmtString(s) {
        if (this.flags.precision !== -1) {
            s = s.slice(0, this.flags.precision);
        }
        return this.pad(s);
    }
    fmtHex(val, upper = false) {
        switch(typeof val){
            case "number":
                return this.fmtNumber(val, 16, upper);
            case "string":
                {
                    const sharp = this.flags.sharp && val.length !== 0;
                    let hex = sharp ? "0x" : "";
                    const prec = this.flags.precision;
                    const end = prec !== -1 ? min(prec, val.length) : val.length;
                    for(let i = 0; i !== end; ++i){
                        if (i !== 0 && this.flags.space) {
                            hex += sharp ? " 0x" : " ";
                        }
                        const c = (val.charCodeAt(i) & 0xff).toString(16);
                        hex += c.length === 1 ? `0${c}` : c;
                    }
                    if (upper) {
                        hex = hex.toUpperCase();
                    }
                    return this.pad(hex);
                }
            default:
                throw new Error("currently only number and string are implemented for hex");
        }
    }
    fmtV(val) {
        if (this.flags.sharp) {
            const options = this.flags.precision !== -1 ? {
                depth: this.flags.precision
            } : {};
            return this.pad(Deno.inspect(val, options));
        } else {
            const p = this.flags.precision;
            return p === -1 ? val.toString() : val.toString().slice(0, p);
        }
    }
    fmtJ(val) {
        return JSON.stringify(val);
    }
    fmtI(val, compact) {
        return Deno.inspect(val, {
            colors: true,
            compact,
            depth: Infinity,
            iterableLimit: Infinity
        });
    }
}
function sprintf(format, ...args) {
    const printf = new Printf(format, ...args);
    return printf.doPrintf();
}
let debugImpls;
let testEnabled;
function initializeDebugEnv(debugEnv) {
    debugImpls = Object.create(null);
    if (debugEnv) {
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll("*", ".*").replaceAll(",", "$|^");
        const debugEnvRegex = new RegExp(`^${debugEnv}$`, "i");
        testEnabled = (str)=>debugEnvRegex.exec(str) !== null;
    } else {
        testEnabled = ()=>false;
    }
}
function emitWarningIfNeeded(set) {
    if ("HTTP" === set || "HTTP2" === set) {
        console.warn("Setting the NODE_DEBUG environment variable " + "to '" + set.toLowerCase() + "' can expose sensitive " + "data (such as passwords, tokens and authentication headers) " + "in the resulting log.");
    }
}
const noop = ()=>{};
function debuglogImpl(enabled, set) {
    if (debugImpls[set] === undefined) {
        if (enabled) {
            emitWarningIfNeeded(set);
            debugImpls[set] = function debug(...args) {
                const msg = args.map((arg)=>inspect(arg)).join(" ");
                console.error(sprintf("%s %s: %s", set, String(Deno.pid), msg));
            };
        } else {
            debugImpls[set] = noop;
        }
    }
    return debugImpls[set];
}
function debuglog(set, cb) {
    function init() {
        set = set.toUpperCase();
        enabled = testEnabled(set);
    }
    let debug = (...args)=>{
        init();
        debug = debuglogImpl(enabled, set);
        if (typeof cb === "function") {
            cb(debug);
        }
        return debug(...args);
    };
    let enabled;
    let test = ()=>{
        init();
        test = ()=>enabled;
        return enabled;
    };
    const logger = (...args)=>debug(...args);
    Object.defineProperty(logger, "enabled", {
        get () {
            return test();
        },
        configurable: true,
        enumerable: true
    });
    return logger;
}
let debugEnv;
try {
    debugEnv = Deno.env.get("NODE_DEBUG") ?? "";
} catch (error) {
    if (error instanceof Deno.errors.PermissionDenied) {
        debugEnv = "";
    } else {
        throw error;
    }
}
initializeDebugEnv(debugEnv);
class Channel {
    _subscribers;
    name;
    constructor(name){
        this._subscribers = [];
        this.name = name;
    }
    publish(message) {
        for (const subscriber of this._subscribers){
            try {
                subscriber(message, this.name);
            } catch (err) {
                nextTick1(()=>{
                    throw err;
                });
            }
        }
    }
    subscribe(subscription) {
        validateFunction(subscription, "subscription");
        this._subscribers.push(subscription);
    }
    unsubscribe(subscription) {
        if (!this._subscribers.includes(subscription)) {
            return false;
        }
        this._subscribers.splice(this._subscribers.indexOf(subscription), 1);
        return true;
    }
    get hasSubscribers() {
        return this._subscribers.length > 0;
    }
}
const channels = {};
function channel(name) {
    if (typeof name !== "string" && typeof name !== "symbol") {
        throw new ERR_INVALID_ARG_TYPE("channel", [
            "string",
            "symbol"
        ], name);
    }
    if (!Object.hasOwn(channels, name)) {
        channels[name] = new Channel(name);
    }
    return channels[name];
}
function hasSubscribers(name) {
    if (!Object.hasOwn(channels, name)) {
        return false;
    }
    return channels[name].hasSubscribers;
}
function subscribe(name, subscription) {
    const c = channel(name);
    return c.subscribe(subscription);
}
function unsubscribe(name, subscription) {
    const c = channel(name);
    return c.unsubscribe(subscription);
}
const __default13 = {
    channel,
    hasSubscribers,
    subscribe,
    unsubscribe,
    Channel
};
let debug = debuglog("net", (fn)=>{
    debug = fn;
});
const kLastWriteQueueSize = Symbol("lastWriteQueueSize");
const kSetNoDelay = Symbol("kSetNoDelay");
const kBytesRead = Symbol("kBytesRead");
const kBytesWritten1 = Symbol("kBytesWritten");
const DEFAULT_IPV4_ADDR = "0.0.0.0";
const DEFAULT_IPV6_ADDR = "::";
function _getNewAsyncId(handle) {
    return !handle || typeof handle.getAsyncId !== "function" ? newAsyncId1() : handle.getAsyncId();
}
const _noop = (_arrayBuffer, _nread)=>{
    return;
};
const netClientSocketChannel = channel("net.client.socket");
const netServerSocketChannel = channel("net.server.socket");
function _toNumber(x) {
    return (x = Number(x)) >= 0 ? x : false;
}
function _isPipeName(s) {
    return typeof s === "string" && _toNumber(s) === false;
}
function _createHandle(fd, isServer) {
    validateInt32(fd, "fd", 0);
    const type = guessHandleType(fd);
    if (type === "PIPE") {
        return new Pipe(isServer ? constants2.SERVER : constants2.SOCKET);
    }
    if (type === "TCP") {
        return new TCP(isServer ? constants3.SERVER : constants3.SOCKET);
    }
    throw new ERR_INVALID_FD_TYPE(type);
}
function _normalizeArgs(args) {
    let arr;
    if (args.length === 0) {
        arr = [
            {},
            null
        ];
        arr[normalizedArgsSymbol] = true;
        return arr;
    }
    const arg0 = args[0];
    let options = {};
    if (typeof arg0 === "object" && arg0 !== null) {
        options = arg0;
    } else if (_isPipeName(arg0)) {
        options.path = arg0;
    } else {
        options.port = arg0;
        if (args.length > 1 && typeof args[1] === "string") {
            options.host = args[1];
        }
    }
    const cb = args[args.length - 1];
    if (!_isConnectionListener(cb)) {
        arr = [
            options,
            null
        ];
    } else {
        arr = [
            options,
            cb
        ];
    }
    arr[normalizedArgsSymbol] = true;
    return arr;
}
function _isTCPConnectWrap(req) {
    return "localAddress" in req && "localPort" in req;
}
function _afterConnect(status, handle, req, readable, writable) {
    let socket = handle[ownerSymbol];
    if (socket.constructor.name === "ReusedHandle") {
        socket = socket.handle;
    }
    if (socket.destroyed) {
        return;
    }
    debug("afterConnect");
    assert(socket.connecting);
    socket.connecting = false;
    socket._sockname = null;
    if (status === 0) {
        if (socket.readable && !readable) {
            socket.push(null);
            socket.read();
        }
        if (socket.writable && !writable) {
            socket.end();
        }
        socket._unrefTimer();
        socket.emit("connect");
        socket.emit("ready");
        if (readable && !socket.isPaused()) {
            socket.read(0);
        }
    } else {
        socket.connecting = false;
        let details;
        if (_isTCPConnectWrap(req)) {
            details = req.localAddress + ":" + req.localPort;
        }
        const ex = exceptionWithHostPort(status, "connect", req.address, req.port, details);
        if (_isTCPConnectWrap(req)) {
            ex.localAddress = req.localAddress;
            ex.localPort = req.localPort;
        }
        socket.destroy(ex);
    }
}
function _checkBindError(err, port, handle) {
    if (err === 0 && port > 0 && handle.getsockname) {
        const out = {};
        err = handle.getsockname(out);
        if (err === 0 && port !== out.port) {
            err = codeMap.get("EADDRINUSE");
        }
    }
    return err;
}
function _isPipe(options) {
    return "path" in options && !!options.path;
}
function _connectErrorNT(socket, err) {
    socket.destroy(err);
}
function _internalConnect(socket, address, port, addressType, localAddress, localPort, flags) {
    assert(socket.connecting);
    let err;
    if (localAddress || localPort) {
        if (addressType === 4) {
            localAddress = localAddress || DEFAULT_IPV4_ADDR;
            err = socket._handle.bind(localAddress, localPort);
        } else {
            localAddress = localAddress || DEFAULT_IPV6_ADDR;
            err = socket._handle.bind6(localAddress, localPort, flags);
        }
        debug("binding to localAddress: %s and localPort: %d (addressType: %d)", localAddress, localPort, addressType);
        err = _checkBindError(err, localPort, socket._handle);
        if (err) {
            const ex = exceptionWithHostPort(err, "bind", localAddress, localPort);
            socket.destroy(ex);
            return;
        }
    }
    if (addressType === 6 || addressType === 4) {
        const req = new TCPConnectWrap();
        req.oncomplete = _afterConnect;
        req.address = address;
        req.port = port;
        req.localAddress = localAddress;
        req.localPort = localPort;
        if (addressType === 4) {
            err = socket._handle.connect(req, address, port);
        } else {
            err = socket._handle.connect6(req, address, port);
        }
    } else {
        const req = new PipeConnectWrap();
        req.oncomplete = _afterConnect;
        req.address = address;
        err = socket._handle.connect(req, address);
    }
    if (err) {
        let details = "";
        const sockname = socket._getsockname();
        if (sockname) {
            details = `${sockname.address}:${sockname.port}`;
        }
        const ex = exceptionWithHostPort(err, "connect", address, port, details);
        socket.destroy(ex);
    }
}
function _writeAfterFIN(chunk, encoding, cb) {
    if (!this.writableEnded) {
        return Tu.prototype.write.call(this, chunk, encoding, cb);
    }
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    const err = genericNodeError("This socket has been ended by the other party", {
        code: "EPIPE"
    });
    if (typeof cb === "function") {
        defaultTriggerAsyncIdScope(this[asyncIdSymbol], nextTick1, cb, err);
    }
    if (this._server) {
        nextTick1(()=>this.destroy(err));
    } else {
        this.destroy(err);
    }
    return false;
}
function _tryReadStart(socket) {
    debug("Socket._handle.readStart");
    socket._handle.reading = true;
    const err = socket._handle.readStart();
    if (err) {
        socket.destroy(errnoException(err, "read"));
    }
}
function _onReadableStreamEnd() {
    if (!this.allowHalfOpen) {
        this.write = _writeAfterFIN;
    }
}
function _initSocketHandle(socket) {
    socket._undestroy();
    socket._sockname = undefined;
    if (socket._handle) {
        socket._handle[ownerSymbol] = socket;
        socket._handle.onread = onStreamRead;
        socket[asyncIdSymbol] = _getNewAsyncId(socket._handle);
        let userBuf = socket[kBuffer];
        if (userBuf) {
            const bufGen = socket[kBufferGen];
            if (bufGen !== null) {
                userBuf = bufGen();
                if (!isUint8Array(userBuf)) {
                    return;
                }
                socket[kBuffer] = userBuf;
            }
            socket._handle.useUserBuffer(userBuf);
        }
    }
}
function _lookupAndConnect(self, options) {
    const { localAddress , localPort  } = options;
    const host = options.host || "localhost";
    let { port  } = options;
    if (localAddress && !isIP(localAddress)) {
        throw new ERR_INVALID_IP_ADDRESS(localAddress);
    }
    if (localPort) {
        validateNumber(localPort, "options.localPort");
    }
    if (typeof port !== "undefined") {
        if (typeof port !== "number" && typeof port !== "string") {
            throw new ERR_INVALID_ARG_TYPE("options.port", [
                "number",
                "string"
            ], port);
        }
        validatePort(port);
    }
    port |= 0;
    const addressType = isIP(host);
    if (addressType) {
        defaultTriggerAsyncIdScope(self[asyncIdSymbol], nextTick1, ()=>{
            if (self.connecting) {
                defaultTriggerAsyncIdScope(self[asyncIdSymbol], _internalConnect, self, host, port, addressType, localAddress, localPort);
            }
        });
        return;
    }
    if (options.lookup !== undefined) {
        validateFunction(options.lookup, "options.lookup");
    }
    const dnsOpts = {
        family: options.family,
        hints: options.hints || 0
    };
    if (!isWindows && dnsOpts.family !== 4 && dnsOpts.family !== 6 && dnsOpts.hints === 0) {
        dnsOpts.hints = AI_ADDRCONFIG;
    }
    debug("connect: find host", host);
    debug("connect: dns options", dnsOpts);
    self._host = host;
    const lookup = options.lookup || lookup1;
    defaultTriggerAsyncIdScope(self[asyncIdSymbol], function() {
        lookup(host, dnsOpts, function emitLookup(err, ip, addressType) {
            self.emit("lookup", err, ip, addressType, host);
            if (!self.connecting) {
                return;
            }
            if (err) {
                nextTick1(_connectErrorNT, self, err);
            } else if (!isIP(ip)) {
                err = new ERR_INVALID_IP_ADDRESS(ip);
                nextTick1(_connectErrorNT, self, err);
            } else if (addressType !== 4 && addressType !== 6) {
                err = new ERR_INVALID_ADDRESS_FAMILY(`${addressType}`, options.host, options.port);
                nextTick1(_connectErrorNT, self, err);
            } else {
                self._unrefTimer();
                defaultTriggerAsyncIdScope(self[asyncIdSymbol], _internalConnect, self, ip, port, addressType, localAddress, localPort);
            }
        });
    });
}
function _afterShutdown() {
    const self = this.handle[ownerSymbol];
    debug("afterShutdown destroyed=%j", self.destroyed, self._readableState);
    this.callback();
}
function _emitCloseNT(s) {
    debug("SERVER: emit close");
    s.emit("close");
}
class Socket extends Tu {
    [asyncIdSymbol] = -1;
    [kHandle1] = null;
    [kSetNoDelay] = false;
    [kLastWriteQueueSize] = 0;
    [kTimeout] = null;
    [kBuffer] = null;
    [kBufferCb] = null;
    [kBufferGen] = null;
    [kBytesRead] = 0;
    [kBytesWritten1] = 0;
    server = null;
    _server = null;
    _peername;
    _sockname;
    _pendingData = null;
    _pendingEncoding = "";
    _host = null;
    _parent = null;
    constructor(options){
        if (typeof options === "number") {
            options = {
                fd: options
            };
        } else {
            options = {
                ...options
            };
        }
        options.allowHalfOpen = Boolean(options.allowHalfOpen);
        options.emitClose = false;
        options.autoDestroy = true;
        options.decodeStrings = false;
        super(options);
        if (options.handle) {
            this._handle = options.handle;
            this[asyncIdSymbol] = _getNewAsyncId(this._handle);
        } else if (options.fd !== undefined) {
            notImplemented("net.Socket.prototype.constructor with fd option");
        }
        const onread = options.onread;
        if (onread !== null && typeof onread === "object" && (isUint8Array(onread.buffer) || typeof onread.buffer === "function") && typeof onread.callback === "function") {
            if (typeof onread.buffer === "function") {
                this[kBuffer] = true;
                this[kBufferGen] = onread.buffer;
            } else {
                this[kBuffer] = onread.buffer;
            }
            this[kBufferCb] = onread.callback;
        }
        this.on("end", _onReadableStreamEnd);
        _initSocketHandle(this);
        if (this._handle && options.readable !== false) {
            if (options.pauseOnCreate) {
                this._handle.reading = false;
                this._handle.readStop();
                this.readableFlowing = false;
            } else if (!options.manualStart) {
                this.read(0);
            }
        }
    }
    connect(...args) {
        let normalized;
        if (Array.isArray(args[0]) && args[0][normalizedArgsSymbol]) {
            normalized = args[0];
        } else {
            normalized = _normalizeArgs(args);
        }
        const options = normalized[0];
        const cb = normalized[1];
        if (options.port === undefined && options.path == null) {
            throw new ERR_MISSING_ARGS([
                "options",
                "port",
                "path"
            ]);
        }
        if (this.write !== Socket.prototype.write) {
            this.write = Socket.prototype.write;
        }
        if (this.destroyed) {
            this._handle = null;
            this._peername = undefined;
            this._sockname = undefined;
        }
        const { path  } = options;
        const pipe = _isPipe(options);
        debug("pipe", pipe, path);
        if (!this._handle) {
            this._handle = pipe ? new Pipe(constants2.SOCKET) : new TCP(constants3.SOCKET);
            _initSocketHandle(this);
        }
        if (cb !== null) {
            this.once("connect", cb);
        }
        this._unrefTimer();
        this.connecting = true;
        if (pipe) {
            validateString(path, "options.path");
            defaultTriggerAsyncIdScope(this[asyncIdSymbol], _internalConnect, this, path);
        } else {
            _lookupAndConnect(this, options);
        }
        return this;
    }
    pause() {
        if (this[kBuffer] && !this.connecting && this._handle && this._handle.reading) {
            this._handle.reading = false;
            if (!this.destroyed) {
                const err = this._handle.readStop();
                if (err) {
                    this.destroy(errnoException(err, "read"));
                }
            }
        }
        return Tu.prototype.pause.call(this);
    }
    resume() {
        if (this[kBuffer] && !this.connecting && this._handle && !this._handle.reading) {
            _tryReadStart(this);
        }
        return Tu.prototype.resume.call(this);
    }
    setTimeout = setStreamTimeout;
    setNoDelay(noDelay) {
        if (!this._handle) {
            this.once("connect", noDelay ? this.setNoDelay : ()=>this.setNoDelay(noDelay));
            return this;
        }
        const newValue = noDelay === undefined ? true : !!noDelay;
        if ("setNoDelay" in this._handle && this._handle.setNoDelay && newValue !== this[kSetNoDelay]) {
            this[kSetNoDelay] = newValue;
            this._handle.setNoDelay(newValue);
        }
        return this;
    }
    setKeepAlive(enable, initialDelay) {
        if (!this._handle) {
            this.once("connect", ()=>this.setKeepAlive(enable, initialDelay));
            return this;
        }
        if ("setKeepAlive" in this._handle) {
            this._handle.setKeepAlive(enable, ~~(initialDelay / 1000));
        }
        return this;
    }
    address() {
        return this._getsockname();
    }
    unref() {
        if (!this._handle) {
            this.once("connect", this.unref);
            return this;
        }
        if (typeof this._handle.unref === "function") {
            this._handle.unref();
        }
        return this;
    }
    ref() {
        if (!this._handle) {
            this.once("connect", this.ref);
            return this;
        }
        if (typeof this._handle.ref === "function") {
            this._handle.ref();
        }
        return this;
    }
    get bufferSize() {
        if (this._handle) {
            return this.writableLength;
        }
        return 0;
    }
    get bytesRead() {
        return this._handle ? this._handle.bytesRead : this[kBytesRead];
    }
    get bytesWritten() {
        let bytes = this._bytesDispatched;
        const data = this._pendingData;
        const encoding = this._pendingEncoding;
        const writableBuffer = this.writableBuffer;
        if (!writableBuffer) {
            return undefined;
        }
        for (const el of writableBuffer){
            bytes += el.chunk instanceof Buffer1 ? el.chunk.length : Buffer1.byteLength(el.chunk, el.encoding);
        }
        if (Array.isArray(data)) {
            for(let i = 0; i < data.length; i++){
                const chunk = data[i];
                if (data.allBuffers || chunk instanceof Buffer1) {
                    bytes += chunk.length;
                } else {
                    bytes += Buffer1.byteLength(chunk.chunk, chunk.encoding);
                }
            }
        } else if (data) {
            if (typeof data !== "string") {
                bytes += data.length;
            } else {
                bytes += Buffer1.byteLength(data, encoding);
            }
        }
        return bytes;
    }
    connecting = false;
    get localAddress() {
        return this._getsockname().address;
    }
    get localPort() {
        return this._getsockname().port;
    }
    get localFamily() {
        return this._getsockname().family;
    }
    get remoteAddress() {
        return this._getpeername().address;
    }
    get remoteFamily() {
        const { family  } = this._getpeername();
        return family ? `IPv${family}` : family;
    }
    get remotePort() {
        return this._getpeername().port;
    }
    get pending() {
        return !this._handle || this.connecting;
    }
    get readyState() {
        if (this.connecting) {
            return "opening";
        } else if (this.readable && this.writable) {
            return "open";
        } else if (this.readable && !this.writable) {
            return "readOnly";
        } else if (!this.readable && this.writable) {
            return "writeOnly";
        }
        return "closed";
    }
    end(data, encoding, cb) {
        Tu.prototype.end.call(this, data, encoding, cb);
        DTRACE_NET_STREAM_END(this);
        return this;
    }
    read(size) {
        if (this[kBuffer] && !this.connecting && this._handle && !this._handle.reading) {
            _tryReadStart(this);
        }
        return Tu.prototype.read.call(this, size);
    }
    destroySoon() {
        if (this.writable) {
            this.end();
        }
        if (this.writableFinished) {
            this.destroy();
        } else {
            this.once("finish", this.destroy);
        }
    }
    _unrefTimer() {
        for(let s = this; s !== null; s = s._parent){
            if (s[kTimeout]) {
                s[kTimeout].refresh();
            }
        }
    }
    _final(cb) {
        if (this.pending) {
            debug("_final: not yet connected");
            return this.once("connect", ()=>this._final(cb));
        }
        if (!this._handle) {
            return cb();
        }
        debug("_final: not ended, call shutdown()");
        const req = new ShutdownWrap();
        req.oncomplete = _afterShutdown;
        req.handle = this._handle;
        req.callback = cb;
        const err = this._handle.shutdown(req);
        if (err === 1 || err === codeMap.get("ENOTCONN")) {
            return cb();
        } else if (err !== 0) {
            return cb(errnoException(err, "shutdown"));
        }
    }
    _onTimeout() {
        const handle = this._handle;
        const lastWriteQueueSize = this[kLastWriteQueueSize];
        if (lastWriteQueueSize > 0 && handle) {
            const { writeQueueSize  } = handle;
            if (lastWriteQueueSize !== writeQueueSize) {
                this[kLastWriteQueueSize] = writeQueueSize;
                this._unrefTimer();
                return;
            }
        }
        debug("_onTimeout");
        this.emit("timeout");
    }
    _read(size) {
        debug("_read");
        if (this.connecting || !this._handle) {
            debug("_read wait for connection");
            this.once("connect", ()=>this._read(size));
        } else if (!this._handle.reading) {
            _tryReadStart(this);
        }
    }
    _destroy(exception, cb) {
        debug("destroy");
        this.connecting = false;
        for(let s = this; s !== null; s = s._parent){
            clearTimeout(s[kTimeout]);
        }
        debug("close");
        if (this._handle) {
            debug("close handle");
            const isException = exception ? true : false;
            this[kBytesRead] = this._handle.bytesRead;
            this[kBytesWritten1] = this._handle.bytesWritten;
            this._handle.close(()=>{
                this._handle.onread = _noop;
                this._handle = null;
                this._sockname = undefined;
                debug("emit close");
                this.emit("close", isException);
            });
            cb(exception);
        } else {
            cb(exception);
            nextTick1(_emitCloseNT, this);
        }
        if (this._server) {
            debug("has server");
            this._server._connections--;
            if (this._server._emitCloseIfDrained) {
                this._server._emitCloseIfDrained();
            }
        }
    }
    _getpeername() {
        if (!this._handle || !("getpeername" in this._handle) || this.connecting) {
            return this._peername || {};
        } else if (!this._peername) {
            this._peername = {};
            this._handle.getpeername(this._peername);
        }
        return this._peername;
    }
    _getsockname() {
        if (!this._handle || !("getsockname" in this._handle)) {
            return {};
        } else if (!this._sockname) {
            this._sockname = {};
            this._handle.getsockname(this._sockname);
        }
        return this._sockname;
    }
    _writeGeneric(writev, data, encoding, cb) {
        if (this.connecting) {
            this._pendingData = data;
            this._pendingEncoding = encoding;
            this.once("connect", function connect() {
                this._writeGeneric(writev, data, encoding, cb);
            });
            return;
        }
        this._pendingData = null;
        this._pendingEncoding = "";
        if (!this._handle) {
            cb(new ERR_SOCKET_CLOSED());
            return false;
        }
        this._unrefTimer();
        let req;
        if (writev) {
            req = writevGeneric(this, data, cb);
        } else {
            req = writeGeneric(this, data, encoding, cb);
        }
        if (req.async) {
            this[kLastWriteQueueSize] = req.bytes;
        }
    }
    _writev(chunks, cb) {
        this._writeGeneric(true, chunks, "", cb);
    }
    _write(data, encoding, cb) {
        this._writeGeneric(false, data, encoding, cb);
    }
    [kAfterAsyncWrite]() {
        this[kLastWriteQueueSize] = 0;
    }
    get [kUpdateTimer]() {
        return this._unrefTimer;
    }
    get _connecting() {
        return this.connecting;
    }
    get _bytesDispatched() {
        return this._handle ? this._handle.bytesWritten : this[kBytesWritten1];
    }
    get _handle() {
        return this[kHandle1];
    }
    set _handle(v) {
        this[kHandle1] = v;
    }
}
const Stream = Socket;
function connect(...args) {
    const normalized = _normalizeArgs(args);
    const options = normalized[0];
    debug("createConnection", normalized);
    const socket = new Socket(options);
    if (netClientSocketChannel.hasSubscribers) {
        netClientSocketChannel.publish({
            socket
        });
    }
    if (options.timeout) {
        socket.setTimeout(options.timeout);
    }
    return socket.connect(normalized);
}
const createConnection = connect;
function _isServerSocketOptions(options) {
    return options === null || typeof options === "undefined" || typeof options === "object";
}
function _isConnectionListener(connectionListener) {
    return typeof connectionListener === "function";
}
function _getFlags(ipv6Only) {
    return ipv6Only === true ? constants3.UV_TCP_IPV6ONLY : 0;
}
function _listenInCluster(server, address, port, addressType, backlog, fd, exclusive, flags) {
    exclusive = !!exclusive;
    if (true || exclusive) {
        server._listen2(address, port, addressType, backlog, fd, flags);
        return;
    }
}
function _lookupAndListen(server, port, address, backlog, exclusive, flags) {
    lookup1(address, function doListen(err, ip, addressType) {
        if (err) {
            server.emit("error", err);
        } else {
            addressType = ip ? addressType : 4;
            _listenInCluster(server, ip, port, addressType, backlog, null, exclusive, flags);
        }
    });
}
function _addAbortSignalOption(server, options) {
    if (options?.signal === undefined) {
        return;
    }
    validateAbortSignal(options.signal, "options.signal");
    const { signal  } = options;
    const onAborted = ()=>{
        server.close();
    };
    if (signal.aborted) {
        nextTick1(onAborted);
    } else {
        signal.addEventListener("abort", onAborted);
        server.once("close", ()=>signal.removeEventListener("abort", onAborted));
    }
}
function _createServerHandle(address, port, addressType, fd, flags) {
    let err = 0;
    let handle;
    let isTCP = false;
    if (typeof fd === "number" && fd >= 0) {
        try {
            handle = _createHandle(fd, true);
        } catch (e) {
            debug("listen invalid fd=%d:", fd, e.message);
            return codeMap.get("EINVAL");
        }
        err = handle.open(fd);
        if (err) {
            return err;
        }
        assert(!address && !port);
    } else if (port === -1 && addressType === -1) {
        handle = new Pipe(constants2.SERVER);
        if (isWindows) {
            const instances = Number.parseInt(Deno.env.get("NODE_PENDING_PIPE_INSTANCES") ?? "");
            if (!Number.isNaN(instances)) {
                handle.setPendingInstances(instances);
            }
        }
    } else {
        handle = new TCP(constants3.SERVER);
        isTCP = true;
    }
    if (address || port || isTCP) {
        debug("bind to", address || "any");
        if (!address) {
            return _createServerHandle(DEFAULT_IPV4_ADDR, port, 4, null, flags);
        } else if (addressType === 6) {
            err = handle.bind6(address, port ?? 0, flags ?? 0);
        } else {
            err = handle.bind(address, port ?? 0);
        }
    }
    if (err) {
        handle.close();
        return err;
    }
    return handle;
}
function _emitErrorNT(server, err) {
    server.emit("error", err);
}
function _emitListeningNT(server) {
    if (server._handle) {
        server.emit("listening");
    }
}
function _onconnection(err, clientHandle) {
    const handle = this;
    const self = handle[ownerSymbol];
    debug("onconnection");
    if (err) {
        self.emit("error", errnoException(err, "accept"));
        return;
    }
    if (self.maxConnections && self._connections >= self.maxConnections) {
        clientHandle.close();
        return;
    }
    const socket = new Socket({
        handle: clientHandle,
        allowHalfOpen: self.allowHalfOpen,
        pauseOnCreate: self.pauseOnConnect,
        readable: true,
        writable: true
    });
    self._connections++;
    socket.server = self;
    socket._server = self;
    DTRACE_NET_SERVER_CONNECTION(socket);
    self.emit("connection", socket);
    if (netServerSocketChannel.hasSubscribers) {
        netServerSocketChannel.publish({
            socket
        });
    }
}
function _setupListenHandle(address, port, addressType, backlog, fd, flags) {
    debug("setupListenHandle", address, port, addressType, backlog, fd);
    if (this._handle) {
        debug("setupListenHandle: have a handle already");
    } else {
        debug("setupListenHandle: create a handle");
        let rval = null;
        if (!address && typeof fd !== "number") {
            address = DEFAULT_IPV4_ADDR;
            addressType = 4;
        }
        if (rval === null) {
            rval = _createServerHandle(address, port, addressType, fd, flags);
        }
        if (typeof rval === "number") {
            const error = uvExceptionWithHostPort(rval, "listen", address, port);
            nextTick1(_emitErrorNT, this, error);
            return;
        }
        this._handle = rval;
    }
    this[asyncIdSymbol] = _getNewAsyncId(this._handle);
    this._handle.onconnection = _onconnection;
    this._handle[ownerSymbol] = this;
    const err = this._handle.listen(backlog || 511);
    if (err) {
        const ex = uvExceptionWithHostPort(err, "listen", address, port);
        this._handle.close();
        this._handle = null;
        defaultTriggerAsyncIdScope(this[asyncIdSymbol], nextTick1, _emitErrorNT, this, ex);
        return;
    }
    this._connectionKey = addressType + ":" + address + ":" + port;
    if (this._unref) {
        this.unref();
    }
    defaultTriggerAsyncIdScope(this[asyncIdSymbol], nextTick1, _emitListeningNT, this);
}
class Server extends EventEmitter {
    [asyncIdSymbol] = -1;
    allowHalfOpen = false;
    pauseOnConnect = false;
    _handle = null;
    _connections = 0;
    _usingWorkers = false;
    _workers = [];
    _unref = false;
    _pipeName;
    _connectionKey;
    constructor(options, connectionListener){
        super();
        if (_isConnectionListener(options)) {
            this.on("connection", options);
        } else if (_isServerSocketOptions(options)) {
            this.allowHalfOpen = options?.allowHalfOpen || false;
            this.pauseOnConnect = !!options?.pauseOnConnect;
            if (_isConnectionListener(connectionListener)) {
                this.on("connection", connectionListener);
            }
        } else {
            throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
    }
    listen(...args) {
        const normalized = _normalizeArgs(args);
        let options = normalized[0];
        const cb = normalized[1];
        if (this._handle) {
            throw new ERR_SERVER_ALREADY_LISTEN();
        }
        if (cb !== null) {
            this.once("listening", cb);
        }
        const backlogFromArgs = _toNumber(args.length > 1 && args[1]) || _toNumber(args.length > 2 && args[2]);
        options = options._handle || options.handle || options;
        const flags = _getFlags(options.ipv6Only);
        if (options instanceof TCP) {
            this._handle = options;
            this[asyncIdSymbol] = this._handle.getAsyncId();
            _listenInCluster(this, null, -1, -1, backlogFromArgs);
            return this;
        }
        _addAbortSignalOption(this, options);
        if (typeof options.fd === "number" && options.fd >= 0) {
            _listenInCluster(this, null, null, null, backlogFromArgs, options.fd);
            return this;
        }
        if (args.length === 0 || typeof args[0] === "function" || typeof options.port === "undefined" && "port" in options || options.port === null) {
            options.port = 0;
        }
        let backlog;
        if (typeof options.port === "number" || typeof options.port === "string") {
            validatePort(options.port, "options.port");
            backlog = options.backlog || backlogFromArgs;
            if (options.host) {
                _lookupAndListen(this, options.port | 0, options.host, backlog, !!options.exclusive, flags);
            } else {
                _listenInCluster(this, null, options.port | 0, 4, backlog, undefined, options.exclusive);
            }
            return this;
        }
        if (options.path && _isPipeName(options.path)) {
            const pipeName = this._pipeName = options.path;
            backlog = options.backlog || backlogFromArgs;
            _listenInCluster(this, pipeName, -1, -1, backlog, undefined, options.exclusive);
            if (!this._handle) {
                return this;
            }
            let mode = 0;
            if (options.readableAll === true) {
                mode |= constants2.UV_READABLE;
            }
            if (options.writableAll === true) {
                mode |= constants2.UV_WRITABLE;
            }
            if (mode !== 0) {
                const err = this._handle.fchmod(mode);
                if (err) {
                    this._handle.close();
                    this._handle = null;
                    throw errnoException(err, "uv_pipe_chmod");
                }
            }
            return this;
        }
        if (!("port" in options || "path" in options)) {
            throw new ERR_INVALID_ARG_VALUE("options", options, 'must have the property "port" or "path"');
        }
        throw new ERR_INVALID_ARG_VALUE("options", options);
    }
    close(cb) {
        if (typeof cb === "function") {
            if (!this._handle) {
                this.once("close", function close() {
                    cb(new ERR_SERVER_NOT_RUNNING());
                });
            } else {
                this.once("close", cb);
            }
        }
        if (this._handle) {
            this._handle.close();
            this._handle = null;
        }
        if (this._usingWorkers) {
            let left = this._workers.length;
            const onWorkerClose = ()=>{
                if (--left !== 0) {
                    return;
                }
                this._connections = 0;
                this._emitCloseIfDrained();
            };
            this._connections++;
            for(let n = 0; n < this._workers.length; n++){
                this._workers[n].close(onWorkerClose);
            }
        } else {
            this._emitCloseIfDrained();
        }
        return this;
    }
    address() {
        if (this._handle && this._handle.getsockname) {
            const out = {};
            const err = this._handle.getsockname(out);
            if (err) {
                throw errnoException(err, "address");
            }
            return out;
        } else if (this._pipeName) {
            return this._pipeName;
        }
        return null;
    }
    getConnections(cb) {
        const server = this;
        function end(err, connections) {
            defaultTriggerAsyncIdScope(server[asyncIdSymbol], nextTick1, cb, err, connections);
        }
        if (!this._usingWorkers) {
            end(null, this._connections);
            return this;
        }
        let left = this._workers.length;
        let total = this._connections;
        function oncount(err, count) {
            if (err) {
                left = -1;
                return end(err);
            }
            total += count;
            if (--left === 0) {
                return end(null, total);
            }
        }
        for(let n = 0; n < this._workers.length; n++){
            this._workers[n].getConnections(oncount);
        }
        return this;
    }
    unref() {
        this._unref = true;
        if (this._handle) {
            this._handle.unref();
        }
        return this;
    }
    ref() {
        this._unref = false;
        if (this._handle) {
            this._handle.ref();
        }
        return this;
    }
    get listening() {
        return !!this._handle;
    }
    _listen2 = _setupListenHandle;
    _emitCloseIfDrained() {
        debug("SERVER _emitCloseIfDrained");
        if (this._handle || this._connections) {
            debug(`SERVER handle? ${!!this._handle}   connections? ${this._connections}`);
            return;
        }
        defaultTriggerAsyncIdScope(this[asyncIdSymbol], setTimeout, _emitCloseNT, 0, this);
    }
    _setupWorker(socketList) {
        this._usingWorkers = true;
        this._workers.push(socketList);
        socketList.once("exit", (socketList)=>{
            const index = this._workers.indexOf(socketList);
            this._workers.splice(index, 1);
        });
    }
    [EventEmitter.captureRejectionSymbol](err, event, sock) {
        switch(event){
            case "connection":
                {
                    sock.destroy(err);
                    break;
                }
            default:
                {
                    this.emit("error", err);
                }
        }
    }
}
function createServer(options, connectionListener) {
    return new Server(options, connectionListener);
}
const __default14 = {
    _createServerHandle,
    _normalizeArgs,
    isIP,
    isIPv4,
    isIPv6,
    connect,
    createConnection,
    createServer,
    Server,
    Socket,
    Stream
};
function assert1(cond) {
    if (!cond) throw new Error("Assertion failed");
}
const asyncContextStack = [];
function pushAsyncFrame(frame) {
    asyncContextStack.push(frame);
}
function popAsyncFrame() {
    assert1(asyncContextStack.length > 0);
    asyncContextStack.pop();
}
let rootAsyncFrame = undefined;
let promiseHooksSet = false;
const asyncContext = Symbol("asyncContext");
function isRejected(promise) {
    const [state] = core.getPromiseDetails(promise);
    return state == 2;
}
function setPromiseHooks() {
    if (promiseHooksSet) {
        return;
    }
    promiseHooksSet = true;
    const init = (promise)=>{
        const currentFrame = AsyncContextFrame.current();
        if (!currentFrame.isRoot()) {
            assert1(AsyncContextFrame.tryGetContext(promise) == null);
            AsyncContextFrame.attachContext(promise);
        }
    };
    const before = (promise)=>{
        const maybeFrame = AsyncContextFrame.tryGetContext(promise);
        if (maybeFrame) {
            pushAsyncFrame(maybeFrame);
        } else {
            pushAsyncFrame(AsyncContextFrame.getRootAsyncContext());
        }
    };
    const after = (promise)=>{
        popAsyncFrame();
        if (!isRejected(promise)) {
            delete promise[asyncContext];
        }
    };
    const resolve = (promise)=>{
        const currentFrame = AsyncContextFrame.current();
        if (!currentFrame.isRoot() && isRejected(promise) && AsyncContextFrame.tryGetContext(promise) == null) {
            AsyncContextFrame.attachContext(promise);
        }
    };
    core.setPromiseHooks(init, before, after, resolve);
}
class AsyncContextFrame {
    storage;
    constructor(maybeParent, maybeStorageEntry, isRoot = false){
        this.storage = [];
        setPromiseHooks();
        const propagate = (parent)=>{
            parent.storage = parent.storage.filter((entry)=>!entry.key.isDead());
            parent.storage.forEach((entry)=>this.storage.push(entry));
            if (maybeStorageEntry) {
                const existingEntry = this.storage.find((entry)=>entry.key === maybeStorageEntry.key);
                if (existingEntry) {
                    existingEntry.value = maybeStorageEntry.value;
                } else {
                    this.storage.push(maybeStorageEntry);
                }
            }
        };
        if (!isRoot) {
            if (maybeParent) {
                propagate(maybeParent);
            } else {
                propagate(AsyncContextFrame.current());
            }
        }
    }
    static tryGetContext(promise) {
        return promise[asyncContext];
    }
    static attachContext(promise) {
        assert1(!(asyncContext in promise));
        promise[asyncContext] = AsyncContextFrame.current();
    }
    static getRootAsyncContext() {
        if (typeof rootAsyncFrame !== "undefined") {
            return rootAsyncFrame;
        }
        rootAsyncFrame = new AsyncContextFrame(null, null, true);
        return rootAsyncFrame;
    }
    static current() {
        if (asyncContextStack.length === 0) {
            return AsyncContextFrame.getRootAsyncContext();
        }
        return asyncContextStack[asyncContextStack.length - 1];
    }
    static create(maybeParent, maybeStorageEntry) {
        return new AsyncContextFrame(maybeParent, maybeStorageEntry);
    }
    static wrap(fn, maybeFrame, thisArg) {
        return (...args)=>{
            const frame = maybeFrame || AsyncContextFrame.current();
            Scope.enter(frame);
            try {
                return fn.apply(thisArg, args);
            } finally{
                Scope.exit();
            }
        };
    }
    get(key) {
        assert1(!key.isDead());
        this.storage = this.storage.filter((entry)=>!entry.key.isDead());
        const entry = this.storage.find((entry)=>entry.key === key);
        if (entry) {
            return entry.value;
        }
        return undefined;
    }
    isRoot() {
        return AsyncContextFrame.getRootAsyncContext() == this;
    }
}
class AsyncResource {
    frame;
    type;
    constructor(type){
        this.type = type;
        this.frame = AsyncContextFrame.current();
    }
    runInAsyncScope(fn, thisArg, ...args) {
        Scope.enter(this.frame);
        try {
            return fn.apply(thisArg, args);
        } finally{
            Scope.exit();
        }
    }
    bind(fn, thisArg = this) {
        validateFunction(fn, "fn");
        const frame = AsyncContextFrame.current();
        const bound = AsyncContextFrame.wrap(fn, frame, thisArg);
        Object.defineProperties(bound, {
            "length": {
                configurable: true,
                enumerable: false,
                value: fn.length,
                writable: false
            },
            "asyncResource": {
                configurable: true,
                enumerable: true,
                value: this,
                writable: true
            }
        });
        return bound;
    }
    static bind(fn, type, thisArg) {
        type = type || fn.name;
        return new AsyncResource(type || "AsyncResource").bind(fn, thisArg);
    }
}
class Scope {
    static enter(maybeFrame) {
        if (maybeFrame) {
            pushAsyncFrame(maybeFrame);
        } else {
            pushAsyncFrame(AsyncContextFrame.getRootAsyncContext());
        }
    }
    static exit() {
        popAsyncFrame();
    }
}
class StorageEntry {
    key;
    value;
    constructor(key, value){
        this.key = key;
        this.value = value;
    }
}
class StorageKey {
    #dead = false;
    reset() {
        this.#dead = true;
    }
    isDead() {
        return this.#dead;
    }
}
const fnReg = new FinalizationRegistry((key)=>{
    key.reset();
});
class AsyncLocalStorage {
    #key;
    constructor(){
        this.#key = new StorageKey();
        fnReg.register(this, this.#key);
    }
    run(store, callback, ...args) {
        const frame = AsyncContextFrame.create(null, new StorageEntry(this.#key, store));
        Scope.enter(frame);
        let res;
        try {
            res = callback(...args);
        } finally{
            Scope.exit();
        }
        return res;
    }
    exit(callback, ...args) {
        return this.run(undefined, callback, args);
    }
    getStore() {
        const currentFrame = AsyncContextFrame.current();
        return currentFrame.get(this.#key);
    }
}
function executionAsyncId() {
    return 1;
}
class AsyncHook1 {
    enable() {}
    disable() {}
}
function createHook() {
    return new AsyncHook1();
}
const __default15 = {
    AsyncResource,
    executionAsyncId,
    createHook,
    AsyncLocalStorage
};
let debug1 = debuglog("http", (fn)=>{
    debug1 = fn;
});
const { async_id_symbol: async_id_symbol1  } = symbols;
const kOnKeylog = Symbol("onkeylog");
const kRequestOptions = Symbol("requestOptions");
const kRequestAsyncResource = Symbol("requestAsyncResource");
class ReusedHandle {
    constructor(type, handle){
        this.type = type;
        this.handle = handle;
    }
}
function freeSocketErrorListener(err) {
    const socket = this;
    debug1("SOCKET ERROR on FREE socket:", err.message, err.stack);
    socket.destroy();
    socket.emit("agentRemove");
}
function Agent(options) {
    if (!(this instanceof Agent)) {
        return new Agent(options);
    }
    EventEmitter.call(this);
    this.defaultPort = 80;
    this.protocol = "http:";
    this.options = {
        __proto__: null,
        ...options
    };
    this.options.path = null;
    this.requests = Object.create(null);
    this.sockets = Object.create(null);
    this.freeSockets = Object.create(null);
    this.keepAliveMsecs = this.options.keepAliveMsecs || 1000;
    this.keepAlive = this.options.keepAlive || false;
    this.maxSockets = this.options.maxSockets || Agent.defaultMaxSockets;
    this.maxFreeSockets = this.options.maxFreeSockets || 256;
    this.scheduling = this.options.scheduling || "lifo";
    this.maxTotalSockets = this.options.maxTotalSockets;
    this.totalSocketCount = 0;
    validateOneOf(this.scheduling, "scheduling", [
        "fifo",
        "lifo"
    ]);
    if (this.maxTotalSockets !== undefined) {
        validateNumber(this.maxTotalSockets, "maxTotalSockets");
        if (this.maxTotalSockets <= 0 || Number.isNaN(this.maxTotalSockets)) {
            throw new ERR_OUT_OF_RANGE("maxTotalSockets", "> 0", this.maxTotalSockets);
        }
    } else {
        this.maxTotalSockets = Infinity;
    }
    this.on("free", (socket, options)=>{
        const name = this.getName(options);
        debug1("agent.on(free)", name);
        if (!socket.writable) {
            socket.destroy();
            return;
        }
        const requests = this.requests[name];
        if (requests && requests.length) {
            const req = requests.shift();
            const reqAsyncRes = req[kRequestAsyncResource];
            if (reqAsyncRes) {
                reqAsyncRes.runInAsyncScope(()=>{
                    asyncResetHandle(socket);
                    setRequestSocket(this, req, socket);
                });
                req[kRequestAsyncResource] = null;
            } else {
                setRequestSocket(this, req, socket);
            }
            if (requests.length === 0) {
                delete this.requests[name];
            }
            return;
        }
        const req = socket._httpMessage;
        if (!req || !req.shouldKeepAlive || !this.keepAlive) {
            socket.destroy();
            return;
        }
        const freeSockets = this.freeSockets[name] || [];
        const freeLen = freeSockets.length;
        let count = freeLen;
        if (this.sockets[name]) {
            count += this.sockets[name].length;
        }
        if (this.totalSocketCount > this.maxTotalSockets || count > this.maxSockets || freeLen >= this.maxFreeSockets || !this.keepSocketAlive(socket)) {
            socket.destroy();
            return;
        }
        this.freeSockets[name] = freeSockets;
        socket[async_id_symbol1] = -1;
        socket._httpMessage = null;
        this.removeSocket(socket, options);
        socket.once("error", freeSocketErrorListener);
        freeSockets.push(socket);
    });
    this.on("newListener", maybeEnableKeylog);
}
Object.setPrototypeOf(Agent.prototype, EventEmitter.prototype);
Object.setPrototypeOf(Agent, EventEmitter);
function maybeEnableKeylog(eventName) {
    if (eventName === "keylog") {
        this.removeListener("newListener", maybeEnableKeylog);
        const agent = this;
        this[kOnKeylog] = function onkeylog(keylog) {
            agent.emit("keylog", keylog, this);
        };
        const sockets = ObjectValues(this.sockets);
        for(let i = 0; i < sockets.length; i++){
            sockets[i].on("keylog", this[kOnKeylog]);
        }
    }
}
Agent.defaultMaxSockets = Infinity;
Agent.prototype.createConnection = createConnection;
Agent.prototype.getName = function getName(options = {}) {
    let name = options.host || "localhost";
    name += ":";
    if (options.port) {
        name += options.port;
    }
    name += ":";
    if (options.localAddress) {
        name += options.localAddress;
    }
    if (options.family === 4 || options.family === 6) {
        name += `:${options.family}`;
    }
    if (options.socketPath) {
        name += `:${options.socketPath}`;
    }
    return name;
};
Agent.prototype.addRequest = function addRequest(req, options, port, localAddress) {
    if (typeof options === "string") {
        options = {
            __proto__: null,
            host: options,
            port,
            localAddress
        };
    }
    options = {
        __proto__: null,
        ...options,
        ...this.options
    };
    if (options.socketPath) {
        options.path = options.socketPath;
    }
    if (!options.servername && options.servername !== "") {
        options.servername = calculateServerName(options, req);
    }
    const name = this.getName(options);
    if (!this.sockets[name]) {
        this.sockets[name] = [];
    }
    const freeSockets = this.freeSockets[name];
    let socket;
    if (freeSockets) {
        while(freeSockets.length && freeSockets[0].destroyed){
            freeSockets.shift();
        }
        socket = this.scheduling === "fifo" ? freeSockets.shift() : freeSockets.pop();
        if (!freeSockets.length) {
            delete this.freeSockets[name];
        }
    }
    const freeLen = freeSockets ? freeSockets.length : 0;
    const sockLen = freeLen + this.sockets[name].length;
    if (socket) {
        asyncResetHandle(socket);
        this.reuseSocket(socket, req);
        setRequestSocket(this, req, socket);
        this.sockets[name].push(socket);
    } else if (sockLen < this.maxSockets && this.totalSocketCount < this.maxTotalSockets) {
        debug1("call onSocket", sockLen, freeLen);
        this.createSocket(req, options, (err, socket)=>{
            if (err) {
                req.onSocket(socket, err);
            } else {
                setRequestSocket(this, req, socket);
            }
        });
    } else {
        debug1("wait for socket");
        if (!this.requests[name]) {
            this.requests[name] = [];
        }
        req[kRequestOptions] = options;
        req[kRequestAsyncResource] = new AsyncResource("QueuedRequest");
        this.requests[name].push(req);
    }
};
Agent.prototype.createSocket = function createSocket(req, options, cb) {
    options = {
        __proto__: null,
        ...options,
        ...this.options
    };
    if (options.socketPath) {
        options.path = options.socketPath;
    }
    if (!options.servername && options.servername !== "") {
        options.servername = calculateServerName(options, req);
    }
    const name = this.getName(options);
    options._agentKey = name;
    debug1("createConnection", name, options);
    options.encoding = null;
    const oncreate = once1((err, s)=>{
        if (err) {
            return cb(err);
        }
        if (!this.sockets[name]) {
            this.sockets[name] = [];
        }
        this.sockets[name].push(s);
        this.totalSocketCount++;
        debug1("sockets", name, this.sockets[name].length, this.totalSocketCount);
        installListeners(this, s, options);
        cb(null, s);
    });
    const newSocket = this.createConnection(options, oncreate);
    if (newSocket) {
        oncreate(null, newSocket);
    }
};
function calculateServerName(options, req) {
    let servername = options.host;
    const hostHeader = req.getHeader("host");
    if (hostHeader) {
        validateString(hostHeader, "options.headers.host");
        if (hostHeader.startsWith("[")) {
            const index = hostHeader.indexOf("]");
            if (index === -1) {
                servername = hostHeader;
            } else {
                servername = hostHeader.slice(1, index);
            }
        } else {
            servername = hostHeader.split(":", 1)[0];
        }
    }
    if (isIP(servername)) {
        servername = "";
    }
    return servername;
}
function installListeners(agent, s, options) {
    function onFree() {
        debug1("CLIENT socket onFree");
        agent.emit("free", s, options);
    }
    s.on("free", onFree);
    function onClose(_err) {
        debug1("CLIENT socket onClose");
        agent.totalSocketCount--;
        agent.removeSocket(s, options);
    }
    s.on("close", onClose);
    function onTimeout() {
        debug1("CLIENT socket onTimeout");
        const sockets = agent.freeSockets;
        if (Object.keys(sockets).some((name)=>sockets[name].includes(s))) {
            return s.destroy();
        }
    }
    s.on("timeout", onTimeout);
    function onRemove() {
        debug1("CLIENT socket onRemove");
        agent.totalSocketCount--;
        agent.removeSocket(s, options);
        s.removeListener("close", onClose);
        s.removeListener("free", onFree);
        s.removeListener("timeout", onTimeout);
        s.removeListener("agentRemove", onRemove);
    }
    s.on("agentRemove", onRemove);
    if (agent[kOnKeylog]) {
        s.on("keylog", agent[kOnKeylog]);
    }
}
Agent.prototype.removeSocket = function removeSocket(s, options) {
    const name = this.getName(options);
    debug1("removeSocket", name, "writable:", s.writable);
    const sets = [
        this.sockets
    ];
    if (!s.writable) {
        sets.push(this.freeSockets);
    }
    for(let sk = 0; sk < sets.length; sk++){
        const sockets = sets[sk];
        if (sockets[name]) {
            const index = sockets[name].indexOf(s);
            if (index !== -1) {
                sockets[name].splice(index, 1);
                if (sockets[name].length === 0) {
                    delete sockets[name];
                }
            }
        }
    }
    let req;
    if (this.requests[name] && this.requests[name].length) {
        debug1("removeSocket, have a request, make a socket");
        req = this.requests[name][0];
    } else {
        const keys = Object.keys(this.requests);
        for(let i = 0; i < keys.length; i++){
            const prop = keys[i];
            if (this.sockets[prop] && this.sockets[prop].length) break;
            debug1("removeSocket, have a request with different origin," + " make a socket");
            req = this.requests[prop][0];
            options = req[kRequestOptions];
            break;
        }
    }
    if (req && options) {
        req[kRequestOptions] = undefined;
        this.createSocket(req, options, (err, socket)=>{
            if (err) {
                req.onSocket(socket, err);
            } else {
                socket.emit("free");
            }
        });
    }
};
Agent.prototype.keepSocketAlive = function keepSocketAlive(socket) {
    socket.setKeepAlive(true, this.keepAliveMsecs);
    socket.unref();
    const agentTimeout = this.options.timeout || 0;
    if (socket.timeout !== agentTimeout) {
        socket.setTimeout(agentTimeout);
    }
    return true;
};
Agent.prototype.reuseSocket = function reuseSocket(socket, req) {
    debug1("have free socket");
    socket.removeListener("error", freeSocketErrorListener);
    req.reusedSocket = true;
    socket.ref();
};
Agent.prototype.destroy = function destroy() {
    const sets = [
        this.freeSockets,
        this.sockets
    ];
    for(let s = 0; s < sets.length; s++){
        const set = sets[s];
        const keys = Object.keys(set);
        for(let v = 0; v < keys.length; v++){
            const setName = set[keys[v]];
            for(let n = 0; n < setName.length; n++){
                setName[n].destroy();
            }
        }
    }
};
function setRequestSocket(agent, req, socket) {
    req.onSocket(socket);
    const agentTimeout = agent.options.timeout || 0;
    if (req.timeout === undefined || req.timeout === agentTimeout) {
        return;
    }
    socket.setTimeout(req.timeout);
}
function asyncResetHandle(socket) {
    const handle = socket._handle;
    if (handle && typeof handle.asyncReset === "function") {
        handle.asyncReset(new ReusedHandle(handle.getProviderType(), handle));
        socket[async_id_symbol1] = handle.getAsyncId();
    }
}
const globalAgent = new Agent();
const __default16 = {
    Agent,
    globalAgent
};
function getDefaultHighWaterMark(objectMode) {
    return objectMode ? 16 : 16 * 1024;
}
const __default17 = {
    getDefaultHighWaterMark
};
function assert2(value, message) {
    if (!value) {
        throw new ERR_INTERNAL_ASSERTION(message);
    }
}
function fail(message) {
    throw new ERR_INTERNAL_ASSERTION(message);
}
assert2.fail = fail;
class NodeFalsyValueRejectionError extends Error {
    reason;
    code = "ERR_FALSY_VALUE_REJECTION";
    constructor(reason){
        super("Promise was rejected with falsy value");
        this.reason = reason;
    }
}
class NodeInvalidArgTypeError extends TypeError {
    code = "ERR_INVALID_ARG_TYPE";
    constructor(argumentName){
        super(`The ${argumentName} argument must be of type function.`);
    }
}
function callbackify(original) {
    if (typeof original !== "function") {
        throw new NodeInvalidArgTypeError('"original"');
    }
    const callbackified = function(...args) {
        const maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
            throw new NodeInvalidArgTypeError("last");
        }
        const cb = (...args)=>{
            maybeCb.apply(this, args);
        };
        original.apply(this, args).then((ret)=>{
            nextTick1(cb.bind(this, null, ret));
        }, (rej)=>{
            rej = rej || new NodeFalsyValueRejectionError(rej);
            nextTick1(cb.bind(this, rej));
        });
    };
    const descriptors = Object.getOwnPropertyDescriptors(original);
    if (typeof descriptors.length.value === "number") {
        descriptors.length.value++;
    }
    if (typeof descriptors.name.value === "string") {
        descriptors.name.value += "Callbackified";
    }
    Object.defineProperties(callbackified, descriptors);
    return callbackified;
}
const __default18 = {
    ...mod2
};
var valueType;
(function(valueType) {
    valueType[valueType["noIterator"] = 0] = "noIterator";
    valueType[valueType["isArray"] = 1] = "isArray";
    valueType[valueType["isSet"] = 2] = "isSet";
    valueType[valueType["isMap"] = 3] = "isMap";
})(valueType || (valueType = {}));
let memo;
function isDeepStrictEqual(val1, val2) {
    return innerDeepEqual(val1, val2, true);
}
function isDeepEqual(val1, val2) {
    return innerDeepEqual(val1, val2, false);
}
function innerDeepEqual(val1, val2, strict, memos = memo) {
    if (val1 === val2) {
        if (val1 !== 0) return true;
        return strict ? Object.is(val1, val2) : true;
    }
    if (strict) {
        if (typeof val1 !== "object") {
            return typeof val1 === "number" && Number.isNaN(val1) && Number.isNaN(val2);
        }
        if (typeof val2 !== "object" || val1 === null || val2 === null) {
            return false;
        }
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
            return false;
        }
    } else {
        if (val1 === null || typeof val1 !== "object") {
            if (val2 === null || typeof val2 !== "object") {
                return val1 == val2 || Number.isNaN(val1) && Number.isNaN(val2);
            }
            return false;
        }
        if (val2 === null || typeof val2 !== "object") {
            return false;
        }
    }
    const val1Tag = Object.prototype.toString.call(val1);
    const val2Tag = Object.prototype.toString.call(val2);
    if (val1Tag !== val2Tag) {
        return false;
    }
    if (Array.isArray(val1)) {
        if (!Array.isArray(val2) || val1.length !== val2.length) {
            return false;
        }
        const filter = strict ? 2 : 2 | 16;
        const keys1 = getOwnNonIndexProperties(val1, filter);
        const keys2 = getOwnNonIndexProperties(val2, filter);
        if (keys1.length !== keys2.length) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isArray, keys1);
    } else if (val1Tag === "[object Object]") {
        return keyCheck(val1, val2, strict, memos, valueType.noIterator);
    } else if (val1 instanceof Date) {
        if (!(val2 instanceof Date) || val1.getTime() !== val2.getTime()) {
            return false;
        }
    } else if (val1 instanceof RegExp) {
        if (!(val2 instanceof RegExp) || !areSimilarRegExps(val1, val2)) {
            return false;
        }
    } else if (isNativeError1(val1) || val1 instanceof Error) {
        if (!isNativeError1(val2) && !(val2 instanceof Error) || val1.message !== val2.message || val1.name !== val2.name) {
            return false;
        }
    } else if (isArrayBufferView(val1)) {
        const TypedArrayPrototypeGetSymbolToStringTag = (val)=>Object.getOwnPropertySymbols(val).map((item)=>item.toString()).toString();
        if (isTypedArray(val1) && isTypedArray(val2) && TypedArrayPrototypeGetSymbolToStringTag(val1) !== TypedArrayPrototypeGetSymbolToStringTag(val2)) {
            return false;
        }
        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
            if (!areSimilarFloatArrays(val1, val2)) {
                return false;
            }
        } else if (!areSimilarTypedArrays(val1, val2)) {
            return false;
        }
        const filter = strict ? 2 : 2 | 16;
        const keysVal1 = getOwnNonIndexProperties(val1, filter);
        const keysVal2 = getOwnNonIndexProperties(val2, filter);
        if (keysVal1.length !== keysVal2.length) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.noIterator, keysVal1);
    } else if (isSet1(val1)) {
        if (!isSet1(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isSet);
    } else if (isMap1(val1)) {
        if (!isMap1(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isMap);
    } else if (isAnyArrayBuffer1(val1)) {
        if (!isAnyArrayBuffer1(val2) || !areEqualArrayBuffers(val1, val2)) {
            return false;
        }
    } else if (isBoxedPrimitive1(val1)) {
        if (!isEqualBoxedPrimitive(val1, val2)) {
            return false;
        }
    } else if (Array.isArray(val2) || isArrayBufferView(val2) || isSet1(val2) || isMap1(val2) || isDate1(val2) || isRegExp1(val2) || isAnyArrayBuffer1(val2) || isBoxedPrimitive1(val2) || isNativeError1(val2) || val2 instanceof Error) {
        return false;
    }
    return keyCheck(val1, val2, strict, memos, valueType.noIterator);
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys = []) {
    if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        const bKeys = Object.keys(val2);
        if (aKeys.length !== bKeys.length) {
            return false;
        }
    }
    let i = 0;
    for(; i < aKeys.length; i++){
        if (!val2.propertyIsEnumerable(aKeys[i])) {
            return false;
        }
    }
    if (strict && arguments.length === 5) {
        const symbolKeysA = Object.getOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
            let count = 0;
            for(i = 0; i < symbolKeysA.length; i++){
                const key = symbolKeysA[i];
                if (val1.propertyIsEnumerable(key)) {
                    if (!val2.propertyIsEnumerable(key)) {
                        return false;
                    }
                    aKeys.push(key.toString());
                    count++;
                } else if (val2.propertyIsEnumerable(key)) {
                    return false;
                }
            }
            const symbolKeysB = Object.getOwnPropertySymbols(val2);
            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                return false;
            }
        } else {
            const symbolKeysB = Object.getOwnPropertySymbols(val2);
            if (symbolKeysB.length !== 0 && getEnumerables(val2, symbolKeysB).length !== 0) {
                return false;
            }
        }
    }
    if (aKeys.length === 0 && (iterationType === valueType.noIterator || iterationType === valueType.isArray && val1.length === 0 || val1.size === 0)) {
        return true;
    }
    if (memos === undefined) {
        memos = {
            val1: new Map(),
            val2: new Map(),
            position: 0
        };
    } else {
        const val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== undefined) {
            const val2MemoB = memos.val2.get(val2);
            if (val2MemoB !== undefined) {
                return val2MemoA === val2MemoB;
            }
        }
        memos.position++;
    }
    memos.val1.set(val1, memos.position);
    memos.val2.set(val2, memos.position);
    const areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
    memos.val1.delete(val1);
    memos.val2.delete(val2);
    return areEq;
}
function areSimilarRegExps(a, b) {
    return a.source === b.source && a.flags === b.flags && a.lastIndex === b.lastIndex;
}
function areSimilarFloatArrays(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    for(let i = 0; i < arr1.byteLength; i++){
        if (arr1[i] !== arr2[i]) {
            return false;
        }
    }
    return true;
}
function areSimilarTypedArrays(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    return Buffer1.compare(new Uint8Array(arr1.buffer, arr1.byteOffset, arr1.byteLength), new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
    return buf1.byteLength === buf2.byteLength && Buffer1.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(a, b) {
    if (Object.getOwnPropertyNames(a).length !== Object.getOwnPropertyNames(b).length) {
        return false;
    }
    if (Object.getOwnPropertySymbols(a).length !== Object.getOwnPropertySymbols(b).length) {
        return false;
    }
    if (isNumberObject1(a)) {
        return isNumberObject1(b) && Object.is(Number.prototype.valueOf.call(a), Number.prototype.valueOf.call(b));
    }
    if (isStringObject1(a)) {
        return isStringObject1(b) && String.prototype.valueOf.call(a) === String.prototype.valueOf.call(b);
    }
    if (isBooleanObject1(a)) {
        return isBooleanObject1(b) && Boolean.prototype.valueOf.call(a) === Boolean.prototype.valueOf.call(b);
    }
    if (isBigIntObject1(a)) {
        return isBigIntObject1(b) && BigInt.prototype.valueOf.call(a) === BigInt.prototype.valueOf.call(b);
    }
    if (isSymbolObject1(a)) {
        return isSymbolObject1(b) && Symbol.prototype.valueOf.call(a) === Symbol.prototype.valueOf.call(b);
    }
    throw Error(`Unknown boxed type`);
}
function getEnumerables(val, keys) {
    return keys.filter((key)=>val.propertyIsEnumerable(key));
}
function objEquiv(obj1, obj2, strict, keys, memos, iterationType) {
    let i = 0;
    if (iterationType === valueType.isSet) {
        if (!setEquiv(obj1, obj2, strict, memos)) {
            return false;
        }
    } else if (iterationType === valueType.isMap) {
        if (!mapEquiv(obj1, obj2, strict, memos)) {
            return false;
        }
    } else if (iterationType === valueType.isArray) {
        for(; i < obj1.length; i++){
            if (obj1.hasOwnProperty(i)) {
                if (!obj2.hasOwnProperty(i) || !innerDeepEqual(obj1[i], obj2[i], strict, memos)) {
                    return false;
                }
            } else if (obj2.hasOwnProperty(i)) {
                return false;
            } else {
                const keys1 = Object.keys(obj1);
                for(; i < keys1.length; i++){
                    const key = keys1[i];
                    if (!obj2.hasOwnProperty(key) || !innerDeepEqual(obj1[key], obj2[key], strict, memos)) {
                        return false;
                    }
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                return true;
            }
        }
    }
    for(i = 0; i < keys.length; i++){
        const key = keys[i];
        if (!innerDeepEqual(obj1[key], obj2[key], strict, memos)) {
            return false;
        }
    }
    return true;
}
function findLooseMatchingPrimitives(primitive) {
    switch(typeof primitive){
        case "undefined":
            return null;
        case "object":
            return undefined;
        case "symbol":
            return false;
        case "string":
            primitive = +primitive;
        case "number":
            if (Number.isNaN(primitive)) {
                return false;
            }
    }
    return true;
}
function setMightHaveLoosePrim(set1, set2, primitive) {
    const altValue = findLooseMatchingPrimitives(primitive);
    if (altValue != null) return altValue;
    return set2.has(altValue) && !set1.has(altValue);
}
function setHasEqualElement(set, val1, strict, memos) {
    for (const val2 of set){
        if (innerDeepEqual(val1, val2, strict, memos)) {
            set.delete(val2);
            return true;
        }
    }
    return false;
}
function setEquiv(set1, set2, strict, memos) {
    let set = null;
    for (const item of set1){
        if (typeof item === "object" && item !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        } else if (!set2.has(item)) {
            if (strict) return false;
            if (!setMightHaveLoosePrim(set1, set2, item)) {
                return false;
            }
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        }
    }
    if (set !== null) {
        for (const item of set2){
            if (typeof item === "object" && item !== null) {
                if (!setHasEqualElement(set, item, strict, memos)) return false;
            } else if (!strict && !set1.has(item) && !setHasEqualElement(set, item, strict, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapMightHaveLoosePrimitive(map1, map2, primitive, item, memos) {
    const altValue = findLooseMatchingPrimitives(primitive);
    if (altValue != null) {
        return altValue;
    }
    const curB = map2.get(altValue);
    if (curB === undefined && !map2.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
        return false;
    }
    return !map1.has(altValue) && innerDeepEqual(item, curB, false, memos);
}
function mapEquiv(map1, map2, strict, memos) {
    let set = null;
    for (const { 0: key , 1: item1  } of map1){
        if (typeof key === "object" && key !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(key);
        } else {
            const item2 = map2.get(key);
            if (item2 === undefined && !map2.has(key) || !innerDeepEqual(item1, item2, strict, memos)) {
                if (strict) return false;
                if (!mapMightHaveLoosePrimitive(map1, map2, key, item1, memos)) {
                    return false;
                }
                if (set === null) {
                    set = new Set();
                }
                set.add(key);
            }
        }
    }
    if (set !== null) {
        for (const { 0: key , 1: item  } of map2){
            if (typeof key === "object" && key !== null) {
                if (!mapHasEqualEntry(set, map1, key, item, strict, memos)) {
                    return false;
                }
            } else if (!strict && (!map1.has(key) || !innerDeepEqual(map1.get(key), item, false, memos)) && !mapHasEqualEntry(set, map1, key, item, false, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict, memos) {
    for (const key2 of set){
        if (innerDeepEqual(key1, key2, strict, memos) && innerDeepEqual(item1, map.get(key2), strict, memos)) {
            set.delete(key2);
            return true;
        }
    }
    return false;
}
function isArray(value) {
    return Array.isArray(value);
}
function isBoolean(value) {
    return typeof value === "boolean" || value instanceof Boolean;
}
function isNull(value) {
    return value === null;
}
function isNullOrUndefined(value) {
    return value === null || value === undefined;
}
function isNumber1(value) {
    return typeof value === "number" || value instanceof Number;
}
function isString(value) {
    return typeof value === "string" || value instanceof String;
}
function isSymbol(value) {
    return typeof value === "symbol";
}
function isUndefined(value) {
    return value === undefined;
}
function isObject(value) {
    return value !== null && typeof value === "object";
}
function isError(e) {
    return e instanceof Error;
}
function isFunction(value) {
    return typeof value === "function";
}
function isRegExp2(value) {
    return __default18.isRegExp(value);
}
function isDate2(value) {
    return __default18.isDate(value);
}
function isPrimitive(value) {
    return value === null || typeof value !== "object" && typeof value !== "function";
}
function isBuffer(value) {
    return Buffer1.isBuffer(value);
}
function _extend(target, source) {
    if (source === null || typeof source !== "object") return target;
    const keys = Object.keys(source);
    let i = keys.length;
    while(i--){
        target[keys[i]] = source[keys[i]];
    }
    return target;
}
function inherits(ctor, superCtor) {
    if (ctor === undefined || ctor === null) {
        throw new codes.ERR_INVALID_ARG_TYPE("ctor", "Function", ctor);
    }
    if (superCtor === undefined || superCtor === null) {
        throw new codes.ERR_INVALID_ARG_TYPE("superCtor", "Function", superCtor);
    }
    if (superCtor.prototype === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("superCtor.prototype", "Object", superCtor.prototype);
    }
    Object.defineProperty(ctor, "super_", {
        value: superCtor,
        writable: true,
        configurable: true
    });
    Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
}
function pad(n) {
    return n.toString().padStart(2, "0");
}
const months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
];
function timestamp() {
    const d = new Date();
    const t = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
    ].join(":");
    return `${d.getDate()} ${months[d.getMonth()]} ${t}`;
}
function log(...args) {
    console.log("%s - %s", timestamp(), format(...args));
}
const codesWarned = new Set();
function deprecate(fn, msg, code) {
    if (process2.noDeprecation === true) {
        return fn;
    }
    if (code !== undefined) {
        validateString(code, "code");
    }
    let warned = false;
    function deprecated(...args) {
        if (!warned) {
            warned = true;
            if (code !== undefined) {
                if (!codesWarned.has(code)) {
                    process2.emitWarning(msg, "DeprecationWarning", code, deprecated);
                    codesWarned.add(code);
                }
            } else {
                process2.emitWarning(msg, "DeprecationWarning", deprecated);
            }
        }
        if (new.target) {
            return Reflect.construct(fn, args, new.target);
        }
        return Reflect.apply(fn, this, args);
    }
    Object.setPrototypeOf(deprecated, fn);
    if (fn.prototype) {
        deprecated.prototype = fn.prototype;
    }
    return deprecated;
}
const __default19 = {
    format,
    formatWithOptions,
    inspect,
    isArray,
    isBoolean,
    isNull,
    isNullOrUndefined,
    isNumber: isNumber1,
    isString,
    isSymbol,
    isUndefined,
    isObject,
    isError,
    isFunction,
    isRegExp: isRegExp2,
    isDate: isDate2,
    isPrimitive,
    isBuffer,
    _extend,
    getSystemErrorName,
    deprecate,
    callbackify,
    promisify,
    inherits,
    types: __default18,
    stripVTControlCharacters,
    TextDecoder: _TextDecoder,
    TextEncoder: _TextEncoder,
    log,
    debuglog,
    isDeepStrictEqual
};
let utcCache;
function utcDate() {
    if (!utcCache) cache();
    return utcCache;
}
function cache() {
    const d = new Date();
    utcCache = d.toUTCString();
    setUnrefTimeout(resetCache, 1000 - d.getMilliseconds());
}
function resetCache() {
    utcCache = undefined;
}
function emitStatistics(_statistics) {
    notImplemented("internal/http.emitStatistics");
}
const kOutHeaders = Symbol("kOutHeaders");
const kNeedDrain = Symbol("kNeedDrain");
const __default20 = {
    utcDate,
    emitStatistics,
    kOutHeaders,
    kNeedDrain
};
const tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
function checkIsHttpToken(val) {
    return tokenRegExp.test(val);
}
const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
function checkInvalidHeaderChar(val) {
    return headerCharRegex.test(val);
}
const chunkExpression = /(?:^|\W)chunked(?:$|\W)/i;
const { async_id_symbol: async_id_symbol2  } = symbols;
let debug2 = debuglog("http", (fn)=>{
    debug2 = fn;
});
const HIGH_WATER_MARK = getDefaultHighWaterMark();
const kCorked = Symbol("corked");
const nop1 = ()=>{};
const RE_CONN_CLOSE = /(?:^|\W)close(?:$|\W)/i;
function isCookieField(s) {
    return s.length === 6 && s.toLowerCase() === "cookie";
}
function OutgoingMessage() {
    Lu.call(this);
    this.outputData = [];
    this.outputSize = 0;
    this.writable = true;
    this.destroyed = false;
    this._last = false;
    this.chunkedEncoding = false;
    this.shouldKeepAlive = true;
    this.maxRequestsOnConnectionReached = false;
    this._defaultKeepAlive = true;
    this.useChunkedEncodingByDefault = true;
    this.sendDate = false;
    this._removedConnection = false;
    this._removedContLen = false;
    this._removedTE = false;
    this._contentLength = null;
    this._hasBody = true;
    this._trailer = "";
    this[kNeedDrain] = false;
    this.finished = false;
    this._headerSent = false;
    this[kCorked] = 0;
    this._closed = false;
    this.socket = null;
    this._header = null;
    this[kOutHeaders] = null;
    this._keepAliveTimeout = 0;
    this._onPendingData = nop1;
}
Object.setPrototypeOf(OutgoingMessage.prototype, Lu.prototype);
Object.setPrototypeOf(OutgoingMessage, Lu);
Object.defineProperty(OutgoingMessage.prototype, "writableFinished", {
    get () {
        return this.finished && this.outputSize === 0 && (!this.socket || this.socket.writableLength === 0);
    }
});
Object.defineProperty(OutgoingMessage.prototype, "writableObjectMode", {
    get () {
        return false;
    }
});
Object.defineProperty(OutgoingMessage.prototype, "writableLength", {
    get () {
        return this.outputSize + (this.socket ? this.socket.writableLength : 0);
    }
});
Object.defineProperty(OutgoingMessage.prototype, "writableHighWaterMark", {
    get () {
        return this.socket ? this.socket.writableHighWaterMark : HIGH_WATER_MARK;
    }
});
Object.defineProperty(OutgoingMessage.prototype, "writableCorked", {
    get () {
        const corked = this.socket ? this.socket.writableCorked : 0;
        return corked + this[kCorked];
    }
});
Object.defineProperty(OutgoingMessage.prototype, "_headers", {
    get: deprecate(function() {
        return this.getHeaders();
    }, "OutgoingMessage.prototype._headers is deprecated", "DEP0066"),
    set: deprecate(function(val) {
        if (val == null) {
            this[kOutHeaders] = null;
        } else if (typeof val === "object") {
            const headers = this[kOutHeaders] = Object.create(null);
            const keys = Object.keys(val);
            for(let i = 0; i < keys.length; ++i){
                const name = keys[i];
                headers[name.toLowerCase()] = [
                    name,
                    val[name]
                ];
            }
        }
    }, "OutgoingMessage.prototype._headers is deprecated", "DEP0066")
});
Object.defineProperty(OutgoingMessage.prototype, "connection", {
    get: function() {
        return this.socket;
    },
    set: function(val) {
        this.socket = val;
    }
});
Object.defineProperty(OutgoingMessage.prototype, "_headerNames", {
    get: deprecate(function() {
        const headers = this[kOutHeaders];
        if (headers !== null) {
            const out = Object.create(null);
            const keys = Object.keys(headers);
            for(let i = 0; i < keys.length; ++i){
                const key = keys[i];
                const val = headers[key][0];
                out[key] = val;
            }
            return out;
        }
        return null;
    }, "OutgoingMessage.prototype._headerNames is deprecated", "DEP0066"),
    set: deprecate(function(val) {
        if (typeof val === "object" && val !== null) {
            const headers = this[kOutHeaders];
            if (!headers) {
                return;
            }
            const keys = Object.keys(val);
            for(let i = 0; i < keys.length; ++i){
                const header = headers[keys[i]];
                if (header) {
                    header[0] = val[keys[i]];
                }
            }
        }
    }, "OutgoingMessage.prototype._headerNames is deprecated", "DEP0066")
});
OutgoingMessage.prototype._renderHeaders = function _renderHeaders() {
    if (this._header) {
        throw new ERR_HTTP_HEADERS_SENT("render");
    }
    const headersMap = this[kOutHeaders];
    const headers = {};
    if (headersMap !== null) {
        const keys = Object.keys(headersMap);
        for(let i = 0, l = keys.length; i < l; i++){
            const key = keys[i];
            headers[headersMap[key][0]] = headersMap[key][1];
        }
    }
    return headers;
};
OutgoingMessage.prototype.cork = function() {
    if (this.socket) {
        this.socket.cork();
    } else {
        this[kCorked]++;
    }
};
OutgoingMessage.prototype.uncork = function() {
    if (this.socket) {
        this.socket.uncork();
    } else if (this[kCorked]) {
        this[kCorked]--;
    }
};
OutgoingMessage.prototype.setTimeout = function setTimeout1(msecs, callback) {
    if (callback) {
        this.on("timeout", callback);
    }
    if (!this.socket) {
        this.once("socket", function socketSetTimeoutOnConnect(socket) {
            socket.setTimeout(msecs);
        });
    } else {
        this.socket.setTimeout(msecs);
    }
    return this;
};
OutgoingMessage.prototype.destroy = function destroy(error) {
    if (this.destroyed) {
        return this;
    }
    this.destroyed = true;
    if (this.socket) {
        this.socket.destroy(error);
    } else {
        this.once("socket", function socketDestroyOnConnect(socket) {
            socket.destroy(error);
        });
    }
    return this;
};
OutgoingMessage.prototype._send = function _send(data, encoding, callback) {
    if (!this._headerSent) {
        if (typeof data === "string" && (encoding === "utf8" || encoding === "latin1" || !encoding)) {
            data = this._header + data;
        } else {
            const header = this._header;
            this.outputData.unshift({
                data: header,
                encoding: "latin1",
                callback: null
            });
            this.outputSize += header.length;
            this._onPendingData(header.length);
        }
        this._headerSent = true;
    }
    return this._writeRaw(data, encoding, callback);
};
OutgoingMessage.prototype._writeRaw = _writeRaw;
function _writeRaw(data, encoding, callback) {
    const conn = this.socket;
    if (conn && conn.destroyed) {
        return false;
    }
    if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
    }
    if (conn && conn._httpMessage === this && conn.writable) {
        if (this.outputData.length) {
            this._flushOutput(conn);
        }
        return conn.write(data, encoding, callback);
    }
    this.outputData.push({
        data,
        encoding,
        callback
    });
    this.outputSize += data.length;
    this._onPendingData(data.length);
    return this.outputSize < HIGH_WATER_MARK;
}
OutgoingMessage.prototype._storeHeader = _storeHeader;
function _storeHeader(firstLine, headers) {
    const state = {
        connection: false,
        contLen: false,
        te: false,
        date: false,
        expect: false,
        trailer: false,
        header: firstLine
    };
    if (headers) {
        if (headers === this[kOutHeaders]) {
            for(const key in headers){
                const entry = headers[key];
                processHeader(this, state, entry[0], entry[1], false);
            }
        } else if (Array.isArray(headers)) {
            if (headers.length && Array.isArray(headers[0])) {
                for(let i = 0; i < headers.length; i++){
                    const entry = headers[i];
                    processHeader(this, state, entry[0], entry[1], true);
                }
            } else {
                if (headers.length % 2 !== 0) {
                    throw new ERR_INVALID_ARG_VALUE("headers", headers);
                }
                for(let n = 0; n < headers.length; n += 2){
                    processHeader(this, state, headers[n + 0], headers[n + 1], true);
                }
            }
        } else {
            for(const key in headers){
                if (Object.hasOwn(headers, key)) {
                    processHeader(this, state, key, headers[key], true);
                }
            }
        }
    }
    let { header  } = state;
    if (this.sendDate && !state.date) {
        header += "Date: " + utcDate() + "\r\n";
    }
    if (this.chunkedEncoding && (this.statusCode === 204 || this.statusCode === 304)) {
        debug2(this.statusCode + " response should not use chunked encoding," + " closing connection.");
        this.chunkedEncoding = false;
        this.shouldKeepAlive = false;
    }
    if (this._removedConnection) {
        this._last = true;
        this.shouldKeepAlive = false;
    } else if (!state.connection) {
        const shouldSendKeepAlive = this.shouldKeepAlive && (state.contLen || this.useChunkedEncodingByDefault || this.agent);
        if (shouldSendKeepAlive && this.maxRequestsOnConnectionReached) {
            header += "Connection: close\r\n";
        } else if (shouldSendKeepAlive) {
            header += "Connection: keep-alive\r\n";
            if (this._keepAliveTimeout && this._defaultKeepAlive) {
                const timeoutSeconds = Math.floor(this._keepAliveTimeout / 1000);
                header += `Keep-Alive: timeout=${timeoutSeconds}\r\n`;
            }
        } else {
            this._last = true;
            header += "Connection: close\r\n";
        }
    }
    if (!state.contLen && !state.te) {
        if (!this._hasBody) {
            this.chunkedEncoding = false;
        } else if (!this.useChunkedEncodingByDefault) {
            this._last = true;
        } else if (!state.trailer && !this._removedContLen && typeof this._contentLength === "number") {
            header += "Content-Length: " + this._contentLength + "\r\n";
        } else if (!this._removedTE) {
            header += "Transfer-Encoding: chunked\r\n";
            this.chunkedEncoding = true;
        } else {
            debug2("Both Content-Length and Transfer-Encoding are removed");
        }
    }
    if (this.chunkedEncoding !== true && state.trailer) {
        throw new ERR_HTTP_TRAILER_INVALID();
    }
    this._header = header + "\r\n";
    this._headerSent = false;
    if (state.expect) this._send("");
}
function processHeader(self, state, key, value, validate) {
    if (validate) {
        validateHeaderName(key);
    }
    if (Array.isArray(value)) {
        if (value.length < 2 || !isCookieField(key)) {
            for(let i = 0; i < value.length; i++){
                storeHeader(self, state, key, value[i], validate);
            }
            return;
        }
        value = value.join("; ");
    }
    storeHeader(self, state, key, value, validate);
}
function storeHeader(self, state, key, value, validate) {
    if (validate) {
        validateHeaderValue(key, value);
    }
    state.header += key + ": " + value + "\r\n";
    matchHeader(self, state, key, value);
}
function matchHeader(self, state, field, value) {
    if (field.length < 4 || field.length > 17) {
        return;
    }
    field = field.toLowerCase();
    switch(field){
        case "connection":
            state.connection = true;
            self._removedConnection = false;
            if (RE_CONN_CLOSE.test(value)) {
                self._last = true;
            } else {
                self.shouldKeepAlive = true;
            }
            break;
        case "transfer-encoding":
            state.te = true;
            self._removedTE = false;
            if (chunkExpression.test(value)) {
                self.chunkedEncoding = true;
            }
            break;
        case "content-length":
            state.contLen = true;
            self._removedContLen = false;
            break;
        case "date":
        case "expect":
        case "trailer":
            state[field] = true;
            break;
        case "keep-alive":
            self._defaultKeepAlive = false;
            break;
    }
}
const validateHeaderName = hideStackFrames((name)=>{
    if (typeof name !== "string" || !name || !checkIsHttpToken(name)) {
        throw new ERR_INVALID_HTTP_TOKEN("Header name", name);
    }
});
const validateHeaderValue = hideStackFrames((name, value)=>{
    if (value === undefined) {
        throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);
    }
    if (checkInvalidHeaderChar(value)) {
        debug2('Header "%s" contains invalid characters', name);
        throw new ERR_INVALID_CHAR("header content", name);
    }
});
OutgoingMessage.prototype.setHeader = function setHeader(name, value) {
    if (this._header) {
        throw new ERR_HTTP_HEADERS_SENT("set");
    }
    validateHeaderName(name);
    validateHeaderValue(name, value);
    let headers = this[kOutHeaders];
    if (headers === null) {
        this[kOutHeaders] = headers = Object.create(null);
    }
    headers[name.toLowerCase()] = [
        name,
        value
    ];
    return this;
};
OutgoingMessage.prototype.getHeader = function getHeader(name) {
    validateString(name, "name");
    const headers = this[kOutHeaders];
    if (headers === null) {
        return;
    }
    const entry = headers[name.toLowerCase()];
    return entry && entry[1];
};
OutgoingMessage.prototype.getHeaderNames = function getHeaderNames() {
    return this[kOutHeaders] !== null ? Object.keys(this[kOutHeaders]) : [];
};
OutgoingMessage.prototype.getRawHeaderNames = function getRawHeaderNames() {
    const headersMap = this[kOutHeaders];
    if (headersMap === null) return [];
    const values = Object.values(headersMap);
    const headers = Array(values.length);
    for(let i = 0, l = values.length; i < l; i++){
        headers[i] = values[i][0];
    }
    return headers;
};
OutgoingMessage.prototype.getHeaders = function getHeaders() {
    const headers = this[kOutHeaders];
    const ret = Object.create(null);
    if (headers) {
        const keys = Object.keys(headers);
        for(let i = 0; i < keys.length; ++i){
            const key = keys[i];
            const val = headers[key][1];
            ret[key] = val;
        }
    }
    return ret;
};
OutgoingMessage.prototype.hasHeader = function hasHeader(name) {
    validateString(name, "name");
    return this[kOutHeaders] !== null && !!this[kOutHeaders][name.toLowerCase()];
};
OutgoingMessage.prototype.removeHeader = function removeHeader(name) {
    validateString(name, "name");
    if (this._header) {
        throw new ERR_HTTP_HEADERS_SENT("remove");
    }
    const key = name.toLowerCase();
    switch(key){
        case "connection":
            this._removedConnection = true;
            break;
        case "content-length":
            this._removedContLen = true;
            break;
        case "transfer-encoding":
            this._removedTE = true;
            break;
        case "date":
            this.sendDate = false;
            break;
    }
    if (this[kOutHeaders] !== null) {
        delete this[kOutHeaders][key];
    }
};
OutgoingMessage.prototype._implicitHeader = function _implicitHeader() {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_implicitHeader()");
};
Object.defineProperty(OutgoingMessage.prototype, "headersSent", {
    configurable: true,
    enumerable: true,
    get: function() {
        return !!this._header;
    }
});
Object.defineProperty(OutgoingMessage.prototype, "writableEnded", {
    get: function() {
        return this.finished;
    }
});
Object.defineProperty(OutgoingMessage.prototype, "writableNeedDrain", {
    get: function() {
        return !this.destroyed && !this.finished && this[kNeedDrain];
    }
});
const crlf_buf = Buffer1.from("\r\n");
OutgoingMessage.prototype.write = function write(chunk, encoding, callback) {
    if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
    }
    const ret = write_(this, chunk, encoding, callback, false);
    if (!ret) {
        this[kNeedDrain] = true;
    }
    return ret;
};
function onError(msg, err, callback) {
    const triggerAsyncId = msg.socket ? msg.socket[async_id_symbol2] : undefined;
    defaultTriggerAsyncIdScope(triggerAsyncId, globalThis.process.nextTick, emitErrorNt, msg, err, callback);
}
function emitErrorNt(msg, err, callback) {
    callback(err);
    if (typeof msg.emit === "function" && !msg._closed) {
        msg.emit("error", err);
    }
}
function write_(msg, chunk, encoding, callback, fromEnd) {
    if (typeof callback !== "function") {
        callback = nop1;
    }
    let len;
    if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk === "string") {
        len = Buffer1.byteLength(chunk, encoding);
    } else if (isUint8Array(chunk)) {
        len = chunk.length;
    } else {
        throw new ERR_INVALID_ARG_TYPE("chunk", [
            "string",
            "Buffer",
            "Uint8Array"
        ], chunk);
    }
    let err;
    if (msg.finished) {
        err = new ERR_STREAM_WRITE_AFTER_END();
    } else if (msg.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
    }
    if (err) {
        if (!msg.destroyed) {
            onError(msg, err, callback);
        } else {
            globalThis.process.nextTick(callback, err);
        }
        return false;
    }
    if (!msg._header) {
        if (fromEnd) {
            msg._contentLength = len;
        }
        msg._implicitHeader();
    }
    if (!msg._hasBody) {
        debug2("This type of response MUST NOT have a body. " + "Ignoring write() calls.");
        globalThis.process.nextTick(callback);
        return true;
    }
    if (!fromEnd && msg.socket && !msg.socket.writableCorked) {
        msg.socket.cork();
        globalThis.process.nextTick(connectionCorkNT, msg.socket);
    }
    let ret;
    if (msg.chunkedEncoding && chunk.length !== 0) {
        msg._send(len.toString(16), "latin1", null);
        msg._send(crlf_buf, null, null);
        msg._send(chunk, encoding, null);
        ret = msg._send(crlf_buf, null, callback);
    } else {
        ret = msg._send(chunk, encoding, callback);
    }
    debug2("write ret = " + ret);
    return ret;
}
function connectionCorkNT(conn) {
    conn.uncork();
}
OutgoingMessage.prototype.addTrailers = function addTrailers(headers) {
    this._trailer = "";
    const keys = Object.keys(headers);
    const isArray = Array.isArray(headers);
    for(let i = 0, l = keys.length; i < l; i++){
        let field, value;
        const key = keys[i];
        if (isArray) {
            field = headers[key][0];
            value = headers[key][1];
        } else {
            field = key;
            value = headers[key];
        }
        if (typeof field !== "string" || !field || !checkIsHttpToken(field)) {
            throw new ERR_INVALID_HTTP_TOKEN("Trailer name", field);
        }
        if (checkInvalidHeaderChar(value)) {
            debug2('Trailer "%s" contains invalid characters', field);
            throw new ERR_INVALID_CHAR("trailer content", field);
        }
        this._trailer += field + ": " + value + "\r\n";
    }
};
function onFinish(outmsg) {
    if (outmsg && outmsg.socket && outmsg.socket._hadError) return;
    outmsg.emit("finish");
}
OutgoingMessage.prototype.end = function end(chunk, encoding, callback) {
    if (typeof chunk === "function") {
        callback = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
    }
    if (chunk) {
        if (this.finished) {
            onError(this, new ERR_STREAM_WRITE_AFTER_END(), typeof callback !== "function" ? nop1 : callback);
            return this;
        }
        if (this.socket) {
            this.socket.cork();
        }
        write_(this, chunk, encoding, null, true);
    } else if (this.finished) {
        if (typeof callback === "function") {
            if (!this.writableFinished) {
                this.on("finish", callback);
            } else {
                callback(new ERR_STREAM_ALREADY_FINISHED("end"));
            }
        }
        return this;
    } else if (!this._header) {
        if (this.socket) {
            this.socket.cork();
        }
        this._contentLength = 0;
        this._implicitHeader();
    }
    if (typeof callback === "function") {
        this.once("finish", callback);
    }
    const finish = onFinish.bind(undefined, this);
    if (this._hasBody && this.chunkedEncoding) {
        this._send("0\r\n" + this._trailer + "\r\n", "latin1", finish);
    } else if (!this._headerSent || this.writableLength || chunk) {
        this._send("", "latin1", finish);
    } else {
        globalThis.process.nextTick(finish);
    }
    if (this.socket) {
        this.socket._writableState.corked = 1;
        this.socket.uncork();
    }
    this[kCorked] = 0;
    this.finished = true;
    debug2("outgoing message end.");
    if (this.outputData.length === 0 && this.socket && this.socket._httpMessage === this) {
        this._finish();
    }
    return this;
};
OutgoingMessage.prototype._finish = function _finish() {
    assert2(this.socket);
    this.emit("prefinish");
};
OutgoingMessage.prototype._flush = function _flush() {
    const socket = this.socket;
    if (socket && socket.writable) {
        const ret = this._flushOutput(socket);
        if (this.finished) {
            this._finish();
        } else if (ret && this[kNeedDrain]) {
            this[kNeedDrain] = false;
            this.emit("drain");
        }
    }
};
OutgoingMessage.prototype._flushOutput = function _flushOutput(socket) {
    while(this[kCorked]){
        this[kCorked]--;
        socket.cork();
    }
    const outputLength = this.outputData.length;
    if (outputLength <= 0) {
        return undefined;
    }
    const outputData = this.outputData;
    socket.cork();
    let ret;
    for(let i = 0; i < outputLength; i++){
        const { data , encoding , callback  } = outputData[i];
        ret = socket.write(data, encoding, callback);
    }
    socket.uncork();
    this.outputData = [];
    this._onPendingData(-this.outputSize);
    this.outputSize = 0;
    return ret;
};
OutgoingMessage.prototype.flushHeaders = function flushHeaders() {
    if (!this._header) {
        this._implicitHeader();
    }
    this._send("");
};
OutgoingMessage.prototype.pipe = function pipe() {
    this.emit("error", new ERR_STREAM_CANNOT_PIPE());
};
OutgoingMessage.prototype[EventEmitter.captureRejectionSymbol] = function(err, _event) {
    this.destroy(err);
};
const __default21 = {
    validateHeaderName,
    validateHeaderValue,
    OutgoingMessage
};
const { from , fromWeb , toWeb  } = Tu;
const { ReadableState , _fromList , from: from1 , fromWeb: fromWeb1 , toWeb: toWeb1 , wrap  } = Au;
const { WritableState , fromWeb: fromWeb2 , toWeb: toWeb2  } = mu;
const { Deno: Deno2  } = globalThis;
const noColor = typeof Deno2?.noColor === "boolean" ? Deno2.noColor : true;
let enabled = !noColor;
function code(open, close) {
    return {
        open: `\x1b[${open.join(";")}m`,
        close: `\x1b[${close}m`,
        regexp: new RegExp(`\\x1b\\[${close}m`, "g")
    };
}
function run(str, code) {
    return enabled ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}` : str;
}
function bold(str) {
    return run(str, code([
        1
    ], 22));
}
function red(str) {
    return run(str, code([
        31
    ], 39));
}
function green(str) {
    return run(str, code([
        32
    ], 39));
}
function white(str) {
    return run(str, code([
        37
    ], 39));
}
function gray(str) {
    return brightBlack(str);
}
function brightBlack(str) {
    return run(str, code([
        90
    ], 39));
}
function bgRed(str) {
    return run(str, code([
        41
    ], 49));
}
function bgGreen(str) {
    return run(str, code([
        42
    ], 49));
}
const ANSI_PATTERN = new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
].join("|"), "g");
function stripColor(string) {
    return string.replace(ANSI_PATTERN, "");
}
function getConsoleWidth() {
    try {
        return Deno.consoleSize().columns;
    } catch  {
        return 80;
    }
}
const MathMax = Math.max;
const { Error: Error1  } = globalThis;
const { create: ObjectCreate1 , defineProperty: ObjectDefineProperty , getPrototypeOf: ObjectGetPrototypeOf , getOwnPropertyDescriptor: ObjectGetOwnPropertyDescriptor , keys: ObjectKeys  } = Object;
let blue = "";
let green1 = "";
let red1 = "";
let defaultColor = "";
const kReadableOperator = {
    deepStrictEqual: "Expected values to be strictly deep-equal:",
    strictEqual: "Expected values to be strictly equal:",
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: "Expected values to be loosely deep-equal:",
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notIdentical: "Values have same structure but are not reference-equal:",
    notDeepEqualUnequal: "Expected values not to be loosely deep-equal:"
};
function copyError(source) {
    const keys = ObjectKeys(source);
    const target = ObjectCreate1(ObjectGetPrototypeOf(source));
    for (const key of keys){
        const desc = ObjectGetOwnPropertyDescriptor(source, key);
        if (desc !== undefined) {
            ObjectDefineProperty(target, key, desc);
        }
    }
    ObjectDefineProperty(target, "message", {
        value: source.message
    });
    return target;
}
function inspectValue(val) {
    return inspect(val, {
        compact: true,
        customInspect: false,
        depth: 1000,
        maxArrayLength: Infinity,
        showHidden: false,
        showProxy: false,
        sorted: true,
        getters: true
    });
}
function createErrDiff(actual, expected, operator) {
    let other = "";
    let res = "";
    let end = "";
    let skipped = false;
    const actualInspected = inspectValue(actual);
    const actualLines = actualInspected.split("\n");
    const expectedLines = inspectValue(expected).split("\n");
    let i = 0;
    let indicator = "";
    if (operator === "strictEqual" && (typeof actual === "object" && actual !== null && typeof expected === "object" && expected !== null || typeof actual === "function" && typeof expected === "function")) {
        operator = "strictEqualObject";
    }
    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
        const c = inspect.defaultOptions.colors;
        const actualRaw = c ? stripColor(actualLines[0]) : actualLines[0];
        const expectedRaw = c ? stripColor(expectedLines[0]) : expectedLines[0];
        const inputLength = actualRaw.length + expectedRaw.length;
        if (inputLength <= 12) {
            if ((typeof actual !== "object" || actual === null) && (typeof expected !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
                return `${kReadableOperator[operator]}\n\n` + `${actualLines[0]} !== ${expectedLines[0]}\n`;
            }
        } else if (operator !== "strictEqualObject") {
            const maxLength = Deno.isatty(Deno.stderr.rid) ? getConsoleWidth() : 80;
            if (inputLength < maxLength) {
                while(actualRaw[i] === expectedRaw[i]){
                    i++;
                }
                if (i > 2) {
                    indicator = `\n  ${" ".repeat(i)}^`;
                    i = 0;
                }
            }
        }
    }
    let a = actualLines[actualLines.length - 1];
    let b = expectedLines[expectedLines.length - 1];
    while(a === b){
        if (i++ < 3) {
            end = `\n  ${a}${end}`;
        } else {
            other = a;
        }
        actualLines.pop();
        expectedLines.pop();
        if (actualLines.length === 0 || expectedLines.length === 0) {
            break;
        }
        a = actualLines[actualLines.length - 1];
        b = expectedLines[expectedLines.length - 1];
    }
    const maxLines = MathMax(actualLines.length, expectedLines.length);
    if (maxLines === 0) {
        const actualLines = actualInspected.split("\n");
        if (actualLines.length > 50) {
            actualLines[46] = `${blue}...${defaultColor}`;
            while(actualLines.length > 47){
                actualLines.pop();
            }
        }
        return `${kReadableOperator.notIdentical}\n\n${actualLines.join("\n")}\n`;
    }
    if (i >= 5) {
        end = `\n${blue}...${defaultColor}${end}`;
        skipped = true;
    }
    if (other !== "") {
        end = `\n  ${other}${end}`;
        other = "";
    }
    let printedLines = 0;
    let identical = 0;
    const msg = kReadableOperator[operator] + `\n${green1}+ actual${defaultColor} ${red1}- expected${defaultColor}`;
    const skippedMsg = ` ${blue}...${defaultColor} Lines skipped`;
    let lines = actualLines;
    let plusMinus = `${green1}+${defaultColor}`;
    let maxLength = expectedLines.length;
    if (actualLines.length < maxLines) {
        lines = expectedLines;
        plusMinus = `${red1}-${defaultColor}`;
        maxLength = actualLines.length;
    }
    for(i = 0; i < maxLines; i++){
        if (maxLength < i + 1) {
            if (identical > 2) {
                if (identical > 3) {
                    if (identical > 4) {
                        if (identical === 5) {
                            res += `\n  ${lines[i - 3]}`;
                            printedLines++;
                        } else {
                            res += `\n${blue}...${defaultColor}`;
                            skipped = true;
                        }
                    }
                    res += `\n  ${lines[i - 2]}`;
                    printedLines++;
                }
                res += `\n  ${lines[i - 1]}`;
                printedLines++;
            }
            identical = 0;
            if (lines === actualLines) {
                res += `\n${plusMinus} ${lines[i]}`;
            } else {
                other += `\n${plusMinus} ${lines[i]}`;
            }
            printedLines++;
        } else {
            const expectedLine = expectedLines[i];
            let actualLine = actualLines[i];
            let divergingLines = actualLine !== expectedLine && (!actualLine.endsWith(",") || actualLine.slice(0, -1) !== expectedLine);
            if (divergingLines && expectedLine.endsWith(",") && expectedLine.slice(0, -1) === actualLine) {
                divergingLines = false;
                actualLine += ",";
            }
            if (divergingLines) {
                if (identical > 2) {
                    if (identical > 3) {
                        if (identical > 4) {
                            if (identical === 5) {
                                res += `\n  ${actualLines[i - 3]}`;
                                printedLines++;
                            } else {
                                res += `\n${blue}...${defaultColor}`;
                                skipped = true;
                            }
                        }
                        res += `\n  ${actualLines[i - 2]}`;
                        printedLines++;
                    }
                    res += `\n  ${actualLines[i - 1]}`;
                    printedLines++;
                }
                identical = 0;
                res += `\n${green1}+${defaultColor} ${actualLine}`;
                other += `\n${red1}-${defaultColor} ${expectedLine}`;
                printedLines += 2;
            } else {
                res += other;
                other = "";
                identical++;
                if (identical <= 2) {
                    res += `\n  ${actualLine}`;
                    printedLines++;
                }
            }
        }
        if (printedLines > 50 && i < maxLines - 2) {
            return `${msg}${skippedMsg}\n${res}\n${blue}...${defaultColor}${other}\n` + `${blue}...${defaultColor}`;
        }
    }
    return `${msg}${skipped ? skippedMsg : ""}\n${res}${other}${end}${indicator}`;
}
class AssertionError extends Error1 {
    constructor(options){
        if (typeof options !== "object" || options === null) {
            throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        const { message , operator , stackStartFn , details , stackStartFunction  } = options;
        let { actual , expected  } = options;
        const limit = Error1.stackTraceLimit;
        Error1.stackTraceLimit = 0;
        if (message != null) {
            super(String(message));
        } else {
            if (Deno.isatty(Deno.stderr.rid)) {
                if (Deno.noColor) {
                    blue = "";
                    green1 = "";
                    defaultColor = "";
                    red1 = "";
                } else {
                    blue = "\u001b[34m";
                    green1 = "\u001b[32m";
                    defaultColor = "\u001b[39m";
                    red1 = "\u001b[31m";
                }
            }
            if (typeof actual === "object" && actual !== null && typeof expected === "object" && expected !== null && "stack" in actual && actual instanceof Error1 && "stack" in expected && expected instanceof Error1) {
                actual = copyError(actual);
                expected = copyError(expected);
            }
            if (operator === "deepStrictEqual" || operator === "strictEqual") {
                super(createErrDiff(actual, expected, operator));
            } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
                let base = kReadableOperator[operator];
                const res = inspectValue(actual).split("\n");
                if (operator === "notStrictEqual" && (typeof actual === "object" && actual !== null || typeof actual === "function")) {
                    base = kReadableOperator.notStrictEqualObject;
                }
                if (res.length > 50) {
                    res[46] = `${blue}...${defaultColor}`;
                    while(res.length > 47){
                        res.pop();
                    }
                }
                if (res.length === 1) {
                    super(`${base}${res[0].length > 5 ? "\n\n" : " "}${res[0]}`);
                } else {
                    super(`${base}\n\n${res.join("\n")}\n`);
                }
            } else {
                let res = inspectValue(actual);
                let other = inspectValue(expected);
                const knownOperator = kReadableOperator[operator ?? ""];
                if (operator === "notDeepEqual" && res === other) {
                    res = `${knownOperator}\n\n${res}`;
                    if (res.length > 1024) {
                        res = `${res.slice(0, 1021)}...`;
                    }
                    super(res);
                } else {
                    if (res.length > 512) {
                        res = `${res.slice(0, 509)}...`;
                    }
                    if (other.length > 512) {
                        other = `${other.slice(0, 509)}...`;
                    }
                    if (operator === "deepEqual") {
                        res = `${knownOperator}\n\n${res}\n\nshould loosely deep-equal\n\n`;
                    } else {
                        const newOp = kReadableOperator[`${operator}Unequal`];
                        if (newOp) {
                            res = `${newOp}\n\n${res}\n\nshould not loosely deep-equal\n\n`;
                        } else {
                            other = ` ${operator} ${other}`;
                        }
                    }
                    super(`${res}${other}`);
                }
            }
        }
        Error1.stackTraceLimit = limit;
        this.generatedMessage = !message;
        ObjectDefineProperty(this, "name", {
            __proto__: null,
            value: "AssertionError [ERR_ASSERTION]",
            enumerable: false,
            writable: true,
            configurable: true
        });
        this.code = "ERR_ASSERTION";
        if (details) {
            this.actual = undefined;
            this.expected = undefined;
            this.operator = undefined;
            for(let i = 0; i < details.length; i++){
                this["message " + i] = details[i].message;
                this["actual " + i] = details[i].actual;
                this["expected " + i] = details[i].expected;
                this["operator " + i] = details[i].operator;
                this["stack trace " + i] = details[i].stack;
            }
        } else {
            this.actual = actual;
            this.expected = expected;
            this.operator = operator;
        }
        Error1.captureStackTrace(this, stackStartFn || stackStartFunction);
        this.stack;
        this.name = "AssertionError";
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
    [inspect.custom](_recurseTimes, ctx) {
        const tmpActual = this.actual;
        const tmpExpected = this.expected;
        for (const name of [
            "actual",
            "expected"
        ]){
            if (typeof this[name] === "string") {
                const value = this[name];
                const lines = value.split("\n");
                if (lines.length > 10) {
                    lines.length = 10;
                    this[name] = `${lines.join("\n")}\n...`;
                } else if (value.length > 512) {
                    this[name] = `${value.slice(512)}...`;
                }
            }
        }
        const result = inspect(this, {
            ...ctx,
            customInspect: false,
            depth: 0
        });
        this.actual = tmpActual;
        this.expected = tmpExpected;
        return result;
    }
}
var DiffType;
(function(DiffType) {
    DiffType["removed"] = "removed";
    DiffType["common"] = "common";
    DiffType["added"] = "added";
})(DiffType || (DiffType = {}));
const REMOVED = 1;
const COMMON = 2;
const ADDED = 3;
function createCommon(A, B, reverse) {
    const common = [];
    if (A.length === 0 || B.length === 0) return [];
    for(let i = 0; i < Math.min(A.length, B.length); i += 1){
        if (A[reverse ? A.length - i - 1 : i] === B[reverse ? B.length - i - 1 : i]) {
            common.push(A[reverse ? A.length - i - 1 : i]);
        } else {
            return common;
        }
    }
    return common;
}
function diff(A, B) {
    const prefixCommon = createCommon(A, B);
    const suffixCommon = createCommon(A.slice(prefixCommon.length), B.slice(prefixCommon.length), true).reverse();
    A = suffixCommon.length ? A.slice(prefixCommon.length, -suffixCommon.length) : A.slice(prefixCommon.length);
    B = suffixCommon.length ? B.slice(prefixCommon.length, -suffixCommon.length) : B.slice(prefixCommon.length);
    const swapped = B.length > A.length;
    [A, B] = swapped ? [
        B,
        A
    ] : [
        A,
        B
    ];
    const M = A.length;
    const N = B.length;
    if (!M && !N && !suffixCommon.length && !prefixCommon.length) return [];
    if (!N) {
        return [
            ...prefixCommon.map((c)=>({
                    type: DiffType.common,
                    value: c
                })),
            ...A.map((a)=>({
                    type: swapped ? DiffType.added : DiffType.removed,
                    value: a
                })),
            ...suffixCommon.map((c)=>({
                    type: DiffType.common,
                    value: c
                }))
        ];
    }
    const offset = N;
    const delta = M - N;
    const size = M + N + 1;
    const fp = Array.from({
        length: size
    }, ()=>({
            y: -1,
            id: -1
        }));
    const routes = new Uint32Array((M * N + size + 1) * 2);
    const diffTypesPtrOffset = routes.length / 2;
    let ptr = 0;
    let p = -1;
    function backTrace(A, B, current, swapped) {
        const M = A.length;
        const N = B.length;
        const result = [];
        let a = M - 1;
        let b = N - 1;
        let j = routes[current.id];
        let type = routes[current.id + diffTypesPtrOffset];
        while(true){
            if (!j && !type) break;
            const prev = j;
            if (type === 1) {
                result.unshift({
                    type: swapped ? DiffType.removed : DiffType.added,
                    value: B[b]
                });
                b -= 1;
            } else if (type === 3) {
                result.unshift({
                    type: swapped ? DiffType.added : DiffType.removed,
                    value: A[a]
                });
                a -= 1;
            } else {
                result.unshift({
                    type: DiffType.common,
                    value: A[a]
                });
                a -= 1;
                b -= 1;
            }
            j = routes[prev];
            type = routes[prev + diffTypesPtrOffset];
        }
        return result;
    }
    function createFP(slide, down, k, M) {
        if (slide && slide.y === -1 && down && down.y === -1) {
            return {
                y: 0,
                id: 0
            };
        }
        if (down && down.y === -1 || k === M || (slide && slide.y) > (down && down.y) + 1) {
            const prev = slide.id;
            ptr++;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = ADDED;
            return {
                y: slide.y,
                id: ptr
            };
        } else {
            const prev = down.id;
            ptr++;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = REMOVED;
            return {
                y: down.y + 1,
                id: ptr
            };
        }
    }
    function snake(k, slide, down, _offset, A, B) {
        const M = A.length;
        const N = B.length;
        if (k < -N || M < k) return {
            y: -1,
            id: -1
        };
        const fp = createFP(slide, down, k, M);
        while(fp.y + k < M && fp.y < N && A[fp.y + k] === B[fp.y]){
            const prev = fp.id;
            ptr++;
            fp.id = ptr;
            fp.y += 1;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = COMMON;
        }
        return fp;
    }
    while(fp[delta + offset].y < N){
        p = p + 1;
        for(let k = -p; k < delta; ++k){
            fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
        }
        for(let k = delta + p; k > delta; --k){
            fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
        }
        fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A, B);
    }
    return [
        ...prefixCommon.map((c)=>({
                type: DiffType.common,
                value: c
            })),
        ...backTrace(A, B, fp[delta + offset], swapped),
        ...suffixCommon.map((c)=>({
                type: DiffType.common,
                value: c
            }))
    ];
}
function diffstr(A, B) {
    function unescape(string) {
        return string.replaceAll("\b", "\\b").replaceAll("\f", "\\f").replaceAll("\t", "\\t").replaceAll("\v", "\\v").replaceAll(/\r\n|\r|\n/g, (str)=>str === "\r" ? "\\r" : str === "\n" ? "\\n\n" : "\\r\\n\r\n");
    }
    function tokenize(string, { wordDiff =false  } = {}) {
        if (wordDiff) {
            const tokens = string.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
            const words = /^[a-zA-Z\u{C0}-\u{FF}\u{D8}-\u{F6}\u{F8}-\u{2C6}\u{2C8}-\u{2D7}\u{2DE}-\u{2FF}\u{1E00}-\u{1EFF}]+$/u;
            for(let i = 0; i < tokens.length - 1; i++){
                if (!tokens[i + 1] && tokens[i + 2] && words.test(tokens[i]) && words.test(tokens[i + 2])) {
                    tokens[i] += tokens[i + 2];
                    tokens.splice(i + 1, 2);
                    i--;
                }
            }
            return tokens.filter((token)=>token);
        } else {
            const tokens = [], lines = string.split(/(\n|\r\n)/);
            if (!lines[lines.length - 1]) {
                lines.pop();
            }
            for(let i = 0; i < lines.length; i++){
                if (i % 2) {
                    tokens[tokens.length - 1] += lines[i];
                } else {
                    tokens.push(lines[i]);
                }
            }
            return tokens;
        }
    }
    function createDetails(line, tokens) {
        return tokens.filter(({ type  })=>type === line.type || type === DiffType.common).map((result, i, t)=>{
            if (result.type === DiffType.common && t[i - 1] && t[i - 1]?.type === t[i + 1]?.type && /\s+/.test(result.value)) {
                return {
                    ...result,
                    type: t[i - 1].type
                };
            }
            return result;
        });
    }
    const diffResult = diff(tokenize(`${unescape(A)}\n`), tokenize(`${unescape(B)}\n`));
    const added = [], removed = [];
    for (const result of diffResult){
        if (result.type === DiffType.added) {
            added.push(result);
        }
        if (result.type === DiffType.removed) {
            removed.push(result);
        }
    }
    const aLines = added.length < removed.length ? added : removed;
    const bLines = aLines === removed ? added : removed;
    for (const a of aLines){
        let tokens = [], b;
        while(bLines.length){
            b = bLines.shift();
            tokens = diff(tokenize(a.value, {
                wordDiff: true
            }), tokenize(b?.value ?? "", {
                wordDiff: true
            }));
            if (tokens.some(({ type , value  })=>type === DiffType.common && value.trim().length)) {
                break;
            }
        }
        a.details = createDetails(a, tokens);
        if (b) {
            b.details = createDetails(b, tokens);
        }
    }
    return diffResult;
}
function createColor(diffType, { background =false  } = {}) {
    background = false;
    switch(diffType){
        case DiffType.added:
            return (s)=>background ? bgGreen(white(s)) : green(bold(s));
        case DiffType.removed:
            return (s)=>background ? bgRed(white(s)) : red(bold(s));
        default:
            return white;
    }
}
function createSign(diffType) {
    switch(diffType){
        case DiffType.added:
            return "+   ";
        case DiffType.removed:
            return "-   ";
        default:
            return "    ";
    }
}
function buildMessage(diffResult, { stringDiff =false  } = {}) {
    const messages = [], diffMessages = [];
    messages.push("");
    messages.push("");
    messages.push(`    ${gray(bold("[Diff]"))} ${red(bold("Actual"))} / ${green(bold("Expected"))}`);
    messages.push("");
    messages.push("");
    diffResult.forEach((result)=>{
        const c = createColor(result.type);
        const line = result.details?.map((detail)=>detail.type !== DiffType.common ? createColor(detail.type, {
                background: true
            })(detail.value) : detail.value).join("") ?? result.value;
        diffMessages.push(c(`${createSign(result.type)}${line}`));
    });
    messages.push(...stringDiff ? [
        diffMessages.join("")
    ] : diffMessages);
    messages.push("");
    return messages;
}
function format4(v) {
    const { Deno: Deno1  } = globalThis;
    return typeof Deno1?.inspect === "function" ? Deno1.inspect(v, {
        depth: Infinity,
        sorted: true,
        trailingComma: true,
        compact: false,
        iterableLimit: Infinity,
        getters: true
    }) : `"${String(v).replace(/(?=["\\])/g, "\\")}"`;
}
const CAN_NOT_DISPLAY = "[Cannot display]";
class AssertionError1 extends Error {
    name = "AssertionError";
    constructor(message){
        super(message);
    }
}
function isKeyedCollection(x) {
    return [
        Symbol.iterator,
        "size"
    ].every((k)=>k in x);
}
function equal(c, d) {
    const seen = new Map();
    return function compare(a, b) {
        if (a && b && (a instanceof RegExp && b instanceof RegExp || a instanceof URL && b instanceof URL)) {
            return String(a) === String(b);
        }
        if (a instanceof Date && b instanceof Date) {
            const aTime = a.getTime();
            const bTime = b.getTime();
            if (Number.isNaN(aTime) && Number.isNaN(bTime)) {
                return true;
            }
            return aTime === bTime;
        }
        if (typeof a === "number" && typeof b === "number") {
            return Number.isNaN(a) && Number.isNaN(b) || a === b;
        }
        if (Object.is(a, b)) {
            return true;
        }
        if (a && typeof a === "object" && b && typeof b === "object") {
            if (a && b && !constructorsEqual(a, b)) {
                return false;
            }
            if (a instanceof WeakMap || b instanceof WeakMap) {
                if (!(a instanceof WeakMap && b instanceof WeakMap)) return false;
                throw new TypeError("cannot compare WeakMap instances");
            }
            if (a instanceof WeakSet || b instanceof WeakSet) {
                if (!(a instanceof WeakSet && b instanceof WeakSet)) return false;
                throw new TypeError("cannot compare WeakSet instances");
            }
            if (seen.get(a) === b) {
                return true;
            }
            if (Object.keys(a || {}).length !== Object.keys(b || {}).length) {
                return false;
            }
            seen.set(a, b);
            if (isKeyedCollection(a) && isKeyedCollection(b)) {
                if (a.size !== b.size) {
                    return false;
                }
                let unmatchedEntries = a.size;
                for (const [aKey, aValue] of a.entries()){
                    for (const [bKey, bValue] of b.entries()){
                        if (aKey === aValue && bKey === bValue && compare(aKey, bKey) || compare(aKey, bKey) && compare(aValue, bValue)) {
                            unmatchedEntries--;
                            break;
                        }
                    }
                }
                return unmatchedEntries === 0;
            }
            const merged = {
                ...a,
                ...b
            };
            for (const key of [
                ...Object.getOwnPropertyNames(merged),
                ...Object.getOwnPropertySymbols(merged)
            ]){
                if (!compare(a && a[key], b && b[key])) {
                    return false;
                }
                if (key in a && !(key in b) || key in b && !(key in a)) {
                    return false;
                }
            }
            if (a instanceof WeakRef || b instanceof WeakRef) {
                if (!(a instanceof WeakRef && b instanceof WeakRef)) return false;
                return compare(a.deref(), b.deref());
            }
            return true;
        }
        return false;
    }(c, d);
}
function constructorsEqual(a, b) {
    return a.constructor === b.constructor || a.constructor === Object && !b.constructor || !a.constructor && b.constructor === Object;
}
function assert3(expr, msg = "") {
    if (!expr) {
        throw new AssertionError1(msg);
    }
}
function assertEquals(actual, expected, msg) {
    if (equal(actual, expected)) {
        return;
    }
    let message = "";
    const actualString = format4(actual);
    const expectedString = format4(expected);
    try {
        const stringDiff = typeof actual === "string" && typeof expected === "string";
        const diffResult = stringDiff ? diffstr(actual, expected) : diff(actualString.split("\n"), expectedString.split("\n"));
        const diffMsg = buildMessage(diffResult, {
            stringDiff
        }).join("\n");
        message = `Values are not equal:\n${diffMsg}`;
    } catch  {
        message = `\n${red(CAN_NOT_DISPLAY)} + \n\n`;
    }
    if (msg) {
        message = msg;
    }
    throw new AssertionError1(message);
}
function assertNotEquals(actual, expected, msg) {
    if (!equal(actual, expected)) {
        return;
    }
    let actualString;
    let expectedString;
    try {
        actualString = String(actual);
    } catch  {
        actualString = "[Cannot display]";
    }
    try {
        expectedString = String(expected);
    } catch  {
        expectedString = "[Cannot display]";
    }
    if (!msg) {
        msg = `actual: ${actualString} expected not to be: ${expectedString}`;
    }
    throw new AssertionError1(msg);
}
function assertStrictEquals(actual, expected, msg) {
    if (Object.is(actual, expected)) {
        return;
    }
    let message;
    if (msg) {
        message = msg;
    } else {
        const actualString = format4(actual);
        const expectedString = format4(expected);
        if (actualString === expectedString) {
            const withOffset = actualString.split("\n").map((l)=>`    ${l}`).join("\n");
            message = `Values have the same structure but are not reference-equal:\n\n${red(withOffset)}\n`;
        } else {
            try {
                const stringDiff = typeof actual === "string" && typeof expected === "string";
                const diffResult = stringDiff ? diffstr(actual, expected) : diff(actualString.split("\n"), expectedString.split("\n"));
                const diffMsg = buildMessage(diffResult, {
                    stringDiff
                }).join("\n");
                message = `Values are not strictly equal:\n${diffMsg}`;
            } catch  {
                message = `\n${red(CAN_NOT_DISPLAY)} + \n\n`;
            }
        }
    }
    throw new AssertionError1(message);
}
function assertNotStrictEquals(actual, expected, msg) {
    if (!Object.is(actual, expected)) {
        return;
    }
    throw new AssertionError1(msg ?? `Expected "actual" to be strictly unequal to: ${format4(actual)}\n`);
}
function assertMatch(actual, expected, msg) {
    if (!expected.test(actual)) {
        if (!msg) {
            msg = `actual: "${actual}" expected to match: "${expected}"`;
        }
        throw new AssertionError1(msg);
    }
}
function assertNotMatch(actual, expected, msg) {
    if (expected.test(actual)) {
        if (!msg) {
            msg = `actual: "${actual}" expected to not match: "${expected}"`;
        }
        throw new AssertionError1(msg);
    }
}
function innerFail(obj) {
    if (obj.message instanceof Error) {
        throw obj.message;
    }
    throw new AssertionError({
        actual: obj.actual,
        expected: obj.expected,
        message: obj.message,
        operator: obj.operator
    });
}
function createAssertionError(options) {
    const error = new AssertionError(options);
    if (options.generatedMessage) {
        error.generatedMessage = true;
    }
    return error;
}
function toNode(fn, opts) {
    const { operator , message , actual , expected  } = opts || {};
    try {
        fn();
    } catch (e) {
        if (e instanceof AssertionError1) {
            if (typeof message === "string") {
                throw new AssertionError({
                    operator,
                    message,
                    actual,
                    expected
                });
            } else if (message instanceof Error) {
                throw message;
            } else {
                throw new AssertionError({
                    operator,
                    message: e.message,
                    actual,
                    expected
                });
            }
        }
        throw e;
    }
}
function assert4(actual, message) {
    if (arguments.length === 0) {
        throw new AssertionError({
            message: "No value argument passed to `assert.ok()`"
        });
    }
    toNode(()=>assert3(actual), {
        message,
        actual,
        expected: true
    });
}
const ok = assert4;
function __throws(fn, error, message) {
    if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", "function", fn);
    }
    if (typeof error === "object" && error !== null && Object.getPrototypeOf(error) === Object.prototype && Object.keys(error).length === 0) {
        throw new ERR_INVALID_ARG_VALUE("error", error, "may not be an empty object");
    }
    if (typeof message === "string") {
        if (!(error instanceof RegExp) && typeof error !== "function" && !(error instanceof Error) && typeof error !== "object") {
            throw new ERR_INVALID_ARG_TYPE("error", [
                "Function",
                "Error",
                "RegExp",
                "Object"
            ], error);
        }
    } else {
        if (typeof error !== "undefined" && typeof error !== "string" && !(error instanceof RegExp) && typeof error !== "function" && !(error instanceof Error) && typeof error !== "object") {
            throw new ERR_INVALID_ARG_TYPE("error", [
                "Function",
                "Error",
                "RegExp",
                "Object"
            ], error);
        }
    }
    try {
        fn();
    } catch (e) {
        if (validateThrownError(e, error, message, {
            operator: __throws
        })) {
            return;
        }
    }
    if (message) {
        let msg = `Missing expected exception: ${message}`;
        if (typeof error === "function" && error?.name) {
            msg = `Missing expected exception (${error.name}): ${message}`;
        }
        throw new AssertionError({
            message: msg,
            operator: "throws",
            actual: undefined,
            expected: error
        });
    } else if (typeof error === "string") {
        throw new AssertionError({
            message: `Missing expected exception: ${error}`,
            operator: "throws",
            actual: undefined,
            expected: undefined
        });
    } else if (typeof error === "function" && error?.prototype !== undefined) {
        throw new AssertionError({
            message: `Missing expected exception (${error.name}).`,
            operator: "throws",
            actual: undefined,
            expected: error
        });
    } else {
        throw new AssertionError({
            message: "Missing expected exception.",
            operator: "throws",
            actual: undefined,
            expected: error
        });
    }
}
function doesNotThrow(fn, expected, message) {
    if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", "function", fn);
    } else if (!(expected instanceof RegExp) && typeof expected !== "function" && typeof expected !== "string" && typeof expected !== "undefined") {
        throw new ERR_INVALID_ARG_TYPE("expected", [
            "Function",
            "RegExp"
        ], fn);
    }
    try {
        fn();
    } catch (e) {
        gotUnwantedException(e, expected, message, doesNotThrow);
    }
}
function equal1(actual, expected, message) {
    if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (actual == expected) {
        return;
    }
    if (Number.isNaN(actual) && Number.isNaN(expected)) {
        return;
    }
    if (typeof message === "string") {
        throw new AssertionError({
            message
        });
    } else if (message instanceof Error) {
        throw message;
    }
    toNode(()=>assertStrictEquals(actual, expected), {
        message: message || `${actual} == ${expected}`,
        operator: "==",
        actual,
        expected
    });
}
function notEqual(actual, expected, message) {
    if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (Number.isNaN(actual) && Number.isNaN(expected)) {
        throw new AssertionError({
            message: `${actual} != ${expected}`,
            operator: "!=",
            actual,
            expected
        });
    }
    if (actual != expected) {
        return;
    }
    if (typeof message === "string") {
        throw new AssertionError({
            message
        });
    } else if (message instanceof Error) {
        throw message;
    }
    toNode(()=>assertNotStrictEquals(actual, expected), {
        message: message || `${actual} != ${expected}`,
        operator: "!=",
        actual,
        expected
    });
}
function strictEqual(actual, expected, message) {
    if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
    }
    toNode(()=>assertStrictEquals(actual, expected), {
        message,
        operator: "strictEqual",
        actual,
        expected
    });
}
function notStrictEqual(actual, expected, message) {
    if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
    }
    toNode(()=>assertNotStrictEquals(actual, expected), {
        message,
        actual,
        expected,
        operator: "notStrictEqual"
    });
}
function deepEqual(actual, expected, message) {
    if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (!isDeepEqual(actual, expected)) {
        innerFail({
            actual,
            expected,
            message,
            operator: "deepEqual"
        });
    }
}
function notDeepEqual(actual, expected, message) {
    if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (isDeepEqual(actual, expected)) {
        innerFail({
            actual,
            expected,
            message,
            operator: "notDeepEqual"
        });
    }
}
function deepStrictEqual(actual, expected, message) {
    if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
    }
    toNode(()=>assertEquals(actual, expected), {
        message,
        actual,
        expected,
        operator: "deepStrictEqual"
    });
}
function notDeepStrictEqual(actual, expected, message) {
    if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
    }
    toNode(()=>assertNotEquals(actual, expected), {
        message,
        actual,
        expected,
        operator: "deepNotStrictEqual"
    });
}
function fail1(message) {
    if (typeof message === "string" || message == null) {
        throw createAssertionError({
            message: message ?? "Failed",
            operator: "fail",
            generatedMessage: message == null
        });
    } else {
        throw message;
    }
}
function match(actual, regexp, message) {
    if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "regexp");
    }
    if (!(regexp instanceof RegExp)) {
        throw new ERR_INVALID_ARG_TYPE("regexp", "RegExp", regexp);
    }
    toNode(()=>assertMatch(actual, regexp), {
        message,
        actual,
        expected: regexp,
        operator: "match"
    });
}
function doesNotMatch(string, regexp, message) {
    if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("string", "regexp");
    }
    if (!(regexp instanceof RegExp)) {
        throw new ERR_INVALID_ARG_TYPE("regexp", "RegExp", regexp);
    }
    if (typeof string !== "string") {
        if (message instanceof Error) {
            throw message;
        }
        throw new AssertionError({
            message: message || `The "string" argument must be of type string. Received type ${typeof string} (${inspect(string)})`,
            actual: string,
            expected: regexp,
            operator: "doesNotMatch"
        });
    }
    toNode(()=>assertNotMatch(string, regexp), {
        message,
        actual: string,
        expected: regexp,
        operator: "doesNotMatch"
    });
}
function strict(actual, message) {
    if (arguments.length === 0) {
        throw new AssertionError({
            message: "No value argument passed to `assert.ok()`"
        });
    }
    assert4(actual, message);
}
function rejects(asyncFn, error, message) {
    let promise;
    if (typeof asyncFn === "function") {
        try {
            promise = asyncFn();
        } catch (err) {
            return Promise.reject(err);
        }
        if (!isValidThenable(promise)) {
            return Promise.reject(new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", promise));
        }
    } else if (!isValidThenable(asyncFn)) {
        return Promise.reject(new ERR_INVALID_ARG_TYPE("promiseFn", [
            "function",
            "Promise"
        ], asyncFn));
    } else {
        promise = asyncFn;
    }
    function onFulfilled() {
        let message = "Missing expected rejection";
        if (typeof error === "string") {
            message += `: ${error}`;
        } else if (typeof error === "function" && error.prototype !== undefined) {
            message += ` (${error.name}).`;
        } else {
            message += ".";
        }
        return Promise.reject(createAssertionError({
            message,
            operator: "rejects",
            generatedMessage: true
        }));
    }
    function rejects_onRejected(e) {
        if (validateThrownError(e, error, message, {
            operator: rejects,
            validationFunctionName: "validate"
        })) {
            return;
        }
    }
    return promise.then(onFulfilled, rejects_onRejected);
}
function doesNotReject(asyncFn, error, message) {
    let promise;
    if (typeof asyncFn === "function") {
        try {
            const value = asyncFn();
            if (!isValidThenable(value)) {
                return Promise.reject(new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", value));
            }
            promise = value;
        } catch (e) {
            return Promise.reject(e);
        }
    } else if (!isValidThenable(asyncFn)) {
        return Promise.reject(new ERR_INVALID_ARG_TYPE("promiseFn", [
            "function",
            "Promise"
        ], asyncFn));
    } else {
        promise = asyncFn;
    }
    return promise.then(()=>{}, (e)=>gotUnwantedException(e, error, message, doesNotReject));
}
function gotUnwantedException(e, expected, message, operator) {
    if (typeof expected === "string") {
        throw new AssertionError({
            message: `Got unwanted exception: ${expected}\nActual message: "${e.message}"`,
            operator: operator.name
        });
    } else if (typeof expected === "function" && expected.prototype !== undefined) {
        if (e instanceof expected) {
            let msg = `Got unwanted exception: ${e.constructor?.name}`;
            if (message) {
                msg += ` ${String(message)}`;
            }
            throw new AssertionError({
                message: msg,
                operator: operator.name
            });
        } else if (expected.prototype instanceof Error) {
            throw e;
        } else {
            const result = expected(e);
            if (result === true) {
                let msg = `Got unwanted rejection.\nActual message: "${e.message}"`;
                if (message) {
                    msg += ` ${String(message)}`;
                }
                throw new AssertionError({
                    message: msg,
                    operator: operator.name
                });
            }
        }
        throw e;
    } else {
        if (message) {
            throw new AssertionError({
                message: `Got unwanted exception: ${message}\nActual message: "${e ? e.message : String(e)}"`,
                operator: operator.name
            });
        }
        throw new AssertionError({
            message: `Got unwanted exception.\nActual message: "${e ? e.message : String(e)}"`,
            operator: operator.name
        });
    }
}
function ifError(err) {
    if (err !== null && err !== undefined) {
        let message = "ifError got unwanted exception: ";
        if (typeof err === "object" && typeof err.message === "string") {
            if (err.message.length === 0 && err.constructor) {
                message += err.constructor.name;
            } else {
                message += err.message;
            }
        } else {
            message += inspect(err);
        }
        const newErr = new AssertionError({
            actual: err,
            expected: null,
            operator: "ifError",
            message,
            stackStartFn: ifError
        });
        const origStack = err.stack;
        if (typeof origStack === "string") {
            const tmp2 = origStack.split("\n");
            tmp2.shift();
            let tmp1 = newErr.stack?.split("\n");
            for (const errFrame of tmp2){
                const pos = tmp1?.indexOf(errFrame);
                if (pos !== -1) {
                    tmp1 = tmp1?.slice(0, pos);
                    break;
                }
            }
            newErr.stack = `${tmp1?.join("\n")}\n${tmp2.join("\n")}`;
        }
        throw newErr;
    }
}
function validateThrownError(e, error, message, options) {
    if (typeof error === "string") {
        if (message != null) {
            throw new ERR_INVALID_ARG_TYPE("error", [
                "Object",
                "Error",
                "Function",
                "RegExp"
            ], error);
        } else if (typeof e === "object" && e !== null) {
            if (e.message === error) {
                throw new ERR_AMBIGUOUS_ARGUMENT("error/message", `The error message "${e.message}" is identical to the message.`);
            }
        } else if (e === error) {
            throw new ERR_AMBIGUOUS_ARGUMENT("error/message", `The error "${e}" is identical to the message.`);
        }
        message = error;
        error = undefined;
    }
    if (error instanceof Function && error.prototype !== undefined && error.prototype instanceof Error) {
        if (e instanceof error) {
            return true;
        }
        throw createAssertionError({
            message: `The error is expected to be an instance of "${error.name}". Received "${e?.constructor?.name}"\n\nError message:\n\n${e?.message}`,
            actual: e,
            expected: error,
            operator: options.operator.name,
            generatedMessage: true
        });
    }
    if (error instanceof Function) {
        const received = error(e);
        if (received === true) {
            return true;
        }
        throw createAssertionError({
            message: `The ${options.validationFunctionName ? `"${options.validationFunctionName}" validation` : "validation"} function is expected to return "true". Received ${inspect(received)}\n\nCaught error:\n\n${e}`,
            actual: e,
            expected: error,
            operator: options.operator.name,
            generatedMessage: true
        });
    }
    if (error instanceof RegExp) {
        if (error.test(String(e))) {
            return true;
        }
        throw createAssertionError({
            message: `The input did not match the regular expression ${error.toString()}. Input:\n\n'${String(e)}'\n`,
            actual: e,
            expected: error,
            operator: options.operator.name,
            generatedMessage: true
        });
    }
    if (typeof error === "object" && error !== null) {
        const keys = Object.keys(error);
        if (error instanceof Error) {
            keys.push("name", "message");
        }
        for (const k of keys){
            if (e == null) {
                throw createAssertionError({
                    message: message || "object is expected to thrown, but got null",
                    actual: e,
                    expected: error,
                    operator: options.operator.name,
                    generatedMessage: message == null
                });
            }
            if (typeof e === "string") {
                throw createAssertionError({
                    message: message || `object is expected to thrown, but got string: ${e}`,
                    actual: e,
                    expected: error,
                    operator: options.operator.name,
                    generatedMessage: message == null
                });
            }
            if (typeof e === "number") {
                throw createAssertionError({
                    message: message || `object is expected to thrown, but got number: ${e}`,
                    actual: e,
                    expected: error,
                    operator: options.operator.name,
                    generatedMessage: message == null
                });
            }
            if (!(k in e)) {
                throw createAssertionError({
                    message: message || `A key in the expected object is missing: ${k}`,
                    actual: e,
                    expected: error,
                    operator: options.operator.name,
                    generatedMessage: message == null
                });
            }
            const actual = e[k];
            const expected = error[k];
            if (typeof actual === "string" && expected instanceof RegExp) {
                match(actual, expected);
            } else {
                deepStrictEqual(actual, expected);
            }
        }
        return true;
    }
    if (typeof error === "undefined") {
        return true;
    }
    throw createAssertionError({
        message: `Invalid expectation: ${error}`,
        operator: options.operator.name,
        generatedMessage: true
    });
}
function isValidThenable(maybeThennable) {
    if (!maybeThennable) {
        return false;
    }
    if (maybeThennable instanceof Promise) {
        return true;
    }
    const isThenable = typeof maybeThennable.then === "function" && typeof maybeThennable.catch === "function";
    return isThenable && typeof maybeThennable !== "function";
}
Object.assign(strict, {
    AssertionError,
    deepEqual: deepStrictEqual,
    deepStrictEqual,
    doesNotMatch,
    doesNotReject,
    doesNotThrow,
    equal: strictEqual,
    fail: fail1,
    ifError,
    match,
    notDeepEqual: notDeepStrictEqual,
    notDeepStrictEqual,
    notEqual: notStrictEqual,
    notStrictEqual,
    ok,
    rejects,
    strict,
    strictEqual,
    throws: __throws
});
const __default22 = Object.assign(assert4, {
    AssertionError,
    deepEqual,
    deepStrictEqual,
    doesNotMatch,
    doesNotReject,
    doesNotThrow,
    equal: equal1,
    fail: fail1,
    ifError,
    match,
    notDeepEqual,
    notDeepStrictEqual,
    notEqual,
    notStrictEqual,
    ok,
    rejects,
    strict,
    strictEqual,
    throws: __throws
});
function mapValues(record, transformer) {
    const ret = {};
    const entries = Object.entries(record);
    for (const [key, value] of entries){
        const mappedValue = transformer(value);
        ret[key] = mappedValue;
    }
    return ret;
}
const CHAR_FORWARD_SLASH1 = 47;
function assertPath1(path) {
    if (typeof path !== "string") {
        throw new ERR_INVALID_ARG_TYPE("path", [
            "string"
        ], path);
    }
}
function isPosixPathSeparator1(code) {
    return code === 47;
}
function isPathSeparator1(code) {
    return isPosixPathSeparator1(code) || code === 92;
}
function isWindowsDeviceRoot1(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString1(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH1;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format1(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS1 = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace1(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS1[c] ?? c;
    });
}
const sep3 = "\\";
const delimiter4 = ";";
function resolve7(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1  } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath1(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator1(code)) {
                isAbsolute = true;
                if (isPathSeparator1(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator1(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot1(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator1(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator1(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString1(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator1);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize4(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            isAbsolute = true;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString1(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator1);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator1(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute3(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator1(code)) {
        return true;
    } else if (isWindowsDeviceRoot1(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator1(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join5(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath1(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert(firstPart != null);
    if (isPathSeparator1(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator1(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator1(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator1(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize4(joined);
}
function relative3(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    const fromOrig = resolve7(from);
    const toOrig = resolve7(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath3(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve7(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot1(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname3(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator1(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path.slice(0, end);
}
function basename3(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new ERR_INVALID_ARG_TYPE("ext", [
            "string"
        ], ext);
    }
    assertPath1(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot1(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= start; --i){
            const code = path.charCodeAt(i);
            if (isPathSeparator1(code)) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= start; --i){
            if (isPathSeparator1(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname3(path) {
    assertPath1(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot1(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format5(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new ERR_INVALID_ARG_TYPE("pathObject", [
            "Object"
        ], pathObject);
    }
    return _format1("\\", pathObject);
}
function parse4(path) {
    assertPath1(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            rootEnd = 1;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        ret.root = ret.dir = path;
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl3(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl3(path) {
    if (!isAbsolute3(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const __default23 = {
    basename: basename3,
    delimiter: delimiter4,
    dirname: dirname3,
    extname: extname3,
    format: format5,
    fromFileUrl: fromFileUrl3,
    isAbsolute: isAbsolute3,
    join: join5,
    normalize: normalize4,
    parse: parse4,
    relative: relative3,
    resolve: resolve7,
    sep: sep3,
    toFileUrl: toFileUrl3,
    toNamespacedPath: toNamespacedPath3
};
const mod50 = {
    sep: sep3,
    delimiter: delimiter4,
    resolve: resolve7,
    normalize: normalize4,
    isAbsolute: isAbsolute3,
    join: join5,
    relative: relative3,
    toNamespacedPath: toNamespacedPath3,
    dirname: dirname3,
    basename: basename3,
    extname: extname3,
    format: format5,
    parse: parse4,
    fromFileUrl: fromFileUrl3,
    toFileUrl: toFileUrl3,
    default: __default23
};
const sep4 = "/";
const delimiter5 = ":";
function resolve8(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1  } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath1(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH1;
    }
    resolvedPath = normalizeString1(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator1);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize5(path) {
    assertPath1(path);
    if (path.length === 0) return ".";
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeString1(path, !isAbsolute, "/", isPosixPathSeparator1);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute4(path) {
    assertPath1(path);
    return path.length > 0 && path.charCodeAt(0) === 47;
}
function join6(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath1(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize5(joined);
}
function relative4(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    from = resolve8(from);
    to = resolve8(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath4(path) {
    return path;
}
function dirname4(path) {
    assertPath1(path);
    if (path.length === 0) return ".";
    const hasRoot = path.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i = path.length - 1; i >= 1; --i){
        if (path.charCodeAt(i) === 47) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path.slice(0, end);
}
function basename4(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new ERR_INVALID_ARG_TYPE("ext", [
            "string"
        ], ext);
    }
    assertPath1(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= 0; --i){
            const code = path.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= 0; --i){
            if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname4(path) {
    assertPath1(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format6(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new ERR_INVALID_ARG_TYPE("pathObject", [
            "Object"
        ], pathObject);
    }
    return _format1("/", pathObject);
}
function parse5(path) {
    assertPath1(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = path.charCodeAt(0) === 47;
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl4(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl4(path) {
    if (!isAbsolute4(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const __default24 = {
    basename: basename4,
    delimiter: delimiter5,
    dirname: dirname4,
    extname: extname4,
    format: format6,
    fromFileUrl: fromFileUrl4,
    isAbsolute: isAbsolute4,
    join: join6,
    normalize: normalize5,
    parse: parse5,
    relative: relative4,
    resolve: resolve8,
    sep: sep4,
    toFileUrl: toFileUrl4,
    toNamespacedPath: toNamespacedPath4
};
const mod51 = {
    sep: sep4,
    delimiter: delimiter5,
    resolve: resolve8,
    normalize: normalize5,
    isAbsolute: isAbsolute4,
    join: join6,
    relative: relative4,
    toNamespacedPath: toNamespacedPath4,
    dirname: dirname4,
    basename: basename4,
    extname: extname4,
    format: format6,
    parse: parse5,
    fromFileUrl: fromFileUrl4,
    toFileUrl: toFileUrl4,
    default: __default24
};
const SEP = isWindows ? "\\" : "/";
const SEP_PATTERN = isWindows ? /[\\/]+/ : /\/+/;
function common(paths, sep = SEP) {
    const [first = "", ...remaining] = paths;
    if (first === "" || remaining.length === 0) {
        return first.substring(0, first.lastIndexOf(sep) + 1);
    }
    const parts = first.split(sep);
    let endOfPrefix = parts.length;
    for (const path of remaining){
        const compare = path.split(sep);
        for(let i = 0; i < endOfPrefix; i++){
            if (compare[i] !== parts[i]) {
                endOfPrefix = i;
            }
        }
        if (endOfPrefix === 0) {
            return "";
        }
    }
    const prefix = parts.slice(0, endOfPrefix).join(sep);
    return prefix.endsWith(sep) ? prefix : `${prefix}${sep}`;
}
const path2 = isWindows ? mod50 : mod51;
const { join: join7 , normalize: normalize6  } = path2;
const regExpEscapeChars = [
    "!",
    "$",
    "(",
    ")",
    "*",
    "+",
    ".",
    "=",
    "?",
    "[",
    "\\",
    "^",
    "{",
    "|"
];
const rangeEscapeChars = [
    "-",
    "\\",
    "]"
];
function globToRegExp(glob, { extended =true , globstar: globstarOption = true , os =osType , caseInsensitive =false  } = {}) {
    if (glob == "") {
        return /(?!)/;
    }
    const sep = os == "windows" ? "(?:\\\\|/)+" : "/+";
    const sepMaybe = os == "windows" ? "(?:\\\\|/)*" : "/*";
    const seps = os == "windows" ? [
        "\\",
        "/"
    ] : [
        "/"
    ];
    const globstar = os == "windows" ? "(?:[^\\\\/]*(?:\\\\|/|$)+)*" : "(?:[^/]*(?:/|$)+)*";
    const wildcard = os == "windows" ? "[^\\\\/]*" : "[^/]*";
    const escapePrefix = os == "windows" ? "`" : "\\";
    let newLength = glob.length;
    for(; newLength > 1 && seps.includes(glob[newLength - 1]); newLength--);
    glob = glob.slice(0, newLength);
    let regExpString = "";
    for(let j = 0; j < glob.length;){
        let segment = "";
        const groupStack = [];
        let inRange = false;
        let inEscape = false;
        let endsWithSep = false;
        let i = j;
        for(; i < glob.length && !seps.includes(glob[i]); i++){
            if (inEscape) {
                inEscape = false;
                const escapeChars = inRange ? rangeEscapeChars : regExpEscapeChars;
                segment += escapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
                continue;
            }
            if (glob[i] == escapePrefix) {
                inEscape = true;
                continue;
            }
            if (glob[i] == "[") {
                if (!inRange) {
                    inRange = true;
                    segment += "[";
                    if (glob[i + 1] == "!") {
                        i++;
                        segment += "^";
                    } else if (glob[i + 1] == "^") {
                        i++;
                        segment += "\\^";
                    }
                    continue;
                } else if (glob[i + 1] == ":") {
                    let k = i + 1;
                    let value = "";
                    while(glob[k + 1] != null && glob[k + 1] != ":"){
                        value += glob[k + 1];
                        k++;
                    }
                    if (glob[k + 1] == ":" && glob[k + 2] == "]") {
                        i = k + 2;
                        if (value == "alnum") segment += "\\dA-Za-z";
                        else if (value == "alpha") segment += "A-Za-z";
                        else if (value == "ascii") segment += "\x00-\x7F";
                        else if (value == "blank") segment += "\t ";
                        else if (value == "cntrl") segment += "\x00-\x1F\x7F";
                        else if (value == "digit") segment += "\\d";
                        else if (value == "graph") segment += "\x21-\x7E";
                        else if (value == "lower") segment += "a-z";
                        else if (value == "print") segment += "\x20-\x7E";
                        else if (value == "punct") {
                            segment += "!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_{|}~";
                        } else if (value == "space") segment += "\\s\v";
                        else if (value == "upper") segment += "A-Z";
                        else if (value == "word") segment += "\\w";
                        else if (value == "xdigit") segment += "\\dA-Fa-f";
                        continue;
                    }
                }
            }
            if (glob[i] == "]" && inRange) {
                inRange = false;
                segment += "]";
                continue;
            }
            if (inRange) {
                if (glob[i] == "\\") {
                    segment += `\\\\`;
                } else {
                    segment += glob[i];
                }
                continue;
            }
            if (glob[i] == ")" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
                segment += ")";
                const type = groupStack.pop();
                if (type == "!") {
                    segment += wildcard;
                } else if (type != "@") {
                    segment += type;
                }
                continue;
            }
            if (glob[i] == "|" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
                segment += "|";
                continue;
            }
            if (glob[i] == "+" && extended && glob[i + 1] == "(") {
                i++;
                groupStack.push("+");
                segment += "(?:";
                continue;
            }
            if (glob[i] == "@" && extended && glob[i + 1] == "(") {
                i++;
                groupStack.push("@");
                segment += "(?:";
                continue;
            }
            if (glob[i] == "?") {
                if (extended && glob[i + 1] == "(") {
                    i++;
                    groupStack.push("?");
                    segment += "(?:";
                } else {
                    segment += ".";
                }
                continue;
            }
            if (glob[i] == "!" && extended && glob[i + 1] == "(") {
                i++;
                groupStack.push("!");
                segment += "(?!";
                continue;
            }
            if (glob[i] == "{") {
                groupStack.push("BRACE");
                segment += "(?:";
                continue;
            }
            if (glob[i] == "}" && groupStack[groupStack.length - 1] == "BRACE") {
                groupStack.pop();
                segment += ")";
                continue;
            }
            if (glob[i] == "," && groupStack[groupStack.length - 1] == "BRACE") {
                segment += "|";
                continue;
            }
            if (glob[i] == "*") {
                if (extended && glob[i + 1] == "(") {
                    i++;
                    groupStack.push("*");
                    segment += "(?:";
                } else {
                    const prevChar = glob[i - 1];
                    let numStars = 1;
                    while(glob[i + 1] == "*"){
                        i++;
                        numStars++;
                    }
                    const nextChar = glob[i + 1];
                    if (globstarOption && numStars == 2 && [
                        ...seps,
                        undefined
                    ].includes(prevChar) && [
                        ...seps,
                        undefined
                    ].includes(nextChar)) {
                        segment += globstar;
                        endsWithSep = true;
                    } else {
                        segment += wildcard;
                    }
                }
                continue;
            }
            segment += regExpEscapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
        }
        if (groupStack.length > 0 || inRange || inEscape) {
            segment = "";
            for (const c of glob.slice(j, i)){
                segment += regExpEscapeChars.includes(c) ? `\\${c}` : c;
                endsWithSep = false;
            }
        }
        regExpString += segment;
        if (!endsWithSep) {
            regExpString += i < glob.length ? sep : sepMaybe;
            endsWithSep = true;
        }
        while(seps.includes(glob[i]))i++;
        if (!(i > j)) {
            throw new Error("Assertion failure: i > j (potential infinite loop)");
        }
        j = i;
    }
    regExpString = `^${regExpString}$`;
    return new RegExp(regExpString, caseInsensitive ? "i" : "");
}
function isGlob(str) {
    const chars = {
        "{": "}",
        "(": ")",
        "[": "]"
    };
    const regex = /\\(.)|(^!|\*|\?|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
    if (str === "") {
        return false;
    }
    let match;
    while(match = regex.exec(str)){
        if (match[2]) return true;
        let idx = match.index + match[0].length;
        const open = match[1];
        const close = open ? chars[open] : null;
        if (open && close) {
            const n = str.indexOf(close, idx);
            if (n !== -1) {
                idx = n + 1;
            }
        }
        str = str.slice(idx);
    }
    return false;
}
function normalizeGlob(glob, { globstar =false  } = {}) {
    if (glob.match(/\0/g)) {
        throw new Error(`Glob contains invalid characters: "${glob}"`);
    }
    if (!globstar) {
        return normalize6(glob);
    }
    const s = SEP_PATTERN.source;
    const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
    return normalize6(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
}
function joinGlobs(globs, { extended =true , globstar =false  } = {}) {
    if (!globstar || globs.length == 0) {
        return join7(...globs);
    }
    if (globs.length === 0) return ".";
    let joined;
    for (const glob of globs){
        const path = glob;
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `${SEP}${path}`;
        }
    }
    if (!joined) return ".";
    return normalizeGlob(joined, {
        extended,
        globstar
    });
}
const path3 = isWindows ? __default23 : __default24;
const { basename: basename5 , delimiter: delimiter6 , dirname: dirname5 , extname: extname5 , format: format7 , fromFileUrl: fromFileUrl5 , isAbsolute: isAbsolute5 , join: join8 , normalize: normalize7 , parse: parse6 , relative: relative5 , resolve: resolve9 , sep: sep5 , toFileUrl: toFileUrl5 , toNamespacedPath: toNamespacedPath5  } = path3;
const mod52 = {
    SEP: SEP,
    SEP_PATTERN: SEP_PATTERN,
    win32: __default23,
    posix: __default24,
    basename: basename5,
    delimiter: delimiter6,
    dirname: dirname5,
    extname: extname5,
    format: format7,
    fromFileUrl: fromFileUrl5,
    isAbsolute: isAbsolute5,
    join: join8,
    normalize: normalize7,
    parse: parse6,
    relative: relative5,
    resolve: resolve9,
    sep: sep5,
    toFileUrl: toFileUrl5,
    toNamespacedPath: toNamespacedPath5,
    common,
    globToRegExp,
    isGlob,
    normalizeGlob,
    joinGlobs
};
const __default25 = {
    ...mod52
};
const hexTable = new Array(256);
for(let i = 0; i < 256; ++i){
    hexTable[i] = "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase();
}
new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
]);
function encodeStr(str, noEscapeTable, hexTable) {
    const len = str.length;
    if (len === 0) return "";
    let out = "";
    let lastPos = 0;
    for(let i = 0; i < len; i++){
        let c = str.charCodeAt(i);
        if (c < 0x80) {
            if (noEscapeTable[c] === 1) continue;
            if (lastPos < i) out += str.slice(lastPos, i);
            lastPos = i + 1;
            out += hexTable[c];
            continue;
        }
        if (lastPos < i) out += str.slice(lastPos, i);
        if (c < 0x800) {
            lastPos = i + 1;
            out += hexTable[0xc0 | c >> 6] + hexTable[0x80 | c & 0x3f];
            continue;
        }
        if (c < 0xd800 || c >= 0xe000) {
            lastPos = i + 1;
            out += hexTable[0xe0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3f] + hexTable[0x80 | c & 0x3f];
            continue;
        }
        ++i;
        if (i >= len) throw new ERR_INVALID_URI();
        const c2 = str.charCodeAt(i) & 0x3ff;
        lastPos = i + 1;
        c = 0x10000 + ((c & 0x3ff) << 10 | c2);
        out += hexTable[0xf0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3f] + hexTable[0x80 | c >> 6 & 0x3f] + hexTable[0x80 | c & 0x3f];
    }
    if (lastPos === 0) return str;
    if (lastPos < len) return out + str.slice(lastPos);
    return out;
}
const decode3 = parse7;
const encode3 = stringify;
function qsEscape(str) {
    if (typeof str !== "string") {
        if (typeof str === "object") {
            str = String(str);
        } else {
            str += "";
        }
    }
    return encodeStr(str, noEscape, hexTable);
}
const escape = qsEscape;
const isHexTable = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
]);
function charCodes(str) {
    const ret = new Array(str.length);
    for(let i = 0; i < str.length; ++i){
        ret[i] = str.charCodeAt(i);
    }
    return ret;
}
function addKeyVal(obj, key, value, keyEncoded, valEncoded, decode) {
    if (key.length > 0 && keyEncoded) {
        key = decode(key);
    }
    if (value.length > 0 && valEncoded) {
        value = decode(value);
    }
    if (obj[key] === undefined) {
        obj[key] = value;
    } else {
        const curValue = obj[key];
        if (curValue.pop) {
            curValue[curValue.length] = value;
        } else {
            obj[key] = [
                curValue,
                value
            ];
        }
    }
}
function parse7(str, sep = "&", eq = "=", { decodeURIComponent: decodeURIComponent1 = unescape , maxKeys =1000  } = {}) {
    const obj = Object.create(null);
    if (typeof str !== "string" || str.length === 0) {
        return obj;
    }
    const sepCodes = !sep ? [
        38
    ] : charCodes(String(sep));
    const eqCodes = !eq ? [
        61
    ] : charCodes(String(eq));
    const sepLen = sepCodes.length;
    const eqLen = eqCodes.length;
    let pairs = 1000;
    if (typeof maxKeys === "number") {
        pairs = maxKeys > 0 ? maxKeys : -1;
    }
    let decode = unescape;
    if (decodeURIComponent1) {
        decode = decodeURIComponent1;
    }
    const customDecode = decode !== unescape;
    let lastPos = 0;
    let sepIdx = 0;
    let eqIdx = 0;
    let key = "";
    let value = "";
    let keyEncoded = customDecode;
    let valEncoded = customDecode;
    const plusChar = customDecode ? "%20" : " ";
    let encodeCheck = 0;
    for(let i = 0; i < str.length; ++i){
        const code = str.charCodeAt(i);
        if (code === sepCodes[sepIdx]) {
            if (++sepIdx === sepLen) {
                const end = i - sepIdx + 1;
                if (eqIdx < eqLen) {
                    if (lastPos < end) {
                        key += str.slice(lastPos, end);
                    } else if (key.length === 0) {
                        if (--pairs === 0) {
                            return obj;
                        }
                        lastPos = i + 1;
                        sepIdx = eqIdx = 0;
                        continue;
                    }
                } else if (lastPos < end) {
                    value += str.slice(lastPos, end);
                }
                addKeyVal(obj, key, value, keyEncoded, valEncoded, decode);
                if (--pairs === 0) {
                    return obj;
                }
                key = value = "";
                encodeCheck = 0;
                lastPos = i + 1;
                sepIdx = eqIdx = 0;
            }
        } else {
            sepIdx = 0;
            if (eqIdx < eqLen) {
                if (code === eqCodes[eqIdx]) {
                    if (++eqIdx === eqLen) {
                        const end = i - eqIdx + 1;
                        if (lastPos < end) {
                            key += str.slice(lastPos, end);
                        }
                        encodeCheck = 0;
                        lastPos = i + 1;
                    }
                    continue;
                } else {
                    eqIdx = 0;
                    if (!keyEncoded) {
                        if (code === 37) {
                            encodeCheck = 1;
                            continue;
                        } else if (encodeCheck > 0) {
                            if (isHexTable[code] === 1) {
                                if (++encodeCheck === 3) {
                                    keyEncoded = true;
                                }
                                continue;
                            } else {
                                encodeCheck = 0;
                            }
                        }
                    }
                }
                if (code === 43) {
                    if (lastPos < i) {
                        key += str.slice(lastPos, i);
                    }
                    key += plusChar;
                    lastPos = i + 1;
                    continue;
                }
            }
            if (code === 43) {
                if (lastPos < i) {
                    value += str.slice(lastPos, i);
                }
                value += plusChar;
                lastPos = i + 1;
            } else if (!valEncoded) {
                if (code === 37) {
                    encodeCheck = 1;
                } else if (encodeCheck > 0) {
                    if (isHexTable[code] === 1) {
                        if (++encodeCheck === 3) {
                            valEncoded = true;
                        }
                    } else {
                        encodeCheck = 0;
                    }
                }
            }
        }
    }
    if (lastPos < str.length) {
        if (eqIdx < eqLen) {
            key += str.slice(lastPos);
        } else if (sepIdx < sepLen) {
            value += str.slice(lastPos);
        }
    } else if (eqIdx === 0 && key.length === 0) {
        return obj;
    }
    addKeyVal(obj, key, value, keyEncoded, valEncoded, decode);
    return obj;
}
const noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
]);
function stringifyPrimitive(v) {
    if (typeof v === "string") {
        return v;
    }
    if (typeof v === "number" && isFinite(v)) {
        return "" + v;
    }
    if (typeof v === "bigint") {
        return "" + v;
    }
    if (typeof v === "boolean") {
        return v ? "true" : "false";
    }
    return "";
}
function encodeStringifiedCustom(v, encode) {
    return encode(stringifyPrimitive(v));
}
function encodeStringified(v, encode) {
    if (typeof v === "string") {
        return v.length ? encode(v) : "";
    }
    if (typeof v === "number" && isFinite(v)) {
        return Math.abs(v) < 1e21 ? "" + v : encode("" + v);
    }
    if (typeof v === "bigint") {
        return "" + v;
    }
    if (typeof v === "boolean") {
        return v ? "true" : "false";
    }
    return "";
}
function stringify(obj, sep, eq, options) {
    sep ||= "&";
    eq ||= "=";
    const encode = options ? options.encodeURIComponent : qsEscape;
    const convert = options ? encodeStringifiedCustom : encodeStringified;
    if (obj !== null && typeof obj === "object") {
        const keys = Object.keys(obj);
        const len = keys.length;
        let fields = "";
        for(let i = 0; i < len; ++i){
            const k = keys[i];
            const v = obj[k];
            let ks = convert(k, encode);
            ks += eq;
            if (Array.isArray(v)) {
                const vlen = v.length;
                if (vlen === 0) continue;
                if (fields) {
                    fields += sep;
                }
                for(let j = 0; j < vlen; ++j){
                    if (j) {
                        fields += sep;
                    }
                    fields += ks;
                    fields += convert(v[j], encode);
                }
            } else {
                if (fields) {
                    fields += sep;
                }
                fields += ks;
                fields += convert(v, encode);
            }
        }
        return fields;
    }
    return "";
}
const unhexTable = new Int8Array([
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    +0,
    +1,
    +2,
    +3,
    +4,
    +5,
    +6,
    +7,
    +8,
    +9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
]);
function unescapeBuffer(s, decodeSpaces = false) {
    const out = Buffer1.alloc(s.length);
    let index = 0;
    let outIndex = 0;
    let currentChar;
    let nextChar;
    let hexHigh;
    let hexLow;
    const maxLength = s.length - 2;
    let hasHex = false;
    while(index < s.length){
        currentChar = s.charCodeAt(index);
        if (currentChar === 43 && decodeSpaces) {
            out[outIndex++] = 32;
            index++;
            continue;
        }
        if (currentChar === 37 && index < maxLength) {
            currentChar = s.charCodeAt(++index);
            hexHigh = unhexTable[currentChar];
            if (!(hexHigh >= 0)) {
                out[outIndex++] = 37;
                continue;
            } else {
                nextChar = s.charCodeAt(++index);
                hexLow = unhexTable[nextChar];
                if (!(hexLow >= 0)) {
                    out[outIndex++] = 37;
                    index--;
                } else {
                    hasHex = true;
                    currentChar = hexHigh * 16 + hexLow;
                }
            }
        }
        out[outIndex++] = currentChar;
        index++;
    }
    return hasHex ? out.slice(0, outIndex) : out;
}
function qsUnescape(s) {
    try {
        return decodeURIComponent(s);
    } catch  {
        return unescapeBuffer(s).toString();
    }
}
const unescape = qsUnescape;
const __default26 = {
    parse: parse7,
    stringify,
    decode: decode3,
    encode: encode3,
    unescape,
    escape,
    unescapeBuffer
};
const forwardSlashRegEx = /\//g;
const percentRegEx = /%/g;
const backslashRegEx = /\\/g;
const newlineRegEx = /\n/g;
const carriageReturnRegEx = /\r/g;
const tabRegEx = /\t/g;
const protocolPattern = /^[a-z0-9.+-]+:/i;
const portPattern = /:[0-9]*$/;
const hostPattern = /^\/\/[^@/]+@[^@/]+/;
const simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/;
const unsafeProtocol = new Set([
    "javascript",
    "javascript:"
]);
const hostlessProtocol = new Set([
    "javascript",
    "javascript:"
]);
const slashedProtocol = new Set([
    "http",
    "http:",
    "https",
    "https:",
    "ftp",
    "ftp:",
    "gopher",
    "gopher:",
    "file",
    "file:",
    "ws",
    "ws:",
    "wss",
    "wss:"
]);
const noEscapeAuth = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
]);
const forbiddenHostChars = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
const forbiddenHostCharsIpv6 = /[\0\t\n\r #%/<>?@\\^|]/;
URL;
class Url {
    protocol;
    slashes;
    auth;
    host;
    port;
    hostname;
    hash;
    search;
    query;
    pathname;
    path;
    href;
    constructor(){
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
    }
    #parseHost() {
        let host = this.host || "";
        let port = portPattern.exec(host);
        if (port) {
            port = port[0];
            if (port !== ":") {
                this.port = port.slice(1);
            }
            host = host.slice(0, host.length - port.length);
        }
        if (host) this.hostname = host;
    }
    resolve(relative) {
        return this.resolveObject(parse8(relative, false, true)).format();
    }
    resolveObject(relative) {
        if (typeof relative === "string") {
            const rel = new Url();
            rel.urlParse(relative, false, true);
            relative = rel;
        }
        const result = new Url();
        const tkeys = Object.keys(this);
        for(let tk = 0; tk < tkeys.length; tk++){
            const tkey = tkeys[tk];
            result[tkey] = this[tkey];
        }
        result.hash = relative.hash;
        if (relative.href === "") {
            result.href = result.format();
            return result;
        }
        if (relative.slashes && !relative.protocol) {
            const rkeys = Object.keys(relative);
            for(let rk = 0; rk < rkeys.length; rk++){
                const rkey = rkeys[rk];
                if (rkey !== "protocol") result[rkey] = relative[rkey];
            }
            if (result.protocol && slashedProtocol.has(result.protocol) && result.hostname && !result.pathname) {
                result.path = result.pathname = "/";
            }
            result.href = result.format();
            return result;
        }
        if (relative.protocol && relative.protocol !== result.protocol) {
            if (!slashedProtocol.has(relative.protocol)) {
                const keys = Object.keys(relative);
                for(let v = 0; v < keys.length; v++){
                    const k = keys[v];
                    result[k] = relative[k];
                }
                result.href = result.format();
                return result;
            }
            result.protocol = relative.protocol;
            if (!relative.host && !/^file:?$/.test(relative.protocol) && !hostlessProtocol.has(relative.protocol)) {
                const relPath = (relative.pathname || "").split("/");
                while(relPath.length && !(relative.host = relPath.shift() || null));
                if (!relative.host) relative.host = "";
                if (!relative.hostname) relative.hostname = "";
                if (relPath[0] !== "") relPath.unshift("");
                if (relPath.length < 2) relPath.unshift("");
                result.pathname = relPath.join("/");
            } else {
                result.pathname = relative.pathname;
            }
            result.search = relative.search;
            result.query = relative.query;
            result.host = relative.host || "";
            result.auth = relative.auth;
            result.hostname = relative.hostname || relative.host;
            result.port = relative.port;
            if (result.pathname || result.search) {
                const p = result.pathname || "";
                const s = result.search || "";
                result.path = p + s;
            }
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
        }
        const isSourceAbs = result.pathname && result.pathname.charAt(0) === "/";
        const isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/";
        let mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname;
        const removeAllDots = mustEndAbs;
        let srcPath = result.pathname && result.pathname.split("/") || [];
        const relPath = relative.pathname && relative.pathname.split("/") || [];
        const noLeadingSlashes = result.protocol && !slashedProtocol.has(result.protocol);
        if (noLeadingSlashes) {
            result.hostname = "";
            result.port = null;
            if (result.host) {
                if (srcPath[0] === "") srcPath[0] = result.host;
                else srcPath.unshift(result.host);
            }
            result.host = "";
            if (relative.protocol) {
                relative.hostname = null;
                relative.port = null;
                result.auth = null;
                if (relative.host) {
                    if (relPath[0] === "") relPath[0] = relative.host;
                    else relPath.unshift(relative.host);
                }
                relative.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
        }
        if (isRelAbs) {
            if (relative.host || relative.host === "") {
                if (result.host !== relative.host) result.auth = null;
                result.host = relative.host;
                result.port = relative.port;
            }
            if (relative.hostname || relative.hostname === "") {
                if (result.hostname !== relative.hostname) result.auth = null;
                result.hostname = relative.hostname;
            }
            result.search = relative.search;
            result.query = relative.query;
            srcPath = relPath;
        } else if (relPath.length) {
            if (!srcPath) srcPath = [];
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative.search;
            result.query = relative.query;
        } else if (relative.search !== null && relative.search !== undefined) {
            if (noLeadingSlashes) {
                result.hostname = result.host = srcPath.shift() || null;
                const authInHost = result.host && result.host.indexOf("@") > 0 && result.host.split("@");
                if (authInHost) {
                    result.auth = authInHost.shift() || null;
                    result.host = result.hostname = authInHost.shift() || null;
                }
            }
            result.search = relative.search;
            result.query = relative.query;
            if (result.pathname !== null || result.search !== null) {
                result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
            }
            result.href = result.format();
            return result;
        }
        if (!srcPath.length) {
            result.pathname = null;
            if (result.search) {
                result.path = "/" + result.search;
            } else {
                result.path = null;
            }
            result.href = result.format();
            return result;
        }
        let last = srcPath.slice(-1)[0];
        const hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
        let up = 0;
        for(let i = srcPath.length - 1; i >= 0; i--){
            last = srcPath[i];
            if (last === ".") {
                srcPath.splice(i, 1);
            } else if (last === "..") {
                srcPath.splice(i, 1);
                up++;
            } else if (up) {
                srcPath.splice(i, 1);
                up--;
            }
        }
        if (!mustEndAbs && !removeAllDots) {
            while(up--){
                srcPath.unshift("..");
            }
        }
        if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
            srcPath.unshift("");
        }
        if (hasTrailingSlash && srcPath.join("/").slice(-1) !== "/") {
            srcPath.push("");
        }
        const isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
        if (noLeadingSlashes) {
            result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() || null : "";
            const authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
                result.auth = authInHost.shift() || null;
                result.host = result.hostname = authInHost.shift() || null;
            }
        }
        mustEndAbs = mustEndAbs || result.host && srcPath.length;
        if (mustEndAbs && !isAbsolute) {
            srcPath.unshift("");
        }
        if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
        } else {
            result.pathname = srcPath.join("/");
        }
        if (result.pathname !== null || result.search !== null) {
            result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.auth = relative.auth || result.auth;
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
    }
    format() {
        let auth = this.auth || "";
        if (auth) {
            auth = encodeStr(auth, noEscapeAuth, hexTable);
            auth += "@";
        }
        let protocol = this.protocol || "";
        let pathname = this.pathname || "";
        let hash = this.hash || "";
        let host = "";
        let query = "";
        if (this.host) {
            host = auth + this.host;
        } else if (this.hostname) {
            host = auth + (this.hostname.includes(":") && !isIpv6Hostname(this.hostname) ? "[" + this.hostname + "]" : this.hostname);
            if (this.port) {
                host += ":" + this.port;
            }
        }
        if (this.query !== null && typeof this.query === "object") {
            query = __default26.stringify(this.query);
        }
        let search = this.search || query && "?" + query || "";
        if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58) {
            protocol += ":";
        }
        let newPathname = "";
        let lastPos = 0;
        for(let i = 0; i < pathname.length; ++i){
            switch(pathname.charCodeAt(i)){
                case 35:
                    if (i - lastPos > 0) {
                        newPathname += pathname.slice(lastPos, i);
                    }
                    newPathname += "%23";
                    lastPos = i + 1;
                    break;
                case 63:
                    if (i - lastPos > 0) {
                        newPathname += pathname.slice(lastPos, i);
                    }
                    newPathname += "%3F";
                    lastPos = i + 1;
                    break;
            }
        }
        if (lastPos > 0) {
            if (lastPos !== pathname.length) {
                pathname = newPathname + pathname.slice(lastPos);
            } else pathname = newPathname;
        }
        if (this.slashes || slashedProtocol.has(protocol)) {
            if (this.slashes || host) {
                if (pathname && pathname.charCodeAt(0) !== 47) {
                    pathname = "/" + pathname;
                }
                host = "//" + host;
            } else if (protocol.length >= 4 && protocol.charCodeAt(0) === 102 && protocol.charCodeAt(1) === 105 && protocol.charCodeAt(2) === 108 && protocol.charCodeAt(3) === 101) {
                host = "//";
            }
        }
        search = search.replace(/#/g, "%23");
        if (hash && hash.charCodeAt(0) !== 35) {
            hash = "#" + hash;
        }
        if (search && search.charCodeAt(0) !== 63) {
            search = "?" + search;
        }
        return protocol + host + pathname + search + hash;
    }
    urlParse(url, parseQueryString, slashesDenoteHost) {
        validateString(url, "url");
        let hasHash = false;
        let start = -1;
        let end = -1;
        let rest = "";
        let lastPos = 0;
        for(let i = 0, inWs = false, split = false; i < url.length; ++i){
            const code = url.charCodeAt(i);
            const isWs = code === 32 || code === 9 || code === 13 || code === 10 || code === 12 || code === 160 || code === 65279;
            if (start === -1) {
                if (isWs) continue;
                lastPos = start = i;
            } else if (inWs) {
                if (!isWs) {
                    end = -1;
                    inWs = false;
                }
            } else if (isWs) {
                end = i;
                inWs = true;
            }
            if (!split) {
                switch(code){
                    case 35:
                        hasHash = true;
                    case 63:
                        split = true;
                        break;
                    case 92:
                        if (i - lastPos > 0) rest += url.slice(lastPos, i);
                        rest += "/";
                        lastPos = i + 1;
                        break;
                }
            } else if (!hasHash && code === 35) {
                hasHash = true;
            }
        }
        if (start !== -1) {
            if (lastPos === start) {
                if (end === -1) {
                    if (start === 0) rest = url;
                    else rest = url.slice(start);
                } else {
                    rest = url.slice(start, end);
                }
            } else if (end === -1 && lastPos < url.length) {
                rest += url.slice(lastPos);
            } else if (end !== -1 && lastPos < end) {
                rest += url.slice(lastPos, end);
            }
        }
        if (!slashesDenoteHost && !hasHash) {
            const simplePath = simplePathPattern.exec(rest);
            if (simplePath) {
                this.path = rest;
                this.href = rest;
                this.pathname = simplePath[1];
                if (simplePath[2]) {
                    this.search = simplePath[2];
                    if (parseQueryString) {
                        this.query = __default26.parse(this.search.slice(1));
                    } else {
                        this.query = this.search.slice(1);
                    }
                } else if (parseQueryString) {
                    this.search = null;
                    this.query = Object.create(null);
                }
                return this;
            }
        }
        let proto = protocolPattern.exec(rest);
        let lowerProto = "";
        if (proto) {
            proto = proto[0];
            lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.slice(proto.length);
        }
        let slashes;
        if (slashesDenoteHost || proto || hostPattern.test(rest)) {
            slashes = rest.charCodeAt(0) === CHAR_FORWARD_SLASH && rest.charCodeAt(1) === CHAR_FORWARD_SLASH;
            if (slashes && !(proto && hostlessProtocol.has(lowerProto))) {
                rest = rest.slice(2);
                this.slashes = true;
            }
        }
        if (!hostlessProtocol.has(lowerProto) && (slashes || proto && !slashedProtocol.has(proto))) {
            let hostEnd = -1;
            let atSign = -1;
            let nonHost = -1;
            for(let i = 0; i < rest.length; ++i){
                switch(rest.charCodeAt(i)){
                    case 9:
                    case 10:
                    case 13:
                    case 32:
                    case 34:
                    case 37:
                    case 39:
                    case 59:
                    case 60:
                    case 62:
                    case 92:
                    case 94:
                    case 96:
                    case 123:
                    case 124:
                    case 125:
                        if (nonHost === -1) nonHost = i;
                        break;
                    case 35:
                    case 47:
                    case 63:
                        if (nonHost === -1) nonHost = i;
                        hostEnd = i;
                        break;
                    case 64:
                        atSign = i;
                        nonHost = -1;
                        break;
                }
                if (hostEnd !== -1) break;
            }
            start = 0;
            if (atSign !== -1) {
                this.auth = decodeURIComponent(rest.slice(0, atSign));
                start = atSign + 1;
            }
            if (nonHost === -1) {
                this.host = rest.slice(start);
                rest = "";
            } else {
                this.host = rest.slice(start, nonHost);
                rest = rest.slice(nonHost);
            }
            this.#parseHost();
            if (typeof this.hostname !== "string") this.hostname = "";
            const hostname = this.hostname;
            const ipv6Hostname = isIpv6Hostname(hostname);
            if (!ipv6Hostname) {
                rest = getHostname(this, rest, hostname);
            }
            if (this.hostname.length > 255) {
                this.hostname = "";
            } else {
                this.hostname = this.hostname.toLowerCase();
            }
            if (this.hostname !== "") {
                if (ipv6Hostname) {
                    if (forbiddenHostCharsIpv6.test(this.hostname)) {
                        throw new ERR_INVALID_URL(url);
                    }
                } else {
                    this.hostname = toASCII(this.hostname);
                    if (this.hostname === "" || forbiddenHostChars.test(this.hostname)) {
                        throw new ERR_INVALID_URL(url);
                    }
                }
            }
            const p = this.port ? ":" + this.port : "";
            const h = this.hostname || "";
            this.host = h + p;
            if (ipv6Hostname) {
                this.hostname = this.hostname.slice(1, -1);
                if (rest[0] !== "/") {
                    rest = "/" + rest;
                }
            }
        }
        if (!unsafeProtocol.has(lowerProto)) {
            rest = autoEscapeStr(rest);
        }
        let questionIdx = -1;
        let hashIdx = -1;
        for(let i = 0; i < rest.length; ++i){
            const code = rest.charCodeAt(i);
            if (code === 35) {
                this.hash = rest.slice(i);
                hashIdx = i;
                break;
            } else if (code === 63 && questionIdx === -1) {
                questionIdx = i;
            }
        }
        if (questionIdx !== -1) {
            if (hashIdx === -1) {
                this.search = rest.slice(questionIdx);
                this.query = rest.slice(questionIdx + 1);
            } else {
                this.search = rest.slice(questionIdx, hashIdx);
                this.query = rest.slice(questionIdx + 1, hashIdx);
            }
            if (parseQueryString) {
                this.query = __default26.parse(this.query);
            }
        } else if (parseQueryString) {
            this.search = null;
            this.query = Object.create(null);
        }
        const useQuestionIdx = questionIdx !== -1 && (hashIdx === -1 || questionIdx < hashIdx);
        const firstIdx = useQuestionIdx ? questionIdx : hashIdx;
        if (firstIdx === -1) {
            if (rest.length > 0) this.pathname = rest;
        } else if (firstIdx > 0) {
            this.pathname = rest.slice(0, firstIdx);
        }
        if (slashedProtocol.has(lowerProto) && this.hostname && !this.pathname) {
            this.pathname = "/";
        }
        if (this.pathname || this.search) {
            const p = this.pathname || "";
            const s = this.search || "";
            this.path = p + s;
        }
        this.href = this.format();
        return this;
    }
}
function format8(urlObject, options) {
    if (typeof urlObject === "string") {
        urlObject = parse8(urlObject, true, false);
    } else if (typeof urlObject !== "object" || urlObject === null) {
        throw new ERR_INVALID_ARG_TYPE("urlObject", [
            "Object",
            "string"
        ], urlObject);
    } else if (!(urlObject instanceof Url)) {
        if (urlObject instanceof URL) {
            return formatWhatwg(urlObject, options);
        }
        return Url.prototype.format.call(urlObject);
    }
    return urlObject.format();
}
function formatWhatwg(urlObject, options) {
    if (typeof urlObject === "string") {
        urlObject = new URL(urlObject);
    }
    if (options) {
        if (typeof options !== "object") {
            throw new ERR_INVALID_ARG_TYPE("options", "object", options);
        }
    }
    options = {
        auth: true,
        fragment: true,
        search: true,
        unicode: false,
        ...options
    };
    let ret = urlObject.protocol;
    if (urlObject.host !== null) {
        ret += "//";
        const hasUsername = !!urlObject.username;
        const hasPassword = !!urlObject.password;
        if (options.auth && (hasUsername || hasPassword)) {
            if (hasUsername) {
                ret += urlObject.username;
            }
            if (hasPassword) {
                ret += `:${urlObject.password}`;
            }
            ret += "@";
        }
        ret += urlObject.host;
        if (urlObject.port) {
            ret += `:${urlObject.port}`;
        }
    }
    ret += urlObject.pathname;
    if (options.search && urlObject.search) {
        ret += urlObject.search;
    }
    if (options.fragment && urlObject.hash) {
        ret += urlObject.hash;
    }
    return ret;
}
function isIpv6Hostname(hostname) {
    return hostname.charCodeAt(0) === 91 && hostname.charCodeAt(hostname.length - 1) === 93;
}
function getHostname(self, rest, hostname) {
    for(let i = 0; i < hostname.length; ++i){
        const code = hostname.charCodeAt(i);
        const isValid = code >= 97 && code <= 122 || code === 46 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 43 || code === 95 || code > 127;
        if (!isValid) {
            self.hostname = hostname.slice(0, i);
            return `/${hostname.slice(i)}${rest}`;
        }
    }
    return rest;
}
const escapedCodes = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%09",
    "%0A",
    "",
    "",
    "%0D",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%20",
    "",
    "%22",
    "",
    "",
    "",
    "",
    "%27",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%3C",
    "",
    "%3E",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%5C",
    "",
    "%5E",
    "",
    "%60",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%7B",
    "%7C",
    "%7D"
];
function autoEscapeStr(rest) {
    let escaped = "";
    let lastEscapedPos = 0;
    for(let i = 0; i < rest.length; ++i){
        const escapedChar = escapedCodes[rest.charCodeAt(i)];
        if (escapedChar) {
            if (i > lastEscapedPos) {
                escaped += rest.slice(lastEscapedPos, i);
            }
            escaped += escapedChar;
            lastEscapedPos = i + 1;
        }
    }
    if (lastEscapedPos === 0) {
        return rest;
    }
    if (lastEscapedPos < rest.length) {
        escaped += rest.slice(lastEscapedPos);
    }
    return escaped;
}
function parse8(url, parseQueryString, slashesDenoteHost) {
    if (url instanceof Url) return url;
    const urlObject = new Url();
    urlObject.urlParse(url, parseQueryString, slashesDenoteHost);
    return urlObject;
}
function resolve10(from, to) {
    return parse8(from, false, true).resolve(to);
}
function resolveObject(source, relative) {
    if (!source) return relative;
    return parse8(source, false, true).resolveObject(relative);
}
function domainToASCII(domain) {
    if (regexPunycode.test(domain) && regexNonASCII.test(domain)) {
        return "";
    }
    return toASCII(domain);
}
function domainToUnicode(domain) {
    if (regexPunycode.test(domain) && regexNonASCII.test(domain)) {
        return "";
    }
    return toUnicode(domain);
}
function fileURLToPath(path) {
    if (typeof path === "string") path = new URL(path);
    else if (!(path instanceof URL)) {
        throw new ERR_INVALID_ARG_TYPE("path", [
            "string",
            "URL"
        ], path);
    }
    if (path.protocol !== "file:") {
        throw new ERR_INVALID_URL_SCHEME("file");
    }
    return isWindows ? getPathFromURLWin(path) : getPathFromURLPosix(path);
}
function getPathFromURLWin(url) {
    const hostname = url.hostname;
    let pathname = url.pathname;
    for(let n = 0; n < pathname.length; n++){
        if (pathname[n] === "%") {
            const third = pathname.codePointAt(n + 2) | 0x20;
            if (pathname[n + 1] === "2" && third === 102 || pathname[n + 1] === "5" && third === 99) {
                throw new ERR_INVALID_FILE_URL_PATH("must not include encoded \\ or / characters");
            }
        }
    }
    pathname = pathname.replace(forwardSlashRegEx, "\\");
    pathname = decodeURIComponent(pathname);
    if (hostname !== "") {
        return `\\\\${hostname}${pathname}`;
    } else {
        const letter = pathname.codePointAt(1) | 0x20;
        const sep = pathname[2];
        if (letter < 97 || letter > 122 || sep !== ":") {
            throw new ERR_INVALID_FILE_URL_PATH("must be absolute");
        }
        return pathname.slice(1);
    }
}
function getPathFromURLPosix(url) {
    if (url.hostname !== "") {
        throw new ERR_INVALID_FILE_URL_HOST(osType);
    }
    const pathname = url.pathname;
    for(let n = 0; n < pathname.length; n++){
        if (pathname[n] === "%") {
            const third = pathname.codePointAt(n + 2) | 0x20;
            if (pathname[n + 1] === "2" && third === 102) {
                throw new ERR_INVALID_FILE_URL_PATH("must not include encoded / characters");
            }
        }
    }
    return decodeURIComponent(pathname);
}
function encodePathChars(filepath) {
    if (filepath.includes("%")) {
        filepath = filepath.replace(percentRegEx, "%25");
    }
    if (!isWindows && filepath.includes("\\")) {
        filepath = filepath.replace(backslashRegEx, "%5C");
    }
    if (filepath.includes("\n")) {
        filepath = filepath.replace(newlineRegEx, "%0A");
    }
    if (filepath.includes("\r")) {
        filepath = filepath.replace(carriageReturnRegEx, "%0D");
    }
    if (filepath.includes("\t")) {
        filepath = filepath.replace(tabRegEx, "%09");
    }
    return filepath;
}
function pathToFileURL(filepath) {
    const outURL = new URL("file://");
    if (isWindows && filepath.startsWith("\\\\")) {
        const paths = filepath.split("\\");
        if (paths.length <= 3) {
            throw new ERR_INVALID_ARG_VALUE("filepath", filepath, "Missing UNC resource path");
        }
        const hostname = paths[2];
        if (hostname.length === 0) {
            throw new ERR_INVALID_ARG_VALUE("filepath", filepath, "Empty UNC servername");
        }
        outURL.hostname = domainToASCII(hostname);
        outURL.pathname = encodePathChars(paths.slice(3).join("/"));
    } else {
        let resolved = resolve9(filepath);
        const filePathLast = filepath.charCodeAt(filepath.length - 1);
        if ((filePathLast === 47 || isWindows && filePathLast === 92) && resolved[resolved.length - 1] !== sep5) {
            resolved += "/";
        }
        outURL.pathname = encodePathChars(resolved);
    }
    return outURL;
}
function urlToHttpOptions(url) {
    const options = {
        protocol: url.protocol,
        hostname: typeof url.hostname === "string" && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        path: `${url.pathname || ""}${url.search || ""}`,
        href: url.href
    };
    if (url.port !== "") {
        options.port = Number(url.port);
    }
    if (url.username || url.password) {
        options.auth = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)}`;
    }
    return options;
}
URLSearchParams;
const __default27 = {
    parse: parse8,
    format: format8,
    resolve: resolve10,
    resolveObject,
    domainToASCII,
    domainToUnicode,
    fileURLToPath,
    pathToFileURL,
    urlToHttpOptions,
    Url,
    URL,
    URLSearchParams
};
Symbol("query");
function toPathIfFileURL(fileURLOrPath) {
    if (!(fileURLOrPath instanceof URL)) {
        return fileURLOrPath;
    }
    return fileURLToPath(fileURLOrPath);
}
function urlToHttpOptions1(url) {
    const options = {
        protocol: url.protocol,
        hostname: typeof url.hostname === "string" && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        path: `${url.pathname || ""}${url.search || ""}`,
        href: url.href
    };
    if (url.port !== "") {
        options.port = Number(url.port);
    }
    if (url.username || url.password) {
        options.auth = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)}`;
    }
    return options;
}
function convertFileInfoToStats(origin) {
    return {
        dev: origin.dev,
        ino: origin.ino,
        mode: origin.mode,
        nlink: origin.nlink,
        uid: origin.uid,
        gid: origin.gid,
        rdev: origin.rdev,
        size: origin.size,
        blksize: origin.blksize,
        blocks: origin.blocks,
        mtime: origin.mtime,
        atime: origin.atime,
        birthtime: origin.birthtime,
        mtimeMs: origin.mtime?.getTime() || null,
        atimeMs: origin.atime?.getTime() || null,
        birthtimeMs: origin.birthtime?.getTime() || null,
        isFile: ()=>origin.isFile,
        isDirectory: ()=>origin.isDirectory,
        isSymbolicLink: ()=>origin.isSymlink,
        isBlockDevice: ()=>false,
        isFIFO: ()=>false,
        isCharacterDevice: ()=>false,
        isSocket: ()=>false,
        ctime: origin.mtime,
        ctimeMs: origin.mtime?.getTime() || null
    };
}
function toBigInt(number) {
    if (number === null || number === undefined) return null;
    return BigInt(number);
}
function convertFileInfoToBigIntStats(origin) {
    return {
        dev: toBigInt(origin.dev),
        ino: toBigInt(origin.ino),
        mode: toBigInt(origin.mode),
        nlink: toBigInt(origin.nlink),
        uid: toBigInt(origin.uid),
        gid: toBigInt(origin.gid),
        rdev: toBigInt(origin.rdev),
        size: toBigInt(origin.size) || 0n,
        blksize: toBigInt(origin.blksize),
        blocks: toBigInt(origin.blocks),
        mtime: origin.mtime,
        atime: origin.atime,
        birthtime: origin.birthtime,
        mtimeMs: origin.mtime ? BigInt(origin.mtime.getTime()) : null,
        atimeMs: origin.atime ? BigInt(origin.atime.getTime()) : null,
        birthtimeMs: origin.birthtime ? BigInt(origin.birthtime.getTime()) : null,
        mtimeNs: origin.mtime ? BigInt(origin.mtime.getTime()) * 1000000n : null,
        atimeNs: origin.atime ? BigInt(origin.atime.getTime()) * 1000000n : null,
        birthtimeNs: origin.birthtime ? BigInt(origin.birthtime.getTime()) * 1000000n : null,
        isFile: ()=>origin.isFile,
        isDirectory: ()=>origin.isDirectory,
        isSymbolicLink: ()=>origin.isSymlink,
        isBlockDevice: ()=>false,
        isFIFO: ()=>false,
        isCharacterDevice: ()=>false,
        isSocket: ()=>false,
        ctime: origin.mtime,
        ctimeMs: origin.mtime ? BigInt(origin.mtime.getTime()) : null,
        ctimeNs: origin.mtime ? BigInt(origin.mtime.getTime()) * 1000000n : null
    };
}
function CFISBIS(fileInfo, bigInt) {
    if (bigInt) return convertFileInfoToBigIntStats(fileInfo);
    return convertFileInfoToStats(fileInfo);
}
function stat(path, optionsOrCallback, maybeCallback) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : {
        bigint: false
    };
    if (!callback) throw new Error("No callback function supplied");
    Deno.stat(path).then((stat)=>callback(null, CFISBIS(stat, options.bigint)), (err)=>callback(denoErrorToNodeError(err, {
            syscall: "stat"
        })));
}
const statPromise = promisify(stat);
function statSync(path, options = {
    bigint: false,
    throwIfNoEntry: true
}) {
    try {
        const origin = Deno.statSync(path);
        return CFISBIS(origin, options.bigint);
    } catch (err) {
        if (options?.throwIfNoEntry === false && err instanceof Deno.errors.NotFound) {
            return;
        }
        if (err instanceof Error) {
            throw denoErrorToNodeError(err, {
                syscall: "stat"
            });
        } else {
            throw err;
        }
    }
}
function lstat(path, optionsOrCallback, maybeCallback) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : {
        bigint: false
    };
    if (!callback) throw new Error("No callback function supplied");
    Deno.lstat(path).then((stat)=>callback(null, CFISBIS(stat, options.bigint)), (err)=>callback(err));
}
const lstatPromise = promisify(lstat);
function lstatSync(path, options) {
    const origin = Deno.lstatSync(path);
    return CFISBIS(origin, options?.bigint || false);
}
"use strict";
const kType = Symbol("type");
const kStats = Symbol("stats");
const { F_OK =0 , W_OK =0 , R_OK =0 , X_OK =0 , COPYFILE_EXCL , COPYFILE_FICLONE , COPYFILE_FICLONE_FORCE , O_APPEND , O_CREAT , O_EXCL , O_RDONLY , O_RDWR , O_SYNC , O_TRUNC , O_WRONLY , S_IFBLK , S_IFCHR , S_IFDIR , S_IFIFO , S_IFLNK , S_IFMT , S_IFREG , S_IFSOCK , UV_FS_SYMLINK_DIR , UV_FS_SYMLINK_JUNCTION , UV_DIRENT_UNKNOWN , UV_DIRENT_FILE , UV_DIRENT_DIR , UV_DIRENT_LINK , UV_DIRENT_FIFO , UV_DIRENT_SOCKET , UV_DIRENT_CHAR , UV_DIRENT_BLOCK  } = fs;
const { errno: { EISDIR  }  } = os;
const kMinimumAccessMode = Math.min(F_OK, W_OK, R_OK, X_OK);
const kMaximumAccessMode = F_OK | W_OK | R_OK | X_OK;
const kDefaultCopyMode = 0;
const kMinimumCopyMode = Math.min(0, COPYFILE_EXCL, COPYFILE_FICLONE, COPYFILE_FICLONE_FORCE);
const kMaximumCopyMode = COPYFILE_EXCL | COPYFILE_FICLONE | COPYFILE_FICLONE_FORCE;
const kIoMaxLength = 2 ** 31 - 1;
const kReadFileUnknownBufferLength = 64 * 1024;
const kReadFileBufferLength = 512 * 1024;
const kWriteFileMaxChunkSize = 512 * 1024;
const kMaxUserId = 2 ** 32 - 1;
function assertEncoding(encoding) {
    if (encoding && !Buffer1.isEncoding(encoding)) {
        const reason = "is invalid encoding";
        throw new ERR_INVALID_ARG_VALUE(encoding, "encoding", reason);
    }
}
class Dirent {
    constructor(name, type){
        this.name = name;
        this[kType] = type;
    }
    isDirectory() {
        return this[kType] === UV_DIRENT_DIR;
    }
    isFile() {
        return this[kType] === UV_DIRENT_FILE;
    }
    isBlockDevice() {
        return this[kType] === UV_DIRENT_BLOCK;
    }
    isCharacterDevice() {
        return this[kType] === UV_DIRENT_CHAR;
    }
    isSymbolicLink() {
        return this[kType] === UV_DIRENT_LINK;
    }
    isFIFO() {
        return this[kType] === UV_DIRENT_FIFO;
    }
    isSocket() {
        return this[kType] === UV_DIRENT_SOCKET;
    }
}
class DirentFromStats extends Dirent {
    constructor(name, stats){
        super(name, null);
        this[kStats] = stats;
    }
}
for (const name of Reflect.ownKeys(Dirent.prototype)){
    if (name === "constructor") {
        continue;
    }
    DirentFromStats.prototype[name] = function() {
        return this[kStats][name]();
    };
}
function copyObject(source) {
    const target = {};
    for(const key in source){
        target[key] = source[key];
    }
    return target;
}
const bufferSep = Buffer1.from(__default25.sep);
function join9(path, name) {
    if ((typeof path === "string" || isUint8Array(path)) && name === undefined) {
        return path;
    }
    if (typeof path === "string" && isUint8Array(name)) {
        const pathBuffer = Buffer1.from(__default25.join(path, __default25.sep));
        return Buffer1.concat([
            pathBuffer,
            name
        ]);
    }
    if (typeof path === "string" && typeof name === "string") {
        return __default25.join(path, name);
    }
    if (isUint8Array(path) && isUint8Array(name)) {
        return Buffer1.concat([
            path,
            bufferSep,
            name
        ]);
    }
    throw new ERR_INVALID_ARG_TYPE("path", [
        "string",
        "Buffer"
    ], path);
}
function getDirents(path, { 0: names , 1: types  }, callback) {
    let i;
    if (typeof callback === "function") {
        const len = names.length;
        let toFinish = 0;
        callback = once1(callback);
        for(i = 0; i < len; i++){
            const type = types[i];
            if (type === UV_DIRENT_UNKNOWN) {
                const name = names[i];
                const idx = i;
                toFinish++;
                let filepath;
                try {
                    filepath = join9(path, name);
                } catch (err) {
                    callback(err);
                    return;
                }
                lstat(filepath, (err, stats)=>{
                    if (err) {
                        callback(err);
                        return;
                    }
                    names[idx] = new DirentFromStats(name, stats);
                    if (--toFinish === 0) {
                        callback(null, names);
                    }
                });
            } else {
                names[i] = new Dirent(names[i], types[i]);
            }
        }
        if (toFinish === 0) {
            callback(null, names);
        }
    } else {
        const len = names.length;
        for(i = 0; i < len; i++){
            names[i] = getDirent(path, names[i], types[i]);
        }
        return names;
    }
}
function getDirent(path, name, type, callback) {
    if (typeof callback === "function") {
        if (type === UV_DIRENT_UNKNOWN) {
            let filepath;
            try {
                filepath = join9(path, name);
            } catch (err) {
                callback(err);
                return;
            }
            lstat(filepath, (err, stats)=>{
                if (err) {
                    callback(err);
                    return;
                }
                callback(null, new DirentFromStats(name, stats));
            });
        } else {
            callback(null, new Dirent(name, type));
        }
    } else if (type === UV_DIRENT_UNKNOWN) {
        const stats = lstatSync(join9(path, name));
        return new DirentFromStats(name, stats);
    } else {
        return new Dirent(name, type);
    }
}
function getOptions1(options, defaultOptions) {
    if (options === null || options === undefined || typeof options === "function") {
        return defaultOptions;
    }
    if (typeof options === "string") {
        defaultOptions = {
            ...defaultOptions
        };
        defaultOptions.encoding = options;
        options = defaultOptions;
    } else if (typeof options !== "object") {
        throw new ERR_INVALID_ARG_TYPE("options", [
            "string",
            "Object"
        ], options);
    }
    if (options.encoding !== "buffer") {
        assertEncoding(options.encoding);
    }
    if (options.signal !== undefined) {
        validateAbortSignal(options.signal, "options.signal");
    }
    return options;
}
function handleErrorFromBinding(ctx) {
    if (ctx.errno !== undefined) {
        const err = uvException(ctx);
        Error.captureStackTrace(err, handleErrorFromBinding);
        throw err;
    }
    if (ctx.error !== undefined) {
        Error.captureStackTrace(ctx.error, handleErrorFromBinding);
        throw ctx.error;
    }
}
const nullCheck = hideStackFrames((path, propName, throwError = true)=>{
    const pathIsString = typeof path === "string";
    const pathIsUint8Array = isUint8Array(path);
    if (!pathIsString && !pathIsUint8Array || pathIsString && !path.includes("\u0000") || pathIsUint8Array && !path.includes(0)) {
        return;
    }
    const err = new ERR_INVALID_ARG_VALUE(propName, path, "must be a string or Uint8Array without null bytes");
    if (throwError) {
        throw err;
    }
    return err;
});
function preprocessSymlinkDestination(path, type, linkPath) {
    if (!isWindows) {
        return path;
    }
    path = "" + path;
    if (type === "junction") {
        path = __default25.resolve(linkPath, "..", path);
        return __default25.toNamespacedPath(path);
    }
    if (__default25.isAbsolute(path)) {
        return __default25.toNamespacedPath(path);
    }
    return path.replace(/\//g, "\\");
}
function StatsBase(dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks) {
    this.dev = dev;
    this.mode = mode;
    this.nlink = nlink;
    this.uid = uid;
    this.gid = gid;
    this.rdev = rdev;
    this.blksize = blksize;
    this.ino = ino;
    this.size = size;
    this.blocks = blocks;
}
StatsBase.prototype.isDirectory = function() {
    return this._checkModeProperty(S_IFDIR);
};
StatsBase.prototype.isFile = function() {
    return this._checkModeProperty(S_IFREG);
};
StatsBase.prototype.isBlockDevice = function() {
    return this._checkModeProperty(S_IFBLK);
};
StatsBase.prototype.isCharacterDevice = function() {
    return this._checkModeProperty(S_IFCHR);
};
StatsBase.prototype.isSymbolicLink = function() {
    return this._checkModeProperty(S_IFLNK);
};
StatsBase.prototype.isFIFO = function() {
    return this._checkModeProperty(S_IFIFO);
};
StatsBase.prototype.isSocket = function() {
    return this._checkModeProperty(S_IFSOCK);
};
const kNsPerMsBigInt = 10n ** 6n;
const kNsPerSecBigInt = 10n ** 9n;
const kMsPerSec = 10 ** 3;
const kNsPerMs = 10 ** 6;
function msFromTimeSpec(sec, nsec) {
    return sec * kMsPerSec + nsec / kNsPerMs;
}
function nsFromTimeSpecBigInt(sec, nsec) {
    return sec * kNsPerSecBigInt + nsec;
}
function dateFromMs(ms) {
    return new Date(Number(ms) + 0.5);
}
function BigIntStats(dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atimeNs, mtimeNs, ctimeNs, birthtimeNs) {
    Reflect.apply(StatsBase, this, [
        dev,
        mode,
        nlink,
        uid,
        gid,
        rdev,
        blksize,
        ino,
        size,
        blocks
    ]);
    this.atimeMs = atimeNs / kNsPerMsBigInt;
    this.mtimeMs = mtimeNs / kNsPerMsBigInt;
    this.ctimeMs = ctimeNs / kNsPerMsBigInt;
    this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;
    this.atimeNs = atimeNs;
    this.mtimeNs = mtimeNs;
    this.ctimeNs = ctimeNs;
    this.birthtimeNs = birthtimeNs;
    this.atime = dateFromMs(this.atimeMs);
    this.mtime = dateFromMs(this.mtimeMs);
    this.ctime = dateFromMs(this.ctimeMs);
    this.birthtime = dateFromMs(this.birthtimeMs);
}
Object.setPrototypeOf(BigIntStats.prototype, StatsBase.prototype);
Object.setPrototypeOf(BigIntStats, StatsBase);
BigIntStats.prototype._checkModeProperty = function(property) {
    if (isWindows && (property === S_IFIFO || property === S_IFBLK || property === S_IFSOCK)) {
        return false;
    }
    return (this.mode & BigInt(S_IFMT)) === BigInt(property);
};
function Stats(dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atimeMs, mtimeMs, ctimeMs, birthtimeMs) {
    StatsBase.call(this, dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks);
    this.atimeMs = atimeMs;
    this.mtimeMs = mtimeMs;
    this.ctimeMs = ctimeMs;
    this.birthtimeMs = birthtimeMs;
    this.atime = dateFromMs(atimeMs);
    this.mtime = dateFromMs(mtimeMs);
    this.ctime = dateFromMs(ctimeMs);
    this.birthtime = dateFromMs(birthtimeMs);
}
Object.setPrototypeOf(Stats.prototype, StatsBase.prototype);
Object.setPrototypeOf(Stats, StatsBase);
Stats.prototype.isFile = StatsBase.prototype.isFile;
Stats.prototype._checkModeProperty = function(property) {
    if (isWindows && (property === S_IFIFO || property === S_IFBLK || property === S_IFSOCK)) {
        return false;
    }
    return (this.mode & S_IFMT) === property;
};
function getStatsFromBinding(stats, offset = 0) {
    if (isBigUint64Array(stats)) {
        return new BigIntStats(stats[0 + offset], stats[1 + offset], stats[2 + offset], stats[3 + offset], stats[4 + offset], stats[5 + offset], stats[6 + offset], stats[7 + offset], stats[8 + offset], stats[9 + offset], nsFromTimeSpecBigInt(stats[10 + offset], stats[11 + offset]), nsFromTimeSpecBigInt(stats[12 + offset], stats[13 + offset]), nsFromTimeSpecBigInt(stats[14 + offset], stats[15 + offset]), nsFromTimeSpecBigInt(stats[16 + offset], stats[17 + offset]));
    }
    return new Stats(stats[0 + offset], stats[1 + offset], stats[2 + offset], stats[3 + offset], stats[4 + offset], stats[5 + offset], stats[6 + offset], stats[7 + offset], stats[8 + offset], stats[9 + offset], msFromTimeSpec(stats[10 + offset], stats[11 + offset]), msFromTimeSpec(stats[12 + offset], stats[13 + offset]), msFromTimeSpec(stats[14 + offset], stats[15 + offset]), msFromTimeSpec(stats[16 + offset], stats[17 + offset]));
}
function stringToFlags(flags, name = "flags") {
    if (typeof flags === "number") {
        validateInt32(flags, name);
        return flags;
    }
    if (flags == null) {
        return O_RDONLY;
    }
    switch(flags){
        case "r":
            return O_RDONLY;
        case "rs":
        case "sr":
            return O_RDONLY | O_SYNC;
        case "r+":
            return O_RDWR;
        case "rs+":
        case "sr+":
            return O_RDWR | O_SYNC;
        case "w":
            return O_TRUNC | O_CREAT | O_WRONLY;
        case "wx":
        case "xw":
            return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;
        case "w+":
            return O_TRUNC | O_CREAT | O_RDWR;
        case "wx+":
        case "xw+":
            return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;
        case "a":
            return O_APPEND | O_CREAT | O_WRONLY;
        case "ax":
        case "xa":
            return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;
        case "as":
        case "sa":
            return O_APPEND | O_CREAT | O_WRONLY | O_SYNC;
        case "a+":
            return O_APPEND | O_CREAT | O_RDWR;
        case "ax+":
        case "xa+":
            return O_APPEND | O_CREAT | O_RDWR | O_EXCL;
        case "as+":
        case "sa+":
            return O_APPEND | O_CREAT | O_RDWR | O_SYNC;
    }
    throw new ERR_INVALID_ARG_VALUE("flags", flags);
}
const stringToSymlinkType = hideStackFrames((type)=>{
    let flags = 0;
    if (typeof type === "string") {
        switch(type){
            case "dir":
                flags |= UV_FS_SYMLINK_DIR;
                break;
            case "junction":
                flags |= UV_FS_SYMLINK_JUNCTION;
                break;
            case "file":
                break;
            default:
                throw new ERR_FS_INVALID_SYMLINK_TYPE(type);
        }
    }
    return flags;
});
function toUnixTimestamp(time, name = "time") {
    if (typeof time === "string" && +time == time) {
        return +time;
    }
    if (Number.isFinite(time)) {
        if (time < 0) {
            return Date.now() / 1000;
        }
        return time;
    }
    if (isDate1(time)) {
        return Date.getTime(time) / 1000;
    }
    throw new ERR_INVALID_ARG_TYPE(name, [
        "Date",
        "Time in seconds"
    ], time);
}
const validateOffsetLengthRead = hideStackFrames((offset, length, bufferLength)=>{
    if (offset < 0) {
        throw new ERR_OUT_OF_RANGE("offset", ">= 0", offset);
    }
    if (length < 0) {
        throw new ERR_OUT_OF_RANGE("length", ">= 0", length);
    }
    if (offset + length > bufferLength) {
        throw new ERR_OUT_OF_RANGE("length", `<= ${bufferLength - offset}`, length);
    }
});
const validateOffsetLengthWrite = hideStackFrames((offset, length, byteLength)=>{
    if (offset > byteLength) {
        throw new ERR_OUT_OF_RANGE("offset", `<= ${byteLength}`, offset);
    }
    if (length > byteLength - offset) {
        throw new ERR_OUT_OF_RANGE("length", `<= ${byteLength - offset}`, length);
    }
    if (length < 0) {
        throw new ERR_OUT_OF_RANGE("length", ">= 0", length);
    }
    validateInt32(length, "length", 0);
});
const validatePath = hideStackFrames((path, propName = "path")=>{
    if (typeof path !== "string" && !isUint8Array(path)) {
        throw new ERR_INVALID_ARG_TYPE(propName, [
            "string",
            "Buffer",
            "URL"
        ], path);
    }
    const err = nullCheck(path, propName, false);
    if (err !== undefined) {
        throw err;
    }
});
const getValidatedPath = hideStackFrames((fileURLOrPath, propName = "path")=>{
    const path = toPathIfFileURL(fileURLOrPath);
    validatePath(path, propName);
    return path;
});
const getValidatedFd = hideStackFrames((fd, propName = "fd")=>{
    if (Object.is(fd, -0)) {
        return 0;
    }
    validateInt32(fd, propName, 0);
    return fd;
});
const validateBufferArray = hideStackFrames((buffers, propName = "buffers")=>{
    if (!Array.isArray(buffers)) {
        throw new ERR_INVALID_ARG_TYPE(propName, "ArrayBufferView[]", buffers);
    }
    for(let i = 0; i < buffers.length; i++){
        if (!isArrayBufferView(buffers[i])) {
            throw new ERR_INVALID_ARG_TYPE(propName, "ArrayBufferView[]", buffers);
        }
    }
    return buffers;
});
let nonPortableTemplateWarn = true;
function warnOnNonPortableTemplate(template) {
    if (nonPortableTemplateWarn && template.endsWith("X")) {
        process2.emitWarning("mkdtemp() templates ending with X are not portable. " + "For details see: https://nodejs.org/api/fs.html");
        nonPortableTemplateWarn = false;
    }
}
const defaultCpOptions = {
    dereference: false,
    errorOnExist: false,
    filter: undefined,
    force: true,
    preserveTimestamps: false,
    recursive: false
};
const defaultRmOptions = {
    recursive: false,
    force: false,
    retryDelay: 100,
    maxRetries: 0
};
const defaultRmdirOptions = {
    retryDelay: 100,
    maxRetries: 0,
    recursive: false
};
const validateCpOptions = hideStackFrames((options)=>{
    if (options === undefined) {
        return {
            ...defaultCpOptions
        };
    }
    validateObject(options, "options");
    options = {
        ...defaultCpOptions,
        ...options
    };
    validateBoolean(options.dereference, "options.dereference");
    validateBoolean(options.errorOnExist, "options.errorOnExist");
    validateBoolean(options.force, "options.force");
    validateBoolean(options.preserveTimestamps, "options.preserveTimestamps");
    validateBoolean(options.recursive, "options.recursive");
    if (options.filter !== undefined) {
        validateFunction(options.filter, "options.filter");
    }
    return options;
});
const validateRmOptions = hideStackFrames((path, options, expectDir, cb)=>{
    options = validateRmdirOptions(options, defaultRmOptions);
    validateBoolean(options.force, "options.force");
    stat(path, (err, stats)=>{
        if (err) {
            if (options.force && err.code === "ENOENT") {
                return cb(null, options);
            }
            return cb(err, options);
        }
        if (expectDir && !stats.isDirectory()) {
            return cb(false);
        }
        if (stats.isDirectory() && !options.recursive) {
            return cb(new ERR_FS_EISDIR({
                code: "EISDIR",
                message: "is a directory",
                path,
                syscall: "rm",
                errno: EISDIR
            }));
        }
        return cb(null, options);
    });
});
const validateRmOptionsSync = hideStackFrames((path, options, expectDir)=>{
    options = validateRmdirOptions(options, defaultRmOptions);
    validateBoolean(options.force, "options.force");
    if (!options.force || expectDir || !options.recursive) {
        const isDirectory = statSync(path, {
            throwIfNoEntry: !options.force
        })?.isDirectory();
        if (expectDir && !isDirectory) {
            return false;
        }
        if (isDirectory && !options.recursive) {
            throw new ERR_FS_EISDIR({
                code: "EISDIR",
                message: "is a directory",
                path,
                syscall: "rm",
                errno: EISDIR
            });
        }
    }
    return options;
});
let recursiveRmdirWarned = process2.noDeprecation;
function emitRecursiveRmdirWarning() {
    if (!recursiveRmdirWarned) {
        process2.emitWarning("In future versions of Node.js, fs.rmdir(path, { recursive: true }) " + "will be removed. Use fs.rm(path, { recursive: true }) instead", "DeprecationWarning", "DEP0147");
        recursiveRmdirWarned = true;
    }
}
const validateRmdirOptions = hideStackFrames((options, defaults = defaultRmdirOptions)=>{
    if (options === undefined) {
        return defaults;
    }
    validateObject(options, "options");
    options = {
        ...defaults,
        ...options
    };
    validateBoolean(options.recursive, "options.recursive");
    validateInt32(options.retryDelay, "options.retryDelay", 0);
    validateUint32(options.maxRetries, "options.maxRetries");
    return options;
});
const getValidMode = hideStackFrames((mode, type)=>{
    let min = kMinimumAccessMode;
    let max = kMaximumAccessMode;
    let def = F_OK;
    if (type === "copyFile") {
        min = kMinimumCopyMode;
        max = kMaximumCopyMode;
        def = mode || kDefaultCopyMode;
    } else {
        assert2(type === "access");
    }
    if (mode == null) {
        return def;
    }
    if (Number.isInteger(mode) && mode >= min && mode <= max) {
        return mode;
    }
    if (typeof mode !== "number") {
        throw new ERR_INVALID_ARG_TYPE("mode", "integer", mode);
    }
    throw new ERR_OUT_OF_RANGE("mode", `an integer >= ${min} && <= ${max}`, mode);
});
const validateStringAfterArrayBufferView = hideStackFrames((buffer, name)=>{
    if (typeof buffer === "string") {
        return;
    }
    if (typeof buffer === "object" && buffer !== null && typeof buffer.toString === "function" && Object.prototype.hasOwnProperty.call(buffer, "toString")) {
        return;
    }
    throw new ERR_INVALID_ARG_TYPE(name, [
        "string",
        "Buffer",
        "TypedArray",
        "DataView"
    ], buffer);
});
const validatePosition = hideStackFrames((position)=>{
    if (typeof position === "number") {
        validateInteger(position, "position");
    } else if (typeof position === "bigint") {
        if (!(position >= -(2n ** 63n) && position <= 2n ** 63n - 1n)) {
            throw new ERR_OUT_OF_RANGE("position", `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`, position);
        }
    } else {
        throw new ERR_INVALID_ARG_TYPE("position", [
            "integer",
            "bigint"
        ], position);
    }
});
const realpathCacheKey = Symbol("realpathCacheKey");
const constants5 = {
    kIoMaxLength,
    kMaxUserId,
    kReadFileBufferLength,
    kReadFileUnknownBufferLength,
    kWriteFileMaxChunkSize
};
const showStringCoercionDeprecation = deprecate(()=>{}, "Implicit coercion of objects with own toString property is deprecated.", "DEP0162");
const __default28 = {
    constants: constants5,
    assertEncoding,
    BigIntStats,
    copyObject,
    Dirent,
    emitRecursiveRmdirWarning,
    getDirent,
    getDirents,
    getOptions: getOptions1,
    getValidatedFd,
    getValidatedPath,
    getValidMode,
    handleErrorFromBinding,
    kMaxUserId,
    nullCheck,
    preprocessSymlinkDestination,
    realpathCacheKey,
    getStatsFromBinding,
    showStringCoercionDeprecation,
    stringToFlags,
    stringToSymlinkType,
    Stats,
    toUnixTimestamp,
    validateBufferArray,
    validateCpOptions,
    validateOffsetLengthRead,
    validateOffsetLengthWrite,
    validatePath,
    validatePosition,
    validateRmOptions,
    validateRmOptionsSync,
    validateRmdirOptions,
    validateStringAfterArrayBufferView,
    warnOnNonPortableTemplate
};
const DenoCommand1 = Deno[Deno.internal]?.nodeUnstable?.Command || Deno.Command;
function stdioStringToArray(stdio, channel) {
    const options = [];
    switch(stdio){
        case "ignore":
        case "overlapped":
        case "pipe":
            options.push(stdio, stdio, stdio);
            break;
        case "inherit":
            options.push(stdio, stdio, stdio);
            break;
        default:
            throw new ERR_INVALID_ARG_VALUE("stdio", stdio);
    }
    if (channel) options.push(channel);
    return options;
}
class ChildProcess extends EventEmitter {
    exitCode = null;
    killed = false;
    pid;
    signalCode = null;
    spawnargs;
    spawnfile;
    stdin = null;
    stdout = null;
    stderr = null;
    stdio = [
        null,
        null,
        null
    ];
    #process;
    #spawned = deferred();
    constructor(command, args, options){
        super();
        const { env ={} , stdio =[
            "pipe",
            "pipe",
            "pipe"
        ] , cwd , shell =false , signal , windowsVerbatimArguments =false  } = options || {};
        const [stdin = "pipe", stdout = "pipe", stderr = "pipe", _channel] = normalizeStdioOption(stdio);
        const [cmd, cmdArgs] = buildCommand(command, args || [], shell);
        this.spawnfile = cmd;
        this.spawnargs = [
            cmd,
            ...cmdArgs
        ];
        const stringEnv = mapValues(env, (value)=>value.toString());
        try {
            this.#process = new DenoCommand1(cmd, {
                args: cmdArgs,
                cwd,
                env: stringEnv,
                stdin: toDenoStdio(stdin),
                stdout: toDenoStdio(stdout),
                stderr: toDenoStdio(stderr),
                windowsRawArguments: windowsVerbatimArguments
            }).spawn();
            this.pid = this.#process.pid;
            if (stdin === "pipe") {
                assert(this.#process.stdin);
                this.stdin = mu.fromWeb(this.#process.stdin);
            }
            if (stdout === "pipe") {
                assert(this.#process.stdout);
                this.stdout = Au.fromWeb(this.#process.stdout);
            }
            if (stderr === "pipe") {
                assert(this.#process.stderr);
                this.stderr = Au.fromWeb(this.#process.stderr);
            }
            this.stdio[0] = this.stdin;
            this.stdio[1] = this.stdout;
            this.stdio[2] = this.stderr;
            nextTick1(()=>{
                this.emit("spawn");
                this.#spawned.resolve();
            });
            if (signal) {
                const onAbortListener = ()=>{
                    try {
                        if (this.kill("SIGKILL")) {
                            this.emit("error", new AbortError());
                        }
                    } catch (err) {
                        this.emit("error", err);
                    }
                };
                if (signal.aborted) {
                    nextTick1(onAbortListener);
                } else {
                    signal.addEventListener("abort", onAbortListener, {
                        once: true
                    });
                    this.addListener("exit", ()=>signal.removeEventListener("abort", onAbortListener));
                }
            }
            (async ()=>{
                const status = await this.#process.status;
                this.exitCode = status.code;
                this.#spawned.then(async ()=>{
                    const exitCode = this.signalCode == null ? this.exitCode : null;
                    const signalCode = this.signalCode == null ? null : this.signalCode;
                    this.emit("exit", exitCode, signalCode);
                    await this.#_waitForChildStreamsToClose();
                    this.#closePipes();
                    this.emit("close", exitCode, signalCode);
                });
            })();
        } catch (err) {
            this.#_handleError(err);
        }
    }
    kill(signal) {
        if (this.killed) {
            return this.killed;
        }
        const denoSignal = signal == null ? "SIGTERM" : toDenoSignal(signal);
        this.#closePipes();
        try {
            this.#process.kill(denoSignal);
        } catch (err) {
            const alreadyClosed = err instanceof TypeError || err instanceof Deno.errors.PermissionDenied;
            if (!alreadyClosed) {
                throw err;
            }
        }
        this.killed = true;
        this.signalCode = denoSignal;
        return this.killed;
    }
    ref() {
        this.#process.ref();
    }
    unref() {
        this.#process.unref();
    }
    disconnect() {
        warnNotImplemented("ChildProcess.prototype.disconnect");
    }
    async #_waitForChildStreamsToClose() {
        const promises = [];
        if (this.stdin && !this.stdin.destroyed) {
            assert(this.stdin);
            this.stdin.destroy();
            promises.push(waitForStreamToClose(this.stdin));
        }
        if (this.stdout && !this.stdout.destroyed) {
            promises.push(waitForReadableToClose(this.stdout));
        }
        if (this.stderr && !this.stderr.destroyed) {
            promises.push(waitForReadableToClose(this.stderr));
        }
        await Promise.all(promises);
    }
    #_handleError(err) {
        nextTick1(()=>{
            this.emit("error", err);
        });
    }
    #closePipes() {
        if (this.stdin) {
            assert(this.stdin);
            this.stdin.destroy();
        }
    }
}
const supportedNodeStdioTypes = [
    "pipe",
    "ignore",
    "inherit"
];
function toDenoStdio(pipe) {
    if (!supportedNodeStdioTypes.includes(pipe) || typeof pipe === "number" || pipe instanceof Lu) {
        notImplemented(`toDenoStdio pipe=${typeof pipe} (${pipe})`);
    }
    switch(pipe){
        case "pipe":
        case undefined:
        case null:
            return "piped";
        case "ignore":
            return "null";
        case "inherit":
            return "inherit";
        default:
            notImplemented(`toDenoStdio pipe=${typeof pipe} (${pipe})`);
    }
}
function toDenoSignal(signal) {
    if (typeof signal === "number") {
        for (const name of keys(os.signals)){
            if (os.signals[name] === signal) {
                return name;
            }
        }
        throw new ERR_UNKNOWN_SIGNAL(String(signal));
    }
    const denoSignal = signal;
    if (denoSignal in os.signals) {
        return denoSignal;
    }
    throw new ERR_UNKNOWN_SIGNAL(signal);
}
function keys(object) {
    return Object.keys(object);
}
function copyProcessEnvToEnv(env, name, optionEnv) {
    if (Deno.env.get(name) && (!optionEnv || !ObjectPrototypeHasOwnProperty(optionEnv, name))) {
        env[name] = Deno.env.get(name);
    }
}
function normalizeStdioOption(stdio = [
    "pipe",
    "pipe",
    "pipe"
]) {
    if (Array.isArray(stdio)) {
        return stdio;
    } else {
        switch(stdio){
            case "overlapped":
                if (isWindows) {
                    notImplemented("normalizeStdioOption overlapped (on windows)");
                }
                return [
                    "pipe",
                    "pipe",
                    "pipe"
                ];
            case "pipe":
                return [
                    "pipe",
                    "pipe",
                    "pipe"
                ];
            case "inherit":
                return [
                    "inherit",
                    "inherit",
                    "inherit"
                ];
            case "ignore":
                return [
                    "ignore",
                    "ignore",
                    "ignore"
                ];
            default:
                notImplemented(`normalizeStdioOption stdio=${typeof stdio} (${stdio})`);
        }
    }
}
function normalizeSpawnArguments(file, args, options) {
    validateString(file, "file");
    if (file.length === 0) {
        throw new ERR_INVALID_ARG_VALUE("file", file, "cannot be empty");
    }
    if (ArrayIsArray(args)) {
        args = ArrayPrototypeSlice(args);
    } else if (args == null) {
        args = [];
    } else if (typeof args !== "object") {
        throw new ERR_INVALID_ARG_TYPE("args", "object", args);
    } else {
        options = args;
        args = [];
    }
    if (options === undefined) {
        options = kEmptyObject;
    } else {
        validateObject(options, "options");
    }
    let cwd = options.cwd;
    if (cwd != null) {
        cwd = getValidatedPath(cwd, "options.cwd");
    }
    if (options.detached != null) {
        validateBoolean(options.detached, "options.detached");
    }
    if (options.uid != null && !isInt32(options.uid)) {
        throw new ERR_INVALID_ARG_TYPE("options.uid", "int32", options.uid);
    }
    if (options.gid != null && !isInt32(options.gid)) {
        throw new ERR_INVALID_ARG_TYPE("options.gid", "int32", options.gid);
    }
    if (options.shell != null && typeof options.shell !== "boolean" && typeof options.shell !== "string") {
        throw new ERR_INVALID_ARG_TYPE("options.shell", [
            "boolean",
            "string"
        ], options.shell);
    }
    if (options.argv0 != null) {
        validateString(options.argv0, "options.argv0");
    }
    if (options.windowsHide != null) {
        validateBoolean(options.windowsHide, "options.windowsHide");
    }
    let { windowsVerbatimArguments  } = options;
    if (windowsVerbatimArguments != null) {
        validateBoolean(windowsVerbatimArguments, "options.windowsVerbatimArguments");
    }
    if (options.shell) {
        const command = ArrayPrototypeJoin([
            file,
            ...args
        ], " ");
        if (process2.platform === "win32") {
            if (typeof options.shell === "string") {
                file = options.shell;
            } else {
                file = Deno.env.get("comspec") || "cmd.exe";
            }
            if (/^(?:.*\\)?cmd(?:\.exe)?$/i.exec(file) !== null) {
                args = [
                    "/d",
                    "/s",
                    "/c",
                    `"${command}"`
                ];
                windowsVerbatimArguments = true;
            } else {
                args = [
                    "-c",
                    command
                ];
            }
        } else {
            if (typeof options.shell === "string") {
                file = options.shell;
            } else {
                file = "/bin/sh";
            }
            args = [
                "-c",
                command
            ];
        }
    }
    if (typeof options.argv0 === "string") {
        ArrayPrototypeUnshift(args, options.argv0);
    } else {
        ArrayPrototypeUnshift(args, file);
    }
    const env = options.env || Deno.env.toObject();
    const envPairs = [];
    copyProcessEnvToEnv(env, "NODE_V8_COVERAGE", options.env);
    let envKeys = [];
    for(const key in env){
        ArrayPrototypePush(envKeys, key);
    }
    if (process2.platform === "win32") {
        const sawKey = new Set();
        envKeys = ArrayPrototypeFilter(ArrayPrototypeSort(envKeys), (key)=>{
            const uppercaseKey = StringPrototypeToUpperCase(key);
            if (sawKey.has(uppercaseKey)) {
                return false;
            }
            sawKey.add(uppercaseKey);
            return true;
        });
    }
    for (const key of envKeys){
        const value = env[key];
        if (value !== undefined) {
            ArrayPrototypePush(envPairs, `${key}=${value}`);
        }
    }
    return {
        ...options,
        args,
        cwd,
        detached: !!options.detached,
        envPairs,
        file,
        windowsHide: !!options.windowsHide,
        windowsVerbatimArguments: !!windowsVerbatimArguments
    };
}
function waitForReadableToClose(readable) {
    readable.resume();
    return waitForStreamToClose(readable);
}
function waitForStreamToClose(stream) {
    const promise = deferred();
    const cleanup = ()=>{
        stream.removeListener("close", onClose);
        stream.removeListener("error", onError);
    };
    const onClose = ()=>{
        cleanup();
        promise.resolve();
    };
    const onError = (err)=>{
        cleanup();
        promise.reject(err);
    };
    stream.once("close", onClose);
    stream.once("error", onError);
    return promise;
}
function buildCommand(file, args, shell) {
    if (file === Deno.execPath()) {
        args = toDenoArgs(args);
    }
    if (shell) {
        const command = [
            file,
            ...args
        ].join(" ");
        if (isWindows) {
            if (typeof shell === "string") {
                file = shell;
            } else {
                file = Deno.env.get("comspec") || "cmd.exe";
            }
            if (/^(?:.*\\)?cmd(?:\.exe)?$/i.test(file)) {
                args = [
                    "/d",
                    "/s",
                    "/c",
                    `"${command}"`
                ];
            } else {
                args = [
                    "-c",
                    command
                ];
            }
        } else {
            if (typeof shell === "string") {
                file = shell;
            } else {
                file = "/bin/sh";
            }
            args = [
                "-c",
                command
            ];
        }
    }
    return [
        file,
        args
    ];
}
function _createSpawnSyncError(status, command, args = []) {
    const error = errnoException(codeMap.get(status), "spawnSync " + command);
    error.path = command;
    error.spawnargs = args;
    return error;
}
function parseSpawnSyncOutputStreams(output, name) {
    try {
        return Buffer1.from(output[name]);
    } catch  {
        return null;
    }
}
function spawnSync(command, args, options) {
    const { env =Deno.env.toObject() , stdio =[
        "pipe",
        "pipe",
        "pipe"
    ] , shell =false , cwd , encoding , uid , gid , maxBuffer , windowsVerbatimArguments =false  } = options;
    const normalizedStdio = normalizeStdioOption(stdio);
    [command, args] = buildCommand(command, args ?? [], shell);
    const result = {};
    try {
        const output = new DenoCommand1(command, {
            args,
            cwd,
            env,
            stdout: toDenoStdio(normalizedStdio[1]),
            stderr: toDenoStdio(normalizedStdio[2]),
            uid,
            gid,
            windowsRawArguments: windowsVerbatimArguments
        }).outputSync();
        const status = output.signal ? null : 0;
        let stdout = parseSpawnSyncOutputStreams(output, "stdout");
        let stderr = parseSpawnSyncOutputStreams(output, "stderr");
        if (stdout && stdout.length > maxBuffer || stderr && stderr.length > maxBuffer) {
            result.error = _createSpawnSyncError("ENOBUFS", command, args);
        }
        if (encoding && encoding !== "buffer") {
            stdout = stdout && stdout.toString(encoding);
            stderr = stderr && stderr.toString(encoding);
        }
        result.status = status;
        result.signal = output.signal;
        result.stdout = stdout;
        result.stderr = stderr;
        result.output = [
            output.signal,
            stdout,
            stderr
        ];
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            result.error = _createSpawnSyncError("ENOENT", command, args);
        }
    }
    return result;
}
const kLongArg = {
    type: 1
};
const kShortArg = {
    type: 2
};
const kNodeFlagsMap = new Map([
    [
        "--build-snapshot",
        kLongArg
    ],
    [
        "-c",
        kShortArg
    ],
    [
        "--check",
        kLongArg
    ],
    [
        "-C",
        kShortArg
    ],
    [
        "--conditions",
        kLongArg
    ],
    [
        "--cpu-prof-dir",
        kLongArg
    ],
    [
        "--cpu-prof-interval",
        kLongArg
    ],
    [
        "--cpu-prof-name",
        kLongArg
    ],
    [
        "--diagnostic-dir",
        kLongArg
    ],
    [
        "--disable-proto",
        kLongArg
    ],
    [
        "--dns-result-order",
        kLongArg
    ],
    [
        "-e",
        kShortArg
    ],
    [
        "--eval",
        kLongArg
    ],
    [
        "--experimental-loader",
        kLongArg
    ],
    [
        "--experimental-policy",
        kLongArg
    ],
    [
        "--experimental-specifier-resolution",
        kLongArg
    ],
    [
        "--heapsnapshot-near-heap-limit",
        kLongArg
    ],
    [
        "--heapsnapshot-signal",
        kLongArg
    ],
    [
        "--heap-prof-dir",
        kLongArg
    ],
    [
        "--heap-prof-interval",
        kLongArg
    ],
    [
        "--heap-prof-name",
        kLongArg
    ],
    [
        "--icu-data-dir",
        kLongArg
    ],
    [
        "--input-type",
        kLongArg
    ],
    [
        "--inspect-publish-uid",
        kLongArg
    ],
    [
        "--max-http-header-size",
        kLongArg
    ],
    [
        "--openssl-config",
        kLongArg
    ],
    [
        "-p",
        kShortArg
    ],
    [
        "--print",
        kLongArg
    ],
    [
        "--policy-integrity",
        kLongArg
    ],
    [
        "--prof-process",
        kLongArg
    ],
    [
        "-r",
        kShortArg
    ],
    [
        "--require",
        kLongArg
    ],
    [
        "--redirect-warnings",
        kLongArg
    ],
    [
        "--report-dir",
        kLongArg
    ],
    [
        "--report-directory",
        kLongArg
    ],
    [
        "--report-filename",
        kLongArg
    ],
    [
        "--report-signal",
        kLongArg
    ],
    [
        "--secure-heap",
        kLongArg
    ],
    [
        "--secure-heap-min",
        kLongArg
    ],
    [
        "--snapshot-blob",
        kLongArg
    ],
    [
        "--title",
        kLongArg
    ],
    [
        "--tls-cipher-list",
        kLongArg
    ],
    [
        "--tls-keylog",
        kLongArg
    ],
    [
        "--unhandled-rejections",
        kLongArg
    ],
    [
        "--use-largepages",
        kLongArg
    ],
    [
        "--v8-pool-size",
        kLongArg
    ]
]);
const kDenoSubcommands = new Set([
    "bench",
    "bundle",
    "cache",
    "check",
    "compile",
    "completions",
    "coverage",
    "doc",
    "eval",
    "fmt",
    "help",
    "info",
    "init",
    "install",
    "lint",
    "lsp",
    "repl",
    "run",
    "tasks",
    "test",
    "types",
    "uninstall",
    "upgrade",
    "vendor"
]);
function toDenoArgs(args) {
    if (args.length === 0) {
        return args;
    }
    const denoArgs = [];
    let useRunArgs = true;
    for(let i = 0; i < args.length; i++){
        const arg = args[i];
        if (arg.charAt(0) !== "-" || arg === "--") {
            if (kDenoSubcommands.has(arg)) {
                return args;
            }
            for(let j = i; j < args.length; j++){
                denoArgs.push(args[j]);
            }
            break;
        }
        let flag = arg;
        let flagInfo = kNodeFlagsMap.get(arg);
        let isLongWithValue = false;
        let flagValue;
        if (flagInfo === undefined) {
            const splitAt = arg.indexOf("=");
            if (splitAt !== -1) {
                flag = arg.slice(0, splitAt);
                flagInfo = kNodeFlagsMap.get(flag);
                flagValue = arg.slice(splitAt + 1);
                isLongWithValue = true;
            }
        }
        if (flagInfo === undefined) {
            denoArgs.push(arg);
            continue;
        }
        if (flagValue === undefined) {
            i++;
            if (i >= args.length) {
                denoArgs.push(arg);
                continue;
            }
            flagValue = args[i];
        }
        if (flag === "-e" || flag === "--eval") {
            denoArgs.push("eval", flagValue);
            useRunArgs = false;
        } else if (isLongWithValue) {
            denoArgs.push(arg);
        } else {
            denoArgs.push(flag, flagValue);
        }
    }
    if (useRunArgs) {
        denoArgs.unshift("run", "-A", "--unstable");
    }
    return denoArgs;
}
const __default29 = {
    ChildProcess,
    stdioStringToArray,
    spawnSync
};
const MAX_BUFFER = 1024 * 1024;
function fork(modulePath, _args, _options) {
    validateString(modulePath, "modulePath");
    let execArgv;
    let options = {};
    let args = [];
    let pos = 1;
    if (pos < arguments.length && Array.isArray(arguments[pos])) {
        args = arguments[pos++];
    }
    if (pos < arguments.length && arguments[pos] == null) {
        pos++;
    }
    if (pos < arguments.length && arguments[pos] != null) {
        if (typeof arguments[pos] !== "object") {
            throw new ERR_INVALID_ARG_VALUE(`arguments[${pos}]`, arguments[pos]);
        }
        options = {
            ...arguments[pos++]
        };
    }
    execArgv = options.execArgv || process2.execArgv;
    if (execArgv === process2.execArgv && process2._eval != null) {
        const index = execArgv.lastIndexOf(process2._eval);
        if (index > 0) {
            execArgv = execArgv.slice(0);
            execArgv.splice(index - 1, 2);
        }
    }
    const v8Flags = [];
    if (Array.isArray(execArgv)) {
        for(let index = 0; index < execArgv.length; index++){
            const flag = execArgv[index];
            if (flag.startsWith("--max-old-space-size")) {
                execArgv.splice(index, 1);
                v8Flags.push(flag);
            }
        }
    }
    const stringifiedV8Flags = [];
    if (v8Flags.length > 0) {
        stringifiedV8Flags.push("--v8-flags=" + v8Flags.join(","));
    }
    args = [
        "run",
        "--unstable",
        "--node-modules-dir",
        "-A",
        ...stringifiedV8Flags,
        ...execArgv,
        modulePath,
        ...args
    ];
    if (typeof options.stdio === "string") {
        options.stdio = stdioStringToArray(options.stdio, "ipc");
    } else if (!Array.isArray(options.stdio)) {
        options.stdio = stdioStringToArray(options.silent ? "pipe" : "inherit", "ipc");
    } else if (!options.stdio.includes("ipc")) {
        throw new ERR_CHILD_PROCESS_IPC_REQUIRED("options.stdio");
    }
    options.execPath = options.execPath || Deno.execPath();
    options.shell = false;
    Object.assign(options.env ??= {}, {
        DENO_DONT_USE_INTERNAL_NODE_COMPAT_STATE: core.ops.op_npm_process_state()
    });
    return spawn(options.execPath, args, options);
}
function spawn(command, argsOrOptions, maybeOptions) {
    const args = Array.isArray(argsOrOptions) ? argsOrOptions : [];
    const options = !Array.isArray(argsOrOptions) && argsOrOptions != null ? argsOrOptions : maybeOptions;
    validateAbortSignal(options?.signal, "options.signal");
    return new ChildProcess(command, args, options);
}
function validateTimeout1(timeout) {
    if (timeout != null && !(Number.isInteger(timeout) && timeout >= 0)) {
        throw new ERR_OUT_OF_RANGE("timeout", "an unsigned integer", timeout);
    }
}
function validateMaxBuffer(maxBuffer) {
    if (maxBuffer != null && !(typeof maxBuffer === "number" && maxBuffer >= 0)) {
        throw new ERR_OUT_OF_RANGE("options.maxBuffer", "a positive number", maxBuffer);
    }
}
function sanitizeKillSignal(killSignal) {
    if (typeof killSignal === "string" || typeof killSignal === "number") {
        return convertToValidSignal(killSignal);
    } else if (killSignal != null) {
        throw new ERR_INVALID_ARG_TYPE("options.killSignal", [
            "string",
            "number"
        ], killSignal);
    }
}
function spawnSync1(command, argsOrOptions, maybeOptions) {
    const args = Array.isArray(argsOrOptions) ? argsOrOptions : [];
    let options = !Array.isArray(argsOrOptions) && argsOrOptions ? argsOrOptions : maybeOptions;
    options = {
        maxBuffer: MAX_BUFFER,
        ...normalizeSpawnArguments(command, args, options)
    };
    validateTimeout1(options.timeout);
    validateMaxBuffer(options.maxBuffer);
    sanitizeKillSignal(options.killSignal);
    return spawnSync(command, args, options);
}
function normalizeExecArgs(command, optionsOrCallback, maybeCallback) {
    let callback = maybeCallback;
    if (typeof optionsOrCallback === "function") {
        callback = optionsOrCallback;
        optionsOrCallback = undefined;
    }
    const options = {
        ...optionsOrCallback
    };
    options.shell = typeof options.shell === "string" ? options.shell : true;
    return {
        file: command,
        options: options,
        callback: callback
    };
}
function exec(command, optionsOrCallback, maybeCallback) {
    const opts = normalizeExecArgs(command, optionsOrCallback, maybeCallback);
    return execFile(opts.file, opts.options, opts.callback);
}
const customPromiseExecFunction = (orig)=>{
    return (...args)=>{
        const { promise , resolve , reject  } = createDeferredPromise();
        promise.child = orig(...args, (err, stdout, stderr)=>{
            if (err !== null) {
                const _err = err;
                _err.stdout = stdout;
                _err.stderr = stderr;
                reject && reject(_err);
            } else {
                resolve && resolve({
                    stdout,
                    stderr
                });
            }
        });
        return promise;
    };
};
Object.defineProperty(exec, promisify.custom, {
    enumerable: false,
    value: customPromiseExecFunction(exec)
});
class ExecFileError extends Error {
    code;
    constructor(message){
        super(message);
        this.code = "UNKNOWN";
    }
}
function execFile(file, argsOrOptionsOrCallback, optionsOrCallback, maybeCallback) {
    let args = [];
    let options = {};
    let callback;
    if (Array.isArray(argsOrOptionsOrCallback)) {
        args = argsOrOptionsOrCallback;
    } else if (argsOrOptionsOrCallback instanceof Function) {
        callback = argsOrOptionsOrCallback;
    } else if (argsOrOptionsOrCallback) {
        options = argsOrOptionsOrCallback;
    }
    if (optionsOrCallback instanceof Function) {
        callback = optionsOrCallback;
    } else if (optionsOrCallback) {
        options = optionsOrCallback;
        callback = maybeCallback;
    }
    const execOptions = {
        encoding: "utf8",
        timeout: 0,
        maxBuffer: MAX_BUFFER,
        killSignal: "SIGTERM",
        shell: false,
        ...options
    };
    if (!Number.isInteger(execOptions.timeout) || execOptions.timeout < 0) {
        throw new ERR_OUT_OF_RANGE("timeout", "an unsigned integer", execOptions.timeout);
    }
    if (execOptions.maxBuffer < 0) {
        throw new ERR_OUT_OF_RANGE("options.maxBuffer", "a positive number", execOptions.maxBuffer);
    }
    const spawnOptions = {
        cwd: execOptions.cwd,
        env: execOptions.env,
        gid: execOptions.gid,
        shell: execOptions.shell,
        signal: execOptions.signal,
        uid: execOptions.uid,
        windowsHide: !!execOptions.windowsHide,
        windowsVerbatimArguments: !!execOptions.windowsVerbatimArguments
    };
    const child = spawn(file, args, spawnOptions);
    let encoding;
    const _stdout = [];
    const _stderr = [];
    if (execOptions.encoding !== "buffer" && Buffer1.isEncoding(execOptions.encoding)) {
        encoding = execOptions.encoding;
    } else {
        encoding = null;
    }
    let stdoutLen = 0;
    let stderrLen = 0;
    let killed = false;
    let exited = false;
    let timeoutId;
    let ex = null;
    let cmd = file;
    function exithandler(code = 0, signal) {
        if (exited) return;
        exited = true;
        if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = null;
        }
        if (!callback) return;
        let stdout;
        let stderr;
        if (encoding || child.stdout && child.stdout.readableEncoding) {
            stdout = _stdout.join("");
        } else {
            stdout = Buffer1.concat(_stdout);
        }
        if (encoding || child.stderr && child.stderr.readableEncoding) {
            stderr = _stderr.join("");
        } else {
            stderr = Buffer1.concat(_stderr);
        }
        if (!ex && code === 0 && signal === null) {
            callback(null, stdout, stderr);
            return;
        }
        if (args?.length) {
            cmd += ` ${args.join(" ")}`;
        }
        if (!ex) {
            ex = new ExecFileError("Command failed: " + cmd + "\n" + stderr);
            ex.code = code < 0 ? getSystemErrorName(code) : code;
            ex.killed = child.killed || killed;
            ex.signal = signal;
        }
        ex.cmd = cmd;
        callback(ex, stdout, stderr);
    }
    function errorhandler(e) {
        ex = e;
        if (child.stdout) {
            child.stdout.destroy();
        }
        if (child.stderr) {
            child.stderr.destroy();
        }
        exithandler();
    }
    function kill() {
        if (child.stdout) {
            child.stdout.destroy();
        }
        if (child.stderr) {
            child.stderr.destroy();
        }
        killed = true;
        try {
            child.kill(execOptions.killSignal);
        } catch (e) {
            if (e) {
                ex = e;
            }
            exithandler();
        }
    }
    if (execOptions.timeout > 0) {
        timeoutId = setTimeout(function delayedKill() {
            kill();
            timeoutId = null;
        }, execOptions.timeout);
    }
    if (child.stdout) {
        if (encoding) {
            child.stdout.setEncoding(encoding);
        }
        child.stdout.on("data", function onChildStdout(chunk) {
            if (execOptions.maxBuffer === Infinity) {
                ArrayPrototypePush(_stdout, chunk);
                return;
            }
            const encoding = child.stdout?.readableEncoding;
            const length = encoding ? Buffer1.byteLength(chunk, encoding) : chunk.length;
            const slice = encoding ? StringPrototypeSlice : (buf, ...args)=>buf.slice(...args);
            stdoutLen += length;
            if (stdoutLen > execOptions.maxBuffer) {
                const truncatedLen = execOptions.maxBuffer - (stdoutLen - length);
                ArrayPrototypePush(_stdout, slice(chunk, 0, truncatedLen));
                ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER("stdout");
                kill();
            } else {
                ArrayPrototypePush(_stdout, chunk);
            }
        });
    }
    if (child.stderr) {
        if (encoding) {
            child.stderr.setEncoding(encoding);
        }
        child.stderr.on("data", function onChildStderr(chunk) {
            if (execOptions.maxBuffer === Infinity) {
                ArrayPrototypePush(_stderr, chunk);
                return;
            }
            const encoding = child.stderr?.readableEncoding;
            const length = encoding ? Buffer1.byteLength(chunk, encoding) : chunk.length;
            const slice = encoding ? StringPrototypeSlice : (buf, ...args)=>buf.slice(...args);
            stderrLen += length;
            if (stderrLen > execOptions.maxBuffer) {
                const truncatedLen = execOptions.maxBuffer - (stderrLen - length);
                ArrayPrototypePush(_stderr, slice(chunk, 0, truncatedLen));
                ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER("stderr");
                kill();
            } else {
                ArrayPrototypePush(_stderr, chunk);
            }
        });
    }
    child.addListener("close", exithandler);
    child.addListener("error", errorhandler);
    return child;
}
function checkExecSyncError(ret, args, cmd) {
    let err;
    if (ret.error) {
        err = ret.error;
        ObjectAssign1(err, ret);
    } else if (ret.status !== 0) {
        let msg = "Command failed: ";
        msg += cmd || ArrayPrototypeJoin(args, " ");
        if (ret.stderr && ret.stderr.length > 0) {
            msg += `\n${ret.stderr.toString()}`;
        }
        err = genericNodeError(msg, ret);
    }
    return err;
}
function execSync(command, options) {
    const opts = normalizeExecArgs(command, options);
    const inheritStderr = !opts.options.stdio;
    const ret = spawnSync1(opts.file, opts.options);
    if (inheritStderr && ret.stderr) {
        process2.stderr.write(ret.stderr);
    }
    const err = checkExecSyncError(ret, [], command);
    if (err) {
        throw err;
    }
    return ret.stdout;
}
function normalizeExecFileArgs(file, args, options, callback) {
    if (ArrayIsArray(args)) {
        args = ArrayPrototypeSlice(args);
    } else if (args != null && typeof args === "object") {
        callback = options;
        options = args;
        args = null;
    } else if (typeof args === "function") {
        callback = args;
        options = null;
        args = null;
    }
    if (args == null) {
        args = [];
    }
    if (typeof options === "function") {
        callback = options;
    } else if (options != null) {
        validateObject(options, "options");
    }
    if (options == null) {
        options = kEmptyObject;
    }
    args = args;
    options = options;
    if (callback != null) {
        validateFunction(callback, "callback");
    }
    if (options.argv0 != null) {
        validateString(options.argv0, "options.argv0");
    }
    return {
        file,
        args,
        options,
        callback
    };
}
function execFileSync(file, args, options) {
    ({ file , args , options  } = normalizeExecFileArgs(file, args, options));
    const inheritStderr = !options.stdio;
    const ret = spawnSync1(file, args, options);
    if (inheritStderr && ret.stderr) {
        process2.stderr.write(ret.stderr);
    }
    const errArgs = [
        options.argv0 || file,
        ...args
    ];
    const err = checkExecSyncError(ret, errArgs);
    if (err) {
        throw err;
    }
    return ret.stdout;
}
const __default30 = {
    fork,
    spawn,
    exec,
    execFile,
    execFileSync,
    execSync,
    ChildProcess,
    spawnSync: spawnSync1
};
class Worker1 {
    constructor(){
        notImplemented("cluster.Worker.prototype.constructor");
    }
}
function disconnected() {
    notImplemented("cluster.disconnected");
}
function fork1() {
    notImplemented("cluster.fork");
}
const isPrimary = undefined;
const isWorker = undefined;
const isMaster = isPrimary;
const schedulingPolicy = undefined;
const settings = undefined;
function setupMaster() {
    notImplemented("cluster.setupMaster");
}
function setupPrimary() {
    notImplemented("cluster.setupPrimary");
}
const worker = undefined;
const workers = undefined;
const __default31 = {
    Worker: Worker1,
    disconnected,
    fork: fork1,
    isPrimary,
    isWorker,
    isMaster,
    schedulingPolicy,
    settings,
    setupMaster,
    setupPrimary,
    worker,
    workers
};
Deno.build.os === "windows";
const tableChars = {
    middleMiddle: "",
    rowMiddle: "",
    topRight: "",
    topLeft: "",
    leftMiddle: "",
    topMiddle: "",
    bottomRight: "",
    bottomLeft: "",
    bottomMiddle: "",
    rightMiddle: "",
    left: " ",
    right: " ",
    middle: "  "
};
const renderRow = (row, columnWidths)=>{
    let out = tableChars.left;
    for(let i = 0; i < row.length; i++){
        const cell = row[i];
        const len = getStringWidth(cell);
        const needed = (columnWidths[i] - len) / 2;
        out += " ".repeat(needed) + cell + " ".repeat(Math.ceil(needed));
        if (i !== row.length - 1) {
            out += tableChars.middle;
        }
    }
    out += tableChars.right;
    return out;
};
const table = (head, columns)=>{
    const rows = [];
    const columnWidths = head.map((h)=>getStringWidth(h));
    const longestColumn = Math.max(...columns.map((a)=>a.length));
    for(let i = 0; i < head.length; i++){
        const column = columns[i];
        for(let j = 0; j < longestColumn; j++){
            if (rows[j] === undefined) {
                rows[j] = [];
            }
            const value = rows[j][i] = Object.hasOwn(column, j) ? column[j] : "";
            const width = columnWidths[i] || 0;
            const counted = getStringWidth(value);
            columnWidths[i] = Math.max(width, counted);
        }
    }
    const divider = columnWidths.map((i)=>tableChars.middleMiddle.repeat(i + 2));
    let result = tableChars.topLeft + divider.join(tableChars.topMiddle) + tableChars.topRight + "\n" + renderRow(head, columnWidths) + "\n" + tableChars.leftMiddle + divider.join(tableChars.rowMiddle) + tableChars.rightMiddle + "\n";
    for (const row of rows){
        result += `${renderRow(row, columnWidths)}\n`;
    }
    result += tableChars.bottomLeft + divider.join(tableChars.bottomMiddle) + tableChars.bottomRight;
    return result;
};
const trace1 = ()=>{};
const previewEntries = (iter, isKeyValue)=>{
    if (isKeyValue) {
        const arr = [
            ...iter
        ];
        if (Array.isArray(arr[0]) && arr[0].length === 2) {
            return [
                [].concat(...arr),
                true
            ];
        }
        return [
            arr,
            false
        ];
    } else {
        return [
            ...iter
        ];
    }
};
const { isBuffer: isBuffer1  } = Buffer1;
const kCounts = Symbol("counts");
const kTraceConsoleCategory = "node,node.console";
const kSecond = 1000;
const kMinute = 60 * 1000;
const kHour = 60 * kMinute;
const kGroupIndent = Symbol("kGroupIndent");
const kGroupIndentationWidth = Symbol("kGroupIndentWidth");
const kFormatForStderr = Symbol("kFormatForStderr");
const kFormatForStdout = Symbol("kFormatForStdout");
const kGetInspectOptions = Symbol("kGetInspectOptions");
const kColorMode = Symbol("kColorMode");
const kIsConsole = Symbol("kIsConsole");
const kWriteToConsole = Symbol("kWriteToConsole");
const kBindProperties = Symbol("kBindProperties");
const kBindStreamsEager = Symbol("kBindStreamsEager");
const kBindStreamsLazy = Symbol("kBindStreamsLazy");
const kUseStdout = Symbol("kUseStdout");
const kUseStderr = Symbol("kUseStderr");
const optionsMap1 = new WeakMap();
function Console(options) {
    if (!new.target) {
        return Reflect.construct(Console, arguments);
    }
    if (!options || typeof options.write === "function") {
        options = {
            stdout: options,
            stderr: arguments[1],
            ignoreErrors: arguments[2]
        };
    }
    const { stdout , stderr =stdout , ignoreErrors =true , colorMode ="auto" , inspectOptions , groupIndentation  } = options;
    if (!stdout || typeof stdout.write !== "function") {
        throw new ERR_CONSOLE_WRITABLE_STREAM("stdout");
    }
    if (!stderr || typeof stderr.write !== "function") {
        throw new ERR_CONSOLE_WRITABLE_STREAM("stderr");
    }
    if (typeof colorMode !== "boolean" && colorMode !== "auto") {
        throw new ERR_INVALID_ARG_VALUE("colorMode", colorMode);
    }
    if (groupIndentation !== undefined) {
        validateInteger(groupIndentation, "groupIndentation", 0, 1000);
    }
    if (inspectOptions !== undefined) {
        validateObject(inspectOptions, "options.inspectOptions");
        if (inspectOptions.colors !== undefined && options.colorMode !== undefined) {
            throw new ERR_INCOMPATIBLE_OPTION_PAIR("options.inspectOptions.color", "colorMode");
        }
        optionsMap1.set(this, inspectOptions);
    }
    Object.keys(Console.prototype).forEach((key)=>{
        this[key] = this[key].bind(this);
        Object.defineProperty(this[key], "name", {
            value: key
        });
    });
    this[kBindStreamsEager](stdout, stderr);
    this[kBindProperties](ignoreErrors, colorMode, groupIndentation);
}
const consolePropAttributes = {
    writable: true,
    enumerable: false,
    configurable: true
};
Object.defineProperty(Console, Symbol.hasInstance, {
    value (instance) {
        return instance === console || instance[kIsConsole];
    }
});
const kColorInspectOptions = {
    colors: true
};
const kNoColorInspectOptions = {};
Object.defineProperties(Console.prototype, {
    [kBindStreamsEager]: {
        ...consolePropAttributes,
        value: function(stdout, stderr) {
            Object.defineProperties(this, {
                "_stdout": {
                    ...consolePropAttributes,
                    value: stdout
                },
                "_stderr": {
                    ...consolePropAttributes,
                    value: stderr
                }
            });
        }
    },
    [kBindStreamsLazy]: {
        ...consolePropAttributes,
        value: function(object) {
            let stdout;
            let stderr;
            Object.defineProperties(this, {
                "_stdout": {
                    enumerable: false,
                    configurable: true,
                    get () {
                        if (!stdout) stdout = object.stdout;
                        return stdout;
                    },
                    set (value) {
                        stdout = value;
                    }
                },
                "_stderr": {
                    enumerable: false,
                    configurable: true,
                    get () {
                        if (!stderr) stderr = object.stderr;
                        return stderr;
                    },
                    set (value) {
                        stderr = value;
                    }
                }
            });
        }
    },
    [kBindProperties]: {
        ...consolePropAttributes,
        value: function(ignoreErrors, colorMode, groupIndentation = 2) {
            Object.defineProperties(this, {
                "_stdoutErrorHandler": {
                    ...consolePropAttributes,
                    value: createWriteErrorHandler(this, kUseStdout)
                },
                "_stderrErrorHandler": {
                    ...consolePropAttributes,
                    value: createWriteErrorHandler(this, kUseStderr)
                },
                "_ignoreErrors": {
                    ...consolePropAttributes,
                    value: Boolean(ignoreErrors)
                },
                "_times": {
                    ...consolePropAttributes,
                    value: new Map()
                },
                [kCounts]: {
                    ...consolePropAttributes,
                    value: new Map()
                },
                [kColorMode]: {
                    ...consolePropAttributes,
                    value: colorMode
                },
                [kIsConsole]: {
                    ...consolePropAttributes,
                    value: true
                },
                [kGroupIndent]: {
                    ...consolePropAttributes,
                    value: ""
                },
                [kGroupIndentationWidth]: {
                    ...consolePropAttributes,
                    value: groupIndentation
                },
                [Symbol.toStringTag]: {
                    writable: false,
                    enumerable: false,
                    configurable: true,
                    value: "console"
                }
            });
        }
    },
    [kWriteToConsole]: {
        ...consolePropAttributes,
        value: function(streamSymbol, string) {
            const ignoreErrors = this._ignoreErrors;
            const groupIndent = this[kGroupIndent];
            const useStdout = streamSymbol === kUseStdout;
            const stream = useStdout ? this._stdout : this._stderr;
            const errorHandler = useStdout ? this._stdoutErrorHandler : this._stderrErrorHandler;
            if (groupIndent.length !== 0) {
                if (string.includes("\n")) {
                    string = string.replace(/\n/g, `\n${groupIndent}`);
                }
                string = groupIndent + string;
            }
            string += "\n";
            if (ignoreErrors === false) return stream.write(string);
            try {
                if (stream.listenerCount("error") === 0) {
                    stream.once("error", noop1);
                }
                stream.write(string, errorHandler);
            } catch (e) {
                if (isStackOverflowError(e)) {
                    throw e;
                }
            } finally{
                stream.removeListener("error", noop1);
            }
        }
    },
    [kGetInspectOptions]: {
        ...consolePropAttributes,
        value: function(stream) {
            let color = this[kColorMode];
            if (color === "auto") {
                color = stream.isTTY && (typeof stream.getColorDepth === "function" ? stream.getColorDepth() > 2 : true);
            }
            const options = optionsMap1.get(this);
            if (options) {
                if (options.colors === undefined) {
                    options.colors = color;
                }
                return options;
            }
            return color ? kColorInspectOptions : kNoColorInspectOptions;
        }
    },
    [kFormatForStdout]: {
        ...consolePropAttributes,
        value: function(args) {
            const opts = this[kGetInspectOptions](this._stdout);
            args.unshift(opts);
            return Reflect.apply(formatWithOptions, null, args);
        }
    },
    [kFormatForStderr]: {
        ...consolePropAttributes,
        value: function(args) {
            const opts = this[kGetInspectOptions](this._stderr);
            args.unshift(opts);
            return Reflect.apply(formatWithOptions, null, args);
        }
    }
});
function createWriteErrorHandler(instance, streamSymbol) {
    return (err)=>{
        const stream = streamSymbol === kUseStdout ? instance._stdout : instance._stderr;
        if (err !== null && !stream._writableState.errorEmitted) {
            if (stream.listenerCount("error") === 0) {
                stream.once("error", noop1);
            }
        }
    };
}
const consoleMethods = {
    log (...args) {
        this[kWriteToConsole](kUseStdout, this[kFormatForStdout](args));
    },
    warn (...args) {
        this[kWriteToConsole](kUseStderr, this[kFormatForStderr](args));
    },
    dir (object, options) {
        this[kWriteToConsole](kUseStdout, inspect(object, {
            customInspect: false,
            ...this[kGetInspectOptions](this._stdout),
            ...options
        }));
    },
    time (label = "default") {
        label = `${label}`;
        if (this._times.has(label)) {
            emitWarning(`Label '${label}' already exists for console.time()`);
            return;
        }
        trace1(98, kTraceConsoleCategory, `time::${label}`, 0);
        this._times.set(label, process.hrtime());
    },
    timeEnd (label = "default") {
        label = `${label}`;
        const found = timeLogImpl(this, "timeEnd", label);
        trace1(101, kTraceConsoleCategory, `time::${label}`, 0);
        if (found) {
            this._times.delete(label);
        }
    },
    timeLog (label = "default", ...data) {
        label = `${label}`;
        timeLogImpl(this, "timeLog", label, data);
        trace1(110, kTraceConsoleCategory, `time::${label}`, 0);
    },
    trace: function trace(...args) {
        const err = {
            name: "Trace",
            message: this[kFormatForStderr](args)
        };
        Error.captureStackTrace(err, trace);
        this.error(err.stack);
    },
    assert (expression, ...args) {
        if (!expression) {
            args[0] = `Assertion failed${args.length === 0 ? "" : `: ${args[0]}`}`;
            Reflect.apply(this.warn, this, args);
        }
    },
    clear () {
        if (this._stdout.isTTY && process.env.TERM !== "dumb") {
            cursorTo(this._stdout, 0, 0);
            clearScreenDown(this._stdout);
        }
    },
    count (label = "default") {
        label = `${label}`;
        const counts = this[kCounts];
        let count = counts.get(label);
        if (count === undefined) {
            count = 1;
        } else {
            count++;
        }
        counts.set(label, count);
        trace1(67, kTraceConsoleCategory, `count::${label}`, 0, count);
        this.log(`${label}: ${count}`);
    },
    countReset (label = "default") {
        const counts = this[kCounts];
        if (!counts.has(label)) {
            emitWarning(`Count for '${label}' does not exist`);
            return;
        }
        trace1(67, kTraceConsoleCategory, `count::${label}`, 0, 0);
        counts.delete(`${label}`);
    },
    group (...data) {
        if (data.length > 0) {
            Reflect.apply(this.log, this, data);
        }
        this[kGroupIndent] += " ".repeat(this[kGroupIndentationWidth]);
    },
    groupEnd () {
        this[kGroupIndent] = this[kGroupIndent].slice(0, this[kGroupIndent].length - this[kGroupIndentationWidth]);
    },
    table (tabularData, properties) {
        console.log("tabularData", tabularData);
        if (properties !== undefined) {
            validateArray(properties, "properties");
        }
        if (tabularData === null || typeof tabularData !== "object") {
            return this.log(tabularData);
        }
        const __final = (k, v)=>this.log(table(k, v));
        const _inspect = (v)=>{
            const depth = v !== null && typeof v === "object" && !isArray1(v) && Object.keys(v).length > 2 ? -1 : 0;
            const opt = {
                depth,
                maxArrayLength: 3,
                breakLength: Infinity,
                ...this[kGetInspectOptions](this._stdout)
            };
            return inspect(v, opt);
        };
        const getIndexArray = (length)=>Array.from({
                length
            }, (_, i)=>_inspect(i));
        const mapIter = isMapIterator1(tabularData);
        let isKeyValue = false;
        let i = 0;
        if (mapIter) {
            const res = previewEntries(tabularData, true);
            tabularData = res[0];
            isKeyValue = res[1];
        }
        if (isKeyValue || isMap1(tabularData)) {
            const keys = [];
            const values = [];
            let length = 0;
            if (mapIter) {
                for(; i < tabularData.length / 2; ++i){
                    keys.push(_inspect(tabularData[i * 2]));
                    values.push(_inspect(tabularData[i * 2 + 1]));
                    length++;
                }
            } else {
                for (const { 0: k , 1: v  } of tabularData){
                    keys.push(_inspect(k));
                    values.push(_inspect(v));
                    length++;
                }
            }
            return __final([
                iterKey,
                keyKey,
                valuesKey
            ], [
                getIndexArray(length),
                keys,
                values
            ]);
        }
        const setIter = isSetIterator1(tabularData);
        if (setIter) {
            tabularData = previewEntries(tabularData);
        }
        const setlike = setIter || mapIter || isSet1(tabularData);
        if (setlike) {
            const values = [];
            let length = 0;
            console.log("tabularData", tabularData);
            for (const v of tabularData){
                values.push(_inspect(v));
                length++;
            }
            return __final([
                iterKey,
                valuesKey
            ], [
                getIndexArray(length),
                values
            ]);
        }
        const map = Object.create(null);
        let hasPrimitives = false;
        const valuesKeyArray = [];
        const indexKeyArray = Object.keys(tabularData);
        for(; i < indexKeyArray.length; i++){
            const item = tabularData[indexKeyArray[i]];
            const primitive = item === null || typeof item !== "function" && typeof item !== "object";
            if (properties === undefined && primitive) {
                hasPrimitives = true;
                valuesKeyArray[i] = _inspect(item);
            } else {
                const keys = properties || Object.keys(item);
                for (const key of keys){
                    if (map[key] === undefined) {
                        map[key] = [];
                    }
                    if (primitive && properties || !Object.hasOwn(item, key)) {
                        map[key][i] = "";
                    } else {
                        map[key][i] = _inspect(item[key]);
                    }
                }
            }
        }
        const keys = Object.keys(map);
        const values = Object.values(map);
        if (hasPrimitives) {
            keys.push(valuesKey);
            values.push(valuesKeyArray);
        }
        keys.unshift(indexKey);
        values.unshift(indexKeyArray);
        return __final(keys, values);
    }
};
function timeLogImpl(self, name, label, data) {
    const time = self._times.get(label);
    if (time === undefined) {
        emitWarning(`No such label '${label}' for console.${name}()`);
        return false;
    }
    const duration = process.hrtime(time);
    const ms = duration[0] * 1000 + duration[1] / 1e6;
    const formatted = formatTime(ms);
    if (data === undefined) {
        self.log("%s: %s", label, formatted);
    } else {
        self.log("%s: %s", label, formatted, ...data);
    }
    return true;
}
function pad1(value) {
    return `${value}`.padStart(2, "0");
}
function formatTime(ms) {
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    if (ms >= 1000) {
        if (ms >= kMinute) {
            if (ms >= kHour) {
                hours = Math.floor(ms / kHour);
                ms = ms % kHour;
            }
            minutes = Math.floor(ms / kMinute);
            ms = ms % kMinute;
        }
        seconds = ms / kSecond;
    }
    if (hours !== 0 || minutes !== 0) {
        ({ 0: seconds , 1: ms  } = seconds.toFixed(3).split("."));
        const res = hours !== 0 ? `${hours}:${pad1(minutes)}` : minutes;
        return `${res}:${pad1(seconds)}.${ms} (${hours !== 0 ? "h:m" : ""}m:ss.mmm)`;
    }
    if (seconds !== 0) {
        return `${seconds.toFixed(3)}s`;
    }
    return `${Number(ms.toFixed(3))}ms`;
}
const keyKey = "Key";
const valuesKey = "Values";
const indexKey = "(index)";
const iterKey = "(iteration index)";
const isArray1 = (v)=>Array.isArray(v) || isTypedArray(v) || isBuffer1(v);
function noop1() {}
for (const method of Reflect.ownKeys(consoleMethods)){
    Console.prototype[method] = consoleMethods[method];
}
Console.prototype.debug = Console.prototype.log;
Console.prototype.info = Console.prototype.log;
Console.prototype.dirxml = Console.prototype.log;
Console.prototype.error = Console.prototype.warn;
Console.prototype.groupCollapsed = Console.prototype.group;
const { assert: assert5 , clear , count , countReset , debug: debug3 , dir , dirxml , error: error1 , group , groupCollapsed , groupEnd , info , log: log1 , profile , profileEnd , table: table1 , time , timeEnd , timeLog , timeStamp , trace: trace2 , warn  } = console;
console?.indentLevel;
const __default32 = Object.assign({}, console, {
    Console
});
const { F_OK: F_OK1 , R_OK: R_OK1 , W_OK: W_OK1 , X_OK: X_OK1 , S_IRUSR , S_IWUSR , S_IXUSR , S_IRGRP , S_IWGRP , S_IXGRP , S_IROTH , S_IWOTH , S_IXOTH , COPYFILE_EXCL: COPYFILE_EXCL1 , COPYFILE_FICLONE: COPYFILE_FICLONE1 , COPYFILE_FICLONE_FORCE: COPYFILE_FICLONE_FORCE1 , UV_FS_COPYFILE_EXCL , UV_FS_COPYFILE_FICLONE , UV_FS_COPYFILE_FICLONE_FORCE , O_RDONLY: O_RDONLY1 , O_WRONLY: O_WRONLY1 , O_RDWR: O_RDWR1 , O_NOCTTY , O_TRUNC: O_TRUNC1 , O_APPEND: O_APPEND1 , O_DIRECTORY , O_NOFOLLOW , O_SYNC: O_SYNC1 , O_DSYNC , O_SYMLINK , O_NONBLOCK , O_CREAT: O_CREAT1 , O_EXCL: O_EXCL1  } = fs;
const mod53 = {
    F_OK: F_OK1,
    R_OK: R_OK1,
    W_OK: W_OK1,
    X_OK: X_OK1,
    S_IRUSR: S_IRUSR,
    S_IWUSR: S_IWUSR,
    S_IXUSR: S_IXUSR,
    S_IRGRP: S_IRGRP,
    S_IWGRP: S_IWGRP,
    S_IXGRP: S_IXGRP,
    S_IROTH: S_IROTH,
    S_IWOTH: S_IWOTH,
    S_IXOTH: S_IXOTH,
    COPYFILE_EXCL: COPYFILE_EXCL1,
    COPYFILE_FICLONE: COPYFILE_FICLONE1,
    COPYFILE_FICLONE_FORCE: COPYFILE_FICLONE_FORCE1,
    UV_FS_COPYFILE_EXCL: UV_FS_COPYFILE_EXCL,
    UV_FS_COPYFILE_FICLONE: UV_FS_COPYFILE_FICLONE,
    UV_FS_COPYFILE_FICLONE_FORCE: UV_FS_COPYFILE_FICLONE_FORCE,
    O_RDONLY: O_RDONLY1,
    O_WRONLY: O_WRONLY1,
    O_RDWR: O_RDWR1,
    O_NOCTTY: O_NOCTTY,
    O_TRUNC: O_TRUNC1,
    O_APPEND: O_APPEND1,
    O_DIRECTORY: O_DIRECTORY,
    O_NOFOLLOW: O_NOFOLLOW,
    O_SYNC: O_SYNC1,
    O_DSYNC: O_DSYNC,
    O_SYMLINK: O_SYMLINK,
    O_NONBLOCK: O_NONBLOCK,
    O_CREAT: O_CREAT1,
    O_EXCL: O_EXCL1
};
function isFileOptions(fileOptions) {
    if (!fileOptions) return false;
    return fileOptions.encoding != undefined || fileOptions.flag != undefined || fileOptions.signal != undefined || fileOptions.mode != undefined;
}
function getEncoding(optOrCallback) {
    if (!optOrCallback || typeof optOrCallback === "function") {
        return null;
    }
    const encoding = typeof optOrCallback === "string" ? optOrCallback : optOrCallback.encoding;
    if (!encoding) return null;
    return encoding;
}
function checkEncoding(encoding) {
    if (!encoding) return null;
    encoding = encoding.toLowerCase();
    if ([
        "utf8",
        "hex",
        "base64"
    ].includes(encoding)) return encoding;
    if (encoding === "utf-8") {
        return "utf8";
    }
    if (encoding === "binary") {
        return "binary";
    }
    const notImplementedEncodings = [
        "utf16le",
        "latin1",
        "ascii",
        "ucs2"
    ];
    if (notImplementedEncodings.includes(encoding)) {
        notImplemented(`"${encoding}" encoding`);
    }
    throw new Error(`The value "${encoding}" is invalid for option "encoding"`);
}
function getOpenOptions(flag) {
    if (!flag) {
        return {
            create: true,
            append: true
        };
    }
    let openOptions = {};
    if (typeof flag === "string") {
        switch(flag){
            case "a":
                {
                    openOptions = {
                        create: true,
                        append: true
                    };
                    break;
                }
            case "ax":
            case "xa":
                {
                    openOptions = {
                        createNew: true,
                        write: true,
                        append: true
                    };
                    break;
                }
            case "a+":
                {
                    openOptions = {
                        read: true,
                        create: true,
                        append: true
                    };
                    break;
                }
            case "ax+":
            case "xa+":
                {
                    openOptions = {
                        read: true,
                        createNew: true,
                        append: true
                    };
                    break;
                }
            case "r":
                {
                    openOptions = {
                        read: true
                    };
                    break;
                }
            case "r+":
                {
                    openOptions = {
                        read: true,
                        write: true
                    };
                    break;
                }
            case "w":
                {
                    openOptions = {
                        create: true,
                        write: true,
                        truncate: true
                    };
                    break;
                }
            case "wx":
            case "xw":
                {
                    openOptions = {
                        createNew: true,
                        write: true
                    };
                    break;
                }
            case "w+":
                {
                    openOptions = {
                        create: true,
                        write: true,
                        truncate: true,
                        read: true
                    };
                    break;
                }
            case "wx+":
            case "xw+":
                {
                    openOptions = {
                        createNew: true,
                        write: true,
                        read: true
                    };
                    break;
                }
            case "as":
            case "sa":
                {
                    openOptions = {
                        create: true,
                        append: true
                    };
                    break;
                }
            case "as+":
            case "sa+":
                {
                    openOptions = {
                        create: true,
                        read: true,
                        append: true
                    };
                    break;
                }
            case "rs+":
            case "sr+":
                {
                    openOptions = {
                        create: true,
                        read: true,
                        write: true
                    };
                    break;
                }
            default:
                {
                    throw new Error(`Unrecognized file system flag: ${flag}`);
                }
        }
    } else if (typeof flag === "number") {
        if ((flag & O_APPEND1) === O_APPEND1) {
            openOptions.append = true;
        }
        if ((flag & O_CREAT1) === O_CREAT1) {
            openOptions.create = true;
            openOptions.write = true;
        }
        if ((flag & O_EXCL1) === O_EXCL1) {
            openOptions.createNew = true;
            openOptions.read = true;
            openOptions.write = true;
        }
        if ((flag & O_TRUNC1) === O_TRUNC1) {
            openOptions.truncate = true;
        }
        if ((flag & O_RDONLY1) === O_RDONLY1) {
            openOptions.read = true;
        }
        if ((flag & O_WRONLY1) === O_WRONLY1) {
            openOptions.write = true;
        }
        if ((flag & O_RDWR1) === O_RDWR1) {
            openOptions.read = true;
            openOptions.write = true;
        }
    }
    return openOptions;
}
function maybeCallback(cb) {
    validateFunction(cb, "cb");
    return cb;
}
function makeCallback(cb) {
    validateFunction(cb, "cb");
    return (...args)=>Reflect.apply(cb, this, args);
}
function access(path, mode, callback) {
    if (typeof mode === "function") {
        callback = mode;
        mode = fs.F_OK;
    }
    path = getValidatedPath(path).toString();
    mode = getValidMode(mode, "access");
    const cb = makeCallback(callback);
    Deno.lstat(path).then((info)=>{
        if (info.mode === null) {
            cb(null);
            return;
        }
        const m = +mode || 0;
        let fileMode = +info.mode || 0;
        if (Deno.build.os !== "windows" && info.uid === Deno.uid()) {
            fileMode >>= 6;
        }
        if ((m & fileMode) === m) {
            cb(null);
        } else {
            const e = new Error(`EACCES: permission denied, access '${path}'`);
            e.path = path;
            e.syscall = "access";
            e.errno = codeMap.get("EACCES");
            e.code = "EACCES";
            cb(e);
        }
    }, (err)=>{
        if (err instanceof Deno.errors.NotFound) {
            const e = new Error(`ENOENT: no such file or directory, access '${path}'`);
            e.path = path;
            e.syscall = "access";
            e.errno = codeMap.get("ENOENT");
            e.code = "ENOENT";
            cb(e);
        } else {
            cb(err);
        }
    });
}
const accessPromise = promisify(access);
function accessSync(path, mode) {
    path = getValidatedPath(path).toString();
    mode = getValidMode(mode, "access");
    try {
        const info = Deno.lstatSync(path.toString());
        if (info.mode === null) {
            return;
        }
        const m = +mode || 0;
        let fileMode = +info.mode || 0;
        if (Deno.build.os !== "windows" && info.uid === Deno.uid()) {
            fileMode >>= 6;
        }
        if ((m & fileMode) === m) {} else {
            const e = new Error(`EACCES: permission denied, access '${path}'`);
            e.path = path;
            e.syscall = "access";
            e.errno = codeMap.get("EACCES");
            e.code = "EACCES";
            throw e;
        }
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            const e = new Error(`ENOENT: no such file or directory, access '${path}'`);
            e.path = path;
            e.syscall = "access";
            e.errno = codeMap.get("ENOENT");
            e.code = "ENOENT";
            throw e;
        } else {
            throw err;
        }
    }
}
function writeFile(pathOrRid, data, optOrCallback, callback) {
    const callbackFn = optOrCallback instanceof Function ? optOrCallback : callback;
    const options = optOrCallback instanceof Function ? undefined : optOrCallback;
    if (!callbackFn) {
        throw new TypeError("Callback must be a function.");
    }
    pathOrRid = pathOrRid instanceof URL ? fromFileUrl5(pathOrRid) : pathOrRid;
    const flag = isFileOptions(options) ? options.flag : undefined;
    const mode = isFileOptions(options) ? options.mode : undefined;
    const encoding = checkEncoding(getEncoding(options)) || "utf8";
    const openOptions = getOpenOptions(flag || "w");
    if (!ArrayBuffer.isView(data)) {
        validateStringAfterArrayBufferView(data, "data");
        if (typeof data !== "string") {
            showStringCoercionDeprecation();
        }
        data = Buffer1.from(String(data), encoding);
    }
    const isRid = typeof pathOrRid === "number";
    let file;
    let error = null;
    (async ()=>{
        try {
            file = isRid ? new Deno.FsFile(pathOrRid) : await Deno.open(pathOrRid, openOptions);
            if (!isRid && mode && !isWindows) {
                await Deno.chmod(pathOrRid, mode);
            }
            const signal = isFileOptions(options) ? options.signal : undefined;
            await writeAll1(file, data, {
                signal
            });
        } catch (e) {
            error = e instanceof Error ? denoErrorToNodeError(e, {
                syscall: "write"
            }) : new Error("[non-error thrown]");
        } finally{
            if (!isRid && file) file.close();
            callbackFn(error);
        }
    })();
}
const writeFilePromise = promisify(writeFile);
function writeFileSync(pathOrRid, data, options) {
    pathOrRid = pathOrRid instanceof URL ? fromFileUrl5(pathOrRid) : pathOrRid;
    const flag = isFileOptions(options) ? options.flag : undefined;
    const mode = isFileOptions(options) ? options.mode : undefined;
    const encoding = checkEncoding(getEncoding(options)) || "utf8";
    const openOptions = getOpenOptions(flag || "w");
    if (!ArrayBuffer.isView(data)) {
        validateStringAfterArrayBufferView(data, "data");
        if (typeof data !== "string") {
            showStringCoercionDeprecation();
        }
        data = Buffer1.from(String(data), encoding);
    }
    const isRid = typeof pathOrRid === "number";
    let file;
    let error = null;
    try {
        file = isRid ? new Deno.FsFile(pathOrRid) : Deno.openSync(pathOrRid, openOptions);
        if (!isRid && mode && !isWindows) {
            Deno.chmodSync(pathOrRid, mode);
        }
        writeAllSync(file, data);
    } catch (e) {
        error = e instanceof Error ? denoErrorToNodeError(e, {
            syscall: "write"
        }) : new Error("[non-error thrown]");
    } finally{
        if (!isRid && file) file.close();
    }
    if (error) throw error;
}
async function writeAll1(w, arr, options = {}) {
    const { offset =0 , length =arr.byteLength , signal  } = options;
    checkAborted(signal);
    const written = await w.write(arr.subarray(offset, offset + length));
    if (written === length) {
        return;
    }
    await writeAll1(w, arr, {
        offset: offset + written,
        length: length - written,
        signal
    });
}
function checkAborted(signal) {
    if (signal?.aborted) {
        throw new AbortError();
    }
}
function appendFile(path, data, options, callback) {
    callback = maybeCallback(callback || options);
    options = getOptions1(options, {
        encoding: "utf8",
        mode: 0o666,
        flag: "a"
    });
    options = copyObject(options);
    if (!options.flag || isUint32(path)) {
        options.flag = "a";
    }
    writeFile(path, data, options, callback);
}
const appendFilePromise = promisify(appendFile);
function appendFileSync(path, data, options) {
    options = getOptions1(options, {
        encoding: "utf8",
        mode: 0o666,
        flag: "a"
    });
    options = copyObject(options);
    if (!options.flag || isUint32(path)) {
        options.flag = "a";
    }
    writeFileSync(path, data, options);
}
function chmod(path, mode, callback) {
    path = getValidatedPath(path).toString();
    mode = parseFileMode(mode, "mode");
    Deno.chmod(toNamespacedPath2(path), mode).catch((error)=>{
        if (!(error instanceof Deno.errors.NotSupported)) {
            throw error;
        }
    }).then(()=>callback(null), callback);
}
const chmodPromise = promisify(chmod);
function chmodSync(path, mode) {
    path = getValidatedPath(path).toString();
    mode = parseFileMode(mode, "mode");
    try {
        Deno.chmodSync(toNamespacedPath2(path), mode);
    } catch (error) {
        if (!(error instanceof Deno.errors.NotSupported)) {
            throw error;
        }
    }
}
function chown(path, uid, gid, callback) {
    callback = makeCallback(callback);
    path = getValidatedPath(path).toString();
    validateInteger(uid, "uid", -1, kMaxUserId);
    validateInteger(gid, "gid", -1, kMaxUserId);
    Deno.chown(toNamespacedPath2(path), uid, gid).then(()=>callback(null), callback);
}
const chownPromise = promisify(chown);
function chownSync(path, uid, gid) {
    path = getValidatedPath(path).toString();
    validateInteger(uid, "uid", -1, kMaxUserId);
    validateInteger(gid, "gid", -1, kMaxUserId);
    Deno.chownSync(toNamespacedPath2(path), uid, gid);
}
function close(fd, callback) {
    fd = getValidatedFd(fd);
    setTimeout(()=>{
        let error = null;
        try {
            Deno.close(fd);
        } catch (err) {
            error = err instanceof Error ? err : new Error("[non-error thrown]");
        }
        callback(error);
    }, 0);
}
function closeSync(fd) {
    fd = getValidatedFd(fd);
    Deno.close(fd);
}
function copyFile(src, dest, mode, callback) {
    if (typeof mode === "function") {
        callback = mode;
        mode = 0;
    }
    const srcStr = getValidatedPath(src, "src").toString();
    const destStr = getValidatedPath(dest, "dest").toString();
    const modeNum = getValidMode(mode, "copyFile");
    const cb = makeCallback(callback);
    if ((modeNum & fs.COPYFILE_EXCL) === fs.COPYFILE_EXCL) {
        Deno.lstat(destStr).then(()=>{
            const e = new Error(`EEXIST: file already exists, copyfile '${srcStr}' -> '${destStr}'`);
            e.syscall = "copyfile";
            e.errno = codeMap.get("EEXIST");
            e.code = "EEXIST";
            cb(e);
        }, (e)=>{
            if (e instanceof Deno.errors.NotFound) {
                Deno.copyFile(srcStr, destStr).then(()=>cb(null), cb);
            }
            cb(e);
        });
    } else {
        Deno.copyFile(srcStr, destStr).then(()=>cb(null), cb);
    }
}
const copyFilePromise = promisify(copyFile);
function copyFileSync(src, dest, mode) {
    const srcStr = getValidatedPath(src, "src").toString();
    const destStr = getValidatedPath(dest, "dest").toString();
    const modeNum = getValidMode(mode, "copyFile");
    if ((modeNum & fs.COPYFILE_EXCL) === fs.COPYFILE_EXCL) {
        try {
            Deno.lstatSync(destStr);
            throw new Error(`A file exists at the destination: ${destStr}`);
        } catch (e) {
            if (e instanceof Deno.errors.NotFound) {
                Deno.copyFileSync(srcStr, destStr);
            }
            throw e;
        }
    } else {
        Deno.copyFileSync(srcStr, destStr);
    }
}
class Dirent1 {
    constructor(entry){
        this.entry = entry;
    }
    isBlockDevice() {
        notImplemented("Deno does not yet support identification of block devices");
        return false;
    }
    isCharacterDevice() {
        notImplemented("Deno does not yet support identification of character devices");
        return false;
    }
    isDirectory() {
        return this.entry.isDirectory;
    }
    isFIFO() {
        notImplemented("Deno does not yet support identification of FIFO named pipes");
        return false;
    }
    isFile() {
        return this.entry.isFile;
    }
    isSocket() {
        notImplemented("Deno does not yet support identification of sockets");
        return false;
    }
    isSymbolicLink() {
        return this.entry.isSymlink;
    }
    get name() {
        return this.entry.name;
    }
    entry;
}
class Dir {
    #dirPath;
    #syncIterator;
    #asyncIterator;
    constructor(path){
        if (!path) {
            throw new ERR_MISSING_ARGS("path");
        }
        this.#dirPath = path;
    }
    get path() {
        if (this.#dirPath instanceof Uint8Array) {
            return new TextDecoder().decode(this.#dirPath);
        }
        return this.#dirPath;
    }
    read(callback) {
        return new Promise((resolve, reject)=>{
            if (!this.#asyncIterator) {
                this.#asyncIterator = Deno.readDir(this.path)[Symbol.asyncIterator]();
            }
            assert(this.#asyncIterator);
            this.#asyncIterator.next().then((iteratorResult)=>{
                resolve(iteratorResult.done ? null : new Dirent1(iteratorResult.value));
                if (callback) {
                    callback(null, iteratorResult.done ? null : new Dirent1(iteratorResult.value));
                }
            }, (err)=>{
                if (callback) {
                    callback(err);
                }
                reject(err);
            });
        });
    }
    readSync() {
        if (!this.#syncIterator) {
            this.#syncIterator = Deno.readDirSync(this.path)[Symbol.iterator]();
        }
        const iteratorResult = this.#syncIterator.next();
        if (iteratorResult.done) {
            return null;
        } else {
            return new Dirent1(iteratorResult.value);
        }
    }
    close(callback) {
        return new Promise((resolve)=>{
            if (callback) {
                callback(null);
            }
            resolve();
        });
    }
    closeSync() {}
    async *[Symbol.asyncIterator]() {
        try {
            while(true){
                const dirent = await this.read();
                if (dirent === null) {
                    break;
                }
                yield dirent;
            }
        } finally{
            await this.close();
        }
    }
}
function exists(path, callback) {
    path = path instanceof URL ? fromFileUrl5(path) : path;
    Deno.lstat(path).then(()=>callback(true), ()=>callback(false));
}
const kCustomPromisifiedSymbol1 = Symbol.for("nodejs.util.promisify.custom");
Object.defineProperty(exists, kCustomPromisifiedSymbol1, {
    value: (path)=>{
        return new Promise((resolve)=>{
            exists(path, (exists)=>resolve(exists));
        });
    }
});
function existsSync(path) {
    path = path instanceof URL ? fromFileUrl5(path) : path;
    try {
        Deno.lstatSync(path);
        return true;
    } catch (_err) {
        return false;
    }
}
function fdatasync(fd, callback) {
    Deno.fdatasync(fd).then(()=>callback(null), callback);
}
function fdatasyncSync(fd) {
    Deno.fdatasyncSync(fd);
}
function fstat(fd, optionsOrCallback, maybeCallback) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : {
        bigint: false
    };
    if (!callback) throw new Error("No callback function supplied");
    Deno.fstat(fd).then((stat)=>callback(null, CFISBIS(stat, options.bigint)), (err)=>callback(err));
}
function fstatSync(fd, options) {
    const origin = Deno.fstatSync(fd);
    return CFISBIS(origin, options?.bigint || false);
}
function fsync(fd, callback) {
    Deno.fsync(fd).then(()=>callback(null), callback);
}
function fsyncSync(fd) {
    Deno.fsyncSync(fd);
}
function ftruncate(fd, lenOrCallback, maybeCallback) {
    const len = typeof lenOrCallback === "number" ? lenOrCallback : undefined;
    const callback = typeof lenOrCallback === "function" ? lenOrCallback : maybeCallback;
    if (!callback) throw new Error("No callback function supplied");
    Deno.ftruncate(fd, len).then(()=>callback(null), callback);
}
function ftruncateSync(fd, len) {
    Deno.ftruncateSync(fd, len);
}
function getValidTime(time, name) {
    if (typeof time === "string") {
        time = Number(time);
    }
    if (typeof time === "number" && (Number.isNaN(time) || !Number.isFinite(time))) {
        throw new Deno.errors.InvalidData(`invalid ${name}, must not be infinity or NaN`);
    }
    return time;
}
function futimes(fd, atime, mtime, callback) {
    if (!callback) {
        throw new Deno.errors.InvalidData("No callback function supplied");
    }
    atime = getValidTime(atime, "atime");
    mtime = getValidTime(mtime, "mtime");
    Deno.futime(fd, atime, mtime).then(()=>callback(null), callback);
}
function futimesSync(fd, atime, mtime) {
    atime = getValidTime(atime, "atime");
    mtime = getValidTime(mtime, "mtime");
    Deno.futimeSync(fd, atime, mtime);
}
function link(existingPath, newPath, callback) {
    existingPath = existingPath instanceof URL ? fromFileUrl5(existingPath) : existingPath;
    newPath = newPath instanceof URL ? fromFileUrl5(newPath) : newPath;
    Deno.link(existingPath, newPath).then(()=>callback(null), callback);
}
const linkPromise = promisify(link);
function linkSync(existingPath, newPath) {
    existingPath = existingPath instanceof URL ? fromFileUrl5(existingPath) : existingPath;
    newPath = newPath instanceof URL ? fromFileUrl5(newPath) : newPath;
    Deno.linkSync(existingPath, newPath);
}
function mkdir(path, options, callback) {
    path = getValidatedPath(path);
    let mode = 0o777;
    let recursive = false;
    if (typeof options == "function") {
        callback = options;
    } else if (typeof options === "number") {
        mode = options;
    } else if (typeof options === "boolean") {
        recursive = options;
    } else if (options) {
        if (options.recursive !== undefined) recursive = options.recursive;
        if (options.mode !== undefined) mode = options.mode;
    }
    validateBoolean(recursive, "options.recursive");
    Deno.mkdir(path, {
        recursive,
        mode
    }).then(()=>{
        if (typeof callback === "function") {
            callback(null);
        }
    }, (err)=>{
        if (typeof callback === "function") {
            callback(err);
        }
    });
}
const mkdirPromise = promisify(mkdir);
function mkdirSync(path, options) {
    path = getValidatedPath(path);
    let mode = 0o777;
    let recursive = false;
    if (typeof options === "number") {
        mode = options;
    } else if (typeof options === "boolean") {
        recursive = options;
    } else if (options) {
        if (options.recursive !== undefined) recursive = options.recursive;
        if (options.mode !== undefined) mode = options.mode;
    }
    validateBoolean(recursive, "options.recursive");
    try {
        Deno.mkdirSync(path, {
            recursive,
            mode
        });
    } catch (err) {
        throw denoErrorToNodeError(err, {
            syscall: "mkdir",
            path
        });
    }
}
function mkdtemp(prefix, optionsOrCallback, maybeCallback) {
    const callback = typeof optionsOrCallback == "function" ? optionsOrCallback : maybeCallback;
    if (!callback) {
        throw new ERR_INVALID_ARG_TYPE("callback", "function", callback);
    }
    const encoding = parseEncoding(optionsOrCallback);
    const path = tempDirPath(prefix);
    mkdir(path, {
        recursive: false,
        mode: 0o700
    }, (err)=>{
        if (err) callback(err);
        else callback(null, decode4(path, encoding));
    });
}
const mkdtempPromise = promisify(mkdtemp);
function mkdtempSync(prefix, options) {
    const encoding = parseEncoding(options);
    const path = tempDirPath(prefix);
    mkdirSync(path, {
        recursive: false,
        mode: 0o700
    });
    return decode4(path, encoding);
}
function parseEncoding(optionsOrCallback) {
    let encoding;
    if (typeof optionsOrCallback == "function") encoding = undefined;
    else if (optionsOrCallback instanceof Object) {
        encoding = optionsOrCallback?.encoding;
    } else encoding = optionsOrCallback;
    if (encoding) {
        try {
            new TextDecoder(encoding);
        } catch  {
            throw new ERR_INVALID_OPT_VALUE_ENCODING(encoding);
        }
    }
    return encoding;
}
function decode4(str, encoding) {
    if (!encoding) return str;
    else {
        const decoder = new TextDecoder(encoding);
        const encoder = new TextEncoder();
        return decoder.decode(encoder.encode(str));
    }
}
const CHARS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function randomName() {
    return [
        ...Array(6)
    ].map(()=>CHARS[Math.floor(Math.random() * CHARS.length)]).join("");
}
function tempDirPath(prefix) {
    let path;
    do {
        path = prefix + randomName();
    }while (existsSync(path))
    return path;
}
function existsSync1(filePath) {
    try {
        Deno.lstatSync(filePath);
        return true;
    } catch (error) {
        if (error instanceof Deno.errors.NotFound) {
            return false;
        }
        throw error;
    }
}
const FLAGS_AX = O_APPEND1 | O_CREAT1 | O_WRONLY1 | O_EXCL1;
const FLAGS_AX_PLUS = O_APPEND1 | O_CREAT1 | O_RDWR1 | O_EXCL1;
const FLAGS_WX = O_TRUNC1 | O_CREAT1 | O_WRONLY1 | O_EXCL1;
const FLAGS_WX_PLUS = O_TRUNC1 | O_CREAT1 | O_RDWR1 | O_EXCL1;
function convertFlagAndModeToOptions(flag, mode) {
    if (!flag && !mode) return undefined;
    if (!flag && mode) return {
        mode
    };
    return {
        ...getOpenOptions(flag),
        mode
    };
}
function open(path, flags, mode, callback) {
    if (flags === undefined) {
        throw new ERR_INVALID_ARG_TYPE("flags or callback", [
            "string",
            "function"
        ], flags);
    }
    path = getValidatedPath(path);
    if (arguments.length < 3) {
        callback = flags;
        flags = "r";
        mode = 0o666;
    } else if (typeof mode === "function") {
        callback = mode;
        mode = 0o666;
    } else {
        mode = parseFileMode(mode, "mode", 0o666);
    }
    if (typeof callback !== "function") {
        throw new ERR_INVALID_ARG_TYPE("callback", "function", callback);
    }
    if (flags === undefined) {
        flags = "r";
    }
    if (existenceCheckRequired(flags) && existsSync1(path)) {
        const err = new Error(`EEXIST: file already exists, open '${path}'`);
        callback(err);
    } else {
        if (flags === "as" || flags === "as+") {
            let err = null, res;
            try {
                res = openSync(path, flags, mode);
            } catch (error) {
                err = error instanceof Error ? error : new Error("[non-error thrown]");
            }
            if (err) {
                callback(err);
            } else {
                callback(null, res);
            }
            return;
        }
        Deno.open(path, convertFlagAndModeToOptions(flags, mode)).then((file)=>callback(null, file.rid), (err)=>callback(err));
    }
}
const openPromise = promisify(open);
function openSync(path, flags, maybeMode) {
    const mode = parseFileMode(maybeMode, "mode", 0o666);
    path = getValidatedPath(path);
    if (flags === undefined) {
        flags = "r";
    }
    if (existenceCheckRequired(flags) && existsSync1(path)) {
        throw new Error(`EEXIST: file already exists, open '${path}'`);
    }
    return Deno.openSync(path, convertFlagAndModeToOptions(flags, mode)).rid;
}
function existenceCheckRequired(flags) {
    return typeof flags === "string" && [
        "ax",
        "ax+",
        "wx",
        "wx+"
    ].includes(flags) || typeof flags === "number" && ((flags & FLAGS_AX) === FLAGS_AX || (flags & FLAGS_AX_PLUS) === FLAGS_AX_PLUS || (flags & FLAGS_WX) === FLAGS_WX || (flags & FLAGS_WX_PLUS) === FLAGS_WX_PLUS);
}
function _validateFunction(callback) {
    validateFunction(callback, "callback");
}
function opendir(path, options, callback) {
    callback = typeof options === "function" ? options : callback;
    _validateFunction(callback);
    path = getValidatedPath(path).toString();
    let err, dir;
    try {
        const { bufferSize  } = getOptions1(options, {
            encoding: "utf8",
            bufferSize: 32
        });
        validateInteger(bufferSize, "options.bufferSize", 1, 4294967295);
        Deno.readDirSync(path);
        dir = new Dir(path);
    } catch (error) {
        err = denoErrorToNodeError(error, {
            syscall: "opendir"
        });
    }
    if (err) {
        callback(err);
    } else {
        callback(null, dir);
    }
}
const opendirPromise = promisify(opendir);
function opendirSync(path, options) {
    path = getValidatedPath(path).toString();
    const { bufferSize  } = getOptions1(options, {
        encoding: "utf8",
        bufferSize: 32
    });
    validateInteger(bufferSize, "options.bufferSize", 1, 4294967295);
    try {
        Deno.readDirSync(path);
        return new Dir(path);
    } catch (err) {
        throw denoErrorToNodeError(err, {
            syscall: "opendir"
        });
    }
}
function read(fd, optOrBufferOrCb, offsetOrCallback, length, position, callback) {
    let cb;
    let offset = 0, buffer;
    if (typeof fd !== "number") {
        throw new ERR_INVALID_ARG_TYPE("fd", "number", fd);
    }
    if (length == null) {
        length = 0;
    }
    if (typeof offsetOrCallback === "function") {
        cb = offsetOrCallback;
    } else if (typeof optOrBufferOrCb === "function") {
        cb = optOrBufferOrCb;
    } else {
        offset = offsetOrCallback;
        validateInteger(offset, "offset", 0);
        cb = callback;
    }
    if (optOrBufferOrCb instanceof Buffer1 || optOrBufferOrCb instanceof Uint8Array) {
        buffer = optOrBufferOrCb;
    } else if (typeof optOrBufferOrCb === "function") {
        offset = 0;
        buffer = Buffer1.alloc(16384);
        length = buffer.byteLength;
        position = null;
    } else {
        const opt = optOrBufferOrCb;
        if (!(opt.buffer instanceof Buffer1) && !(opt.buffer instanceof Uint8Array)) {
            if (opt.buffer === null) {
                length = opt.buffer.byteLength;
            }
            throw new ERR_INVALID_ARG_TYPE("buffer", [
                "Buffer",
                "TypedArray",
                "DataView"
            ], optOrBufferOrCb);
        }
        offset = opt.offset ?? 0;
        buffer = opt.buffer ?? Buffer1.alloc(16384);
        length = opt.length ?? buffer.byteLength;
        position = opt.position ?? null;
    }
    if (position == null) {
        position = -1;
    }
    validatePosition(position);
    validateOffsetLengthRead(offset, length, buffer.byteLength);
    if (!cb) throw new ERR_INVALID_ARG_TYPE("cb", "Callback", cb);
    (async ()=>{
        try {
            let nread;
            if (typeof position === "number" && position >= 0) {
                const currentPosition = await Deno.seek(fd, 0, Deno.SeekMode.Current);
                Deno.seekSync(fd, position, Deno.SeekMode.Start);
                nread = Deno.readSync(fd, buffer);
                Deno.seekSync(fd, currentPosition, Deno.SeekMode.Start);
            } else {
                nread = await Deno.read(fd, buffer);
            }
            cb(null, nread ?? 0, Buffer1.from(buffer.buffer, offset, length));
        } catch (error) {
            cb(error, null);
        }
    })();
}
function readSync(fd, buffer, offsetOrOpt, length, position) {
    let offset = 0;
    if (typeof fd !== "number") {
        throw new ERR_INVALID_ARG_TYPE("fd", "number", fd);
    }
    validateBuffer(buffer);
    if (length == null) {
        length = 0;
    }
    if (typeof offsetOrOpt === "number") {
        offset = offsetOrOpt;
        validateInteger(offset, "offset", 0);
    } else {
        const opt = offsetOrOpt;
        offset = opt.offset ?? 0;
        length = opt.length ?? buffer.byteLength;
        position = opt.position ?? null;
    }
    if (position == null) {
        position = -1;
    }
    validatePosition(position);
    validateOffsetLengthRead(offset, length, buffer.byteLength);
    let currentPosition = 0;
    if (typeof position === "number" && position >= 0) {
        currentPosition = Deno.seekSync(fd, 0, Deno.SeekMode.Current);
        Deno.seekSync(fd, position, Deno.SeekMode.Start);
    }
    const numberOfBytesRead = Deno.readSync(fd, buffer);
    if (typeof position === "number" && position >= 0) {
        Deno.seekSync(fd, currentPosition, Deno.SeekMode.Start);
    }
    return numberOfBytesRead ?? 0;
}
const statPromisified = promisify(stat);
const statAsync = async (filename)=>{
    try {
        return await statPromisified(filename);
    } catch  {
        return emptyStats;
    }
};
const emptyStats = new Stats(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Date.UTC(1970, 0, 1, 0, 0, 0), Date.UTC(1970, 0, 1, 0, 0, 0), Date.UTC(1970, 0, 1, 0, 0, 0), Date.UTC(1970, 0, 1, 0, 0, 0));
function asyncIterableToCallback(iter, callback, errCallback) {
    const iterator = iter[Symbol.asyncIterator]();
    function next() {
        iterator.next().then((obj)=>{
            if (obj.done) {
                callback(obj.value, true);
                return;
            }
            callback(obj.value);
            next();
        }, errCallback);
    }
    next();
}
function watch(filename, optionsOrListener, optionsOrListener2) {
    const listener = typeof optionsOrListener === "function" ? optionsOrListener : typeof optionsOrListener2 === "function" ? optionsOrListener2 : undefined;
    const options = typeof optionsOrListener === "object" ? optionsOrListener : typeof optionsOrListener2 === "object" ? optionsOrListener2 : undefined;
    const watchPath = getValidatedPath(filename).toString();
    let iterator;
    const timer = setTimeout(()=>{
        iterator = Deno.watchFs(watchPath, {
            recursive: options?.recursive || false
        });
        asyncIterableToCallback(iterator, (val, done)=>{
            if (done) return;
            fsWatcher.emit("change", convertDenoFsEventToNodeFsEvent(val.kind), basename5(val.paths[0]));
        }, (e)=>{
            fsWatcher.emit("error", e);
        });
    }, 5);
    const fsWatcher = new FSWatcher(()=>{
        clearTimeout(timer);
        try {
            iterator?.close();
        } catch (e) {
            if (e instanceof Deno.errors.BadResource) {
                return;
            }
            throw e;
        }
    });
    if (listener) {
        fsWatcher.on("change", listener.bind({
            _handle: fsWatcher
        }));
    }
    return fsWatcher;
}
const watchPromise = promisify(watch);
function watchFile(filename, listenerOrOptions, listener) {
    const watchPath = getValidatedPath(filename).toString();
    const handler = typeof listenerOrOptions === "function" ? listenerOrOptions : listener;
    validateFunction(handler, "listener");
    const { bigint =false , persistent =true , interval =5007  } = typeof listenerOrOptions === "object" ? listenerOrOptions : {};
    let stat = statWatchers.get(watchPath);
    if (stat === undefined) {
        stat = new StatWatcher(bigint);
        stat[kFSStatWatcherStart](watchPath, persistent, interval);
        statWatchers.set(watchPath, stat);
    }
    stat.addListener("change", listener);
    return stat;
}
function unwatchFile(filename, listener) {
    const watchPath = getValidatedPath(filename).toString();
    const stat = statWatchers.get(watchPath);
    if (!stat) {
        return;
    }
    if (typeof listener === "function") {
        const beforeListenerCount = stat.listenerCount("change");
        stat.removeListener("change", listener);
        if (stat.listenerCount("change") < beforeListenerCount) {
            stat[kFSStatWatcherAddOrCleanRef]("clean");
        }
    } else {
        stat.removeAllListeners("change");
        stat[kFSStatWatcherAddOrCleanRef]("cleanAll");
    }
    if (stat.listenerCount("change") === 0) {
        stat.stop();
        statWatchers.delete(watchPath);
    }
}
const statWatchers = new Map();
const kFSStatWatcherStart = Symbol("kFSStatWatcherStart");
const kFSStatWatcherAddOrCleanRef = Symbol("kFSStatWatcherAddOrCleanRef");
class StatWatcher extends EventEmitter {
    #bigint;
    #refCount = 0;
    #abortController = new AbortController();
    constructor(bigint){
        super();
        this.#bigint = bigint;
    }
    [kFSStatWatcherStart](filename, persistent, interval) {
        if (persistent) {
            this.#refCount++;
        }
        (async ()=>{
            let prev = await statAsync(filename);
            if (prev === emptyStats) {
                this.emit("change", prev, prev);
            }
            try {
                while(true){
                    await delay(interval, {
                        signal: this.#abortController.signal
                    });
                    const curr = await statAsync(filename);
                    if (curr?.mtime !== prev?.mtime) {
                        this.emit("change", curr, prev);
                        prev = curr;
                    }
                }
            } catch (e) {
                if (e instanceof DOMException && e.name === "AbortError") {
                    return;
                }
                this.emit("error", e);
            }
        })();
    }
    [kFSStatWatcherAddOrCleanRef](addOrClean) {
        if (addOrClean === "add") {
            this.#refCount++;
        } else if (addOrClean === "clean") {
            this.#refCount--;
        } else {
            this.#refCount = 0;
        }
    }
    stop() {
        if (this.#abortController.signal.aborted) {
            return;
        }
        this.#abortController.abort();
        this.emit("stop");
    }
    ref() {
        notImplemented("FSWatcher.ref() is not implemented");
    }
    unref() {
        notImplemented("FSWatcher.unref() is not implemented");
    }
}
class FSWatcher extends EventEmitter {
    #closer;
    #closed = false;
    constructor(closer){
        super();
        this.#closer = closer;
    }
    close() {
        if (this.#closed) {
            return;
        }
        this.#closed = true;
        this.emit("close");
        this.#closer();
    }
    ref() {
        notImplemented("FSWatcher.ref() is not implemented");
    }
    unref() {
        notImplemented("FSWatcher.unref() is not implemented");
    }
}
function convertDenoFsEventToNodeFsEvent(kind) {
    if (kind === "create" || kind === "remove") {
        return "rename";
    } else {
        return "change";
    }
}
function toDirent(val) {
    return new Dirent1(val);
}
function readdir(path, optionsOrCallback, maybeCallback) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : null;
    const result = [];
    path = getValidatedPath(path);
    if (!callback) throw new Error("No callback function supplied");
    if (options?.encoding) {
        try {
            new TextDecoder(options.encoding);
        } catch  {
            throw new Error(`TypeError [ERR_INVALID_OPT_VALUE_ENCODING]: The value "${options.encoding}" is invalid for option "encoding"`);
        }
    }
    try {
        asyncIterableToCallback(Deno.readDir(path.toString()), (val, done)=>{
            if (typeof path !== "string") return;
            if (done) {
                callback(null, result);
                return;
            }
            if (options?.withFileTypes) {
                result.push(toDirent(val));
            } else result.push(decode5(val.name));
        }, (e)=>{
            callback(denoErrorToNodeError(e, {
                syscall: "readdir"
            }));
        });
    } catch (e) {
        callback(denoErrorToNodeError(e, {
            syscall: "readdir"
        }));
    }
}
function decode5(str, encoding) {
    if (!encoding) return str;
    else {
        const decoder = new TextDecoder(encoding);
        const encoder = new TextEncoder();
        return decoder.decode(encoder.encode(str));
    }
}
const readdirPromise = promisify(readdir);
function readdirSync(path, options) {
    const result = [];
    path = getValidatedPath(path);
    if (options?.encoding) {
        try {
            new TextDecoder(options.encoding);
        } catch  {
            throw new Error(`TypeError [ERR_INVALID_OPT_VALUE_ENCODING]: The value "${options.encoding}" is invalid for option "encoding"`);
        }
    }
    try {
        for (const file of Deno.readDirSync(path.toString())){
            if (options?.withFileTypes) {
                result.push(toDirent(file));
            } else result.push(decode5(file.name));
        }
    } catch (e) {
        throw denoErrorToNodeError(e, {
            syscall: "readdir"
        });
    }
    return result;
}
function maybeDecode(data, encoding) {
    const buffer = Buffer1.from(data.buffer, data.byteOffset, data.byteLength);
    if (encoding && encoding !== "binary") return buffer.toString(encoding);
    return buffer;
}
function readFile(path, optOrCallback, callback) {
    path = path instanceof URL ? fromFileUrl5(path) : path;
    let cb;
    if (typeof optOrCallback === "function") {
        cb = optOrCallback;
    } else {
        cb = callback;
    }
    const encoding = getEncoding(optOrCallback);
    const p = Deno.readFile(path);
    if (cb) {
        p.then((data)=>{
            if (encoding && encoding !== "binary") {
                const text = maybeDecode(data, encoding);
                return cb(null, text);
            }
            const buffer = maybeDecode(data, encoding);
            cb(null, buffer);
        }, (err)=>cb && cb(err));
    }
}
const readFilePromise = promisify(readFile);
function readFileSync(path, opt) {
    path = path instanceof URL ? fromFileUrl5(path) : path;
    const data = Deno.readFileSync(path);
    const encoding = getEncoding(opt);
    if (encoding && encoding !== "binary") {
        const text = maybeDecode(data, encoding);
        return text;
    }
    const buffer = maybeDecode(data, encoding);
    return buffer;
}
function maybeEncode(data, encoding) {
    if (encoding === "buffer") {
        return new TextEncoder().encode(data);
    }
    return data;
}
function getEncoding1(optOrCallback) {
    if (!optOrCallback || typeof optOrCallback === "function") {
        return null;
    } else {
        if (optOrCallback.encoding) {
            if (optOrCallback.encoding === "utf8" || optOrCallback.encoding === "utf-8") {
                return "utf8";
            } else if (optOrCallback.encoding === "buffer") {
                return "buffer";
            } else {
                notImplemented(`fs.readlink encoding=${optOrCallback.encoding}`);
            }
        }
        return null;
    }
}
function readlink(path, optOrCallback, callback) {
    path = path instanceof URL ? fromFileUrl5(path) : path;
    let cb;
    if (typeof optOrCallback === "function") {
        cb = optOrCallback;
    } else {
        cb = callback;
    }
    const encoding = getEncoding1(optOrCallback);
    intoCallbackAPIWithIntercept(Deno.readLink, (data)=>maybeEncode(data, encoding), cb, path);
}
const readlinkPromise = promisify(readlink);
function readlinkSync(path, opt) {
    path = path instanceof URL ? fromFileUrl5(path) : path;
    return maybeEncode(Deno.readLinkSync(path), getEncoding1(opt));
}
function realpath(path, options, callback) {
    if (typeof options === "function") {
        callback = options;
    }
    if (!callback) {
        throw new Error("No callback function supplied");
    }
    Deno.realPath(path).then((path)=>callback(null, path), (err)=>callback(err));
}
realpath.native = realpath;
const realpathPromise = promisify(realpath);
function realpathSync(path) {
    return Deno.realPathSync(path);
}
realpathSync.native = realpathSync;
function rename(oldPath, newPath, callback) {
    oldPath = oldPath instanceof URL ? fromFileUrl5(oldPath) : oldPath;
    newPath = newPath instanceof URL ? fromFileUrl5(newPath) : newPath;
    if (!callback) throw new Error("No callback function supplied");
    Deno.rename(oldPath, newPath).then((_)=>callback(), callback);
}
const renamePromise = promisify(rename);
function renameSync(oldPath, newPath) {
    oldPath = oldPath instanceof URL ? fromFileUrl5(oldPath) : oldPath;
    newPath = newPath instanceof URL ? fromFileUrl5(newPath) : newPath;
    Deno.renameSync(oldPath, newPath);
}
function rmdir(path, optionsOrCallback, maybeCallback) {
    path = toNamespacedPath5(getValidatedPath(path));
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : undefined;
    if (!callback) throw new Error("No callback function supplied");
    if (options?.recursive) {
        emitRecursiveRmdirWarning();
        validateRmOptions(path, {
            ...options,
            force: false
        }, true, (err, options)=>{
            if (err === false) {
                return callback(new ERR_FS_RMDIR_ENOTDIR(path.toString()));
            }
            if (err) {
                return callback(err);
            }
            Deno.remove(path, {
                recursive: options?.recursive
            }).then((_)=>callback(), callback);
        });
    } else {
        validateRmdirOptions(options);
        Deno.remove(path, {
            recursive: options?.recursive
        }).then((_)=>callback(), (err)=>{
            callback(err instanceof Error ? denoErrorToNodeError(err, {
                syscall: "rmdir"
            }) : err);
        });
    }
}
const rmdirPromise = promisify(rmdir);
function rmdirSync(path, options) {
    path = getValidatedPath(path);
    if (options?.recursive) {
        emitRecursiveRmdirWarning();
        const optionsOrFalse = validateRmOptionsSync(path, {
            ...options,
            force: false
        }, true);
        if (optionsOrFalse === false) {
            throw new ERR_FS_RMDIR_ENOTDIR(path.toString());
        }
        options = optionsOrFalse;
    } else {
        validateRmdirOptions(options);
    }
    try {
        Deno.removeSync(toNamespacedPath5(path), {
            recursive: options?.recursive
        });
    } catch (err) {
        throw err instanceof Error ? denoErrorToNodeError(err, {
            syscall: "rmdir"
        }) : err;
    }
}
function rm(path, optionsOrCallback, maybeCallback) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : undefined;
    if (!callback) throw new Error("No callback function supplied");
    validateRmOptions(path, options, false, (err, options)=>{
        if (err) {
            return callback(err);
        }
        Deno.remove(path, {
            recursive: options?.recursive
        }).then((_)=>callback(null), (err)=>{
            if (options?.force && err instanceof Deno.errors.NotFound) {
                callback(null);
            } else {
                callback(err instanceof Error ? denoErrorToNodeError(err, {
                    syscall: "rm"
                }) : err);
            }
        });
    });
}
const rmPromise = promisify(rm);
function rmSync(path, options) {
    options = validateRmOptionsSync(path, options, false);
    try {
        Deno.removeSync(path, {
            recursive: options?.recursive
        });
    } catch (err) {
        if (options?.force && err instanceof Deno.errors.NotFound) {
            return;
        }
        if (err instanceof Error) {
            throw denoErrorToNodeError(err, {
                syscall: "stat"
            });
        } else {
            throw err;
        }
    }
}
function symlink(target, path, typeOrCallback, maybeCallback) {
    target = target instanceof URL ? fromFileUrl5(target) : target;
    path = path instanceof URL ? fromFileUrl5(path) : path;
    const type = typeof typeOrCallback === "string" ? typeOrCallback : "file";
    const callback = typeof typeOrCallback === "function" ? typeOrCallback : maybeCallback;
    if (!callback) throw new Error("No callback function supplied");
    Deno.symlink(target, path, {
        type
    }).then(()=>callback(null), callback);
}
const symlinkPromise = promisify(symlink);
function symlinkSync(target, path, type) {
    target = target instanceof URL ? fromFileUrl5(target) : target;
    path = path instanceof URL ? fromFileUrl5(path) : path;
    type = type || "file";
    Deno.symlinkSync(target, path, {
        type
    });
}
function truncate(path, lenOrCallback, maybeCallback) {
    path = path instanceof URL ? fromFileUrl5(path) : path;
    const len = typeof lenOrCallback === "number" ? lenOrCallback : undefined;
    const callback = typeof lenOrCallback === "function" ? lenOrCallback : maybeCallback;
    if (!callback) throw new Error("No callback function supplied");
    Deno.truncate(path, len).then(()=>callback(null), callback);
}
const truncatePromise = promisify(truncate);
function truncateSync(path, len) {
    path = path instanceof URL ? fromFileUrl5(path) : path;
    Deno.truncateSync(path, len);
}
function unlink(path, callback) {
    if (!callback) throw new Error("No callback function supplied");
    Deno.remove(path).then((_)=>callback(), callback);
}
const unlinkPromise = promisify(unlink);
function unlinkSync(path) {
    Deno.removeSync(path);
}
function getValidTime1(time, name) {
    if (typeof time === "string") {
        time = Number(time);
    }
    if (typeof time === "number" && (Number.isNaN(time) || !Number.isFinite(time))) {
        throw new Deno.errors.InvalidData(`invalid ${name}, must not be infinity or NaN`);
    }
    return time;
}
function utimes(path, atime, mtime, callback) {
    path = path instanceof URL ? fromFileUrl5(path) : path;
    if (!callback) {
        throw new Deno.errors.InvalidData("No callback function supplied");
    }
    atime = getValidTime1(atime, "atime");
    mtime = getValidTime1(mtime, "mtime");
    Deno.utime(path, atime, mtime).then(()=>callback(null), callback);
}
const utimesPromise = promisify(utimes);
function utimesSync(path, atime, mtime) {
    path = path instanceof URL ? fromFileUrl5(path) : path;
    atime = getValidTime1(atime, "atime");
    mtime = getValidTime1(mtime, "mtime");
    Deno.utimeSync(path, atime, mtime);
}
function writeSync(fd, buffer, offset, length, position) {
    fd = getValidatedFd(fd);
    const innerWriteSync = (fd, buffer, offset, length, position)=>{
        if (buffer instanceof DataView) {
            buffer = new Uint8Array(buffer.buffer);
        }
        if (typeof position === "number") {
            Deno.seekSync(fd, position, Deno.SeekMode.Start);
        }
        let currentOffset = offset;
        const end = offset + length;
        while(currentOffset - offset < length){
            currentOffset += Deno.writeSync(fd, buffer.subarray(currentOffset, end));
        }
        return currentOffset - offset;
    };
    if (isArrayBufferView(buffer)) {
        if (position === undefined) {
            position = null;
        }
        if (offset == null) {
            offset = 0;
        } else {
            validateInteger(offset, "offset", 0);
        }
        if (typeof length !== "number") {
            length = buffer.byteLength - offset;
        }
        validateOffsetLengthWrite(offset, length, buffer.byteLength);
        return innerWriteSync(fd, buffer, offset, length, position);
    }
    validateStringAfterArrayBufferView(buffer, "buffer");
    validateEncoding(buffer, length);
    if (offset === undefined) {
        offset = null;
    }
    buffer = Buffer1.from(buffer, length);
    return innerWriteSync(fd, buffer, 0, buffer.length, position);
}
function write(fd, buffer, offset, length, position, callback) {
    fd = getValidatedFd(fd);
    const innerWrite = async (fd, buffer, offset, length, position)=>{
        if (buffer instanceof DataView) {
            buffer = new Uint8Array(buffer.buffer);
        }
        if (typeof position === "number") {
            await Deno.seek(fd, position, Deno.SeekMode.Start);
        }
        let currentOffset = offset;
        const end = offset + length;
        while(currentOffset - offset < length){
            currentOffset += await Deno.write(fd, buffer.subarray(currentOffset, end));
        }
        return currentOffset - offset;
    };
    if (isArrayBufferView(buffer)) {
        callback = maybeCallback(callback || position || length || offset);
        if (offset == null || typeof offset === "function") {
            offset = 0;
        } else {
            validateInteger(offset, "offset", 0);
        }
        if (typeof length !== "number") {
            length = buffer.byteLength - offset;
        }
        if (typeof position !== "number") {
            position = null;
        }
        validateOffsetLengthWrite(offset, length, buffer.byteLength);
        innerWrite(fd, buffer, offset, length, position).then((nwritten)=>{
            callback(null, nwritten, buffer);
        }, (err)=>callback(err));
        return;
    }
    validateStringAfterArrayBufferView(buffer, "buffer");
    if (typeof buffer !== "string") {
        showStringCoercionDeprecation();
    }
    if (typeof position !== "function") {
        if (typeof offset === "function") {
            position = offset;
            offset = null;
        } else {
            position = length;
        }
        length = "utf-8";
    }
    const str = String(buffer);
    validateEncoding(str, length);
    callback = maybeCallback(position);
    buffer = Buffer1.from(str, length);
    innerWrite(fd, buffer, 0, buffer.length, offset, callback).then((nwritten)=>{
        callback(null, nwritten, buffer);
    }, (err)=>callback(err));
}
function writev(fd, buffers, position, callback) {
    const innerWritev = async (fd, buffers, position)=>{
        const chunks = [];
        for(let i = 0; i < buffers.length; i++){
            if (Buffer1.isBuffer(buffers[i])) {
                chunks.push(buffers[i]);
            } else {
                chunks.push(Buffer1.from(buffers[i]));
            }
        }
        if (typeof position === "number") {
            await Deno.seekSync(fd, position, Deno.SeekMode.Start);
        }
        const buffer = Buffer1.concat(chunks);
        let currentOffset = 0;
        while(currentOffset < buffer.byteLength){
            currentOffset += await Deno.writeSync(fd, buffer.subarray(currentOffset));
        }
        return currentOffset - 0;
    };
    fd = getValidatedFd(fd);
    validateBufferArray(buffers);
    callback = maybeCallback(callback || position);
    if (buffers.length === 0) {
        process.nextTick(callback, null, 0, buffers);
        return;
    }
    if (typeof position !== "number") position = null;
    innerWritev(fd, buffers, position).then((nwritten)=>{
        callback(null, nwritten, buffers);
    }, (err)=>callback(err));
}
function writevSync(fd, buffers, position) {
    const innerWritev = (fd, buffers, position)=>{
        const chunks = [];
        for(let i = 0; i < buffers.length; i++){
            if (Buffer1.isBuffer(buffers[i])) {
                chunks.push(buffers[i]);
            } else {
                chunks.push(Buffer1.from(buffers[i]));
            }
        }
        if (typeof position === "number") {
            Deno.seekSync(fd, position, Deno.SeekMode.Start);
        }
        const buffer = Buffer1.concat(chunks);
        let currentOffset = 0;
        while(currentOffset < buffer.byteLength){
            currentOffset += Deno.writeSync(fd, buffer.subarray(currentOffset));
        }
        return currentOffset - 0;
    };
    fd = getValidatedFd(fd);
    validateBufferArray(buffers);
    if (buffers.length === 0) {
        return 0;
    }
    if (typeof position !== "number") position = null;
    return innerWritev(fd, buffers, position);
}
const kIoDone = Symbol("kIoDone");
const kIsPerformingIO = Symbol("kIsPerformingIO");
const kFs = Symbol("kFs");
function _construct(callback) {
    const stream = this;
    if (typeof stream.fd === "number") {
        callback();
        return;
    }
    if (stream.open !== openWriteFs && stream.open !== openReadFs) {
        const orgEmit = stream.emit;
        stream.emit = function(...args) {
            if (args[0] === "open") {
                this.emit = orgEmit;
                callback();
                Reflect.apply(orgEmit, this, args);
            } else if (args[0] === "error") {
                this.emit = orgEmit;
                callback(args[1]);
            } else {
                Reflect.apply(orgEmit, this, args);
            }
        };
        stream.open();
    } else {
        stream[kFs].open(stream.path.toString(), stream.flags, stream.mode, (er, fd)=>{
            if (er) {
                callback(er);
            } else {
                stream.fd = fd;
                callback();
                stream.emit("open", stream.fd);
                stream.emit("ready");
            }
        });
    }
}
function close1(stream, err, cb) {
    if (!stream.fd) {
        cb(err);
    } else {
        stream[kFs].close(stream.fd, (er)=>{
            cb(er || err);
        });
        stream.fd = null;
    }
}
function importFd(stream, options) {
    if (typeof options.fd === "number") {
        if (stream instanceof ReadStream) {
            stream[kFs] = options.fs || {
                read: read,
                close: close
            };
        }
        if (stream instanceof WriteStream) {
            stream[kFs] = options.fs || {
                write: write,
                writev: writev,
                close: close
            };
        }
        return options.fd;
    }
    throw new ERR_INVALID_ARG_TYPE("options.fd", [
        "number"
    ], options.fd);
}
function ReadStream(path, options) {
    if (!(this instanceof ReadStream)) {
        return new ReadStream(path, options);
    }
    options = copyObject(getOptions1(options, kEmptyObject));
    if (options.highWaterMark === undefined) {
        options.highWaterMark = 64 * 1024;
    }
    if (options.autoDestroy === undefined) {
        options.autoDestroy = false;
    }
    if (options.fd == null) {
        this.fd = null;
        this[kFs] = options.fs || {
            open: open,
            read: read,
            close: close
        };
        validateFunction(this[kFs].open, "options.fs.open");
        this.path = toPathIfFileURL(path);
        this.flags = options.flags === undefined ? "r" : options.flags;
        this.mode = options.mode === undefined ? 0o666 : options.mode;
        validatePath(this.path);
    } else {
        this.fd = getValidatedFd(importFd(this, options));
    }
    options.autoDestroy = options.autoClose === undefined ? true : options.autoClose;
    validateFunction(this[kFs].read, "options.fs.read");
    if (options.autoDestroy) {
        validateFunction(this[kFs].close, "options.fs.close");
    }
    this.start = options.start;
    this.end = options.end ?? Infinity;
    this.pos = undefined;
    this.bytesRead = 0;
    this[kIsPerformingIO] = false;
    if (this.start !== undefined) {
        validateInteger(this.start, "start", 0);
        this.pos = this.start;
    }
    if (this.end !== Infinity) {
        validateInteger(this.end, "end", 0);
        if (this.start !== undefined && this.start > this.end) {
            throw new ERR_OUT_OF_RANGE("start", `<= "end" (here: ${this.end})`, this.start);
        }
    }
    Reflect.apply(Au, this, [
        options
    ]);
}
Object.setPrototypeOf(ReadStream.prototype, Au.prototype);
Object.setPrototypeOf(ReadStream, Au);
Object.defineProperty(ReadStream.prototype, "autoClose", {
    get () {
        return this._readableState.autoDestroy;
    },
    set (val) {
        this._readableState.autoDestroy = val;
    }
});
const openReadFs = deprecate(function() {}, "ReadStream.prototype.open() is deprecated", "DEP0135");
ReadStream.prototype.open = openReadFs;
ReadStream.prototype._construct = _construct;
ReadStream.prototype._read = async function(n) {
    n = this.pos !== undefined ? Math.min(this.end - this.pos + 1, n) : Math.min(this.end - this.bytesRead + 1, n);
    if (n <= 0) {
        this.push(null);
        return;
    }
    const buf = Buffer1.allocUnsafeSlow(n);
    let error = null;
    let bytesRead = null;
    let buffer = undefined;
    this[kIsPerformingIO] = true;
    await new Promise((resolve)=>{
        this[kFs].read(this.fd, buf, 0, n, this.pos ?? null, (_er, _bytesRead, _buf)=>{
            error = _er;
            bytesRead = _bytesRead;
            buffer = _buf;
            return resolve(true);
        });
    });
    this[kIsPerformingIO] = false;
    if (this.destroyed) {
        this.emit(kIoDone, error);
        return;
    }
    if (error) {
        errorOrDestroy(this, error);
    } else if (typeof bytesRead === "number" && bytesRead > 0) {
        if (this.pos !== undefined) {
            this.pos += bytesRead;
        }
        this.bytesRead += bytesRead;
        if (bytesRead !== buffer.length) {
            const dst = Buffer1.allocUnsafeSlow(bytesRead);
            buffer.copy(dst, 0, 0, bytesRead);
            buffer = dst;
        }
        this.push(buffer);
    } else {
        this.push(null);
    }
};
ReadStream.prototype._destroy = function(err, cb) {
    if (this[kIsPerformingIO]) {
        this.once(kIoDone, (er)=>close1(this, err || er, cb));
    } else {
        close1(this, err, cb);
    }
};
ReadStream.prototype.close = function(cb) {
    if (typeof cb === "function") Du(this, cb);
    this.destroy();
};
Object.defineProperty(ReadStream.prototype, "pending", {
    get () {
        return this.fd === null;
    },
    configurable: true
});
function WriteStream(path, options) {
    if (!(this instanceof WriteStream)) {
        return new WriteStream(path, options);
    }
    options = copyObject(getOptions1(options, kEmptyObject));
    options.decodeStrings = true;
    if (options.fd == null) {
        this.fd = null;
        this[kFs] = options.fs || {
            open: open,
            write: write,
            writev: writev,
            close: close
        };
        validateFunction(this[kFs].open, "options.fs.open");
        this.path = toPathIfFileURL(path);
        this.flags = options.flags === undefined ? "w" : options.flags;
        this.mode = options.mode === undefined ? 0o666 : options.mode;
        validatePath(this.path);
    } else {
        this.fd = getValidatedFd(importFd(this, options));
    }
    options.autoDestroy = options.autoClose === undefined ? true : options.autoClose;
    if (!this[kFs].write && !this[kFs].writev) {
        throw new ERR_INVALID_ARG_TYPE("options.fs.write", "function", this[kFs].write);
    }
    if (this[kFs].write) {
        validateFunction(this[kFs].write, "options.fs.write");
    }
    if (this[kFs].writev) {
        validateFunction(this[kFs].writev, "options.fs.writev");
    }
    if (options.autoDestroy) {
        validateFunction(this[kFs].close, "options.fs.close");
    }
    if (!this[kFs].write) {
        this._write = null;
    }
    if (!this[kFs].writev) {
        this._writev = null;
    }
    this.start = options.start;
    this.pos = undefined;
    this.bytesWritten = 0;
    this[kIsPerformingIO] = false;
    if (this.start !== undefined) {
        validateInteger(this.start, "start", 0);
        this.pos = this.start;
    }
    Reflect.apply(mu, this, [
        options
    ]);
    if (options.encoding) {
        this.setDefaultEncoding(options.encoding);
    }
}
Object.setPrototypeOf(WriteStream.prototype, mu.prototype);
Object.setPrototypeOf(WriteStream, mu);
Object.defineProperty(WriteStream.prototype, "autoClose", {
    get () {
        return this._writableState.autoDestroy;
    },
    set (val) {
        this._writableState.autoDestroy = val;
    }
});
const openWriteFs = deprecate(function() {}, "WriteStream.prototype.open() is deprecated", "DEP0135");
WriteStream.prototype.open = openWriteFs;
WriteStream.prototype._construct = _construct;
WriteStream.prototype._write = function(data, _encoding, cb) {
    this[kIsPerformingIO] = true;
    this[kFs].write(this.fd, data, 0, data.length, this.pos, (er, bytes)=>{
        this[kIsPerformingIO] = false;
        if (this.destroyed) {
            cb(er);
            return this.emit(kIoDone, er);
        }
        if (er) {
            return cb(er);
        }
        this.bytesWritten += bytes;
        cb();
    });
    if (this.pos !== undefined) {
        this.pos += data.length;
    }
};
WriteStream.prototype._writev = function(data, cb) {
    const len = data.length;
    const chunks = new Array(len);
    let size = 0;
    for(let i = 0; i < len; i++){
        const chunk = data[i].chunk;
        chunks[i] = chunk;
        size += chunk.length;
    }
    this[kIsPerformingIO] = true;
    this[kFs].writev(this.fd, chunks, this.pos ?? null, (er, bytes)=>{
        this[kIsPerformingIO] = false;
        if (this.destroyed) {
            cb(er);
            return this.emit(kIoDone, er);
        }
        if (er) {
            return cb(er);
        }
        this.bytesWritten += bytes;
        cb();
    });
    if (this.pos !== undefined) {
        this.pos += size;
    }
};
WriteStream.prototype._destroy = function(err, cb) {
    if (this[kIsPerformingIO]) {
        this.once(kIoDone, (er)=>close1(this, err || er, cb));
    } else {
        close1(this, err, cb);
    }
};
WriteStream.prototype.close = function(cb) {
    if (cb) {
        if (this.closed) {
            nextTick1(cb);
            return;
        }
        this.on("close", cb);
    }
    if (!this.autoClose) {
        this.on("finish", this.destroy);
    }
    this.end();
};
WriteStream.prototype.destroySoon = WriteStream.prototype.end;
Object.defineProperty(WriteStream.prototype, "pending", {
    get () {
        return this.fd === null;
    },
    configurable: true
});
function createReadStream(path, options) {
    return new ReadStream(path, options);
}
function createWriteStream(path, options) {
    return new WriteStream(path, options);
}
const { F_OK: F_OK2 , R_OK: R_OK2 , W_OK: W_OK2 , X_OK: X_OK2 , O_RDONLY: O_RDONLY2 , O_WRONLY: O_WRONLY2 , O_RDWR: O_RDWR2 , O_NOCTTY: O_NOCTTY1 , O_TRUNC: O_TRUNC2 , O_APPEND: O_APPEND2 , O_DIRECTORY: O_DIRECTORY1 , O_NOFOLLOW: O_NOFOLLOW1 , O_SYNC: O_SYNC2 , O_DSYNC: O_DSYNC1 , O_SYMLINK: O_SYMLINK1 , O_NONBLOCK: O_NONBLOCK1 , O_CREAT: O_CREAT2 , O_EXCL: O_EXCL2  } = mod53;
const promises1 = {
    access: accessPromise,
    copyFile: copyFilePromise,
    open: openPromise,
    opendir: opendirPromise,
    rename: renamePromise,
    truncate: truncatePromise,
    rm: rmPromise,
    rmdir: rmdirPromise,
    mkdir: mkdirPromise,
    readdir: readdirPromise,
    readlink: readlinkPromise,
    symlink: symlinkPromise,
    lstat: lstatPromise,
    stat: statPromise,
    link: linkPromise,
    unlink: unlinkPromise,
    chmod: chmodPromise,
    chown: chownPromise,
    utimes: utimesPromise,
    realpath: realpathPromise,
    mkdtemp: mkdtempPromise,
    writeFile: writeFilePromise,
    appendFile: appendFilePromise,
    readFile: readFilePromise,
    watch: watchPromise
};
const __default33 = {
    access,
    accessSync,
    appendFile,
    appendFileSync,
    chmod,
    chmodSync,
    chown,
    chownSync,
    close,
    closeSync,
    constants: mod53,
    copyFile,
    copyFileSync,
    createReadStream,
    createWriteStream,
    Dir,
    Dirent: Dirent1,
    exists,
    existsSync,
    F_OK: F_OK2,
    fdatasync,
    fdatasyncSync,
    fstat,
    fstatSync,
    fsync,
    fsyncSync,
    ftruncate,
    ftruncateSync,
    futimes,
    futimesSync,
    link,
    linkSync,
    lstat,
    lstatSync,
    mkdir,
    mkdirSync,
    mkdtemp,
    mkdtempSync,
    O_APPEND: O_APPEND2,
    O_CREAT: O_CREAT2,
    O_DIRECTORY: O_DIRECTORY1,
    O_DSYNC: O_DSYNC1,
    O_EXCL: O_EXCL2,
    O_NOCTTY: O_NOCTTY1,
    O_NOFOLLOW: O_NOFOLLOW1,
    O_NONBLOCK: O_NONBLOCK1,
    O_RDONLY: O_RDONLY2,
    O_RDWR: O_RDWR2,
    O_SYMLINK: O_SYMLINK1,
    O_SYNC: O_SYNC2,
    O_TRUNC: O_TRUNC2,
    O_WRONLY: O_WRONLY2,
    open,
    openSync,
    opendir,
    opendirSync,
    read,
    readSync,
    promises: promises1,
    R_OK: R_OK2,
    readdir,
    readdirSync,
    readFile,
    readFileSync,
    readlink,
    readlinkSync,
    ReadStream,
    realpath,
    realpathSync,
    rename,
    renameSync,
    rmdir,
    rmdirSync,
    rm,
    rmSync,
    stat,
    Stats,
    statSync,
    symlink,
    symlinkSync,
    truncate,
    truncateSync,
    unlink,
    unlinkSync,
    unwatchFile,
    utimes,
    utimesSync,
    W_OK: W_OK2,
    watch,
    watchFile,
    write,
    writeFile,
    writev,
    writevSync,
    writeFileSync,
    WriteStream,
    writeSync,
    X_OK: X_OK2
};
var EOL;
(function(EOL) {
    EOL["LF"] = "\n";
    EOL["CRLF"] = "\r\n";
})(EOL || (EOL = {}));
const SEE_GITHUB_ISSUE = "See https://github.com/denoland/deno_std/issues/1436";
const DenoOsUptime = Deno[Deno.internal]?.nodeUnstable?.osUptime || Deno.osUptime;
function arch1() {
    return process2.arch;
}
arch1[Symbol.toPrimitive] = ()=>process2.arch;
endianness[Symbol.toPrimitive] = ()=>endianness();
freemem[Symbol.toPrimitive] = ()=>freemem();
homedir[Symbol.toPrimitive] = ()=>homedir();
hostname[Symbol.toPrimitive] = ()=>hostname();
platform1[Symbol.toPrimitive] = ()=>platform1();
release[Symbol.toPrimitive] = ()=>release();
version1[Symbol.toPrimitive] = ()=>version1();
totalmem[Symbol.toPrimitive] = ()=>totalmem();
type[Symbol.toPrimitive] = ()=>type();
uptime[Symbol.toPrimitive] = ()=>uptime();
function cpus() {
    return Array.from(Array(navigator.hardwareConcurrency)).map(()=>{
        return {
            model: "",
            speed: 0,
            times: {
                user: 0,
                nice: 0,
                sys: 0,
                idle: 0,
                irq: 0
            }
        };
    });
}
function endianness() {
    const buffer = new ArrayBuffer(2);
    new DataView(buffer).setInt16(0, 256, true);
    return new Int16Array(buffer)[0] === 256 ? "LE" : "BE";
}
function freemem() {
    return Deno.systemMemoryInfo().free;
}
function getPriority(pid = 0) {
    validateIntegerRange(pid, "pid");
    notImplemented(SEE_GITHUB_ISSUE);
}
function homedir() {
    switch(osType){
        case "windows":
            return Deno.env.get("USERPROFILE") || null;
        case "linux":
        case "darwin":
        case "freebsd":
            return Deno.env.get("HOME") || null;
        default:
            throw Error("unreachable");
    }
}
function hostname() {
    return Deno.hostname();
}
function loadavg() {
    if (isWindows) {
        return [
            0,
            0,
            0
        ];
    }
    return Deno.loadavg();
}
function networkInterfaces() {
    const interfaces = {};
    for (const { name , address , netmask , family , mac , scopeid , cidr  } of Deno.networkInterfaces()){
        const addresses = interfaces[name] ||= [];
        const networkAddress = {
            address,
            netmask,
            family,
            mac,
            internal: family === "IPv4" && isIPv4LoopbackAddr(address) || family === "IPv6" && isIPv6LoopbackAddr(address),
            cidr
        };
        if (family === "IPv6") {
            networkAddress.scopeid = scopeid;
        }
        addresses.push(networkAddress);
    }
    return interfaces;
}
function isIPv4LoopbackAddr(addr) {
    return addr.startsWith("127");
}
function isIPv6LoopbackAddr(addr) {
    return addr === "::1" || addr === "fe80::1";
}
function platform1() {
    return process2.platform;
}
function release() {
    return Deno.osRelease();
}
function version1() {
    return Deno.osRelease();
}
function setPriority(pid, priority) {
    if (priority === undefined) {
        priority = pid;
        pid = 0;
    }
    validateIntegerRange(pid, "pid");
    validateIntegerRange(priority, "priority", -20, 19);
    notImplemented(SEE_GITHUB_ISSUE);
}
function tmpdir() {
    if (isWindows) {
        const temp = Deno.env.get("TEMP") || Deno.env.get("TMP");
        if (temp) {
            return temp.replace(/(?<!:)[/\\]*$/, "");
        }
        const base = Deno.env.get("SYSTEMROOT") || Deno.env.get("WINDIR");
        if (base) {
            return base + "\\temp";
        }
        return null;
    } else {
        const temp = Deno.env.get("TMPDIR") || Deno.env.get("TMP") || Deno.env.get("TEMP") || "/tmp";
        return temp.replace(/(?<!^)\/*$/, "");
    }
}
function totalmem() {
    return Deno.systemMemoryInfo().total;
}
function type() {
    switch(Deno.build.os){
        case "windows":
            return "Windows_NT";
        case "linux":
            return "Linux";
        case "darwin":
            return "Darwin";
        case "freebsd":
            return "FreeBSD";
        default:
            throw Error("unreachable");
    }
}
function uptime() {
    return DenoOsUptime();
}
function userInfo(options = {
    encoding: "utf-8"
}) {
    notImplemented(SEE_GITHUB_ISSUE);
}
const EOL1 = isWindows ? EOL.CRLF : EOL.LF;
const devNull = isWindows ? "\\\\.\\nul" : "/dev/null";
const __default34 = {
    arch: arch1,
    cpus,
    endianness,
    freemem,
    getPriority,
    homedir,
    hostname,
    loadavg,
    networkInterfaces,
    platform: platform1,
    release,
    setPriority,
    tmpdir,
    totalmem,
    type,
    uptime,
    userInfo,
    version: version1,
    constants: os,
    EOL: EOL1,
    devNull
};
const { F_OK: F_OK3 , R_OK: R_OK3 , W_OK: W_OK3 , X_OK: X_OK3 , O_RDONLY: O_RDONLY3 , O_WRONLY: O_WRONLY3 , O_RDWR: O_RDWR3 , O_NOCTTY: O_NOCTTY2 , O_TRUNC: O_TRUNC3 , O_APPEND: O_APPEND3 , O_DIRECTORY: O_DIRECTORY2 , O_NOFOLLOW: O_NOFOLLOW2 , O_SYNC: O_SYNC3 , O_DSYNC: O_DSYNC2 , O_SYMLINK: O_SYMLINK2 , O_NONBLOCK: O_NONBLOCK2 , O_CREAT: O_CREAT3 , O_EXCL: O_EXCL3 , S_IRUSR: S_IRUSR1 , S_IWUSR: S_IWUSR1 , S_IXUSR: S_IXUSR1 , S_IRGRP: S_IRGRP1 , S_IWGRP: S_IWGRP1 , S_IXGRP: S_IXGRP1 , S_IROTH: S_IROTH1 , S_IWOTH: S_IWOTH1 , S_IXOTH: S_IXOTH1 , COPYFILE_EXCL: COPYFILE_EXCL2 , COPYFILE_FICLONE: COPYFILE_FICLONE2 , COPYFILE_FICLONE_FORCE: COPYFILE_FICLONE_FORCE2 , UV_FS_COPYFILE_EXCL: UV_FS_COPYFILE_EXCL1 , UV_FS_COPYFILE_FICLONE: UV_FS_COPYFILE_FICLONE1 , UV_FS_COPYFILE_FICLONE_FORCE: UV_FS_COPYFILE_FICLONE_FORCE1  } = mod53;
const { RTLD_DEEPBIND , RTLD_GLOBAL , RTLD_LAZY , RTLD_LOCAL , RTLD_NOW  } = os.dlopen;
const { E2BIG , EACCES , EADDRINUSE , EADDRNOTAVAIL , EAFNOSUPPORT , EAGAIN , EALREADY , EBADF , EBADMSG , EBUSY , ECANCELED , ECHILD , ECONNABORTED , ECONNREFUSED , ECONNRESET , EDEADLK , EDESTADDRREQ , EDOM , EDQUOT , EEXIST , EFAULT , EFBIG , EHOSTUNREACH , EIDRM , EILSEQ , EINPROGRESS , EINTR , EINVAL , EIO , EISCONN , EISDIR: EISDIR1 , ELOOP , EMFILE , EMLINK , EMSGSIZE , EMULTIHOP , ENAMETOOLONG , ENETDOWN , ENETRESET , ENETUNREACH , ENFILE , ENOBUFS , ENODATA , ENODEV , ENOENT: ENOENT1 , ENOEXEC , ENOLCK , ENOLINK , ENOMEM , ENOMSG , ENOPROTOOPT , ENOSPC , ENOSR , ENOSTR , ENOSYS , ENOTCONN , ENOTDIR: ENOTDIR1 , ENOTEMPTY , ENOTSOCK , ENOTSUP , ENOTTY , ENXIO , EOPNOTSUPP , EOVERFLOW , EPERM , EPIPE , EPROTO , EPROTONOSUPPORT , EPROTOTYPE , ERANGE , EROFS , ESPIPE , ESRCH , ESTALE , ETIME , ETIMEDOUT , ETXTBSY , EWOULDBLOCK , EXDEV  } = os.errno;
const { PRIORITY_ABOVE_NORMAL , PRIORITY_BELOW_NORMAL , PRIORITY_HIGH , PRIORITY_HIGHEST , PRIORITY_LOW , PRIORITY_NORMAL  } = os.priority;
const { SIGABRT , SIGALRM , SIGBUS , SIGCHLD , SIGCONT , SIGFPE , SIGHUP , SIGILL , SIGINT , SIGIO , SIGIOT , SIGKILL , SIGPIPE , SIGPOLL , SIGPROF , SIGPWR , SIGQUIT , SIGSEGV , SIGSTKFLT , SIGSTOP , SIGSYS , SIGTERM , SIGTRAP , SIGTSTP , SIGTTIN , SIGTTOU , SIGUNUSED , SIGURG , SIGUSR1 , SIGUSR2 , SIGVTALRM , SIGWINCH , SIGXCPU , SIGXFSZ  } = os.signals;
const __default35 = {
    ...mod53,
    ...os.dlopen,
    ...os.errno,
    ...os.signals,
    ...os.priority
};
const MAX_RANDOM_VALUES = 65536;
function generateRandomBytes(size) {
    if (size > 4294967295) {
        throw new RangeError(`The value of "size" is out of range. It must be >= 0 && <= ${4294967295}. Received ${size}`);
    }
    const bytes = Buffer1.allocUnsafe(size);
    if (size > 65536) {
        for(let generated = 0; generated < size; generated += MAX_RANDOM_VALUES){
            globalThis.crypto.getRandomValues(bytes.slice(generated, generated + 65536));
        }
    } else {
        globalThis.crypto.getRandomValues(bytes);
    }
    return bytes;
}
function randomBytes(size, cb) {
    if (typeof cb === "function") {
        let err = null, bytes;
        try {
            bytes = generateRandomBytes(size);
        } catch (e) {
            if (e instanceof RangeError && e.message.includes('The value of "size" is out of range')) {
                throw e;
            } else if (e instanceof Error) {
                err = e;
            } else {
                err = new Error("[non-error thrown]");
            }
        }
        setTimeout(()=>{
            if (err) {
                cb(err);
            } else {
                cb(null, bytes);
            }
        }, 0);
    } else {
        return generateRandomBytes(size);
    }
}
function assertOffset(offset, length) {
    if (offset > 4294967295 || offset < 0) {
        throw new TypeError("offset must be a uint32");
    }
    if (offset > 0x7fffffff || offset > length) {
        throw new RangeError("offset out of range");
    }
}
function assertSize1(size, offset, length) {
    if (size > 4294967295 || size < 0) {
        throw new TypeError("size must be a uint32");
    }
    if (size + offset > length || size > 0x7fffffff) {
        throw new RangeError("buffer too small");
    }
}
function randomFill(buf, offset, size, cb) {
    if (typeof offset === "function") {
        cb = offset;
        offset = 0;
        size = buf.length;
    } else if (typeof size === "function") {
        cb = size;
        size = buf.length - Number(offset);
    }
    assertOffset(offset, buf.length);
    assertSize1(size, offset, buf.length);
    randomBytes(size, (err, bytes)=>{
        if (err) return cb(err, buf);
        bytes?.copy(buf, offset);
        cb(null, buf);
    });
}
function randomFillSync(buf, offset = 0, size) {
    assertOffset(offset, buf.length);
    if (size === undefined) size = buf.length - offset;
    assertSize1(size, offset, buf.length);
    const bytes = randomBytes(size);
    bytes.copy(buf, offset);
    return buf;
}
function randomInt(max, min, cb) {
    if (typeof max === "number" && typeof min === "number") {
        [max, min] = [
            min,
            max
        ];
    }
    if (min === undefined) min = 0;
    else if (typeof min === "function") {
        cb = min;
        min = 0;
    }
    if (!Number.isSafeInteger(min) || typeof max === "number" && !Number.isSafeInteger(max)) {
        throw new Error("max or min is not a Safe Number");
    }
    if (max - min > Math.pow(2, 48)) {
        throw new RangeError("max - min should be less than 2^48!");
    }
    if (min >= max) {
        throw new Error("Min is bigger than Max!");
    }
    const randomBuffer = new Uint32Array(1);
    globalThis.crypto.getRandomValues(randomBuffer);
    const randomNumber = randomBuffer[0] / (0xffffffff + 1);
    min = Math.ceil(min);
    max = Math.floor(max);
    const result = Math.floor(randomNumber * (max - min)) + min;
    if (cb) {
        cb(null, result);
        return;
    }
    return result;
}
function checkPrime(_candidate, _options, _callback) {
    notImplemented("crypto.checkPrime");
}
function checkPrimeSync(_candidate, _options) {
    notImplemented("crypto.checkPrimeSync");
}
function generatePrime(_size, _options, _callback) {
    notImplemented("crypto.generatePrime");
}
function generatePrimeSync(_size, _options) {
    notImplemented("crypto.generatePrimeSync");
}
const randomUUID = ()=>globalThis.crypto.randomUUID();
const __default36 = {
    checkPrime,
    checkPrimeSync,
    generatePrime,
    generatePrimeSync,
    randomUUID,
    randomInt,
    randomBytes,
    randomFill,
    randomFillSync
};
let wasm;
const heap = new Array(32).fill(undefined);
heap.push(undefined, null, true, false);
function getObject(idx) {
    return heap[idx];
}
let heap_next = heap.length;
function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}
function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}
function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];
    heap[idx] = obj;
    return idx;
}
const cachedTextDecoder = new TextDecoder("utf-8", {
    ignoreBOM: true,
    fatal: true
});
cachedTextDecoder.decode();
let cachedUint8Memory0 = new Uint8Array();
function getUint8Memory0() {
    if (cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
let WASM_VECTOR_LEN = 0;
const cachedTextEncoder = new TextEncoder("utf-8");
const encodeString = function(arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
};
function passStringToWasm0(arg, malloc, realloc) {
    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length);
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }
    let len = arg.length;
    let ptr = malloc(len);
    const mem = getUint8Memory0();
    let offset = 0;
    for(; offset < len; offset++){
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }
    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);
        offset += ret.written;
    }
    WASM_VECTOR_LEN = offset;
    return ptr;
}
function isLikeNone(x) {
    return x === undefined || x === null;
}
let cachedInt32Memory0 = new Int32Array();
function getInt32Memory0() {
    if (cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachedInt32Memory0;
}
function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function digest(algorithm, data, length) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.digest(retptr, ptr0, len0, addHeapObject(data), !isLikeNone(length), isLikeNone(length) ? 0 : length);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        if (r3) {
            throw takeObject(r2);
        }
        var v1 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_free(r0, r1 * 1);
        return v1;
    } finally{
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}
const DigestContextFinalization = new FinalizationRegistry((ptr)=>wasm.__wbg_digestcontext_free(ptr));
class DigestContext {
    static __wrap(ptr) {
        const obj = Object.create(DigestContext.prototype);
        obj.ptr = ptr;
        DigestContextFinalization.register(obj, obj.ptr, obj);
        return obj;
    }
    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DigestContextFinalization.unregister(this);
        return ptr;
    }
    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_digestcontext_free(ptr);
    }
    constructor(algorithm){
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.digestcontext_new(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DigestContext.__wrap(r0);
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    update(data) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_update(retptr, this.ptr, addHeapObject(data));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digest(length) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digest(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digestAndReset(length) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digestAndReset(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digestAndDrop(length) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digestAndDrop(retptr, ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    reset() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_reset(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    clone() {
        const ret = wasm.digestcontext_clone(this.ptr);
        return DigestContext.__wrap(ret);
    }
}
const imports = {
    __wbindgen_placeholder__: {
        __wbg_new_db254ae0a1bb0ff5: function(arg0, arg1) {
            const ret = new TypeError(getStringFromWasm0(arg0, arg1));
            return addHeapObject(ret);
        },
        __wbindgen_object_drop_ref: function(arg0) {
            takeObject(arg0);
        },
        __wbg_byteLength_87a0436a74adc26c: function(arg0) {
            const ret = getObject(arg0).byteLength;
            return ret;
        },
        __wbg_byteOffset_4477d54710af6f9b: function(arg0) {
            const ret = getObject(arg0).byteOffset;
            return ret;
        },
        __wbg_buffer_21310ea17257b0b4: function(arg0) {
            const ret = getObject(arg0).buffer;
            return addHeapObject(ret);
        },
        __wbg_newwithbyteoffsetandlength_d9aa266703cb98be: function(arg0, arg1, arg2) {
            const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
            return addHeapObject(ret);
        },
        __wbg_length_9e1ae1900cb0fbd5: function(arg0) {
            const ret = getObject(arg0).length;
            return ret;
        },
        __wbindgen_memory: function() {
            const ret = wasm.memory;
            return addHeapObject(ret);
        },
        __wbg_buffer_3f3d764d4747d564: function(arg0) {
            const ret = getObject(arg0).buffer;
            return addHeapObject(ret);
        },
        __wbg_new_8c3f0052272a457a: function(arg0) {
            const ret = new Uint8Array(getObject(arg0));
            return addHeapObject(ret);
        },
        __wbg_set_83db9690f9353e79: function(arg0, arg1, arg2) {
            getObject(arg0).set(getObject(arg1), arg2 >>> 0);
        },
        __wbindgen_throw: function(arg0, arg1) {
            throw new Error(getStringFromWasm0(arg0, arg1));
        }
    }
};
function instantiate() {
    return instantiateWithInstance().exports;
}
let instanceWithExports;
function instantiateWithInstance() {
    if (instanceWithExports == null) {
        const instance = instantiateInstance();
        wasm = instance.exports;
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
        instanceWithExports = {
            instance,
            exports: {
                digest,
                DigestContext
            }
        };
    }
    return instanceWithExports;
}
function instantiateInstance() {
    const wasmBytes = base64decode("\
AGFzbQEAAAABrIGAgAAZYAAAYAABf2ABfwBgAX8Bf2ABfwF+YAJ/fwBgAn9/AX9gA39/fwBgA39/fw\
F/YAR/f39/AGAEf39/fwF/YAV/f39/fwBgBX9/f39/AX9gBn9/f39/fwBgBn9/f39/fwF/YAV/f39+\
fwBgB39/f35/f38Bf2ADf39+AGAFf39+f38AYAV/f31/fwBgBX9/fH9/AGACf34AYAR/fn9/AGAEf3\
1/fwBgBH98f38AAqSFgIAADBhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmdfbmV3X2RiMjU0\
YWUwYTFiYjBmZjUABhhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmluZGdlbl9vYmplY3RfZH\
JvcF9yZWYAAhhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18hX193YmdfYnl0ZUxlbmd0aF84N2EwNDM2\
YTc0YWRjMjZjAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fIV9fd2JnX2J5dGVPZmZzZXRfNDQ3N2\
Q1NDcxMGFmNmY5YgADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXx1fX3diZ19idWZmZXJfMjEzMTBl\
YTE3MjU3YjBiNAADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXzFfX3diZ19uZXd3aXRoYnl0ZW9mZn\
NldGFuZGxlbmd0aF9kOWFhMjY2NzAzY2I5OGJlAAgYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9f\
d2JnX2xlbmd0aF85ZTFhZTE5MDBjYjBmYmQ1AAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEV9fd2\
JpbmRnZW5fbWVtb3J5AAEYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2J1ZmZlcl8zZjNk\
NzY0ZDQ3NDdkNTY0AAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld184YzNmMDA1Mj\
I3MmE0NTdhAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX3NldF84M2RiOTY5MGY5MzUz\
ZTc5AAcYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEF9fd2JpbmRnZW5fdGhyb3cABQOPgYCAAI0BCw\
cLBwMJEQUHBwUHDwMHBQgFEAUHBQIHBQIGBwYHFQgHDgcHBwYBAQEBBwgHBwcBBwcHAQgHBwcHBwUC\
BwcHBwcBAQcHBQ0IBwkHCQEBAQEBBQkNCwkFBQUFBQUGBgcHBwcCAggHBwUCCgAFAgMCAg4MCwwLCx\
MUEgkICAYGBQcHAAYDAAAFCAgIBAACBIWAgIAAAXABFRUFg4CAgAABABEGiYCAgAABfwFBgIDAAAsH\
uYKAgAAOBm1lbW9yeQIABmRpZ2VzdABSGF9fd2JnX2RpZ2VzdGNvbnRleHRfZnJlZQBuEWRpZ2VzdG\
NvbnRleHRfbmV3AFYUZGlnZXN0Y29udGV4dF91cGRhdGUAcRRkaWdlc3Rjb250ZXh0X2RpZ2VzdABV\
HGRpZ2VzdGNvbnRleHRfZGlnZXN0QW5kUmVzZXQAVxtkaWdlc3Rjb250ZXh0X2RpZ2VzdEFuZERyb3\
AAXhNkaWdlc3Rjb250ZXh0X3Jlc2V0ACETZGlnZXN0Y29udGV4dF9jbG9uZQAQH19fd2JpbmRnZW5f\
YWRkX3RvX3N0YWNrX3BvaW50ZXIAjwERX193YmluZGdlbl9tYWxsb2MAeRJfX3diaW5kZ2VuX3JlYW\
xsb2MAhgEPX193YmluZGdlbl9mcmVlAIoBCaaAgIAAAQBBAQsUiAGJASiOAX1ffn98hwGFAYABgQGC\
AYMBhAGYAWlolgEK//KIgACNAYZ2AhF/An4jAEHAKGsiBSQAAkACQAJAAkACQAJAAkACQAJAAkACQA\
JAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABDhgAAQIDBAUGBwgJCgsMDQ4PEBES\
ExQVFhcAC0HQARAZIgZFDRggBUHQE2pBOGogAkE4aikDADcDACAFQdATakEwaiACQTBqKQMANwMAIA\
VB0BNqQShqIAJBKGopAwA3AwAgBUHQE2pBIGogAkEgaikDADcDACAFQdATakEYaiACQRhqKQMANwMA\
IAVB0BNqQRBqIAJBEGopAwA3AwAgBUHQE2pBCGogAkEIaikDADcDACAFIAIpAwA3A9ATIAIpA0AhFi\
AFQdATakHIAGogAkHIAGoQYiAFIBY3A5AUIAYgBUHQE2pB0AEQlAEaDBcLQdABEBkiBkUNFyAFQdAT\
akE4aiACQThqKQMANwMAIAVB0BNqQTBqIAJBMGopAwA3AwAgBUHQE2pBKGogAkEoaikDADcDACAFQd\
ATakEgaiACQSBqKQMANwMAIAVB0BNqQRhqIAJBGGopAwA3AwAgBUHQE2pBEGogAkEQaikDADcDACAF\
QdATakEIaiACQQhqKQMANwMAIAUgAikDADcD0BMgAikDQCEWIAVB0BNqQcgAaiACQcgAahBiIAUgFj\
cDkBQgBiAFQdATakHQARCUARoMFgtB0AEQGSIGRQ0WIAVB0BNqQThqIAJBOGopAwA3AwAgBUHQE2pB\
MGogAkEwaikDADcDACAFQdATakEoaiACQShqKQMANwMAIAVB0BNqQSBqIAJBIGopAwA3AwAgBUHQE2\
pBGGogAkEYaikDADcDACAFQdATakEQaiACQRBqKQMANwMAIAVB0BNqQQhqIAJBCGopAwA3AwAgBSAC\
KQMANwPQEyACKQNAIRYgBUHQE2pByABqIAJByABqEGIgBSAWNwOQFCAGIAVB0BNqQdABEJQBGgwVC0\
HwABAZIgZFDRUgBUHQE2pBIGogAkEgaikDADcDACAFQdATakEYaiACQRhqKQMANwMAIAVB0BNqQRBq\
IAJBEGopAwA3AwAgBSACKQMINwPYEyACKQMAIRYgBUHQE2pBKGogAkEoahBRIAUgFjcD0BMgBiAFQd\
ATakHwABCUARoMFAtB+A4QGSIGRQ0UIAVB0BNqQYgBaiACQYgBaikDADcDACAFQdATakGAAWogAkGA\
AWopAwA3AwAgBUHQE2pB+ABqIAJB+ABqKQMANwMAIAVB0BNqQRBqIAJBEGopAwA3AwAgBUHQE2pBGG\
ogAkEYaikDADcDACAFQdATakEgaiACQSBqKQMANwMAIAVB0BNqQTBqIAJBMGopAwA3AwAgBUHQE2pB\
OGogAkE4aikDADcDACAFQdATakHAAGogAkHAAGopAwA3AwAgBUHQE2pByABqIAJByABqKQMANwMAIA\
VB0BNqQdAAaiACQdAAaikDADcDACAFQdATakHYAGogAkHYAGopAwA3AwAgBUHQE2pB4ABqIAJB4ABq\
KQMANwMAIAUgAikDcDcDwBQgBSACKQMINwPYEyAFIAIpAyg3A/gTIAIpAwAhFkEAIQcgBUEANgLgFC\
ACKAKQASIIQf///z9xIglBNyAJQTdJGyEKIAJBlAFqIgkgCEEFdCILaiEMIAVBxCJqIQ0gAi0AaiEO\
IAItAGkhDyACLQBoIRACQANAIAsgB0YNASAFQdATaiAHakGUAWoiAiAJKQAANwAAIAJBGGogCUEYai\
kAADcAACACQRBqIAlBEGopAAA3AAAgAkEIaiAJQQhqKQAANwAAIAlBIGoiCCAMRg0BIAJBIGogCCkA\
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\
GGoiDCAEQdATakEcaikCADcDACAEQfgmakEQaiILIARB0BNqQRRqKQIANwMAIARB+CZqQQhqIg0gBE\
HQE2pBDGopAgA3AwAgBCAEKQLUEzcD+CYgBEHQE2ogBEHQARCUARogBCAEKQOQFCAEQZgVai0AACIC\
rXw3A5AUIARBmBRqIQECQCACQYABRg0AIAEgAmpBAEGAASACaxCTARoLIARBADoAmBUgBEHQE2ogAU\
J/EBIgBEH4DmpBCGoiAiAEQdATakEIaikDADcDACAEQfgOakEQaiIBIARB0BNqQRBqKQMANwMAIARB\
+A5qQRhqIgogBEHQE2pBGGopAwA3AwAgBEH4DmpBIGoiDiAEKQPwEzcDACAEQfgOakEoaiIPIARB0B\
NqQShqKQMANwMAIARB+A5qQTBqIhAgBEHQE2pBMGopAwA3AwAgBEH4DmpBOGoiESAEQdATakE4aikD\
ADcDACAEIAQpA9ATNwP4DiANIAIpAwA3AwAgCyABKQMANwMAIAwgCikDADcDACAHIA4pAwA3AwAgCC\
APKQMANwMAIAMgECkDADcDACAJIBEpAwA3AwAgBCAEKQP4DjcD+CZBwAAQGSICRQ0cIAIgBCkD+CY3\
AAAgAkE4aiAEQfgmakE4aikDADcAACACQTBqIARB+CZqQTBqKQMANwAAIAJBKGogBEH4JmpBKGopAw\
A3AAAgAkEgaiAEQfgmakEgaikDADcAACACQRhqIARB+CZqQRhqKQMANwAAIAJBEGogBEH4JmpBEGop\
AwA3AAAgAkEIaiAEQfgmakEIaikDADcAACAGECJBwAAhBAweCyAFIAZB0AEQlAEiBEH4DmpBDGpCAD\
cCACAEQfgOakEUakIANwIAIARB+A5qQRxqQgA3AgAgBEIANwL8DiAEQQA2AvgOIARB+A5qIARB+A5q\
QQRyQX9zakEkakEHSRogBEEgNgL4DiAEQdATakEQaiIHIARB+A5qQRBqIgIpAwA3AwAgBEHQE2pBCG\
oiDCAEQfgOakEIaiIBKQMANwMAIARB0BNqQRhqIgsgBEH4DmpBGGoiCSkDADcDACAEQdATakEgaiAE\
QfgOakEgaiINKAIANgIAIARB+CZqQQhqIgogBEHQE2pBDGopAgA3AwAgBEH4JmpBEGoiDiAEQdATak\
EUaikCADcDACAEQfgmakEYaiIPIARB0BNqQRxqKQIANwMAIAQgBCkD+A43A9ATIAQgBCkC1BM3A/gm\
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\
AgAgAUGUD2pBADYCACABQgA3AvwOIAFBADYC+A5BBCECIAFB+A5qIAFB+A5qQQRyQX9zakEgaiEEA0\
AgAkF/aiICDQALAkAgBEEHSQ0AQRghAgNAIAJBeGoiAg0ACwtBHCEEIAFBHDYC+A4gAUHQE2pBEGog\
AUH4DmpBEGopAwA3AwAgAUHQE2pBCGogAUH4DmpBCGopAwA3AwAgAUHQE2pBGGogAUH4DmpBGGopAw\
A3AwAgAUH4JmpBCGoiCSABQdwTaikCADcDACABQfgmakEQaiIDIAFB5BNqKQIANwMAIAFB+CZqQRhq\
IgggAUHQE2pBHGooAgA2AgAgASABKQP4DjcD0BMgASABKQLUEzcD+CYgAUHQE2ogAUHgAhCUARogAU\
HQE2ogAUGYFWogAUH4JmoQOEEcEBkiAkUNFyACIAEpA/gmNwAAIAJBGGogCCgCADYAACACQRBqIAMp\
AwA3AAAgAkEIaiAJKQMANwAADBYLIAUgBkHYAhCUASIBQfgOakEMakIANwIAIAFB+A5qQRRqQgA3Ag\
AgAUH4DmpBHGpCADcCACABQgA3AvwOIAFBADYC+A4gAUH4DmogAUH4DmpBBHJBf3NqQSRqQQdJGkEg\
IQQgAUEgNgL4DiABQdATakEQaiABQfgOakEQaikDADcDACABQdATakEIaiABQfgOakEIaikDADcDAC\
ABQdATakEYaiABQfgOakEYaikDADcDACABQdATakEgaiABQfgOakEgaigCADYCACABQfgmakEIaiIJ\
IAFB0BNqQQxqKQIANwMAIAFB+CZqQRBqIgMgAUHQE2pBFGopAgA3AwAgAUH4JmpBGGoiCCABQdATak\
EcaikCADcDACABIAEpA/gONwPQEyABIAEpAtQTNwP4JiABQdATaiABQdgCEJQBGiABQdATaiABQZgV\
aiABQfgmahBBQSAQGSICRQ0WIAIgASkD+CY3AAAgAkEYaiAIKQMANwAAIAJBEGogAykDADcAACACQQ\
hqIAkpAwA3AAAMFQsgBSAGQbgCEJQBIgFB+A5qQQxqQgA3AgAgAUH4DmpBFGpCADcCACABQfgOakEc\
akIANwIAIAFB+A5qQSRqQgA3AgAgAUH4DmpBLGpCADcCACABQgA3AvwOIAFBADYC+A4gAUH4DmogAU\
H4DmpBBHJBf3NqQTRqQQdJGkEwIQQgAUEwNgL4DiABQdATakEQaiABQfgOakEQaikDADcDACABQdAT\
akEIaiABQfgOakEIaikDADcDACABQdATakEYaiABQfgOakEYaikDADcDACABQdATakEgaiABQfgOak\
EgaikDADcDACABQdATakEoaiABQfgOakEoaikDADcDACABQdATakEwaiABQfgOakEwaigCADYCACAB\
QfgmakEIaiIJIAFB0BNqQQxqKQIANwMAIAFB+CZqQRBqIgMgAUHQE2pBFGopAgA3AwAgAUH4JmpBGG\
oiCCABQdATakEcaikCADcDACABQfgmakEgaiIHIAFB0BNqQSRqKQIANwMAIAFB+CZqQShqIgwgAUHQ\
E2pBLGopAgA3AwAgASABKQP4DjcD0BMgASABKQLUEzcD+CYgAUHQE2ogAUG4AhCUARogAUHQE2ogAU\
GYFWogAUH4JmoQSUEwEBkiAkUNFSACIAEpA/gmNwAAIAJBKGogDCkDADcAACACQSBqIAcpAwA3AAAg\
AkEYaiAIKQMANwAAIAJBEGogAykDADcAACACQQhqIAkpAwA3AAAMFAsgBSAGQZgCEJQBIgFB+A5qQQ\
xqQgA3AgAgAUH4DmpBFGpCADcCACABQfgOakEcakIANwIAIAFB+A5qQSRqQgA3AgAgAUH4DmpBLGpC\
ADcCACABQfgOakE0akIANwIAIAFB+A5qQTxqQgA3AgAgAUIANwL8DiABQQA2AvgOIAFB+A5qIAFB+A\
5qQQRyQX9zakHEAGpBB0kaQcAAIQQgAUHAADYC+A4gAUHQE2ogAUH4DmpBxAAQlAEaIAFB+CZqQThq\
IgkgAUHQE2pBPGopAgA3AwAgAUH4JmpBMGoiAyABQdATakE0aikCADcDACABQfgmakEoaiIIIAFB0B\
NqQSxqKQIANwMAIAFB+CZqQSBqIgcgAUHQE2pBJGopAgA3AwAgAUH4JmpBGGoiDCABQdATakEcaikC\
ADcDACABQfgmakEQaiILIAFB0BNqQRRqKQIANwMAIAFB+CZqQQhqIg0gAUHQE2pBDGopAgA3AwAgAS\
ABKQLUEzcD+CYgAUHQE2ogAUGYAhCUARogAUHQE2ogAUGYFWogAUH4JmoQS0HAABAZIgJFDRQgAiAB\
KQP4JjcAACACQThqIAkpAwA3AAAgAkEwaiADKQMANwAAIAJBKGogCCkDADcAACACQSBqIAcpAwA3AA\
AgAkEYaiAMKQMANwAAIAJBEGogCykDADcAACACQQhqIA0pAwA3AAAMEwsgBSAGQeAAEJQBIgFB+A5q\
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\
aiABQfgmahBCQSAQGSICRQ0OIAIgASkD+CY3AAAgAkEYaiAIKQMANwAAIAJBEGogAykDADcAACACQQ\
hqIAkpAwA3AAAMDQsgBSAGQbgCEJQBIgFB+A5qQQxqQgA3AgAgAUH4DmpBFGpCADcCACABQfgOakEc\
akIANwIAIAFB+A5qQSRqQgA3AgAgAUH4DmpBLGpCADcCACABQgA3AvwOIAFBADYC+A4gAUH4DmogAU\
H4DmpBBHJBf3NqQTRqQQdJGkEwIQQgAUEwNgL4DiABQdATakEQaiABQfgOakEQaikDADcDACABQdAT\
akEIaiABQfgOakEIaikDADcDACABQdATakEYaiABQfgOakEYaikDADcDACABQdATakEgaiABQfgOak\
EgaikDADcDACABQdATakEoaiABQfgOakEoaikDADcDACABQdATakEwaiABQfgOakEwaigCADYCACAB\
QfgmakEIaiIJIAFB0BNqQQxqKQIANwMAIAFB+CZqQRBqIgMgAUHQE2pBFGopAgA3AwAgAUH4JmpBGG\
oiCCABQdATakEcaikCADcDACABQfgmakEgaiIHIAFB0BNqQSRqKQIANwMAIAFB+CZqQShqIgwgAUHQ\
E2pBLGopAgA3AwAgASABKQP4DjcD0BMgASABKQLUEzcD+CYgAUHQE2ogAUG4AhCUARogAUHQE2ogAU\
GYFWogAUH4JmoQSkEwEBkiAkUNDSACIAEpA/gmNwAAIAJBKGogDCkDADcAACACQSBqIAcpAwA3AAAg\
AkEYaiAIKQMANwAAIAJBEGogAykDADcAACACQQhqIAkpAwA3AAAMDAsgBSAGQZgCEJQBIgFB+A5qQQ\
xqQgA3AgAgAUH4DmpBFGpCADcCACABQfgOakEcakIANwIAIAFB+A5qQSRqQgA3AgAgAUH4DmpBLGpC\
ADcCACABQfgOakE0akIANwIAIAFB+A5qQTxqQgA3AgAgAUIANwL8DiABQQA2AvgOIAFB+A5qIAFB+A\
5qQQRyQX9zakHEAGpBB0kaQcAAIQQgAUHAADYC+A4gAUHQE2ogAUH4DmpBxAAQlAEaIAFB+CZqQThq\
IgkgAUHQE2pBPGopAgA3AwAgAUH4JmpBMGoiAyABQdATakE0aikCADcDACABQfgmakEoaiIIIAFB0B\
NqQSxqKQIANwMAIAFB+CZqQSBqIgcgAUHQE2pBJGopAgA3AwAgAUH4JmpBGGoiDCABQdATakEcaikC\
ADcDACABQfgmakEQaiILIAFB0BNqQRRqKQIANwMAIAFB+CZqQQhqIg0gAUHQE2pBDGopAgA3AwAgAS\
ABKQLUEzcD+CYgAUHQE2ogAUGYAhCUARogAUHQE2ogAUGYFWogAUH4JmoQTEHAABAZIgJFDQwgAiAB\
KQP4JjcAACACQThqIAkpAwA3AAAgAkEwaiADKQMANwAAIAJBKGogCCkDADcAACACQSBqIAcpAwA3AA\
AgAkEYaiAMKQMANwAAIAJBEGogCykDADcAACACQQhqIA0pAwA3AAAMCwsgBSAGQfAAEJQBIQRBBCEC\
A0AgAkF/aiICDQALAkBBG0EHSQ0AQRghAgNAIAJBeGoiAg0ACwsgBEHQE2ogBEHwABCUARogBEH4Jm\
pBDGpCADcCACAEQfgmakEUakIANwIAIARB+CZqQRxqQgA3AgAgBEIANwL8JiAEQQA2AvgmIARB+CZq\
IARB+CZqQQRyQX9zakEkakEHSRogBEEgNgL4JiAEQfgOakEQaiIBIARB+CZqQRBqKQMANwMAIARB+A\
5qQQhqIgkgBEH4JmpBCGopAwA3AwAgBEH4DmpBGGoiAyAEQfgmakEYaikDADcDACAEQfgOakEgaiAE\
QfgmakEgaigCADYCACAEQcglakEIaiICIARB+A5qQQxqKQIANwMAIARByCVqQRBqIgggBEH4DmpBFG\
opAgA3AwAgBEHIJWpBGGoiByAEQfgOakEcaikCADcDACAEIAQpA/gmNwP4DiAEIAQpAvwONwPIJSAE\
QdATaiAEQfgTaiAEQcglahAnIAMgBygCADYCACABIAgpAwA3AwAgCSACKQMANwMAIAQgBCkDyCU3A/\
gOQRwQGSICRQ0LIAIgBCkD+A43AAAgAkEYaiADKAIANgAAIAJBEGogASkDADcAACACQQhqIAkpAwA3\
AAAgBhAiQRwhBAwNCyAFIAZB8AAQlAEiAUHQE2ogAUHwABCUARogAUH4JmpBDGpCADcCACABQfgmak\
EUakIANwIAIAFB+CZqQRxqQgA3AgAgAUIANwL8JiABQQA2AvgmIAFB+CZqIAFB+CZqQQRyQX9zakEk\
akEHSRpBICEEIAFBIDYC+CYgAUH4DmpBEGoiCSABQfgmakEQaikDADcDACABQfgOakEIaiIDIAFB+C\
ZqQQhqKQMANwMAIAFB+A5qQRhqIgggAUH4JmpBGGopAwA3AwAgAUH4DmpBIGogAUH4JmpBIGooAgA2\
AgAgAUHIJWpBCGoiAiABQfgOakEMaikCADcDACABQcglakEQaiIHIAFB+A5qQRRqKQIANwMAIAFByC\
VqQRhqIgwgAUH4DmpBHGopAgA3AwAgASABKQP4JjcD+A4gASABKQL8DjcDyCUgAUHQE2ogAUH4E2og\
AUHIJWoQJyAIIAwpAwA3AwAgCSAHKQMANwMAIAMgAikDADcDACABIAEpA8glNwP4DkEgEBkiAkUNCi\
ACIAEpA/gONwAAIAJBGGogCCkDADcAACACQRBqIAkpAwA3AAAgAkEIaiADKQMANwAADAkLIAUgBkHY\
ARCUASIBQdATaiABQdgBEJQBGiABQfgmakEMakIANwIAIAFB+CZqQRRqQgA3AgAgAUH4JmpBHGpCAD\
cCACABQfgmakEkakIANwIAIAFB+CZqQSxqQgA3AgAgAUH4JmpBNGpCADcCACABQfgmakE8akIANwIA\
IAFCADcC/CYgAUEANgL4JiABQfgmaiABQfgmakEEckF/c2pBxABqQQdJGiABQcAANgL4JiABQfgOai\
ABQfgmakHEABCUARogAUGAJmogAUH4DmpBPGopAgA3AwBBMCEEIAFByCVqQTBqIAFB+A5qQTRqKQIA\
NwMAIAFByCVqQShqIgIgAUH4DmpBLGopAgA3AwAgAUHIJWpBIGoiCSABQfgOakEkaikCADcDACABQc\
glakEYaiIDIAFB+A5qQRxqKQIANwMAIAFByCVqQRBqIgggAUH4DmpBFGopAgA3AwAgAUHIJWpBCGoi\
ByABQfgOakEMaikCADcDACABIAEpAvwONwPIJSABQdATaiABQaAUaiABQcglahAjIAFB+A5qQShqIg\
wgAikDADcDACABQfgOakEgaiILIAkpAwA3AwAgAUH4DmpBGGoiCSADKQMANwMAIAFB+A5qQRBqIgMg\
CCkDADcDACABQfgOakEIaiIIIAcpAwA3AwAgASABKQPIJTcD+A5BMBAZIgJFDQkgAiABKQP4DjcAAC\
ACQShqIAwpAwA3AAAgAkEgaiALKQMANwAAIAJBGGogCSkDADcAACACQRBqIAMpAwA3AAAgAkEIaiAI\
KQMANwAADAgLIAUgBkHYARCUASIBQdATaiABQdgBEJQBGiABQfgmakEMakIANwIAIAFB+CZqQRRqQg\
A3AgAgAUH4JmpBHGpCADcCACABQfgmakEkakIANwIAIAFB+CZqQSxqQgA3AgAgAUH4JmpBNGpCADcC\
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\
ADcCACAFQdgHakE8akIANwIAIAVCADcC3AcgBUEANgLYByAFQdgHaiAFQdgHakEEckF/c2pBxABqQQ\
dJGiAFQcAANgLYByAFQYACaiAFQdgHakHEABCUARogBUGoBmpBOGogBUGAAmpBPGopAgA3AwBBMCEE\
IAVBqAZqQTBqIAVBgAJqQTRqKQIANwMAIAVBqAZqQShqIgEgBUGAAmpBLGopAgA3AwAgBUGoBmpBIG\
oiAyAFQYACakEkaikCADcDACAFQagGakEYaiIGIAVBgAJqQRxqKQIANwMAIAVBqAZqQRBqIgcgBUGA\
AmpBFGopAgA3AwAgBUGoBmpBCGoiCCAFQYACakEMaikCADcDACAFIAUpAoQCNwOoBiACIAJB0ABqIA\
VBqAZqECMgBUGAAmpBKGoiCSABKQMANwMAIAVBgAJqQSBqIgogAykDADcDACAFQYACakEYaiIDIAYp\
AwA3AwAgBUGAAmpBEGoiBiAHKQMANwMAIAVBgAJqQQhqIgcgCCkDADcDACAFIAUpA6gGNwOAAiACQc\
gAakIANwMAIAJCADcDQCACQThqQQApA+COQDcDACACQTBqQQApA9iOQDcDACACQShqQQApA9COQDcD\
ACACQSBqQQApA8iOQDcDACACQRhqQQApA8COQDcDACACQRBqQQApA7iOQDcDACACQQhqQQApA7COQD\
cDACACQQApA6iOQDcDACACQdABakEAOgAAQTAQGSIBRQ0LIAEgBSkDgAI3AAAgAUEoaiAJKQMANwAA\
IAFBIGogCikDADcAACABQRhqIAMpAwA3AAAgAUEQaiAGKQMANwAAIAFBCGogBykDADcAAAwKCyAFQd\
gHakEMakIANwIAIAVB2AdqQRRqQgA3AgAgBUHYB2pBHGpCADcCACAFQdgHakEkakIANwIAIAVB2Adq\
QSxqQgA3AgAgBUHYB2pBNGpCADcCACAFQdgHakE8akIANwIAIAVCADcC3AcgBUEANgLYByAFQdgHai\
AFQdgHakEEckF/c2pBxABqQQdJGkHAACEEIAVBwAA2AtgHIAVBgAJqIAVB2AdqQcQAEJQBGiAFQagG\
akE4aiIBIAVBgAJqQTxqKQIANwMAIAVBqAZqQTBqIgMgBUGAAmpBNGopAgA3AwAgBUGoBmpBKGoiBi\
AFQYACakEsaikCADcDACAFQagGakEgaiIHIAVBgAJqQSRqKQIANwMAIAVBqAZqQRhqIgggBUGAAmpB\
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\
cyAjQR53ICNBE3dzICNBCndzaiACIBtBGXcgG0EOd3MgG0EDdnNqIBlqIBJBD3cgEkENd3MgEkEKdn\
NqICJqIBAgHGoiAiAhIB5zcSAec2ogAkEadyACQRV3cyACQQd3c2pB98fm93tqIiJqIhwgIyAgc3Eg\
E3MgC2ogHEEedyAcQRN3cyAcQQp3c2ogGyAfQRl3IB9BDndzIB9BA3ZzaiARaiAkQQ93ICRBDXdzIC\
RBCnZzaiAeaiAiICVqIhsgAiAhc3EgIXNqIBtBGncgG0EVd3MgG0EHd3NqQfLxxbN8aiIeaiELIBwg\
CmohCiAjIAlqIQkgICAIaiEIIB0gB2ogHmohByAbIAZqIQYgAiAFaiEFICEgBGohBCABQcAAaiIBIA\
xHDQALCyAAIAQ2AhwgACAFNgIYIAAgBjYCFCAAIAc2AhAgACAINgIMIAAgCTYCCCAAIAo2AgQgACAL\
NgIAC71AAgp/BH4jAEGAD2siASQAAkACQAJAAkAgAEUNACAAKAIAIgJBf0YNASAAIAJBAWo2AgAgAE\
EIaigCACECAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAg\
AEEEaigCACIDDhgAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcAC0HQARAZIgRFDRogAUEIakE4aiACQT\
hqKQMANwMAIAFBCGpBMGogAkEwaikDADcDACABQQhqQShqIAJBKGopAwA3AwAgAUEIakEgaiACQSBq\
KQMANwMAIAFBCGpBGGogAkEYaikDADcDACABQQhqQRBqIAJBEGopAwA3AwAgAUEIakEIaiACQQhqKQ\
MANwMAIAEgAikDADcDCCACKQNAIQsgAUEIakHIAGogAkHIAGoQYiABIAs3A0ggBCABQQhqQdABEJQB\
GgwXC0HQARAZIgRFDRkgAUEIakE4aiACQThqKQMANwMAIAFBCGpBMGogAkEwaikDADcDACABQQhqQS\
hqIAJBKGopAwA3AwAgAUEIakEgaiACQSBqKQMANwMAIAFBCGpBGGogAkEYaikDADcDACABQQhqQRBq\
IAJBEGopAwA3AwAgAUEIakEIaiACQQhqKQMANwMAIAEgAikDADcDCCACKQNAIQsgAUEIakHIAGogAk\
HIAGoQYiABIAs3A0ggBCABQQhqQdABEJQBGgwWC0HQARAZIgRFDRggAUEIakE4aiACQThqKQMANwMA\
IAFBCGpBMGogAkEwaikDADcDACABQQhqQShqIAJBKGopAwA3AwAgAUEIakEgaiACQSBqKQMANwMAIA\
FBCGpBGGogAkEYaikDADcDACABQQhqQRBqIAJBEGopAwA3AwAgAUEIakEIaiACQQhqKQMANwMAIAEg\
AikDADcDCCACKQNAIQsgAUEIakHIAGogAkHIAGoQYiABIAs3A0ggBCABQQhqQdABEJQBGgwVC0HwAB\
AZIgRFDRcgAUEIakEgaiACQSBqKQMANwMAIAFBCGpBGGogAkEYaikDADcDACABQQhqQRBqIAJBEGop\
AwA3AwAgASACKQMINwMQIAIpAwAhCyABQQhqQShqIAJBKGoQUSABIAs3AwggBCABQQhqQfAAEJQBGg\
wUC0H4DhAZIgRFDRYgAUEIakGIAWogAkGIAWopAwA3AwAgAUEIakGAAWogAkGAAWopAwA3AwAgAUEI\
akH4AGogAkH4AGopAwA3AwAgASACKQNwNwN4IAFBCGpBEGogAkEQaikDADcDACABQQhqQRhqIAJBGG\
opAwA3AwAgAUEIakEgaiACQSBqKQMANwMAIAEgAikDCDcDECACKQMAIQsgAUEIakHgAGogAkHgAGop\
AwA3AwAgAUEIakHYAGogAkHYAGopAwA3AwAgAUEIakHQAGogAkHQAGopAwA3AwAgAUEIakHIAGogAk\
HIAGopAwA3AwAgAUEIakHAAGogAkHAAGopAwA3AwAgAUEIakE4aiACQThqKQMANwMAIAFBCGpBMGog\
AkEwaikDADcDACABIAIpAyg3AzAgAi0AaiEFIAItAGkhBiACLQBoIQcgAUEANgKYAQJAIAIoApABIg\
hFDQAgAkGUAWoiCUEIaikAACEMIAlBEGopAAAhDSAJKQAAIQ4gAUG0AWogCUEYaikAADcCACABQawB\
aiANNwIAIAFBpAFqIAw3AgAgAUEIakGUAWogDjcCACACQbQBaiIKIAkgCEEFdGoiCUYNACAKQQhqKQ\
AAIQwgCkEQaikAACENIAopAAAhDiABQdQBaiAKQRhqKQAANwIAIAFBzAFqIA03AgAgAUHEAWogDDcC\
ACABQQhqQbQBaiAONwIAIAJB1AFqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQf\
QBaiAKQRhqKQAANwIAIAFB7AFqIA03AgAgAUHkAWogDDcCACABQQhqQdQBaiAONwIAIAJB9AFqIgog\
CUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQCaiAKQRhqKQAANwIAIAFBjAJqIA03Ag\
AgAUGEAmogDDcCACABQQhqQfQBaiAONwIAIAJBlAJqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACEN\
IAopAAAhDiABQbQCaiAKQRhqKQAANwIAIAFBrAJqIA03AgAgAUGkAmogDDcCACABQQhqQZQCaiAONw\
IAIAJBtAJqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQCaiAKQRhqKQAANwIA\
IAFBzAJqIA03AgAgAUHEAmogDDcCACABQQhqQbQCaiAONwIAIAJB1AJqIgogCUYNACAKQQhqKQAAIQ\
wgCkEQaikAACENIAopAAAhDiABQfQCaiAKQRhqKQAANwIAIAFB7AJqIA03AgAgAUHkAmogDDcCACAB\
QQhqQdQCaiAONwIAIAJB9AJqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQDai\
AKQRhqKQAANwIAIAFBjANqIA03AgAgAUGEA2ogDDcCACABQQhqQfQCaiAONwIAIAJBlANqIgogCUYN\
ACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQDaiAKQRhqKQAANwIAIAFBrANqIA03AgAgAU\
GkA2ogDDcCACABQQhqQZQDaiAONwIAIAJBtANqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAop\
AAAhDiABQdQDaiAKQRhqKQAANwIAIAFBzANqIA03AgAgAUHEA2ogDDcCACABQQhqQbQDaiAONwIAIA\
JB1ANqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQDaiAKQRhqKQAANwIAIAFB\
7ANqIA03AgAgAUHkA2ogDDcCACABQQhqQdQDaiAONwIAIAJB9ANqIgogCUYNACAKQQhqKQAAIQwgCk\
EQaikAACENIAopAAAhDiABQZQEaiAKQRhqKQAANwIAIAFBjARqIA03AgAgAUGEBGogDDcCACABQQhq\
QfQDaiAONwIAIAJBlARqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQEaiAKQR\
hqKQAANwIAIAFBrARqIA03AgAgAUGkBGogDDcCACABQQhqQZQEaiAONwIAIAJBtARqIgogCUYNACAK\
QQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQEaiAKQRhqKQAANwIAIAFBzARqIA03AgAgAUHEBG\
ogDDcCACABQQhqQbQEaiAONwIAIAJB1ARqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAh\
DiABQfQEaiAKQRhqKQAANwIAIAFB7ARqIA03AgAgAUHkBGogDDcCACABQQhqQdQEaiAONwIAIAJB9A\
RqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQFaiAKQRhqKQAANwIAIAFBjAVq\
IA03AgAgAUGEBWogDDcCACABQQhqQfQEaiAONwIAIAJBlAVqIgogCUYNACAKQQhqKQAAIQwgCkEQai\
kAACENIAopAAAhDiABQbQFaiAKQRhqKQAANwIAIAFBrAVqIA03AgAgAUGkBWogDDcCACABQQhqQZQF\
aiAONwIAIAJBtAVqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQFaiAKQRhqKQ\
AANwIAIAFBzAVqIA03AgAgAUHEBWogDDcCACABQQhqQbQFaiAONwIAIAJB1AVqIgogCUYNACAKQQhq\
KQAAIQwgCkEQaikAACENIAopAAAhDiABQfQFaiAKQRhqKQAANwIAIAFB7AVqIA03AgAgAUHkBWogDD\
cCACABQQhqQdQFaiAONwIAIAJB9AVqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiAB\
QZQGaiAKQRhqKQAANwIAIAFBjAZqIA03AgAgAUGEBmogDDcCACABQQhqQfQFaiAONwIAIAJBlAZqIg\
ogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQGaiAKQRhqKQAANwIAIAFBrAZqIA03\
AgAgAUGkBmogDDcCACABQQhqQZQGaiAONwIAIAJBtAZqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAAC\
ENIAopAAAhDiABQdQGaiAKQRhqKQAANwIAIAFBzAZqIA03AgAgAUHEBmogDDcCACABQQhqQbQGaiAO\
NwIAIAJB1AZqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQGaiAKQRhqKQAANw\
IAIAFB7AZqIA03AgAgAUHkBmogDDcCACABQQhqQdQGaiAONwIAIAJB9AZqIgogCUYNACAKQQhqKQAA\
IQwgCkEQaikAACENIAopAAAhDiABQZQHaiAKQRhqKQAANwIAIAFBjAdqIA03AgAgAUGEB2ogDDcCAC\
ABQQhqQfQGaiAONwIAIAJBlAdqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQH\
aiAKQRhqKQAANwIAIAFBrAdqIA03AgAgAUGkB2ogDDcCACABQQhqQZQHaiAONwIAIAJBtAdqIgogCU\
YNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQHaiAKQRhqKQAANwIAIAFBzAdqIA03AgAg\
AUHEB2ogDDcCACABQQhqQbQHaiAONwIAIAJB1AdqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIA\
opAAAhDiABQfQHaiAKQRhqKQAANwIAIAFB7AdqIA03AgAgAUHkB2ogDDcCACABQQhqQdQHaiAONwIA\
IAJB9AdqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQIaiAKQRhqKQAANwIAIA\
FBjAhqIA03AgAgAUGECGogDDcCACABQQhqQfQHaiAONwIAIAJBlAhqIgogCUYNACAKQQhqKQAAIQwg\
CkEQaikAACENIAopAAAhDiABQbQIaiAKQRhqKQAANwIAIAFBrAhqIA03AgAgAUGkCGogDDcCACABQQ\
hqQZQIaiAONwIAIAJBtAhqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQIaiAK\
QRhqKQAANwIAIAFBzAhqIA03AgAgAUHECGogDDcCACABQQhqQbQIaiAONwIAIAJB1AhqIgogCUYNAC\
AKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQIaiAKQRhqKQAANwIAIAFB7AhqIA03AgAgAUHk\
CGogDDcCACABQQhqQdQIaiAONwIAIAJB9AhqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAA\
AhDiABQZQJaiAKQRhqKQAANwIAIAFBjAlqIA03AgAgAUGECWogDDcCACABQQhqQfQIaiAONwIAIAJB\
lAlqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQJaiAKQRhqKQAANwIAIAFBrA\
lqIA03AgAgAUGkCWogDDcCACABQQhqQZQJaiAONwIAIAJBtAlqIgogCUYNACAKQQhqKQAAIQwgCkEQ\
aikAACENIAopAAAhDiABQdQJaiAKQRhqKQAANwIAIAFBzAlqIA03AgAgAUHECWogDDcCACABQQhqQb\
QJaiAONwIAIAJB1AlqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQJaiAKQRhq\
KQAANwIAIAFB7AlqIA03AgAgAUHkCWogDDcCACABQQhqQdQJaiAONwIAIAJB9AlqIgogCUYNACAKQQ\
hqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQKaiAKQRhqKQAANwIAIAFBjApqIA03AgAgAUGECmog\
DDcCACABQQhqQfQJaiAONwIAIAJBlApqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDi\
ABQbQKaiAKQRhqKQAANwIAIAFBrApqIA03AgAgAUGkCmogDDcCACABQQhqQZQKaiAONwIAIAJBtApq\
IgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQKaiAKQRhqKQAANwIAIAFBzApqIA\
03AgAgAUHECmogDDcCACABQQhqQbQKaiAONwIAIAJB1ApqIgogCUYNACAKQQhqKQAAIQwgCkEQaikA\
ACENIAopAAAhDiABQfQKaiAKQRhqKQAANwIAIAFB7ApqIA03AgAgAUHkCmogDDcCACABQQhqQdQKai\
AONwIAIAJB9ApqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQLaiAKQRhqKQAA\
NwIAIAFBjAtqIA03AgAgAUGEC2ogDDcCACABQQhqQfQKaiAONwIAIAJBlAtqIgogCUYNACAKQQhqKQ\
AAIQwgCkEQaikAACENIAopAAAhDiABQbQLaiAKQRhqKQAANwIAIAFBrAtqIA03AgAgAUGkC2ogDDcC\
ACABQQhqQZQLaiAONwIAIAJBtAtqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQd\
QLaiAKQRhqKQAANwIAIAFBzAtqIA03AgAgAUHEC2ogDDcCACABQQhqQbQLaiAONwIAIAJB1AtqIgog\
CUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQLaiAKQRhqKQAANwIAIAFB7AtqIA03Ag\
AgAUHkC2ogDDcCACABQQhqQdQLaiAONwIAIAJB9AtqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACEN\
IAopAAAhDiABQZQMaiAKQRhqKQAANwIAIAFBjAxqIA03AgAgAUGEDGogDDcCACABQQhqQfQLaiAONw\
IAIAJBlAxqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQMaiAKQRhqKQAANwIA\
IAFBrAxqIA03AgAgAUGkDGogDDcCACABQQhqQZQMaiAONwIAIAJBtAxqIgogCUYNACAKQQhqKQAAIQ\
wgCkEQaikAACENIAopAAAhDiABQdQMaiAKQRhqKQAANwIAIAFBzAxqIA03AgAgAUHEDGogDDcCACAB\
QQhqQbQMaiAONwIAIAJB1AxqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQMai\
AKQRhqKQAANwIAIAFB7AxqIA03AgAgAUHkDGogDDcCACABQQhqQdQMaiAONwIAIAJB9AxqIgogCUYN\
ACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQNaiAKQRhqKQAANwIAIAFBjA1qIA03AgAgAU\
GEDWogDDcCACABQQhqQfQMaiAONwIAIAJBlA1qIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAop\
AAAhDiABQbQNaiAKQRhqKQAANwIAIAFBrA1qIA03AgAgAUGkDWogDDcCACABQQhqQZQNaiAONwIAIA\
JBtA1qIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQNaiAKQRhqKQAANwIAIAFB\
zA1qIA03AgAgAUHEDWogDDcCACABQQhqQbQNaiAONwIAIAJB1A1qIgogCUYNACAKQQhqKQAAIQwgCk\
EQaikAACENIAopAAAhDiABQfQNaiAKQRhqKQAANwIAIAFB7A1qIA03AgAgAUHkDWogDDcCACABQQhq\
QdQNaiAONwIAIAJB9A1qIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQOaiAKQR\
hqKQAANwIAIAFBjA5qIA03AgAgAUGEDmogDDcCACABQQhqQfQNaiAONwIAIAJBlA5qIgogCUYNACAK\
QQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQOaiAKQRhqKQAANwIAIAFBrA5qIA03AgAgAUGkDm\
ogDDcCACABQQhqQZQOaiAONwIAIAJBtA5qIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAh\
DiABQdQOaiAKQRhqKQAANwIAIAFBzA5qIA03AgAgAUHEDmogDDcCACABQQhqQbQOaiAONwIAIAJB1A\
5qIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQOaiAKQRhqKQAANwIAIAFB7A5q\
IA03AgAgAUHkDmogDDcCACABQQhqQdQOaiAONwIAIAJB9A5qIAlHDRgLIAEgBToAciABIAY6AHEgAS\
AHOgBwIAEgCzcDCCABIAhB////P3EiAkE3IAJBN0kbNgKYASAEIAFBCGpB+A4QlAEaDBMLQeACEBki\
BEUNFSABQQhqIAJByAEQlAEaIAFBCGpByAFqIAJByAFqEGMgBCABQQhqQeACEJQBGgwSC0HYAhAZIg\
RFDRQgAUEIaiACQcgBEJQBGiABQQhqQcgBaiACQcgBahBkIAQgAUEIakHYAhCUARoMEQtBuAIQGSIE\
RQ0TIAFBCGogAkHIARCUARogAUEIakHIAWogAkHIAWoQZSAEIAFBCGpBuAIQlAEaDBALQZgCEBkiBE\
UNEiABQQhqIAJByAEQlAEaIAFBCGpByAFqIAJByAFqEGYgBCABQQhqQZgCEJQBGgwPC0HgABAZIgRF\
DREgAUEIakEQaiACQRBqKQMANwMAIAEgAikDCDcDECACKQMAIQsgAUEIakEYaiACQRhqEFEgASALNw\
MIIAQgAUEIakHgABCUARoMDgtB4AAQGSIERQ0QIAFBCGpBEGogAkEQaikDADcDACABIAIpAwg3AxAg\
AikDACELIAFBCGpBGGogAkEYahBRIAEgCzcDCCAEIAFBCGpB4AAQlAEaDA0LQegAEBkiBEUNDyABQQ\
hqQRhqIAJBGGooAgA2AgAgAUEIakEQaiACQRBqKQMANwMAIAEgAikDCDcDECACKQMAIQsgAUEIakEg\
aiACQSBqEFEgASALNwMIIAQgAUEIakHoABCUARoMDAtB6AAQGSIERQ0OIAFBCGpBGGogAkEYaigCAD\
YCACABQQhqQRBqIAJBEGopAwA3AwAgASACKQMINwMQIAIpAwAhCyABQQhqQSBqIAJBIGoQUSABIAs3\
AwggBCABQQhqQegAEJQBGgwLC0HgAhAZIgRFDQ0gAUEIaiACQcgBEJQBGiABQQhqQcgBaiACQcgBah\
BjIAQgAUEIakHgAhCUARoMCgtB2AIQGSIERQ0MIAFBCGogAkHIARCUARogAUEIakHIAWogAkHIAWoQ\
ZCAEIAFBCGpB2AIQlAEaDAkLQbgCEBkiBEUNCyABQQhqIAJByAEQlAEaIAFBCGpByAFqIAJByAFqEG\
UgBCABQQhqQbgCEJQBGgwIC0GYAhAZIgRFDQogAUEIaiACQcgBEJQBGiABQQhqQcgBaiACQcgBahBm\
IAQgAUEIakGYAhCUARoMBwtB8AAQGSIERQ0JIAFBCGpBIGogAkEgaikDADcDACABQQhqQRhqIAJBGG\
opAwA3AwAgAUEIakEQaiACQRBqKQMANwMAIAEgAikDCDcDECACKQMAIQsgAUEIakEoaiACQShqEFEg\
ASALNwMIIAQgAUEIakHwABCUARoMBgtB8AAQGSIERQ0IIAFBCGpBIGogAkEgaikDADcDACABQQhqQR\
hqIAJBGGopAwA3AwAgAUEIakEQaiACQRBqKQMANwMAIAEgAikDCDcDECACKQMAIQsgAUEIakEoaiAC\
QShqEFEgASALNwMIIAQgAUEIakHwABCUARoMBQtB2AEQGSIERQ0HIAFBCGpBOGogAkE4aikDADcDAC\
ABQQhqQTBqIAJBMGopAwA3AwAgAUEIakEoaiACQShqKQMANwMAIAFBCGpBIGogAkEgaikDADcDACAB\
QQhqQRhqIAJBGGopAwA3AwAgAUEIakEQaiACQRBqKQMANwMAIAFBCGpBCGogAkEIaikDADcDACABIA\
IpAwA3AwggAkHIAGopAwAhCyACKQNAIQwgAUEIakHQAGogAkHQAGoQYiABQQhqQcgAaiALNwMAIAEg\
DDcDSCAEIAFBCGpB2AEQlAEaDAQLQdgBEBkiBEUNBiABQQhqQThqIAJBOGopAwA3AwAgAUEIakEwai\
ACQTBqKQMANwMAIAFBCGpBKGogAkEoaikDADcDACABQQhqQSBqIAJBIGopAwA3AwAgAUEIakEYaiAC\
QRhqKQMANwMAIAFBCGpBEGogAkEQaikDADcDACABQQhqQQhqIAJBCGopAwA3AwAgASACKQMANwMIIA\
JByABqKQMAIQsgAikDQCEMIAFBCGpB0ABqIAJB0ABqEGIgAUEIakHIAGogCzcDACABIAw3A0ggBCAB\
QQhqQdgBEJQBGgwDC0H4AhAZIgRFDQUgAUEIaiACQcgBEJQBGiABQQhqQcgBaiACQcgBahBnIAQgAU\
EIakH4AhCUARoMAgtB2AIQGSIERQ0EIAFBCGogAkHIARCUARogAUEIakHIAWogAkHIAWoQZCAEIAFB\
CGpB2AIQlAEaDAELQegAEBkiBEUNAyABQQhqQRBqIAJBEGopAwA3AwAgAUEIakEYaiACQRhqKQMANw\
MAIAEgAikDCDcDECACKQMAIQsgAUEIakEgaiACQSBqEFEgASALNwMIIAQgAUEIakHoABCUARoLIAAg\
ACgCAEF/ajYCAEEMEBkiAEUNAiAAIAQ2AgggACADNgIEIABBADYCACABQYAPaiQAIAAPCxCQAQALEJ\
EBAAsACxCNAQAL1TwCE38CfiMAQYACayIEJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC\
QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAk\
ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJA\
IAAOGAABAgMEBQYHCAkKCwwNDg8QERITFBUWFwALIAFByABqIQVBgAEgAUHIAWotAAAiAGsiBiADTw\
0XAkAgAEUNACAFIABqIAIgBhCUARogASABKQNAQoABfDcDQCABIAVCABASIAMgBmshAyACIAZqIQIL\
IAMgA0EHdiADQQBHIANB/wBxRXFrIgBBB3QiB2shAyAARQ1GIAchBiACIQADQCABIAEpA0BCgAF8Nw\
NAIAEgAEIAEBIgAEGAAWohACAGQYB/aiIGDQAMRwsLIAFByABqIQVBgAEgAUHIAWotAAAiAGsiBiAD\
Tw0XAkAgAEUNACAFIABqIAIgBhCUARogASABKQNAQoABfDcDQCABIAVCABASIAMgBmshAyACIAZqIQ\
ILIAMgA0EHdiADQQBHIANB/wBxRXFrIgBBB3QiB2shAyAARQ1EIAchBiACIQADQCABIAEpA0BCgAF8\
NwNAIAEgAEIAEBIgAEGAAWohACAGQYB/aiIGDQAMRQsLIAFByABqIQVBgAEgAUHIAWotAAAiAGsiBi\
ADTw0XAkAgAEUNACAFIABqIAIgBhCUARogASABKQNAQoABfDcDQCABIAVCABASIAMgBmshAyACIAZq\
IQILIAMgA0EHdiADQQBHIANB/wBxRXFrIgBBB3QiB2shAyAARQ1CIAchBiACIQADQCABIAEpA0BCgA\
F8NwNAIAEgAEIAEBIgAEGAAWohACAGQYB/aiIGDQAMQwsLIAFBKGohBUHAACABQegAai0AACIAayIG\
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\
OgDIAQwtCyAFIABqIAIgAxCUARogASAAIANqOgBoDCwLIAQgCzYCjAEgBCAJNgKIASAEIAw2AoQBIA\
QgCDYCgAEgBCANNgJ8IAQgCjYCeCAEIA42AnQgBCAPNgJwQbCRwAAgBEHwAGpBpIfAAEGUh8AAEGEA\
CyAGIABqIAIgAxCUARogASAAIANqOgDYAgwqCyAGIABqIAIgAxCUARogASAAIANqOgDQAgwpCyAGIA\
BqIAIgAxCUARogASAAIANqOgCwAgwoCyAGIABqIAIgAxCUARogASAAIANqOgCQAgwnCyAFIABqIAIg\
AxCUARogASAAIANqOgBYDCYLIAYgAGogAiADEJQBGiABIAAgA2o6AFgMJQsgBSAAaiACIAMQlAEaIA\
EgACADajoAYAwkCyAGIABqIAIgAxCUARogASAAIANqOgBgDCMLIAYgAGogAiADEJQBGiABIAAgA2o6\
ANgCDCILIAYgAGogAiADEJQBGiABIAAgA2o6ANACDCELIAYgAGogAiADEJQBGiABIAAgA2o6ALACDC\
ALIAYgAGogAiADEJQBGiABIAAgA2o6AJACDB8LIAYgAGogAiADEJQBGiABIAAgA2o6AGgMHgsgBiAA\
aiACIAMQlAEaIAEgACADajoAaAwdCyAGIABqIAIgAxCUARogASAAIANqOgDQAQwcCyAGIABqIAIgAx\
CUARogASAAIANqOgDQAQwbCyAGIABqIAIgAxCUARogASAAIANqOgDwAgwaCyAGIABqIAIgAxCUARog\
ASAAIANqOgDQAgwZCyAFIAggBxCUARoLIAEgBzoAYAwXCwJAIABBiQFPDQAgBiACIAVqIAAQlAEaIA\
EgADoA0AIMFwsgAEGIAUGAgMAAEIsBAAsCQCAAQakBTw0AIAYgAiAFaiAAEJQBGiABIAA6APACDBYL\
IABBqAFBgIDAABCLAQALIAYgBSAAEJQBGiABIAA6ANABDBQLIAYgBSAAEJQBGiABIAA6ANABDBMLIA\
YgBSAAEJQBGiABIAA6AGgMEgsgBiAFIAAQlAEaIAEgADoAaAwRCwJAIABByQBPDQAgBiACIAVqIAAQ\
lAEaIAEgADoAkAIMEQsgAEHIAEGAgMAAEIsBAAsCQCAAQekATw0AIAYgAiAFaiAAEJQBGiABIAA6AL\
ACDBALIABB6ABBgIDAABCLAQALAkAgAEGJAU8NACAGIAIgBWogABCUARogASAAOgDQAgwPCyAAQYgB\
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\
QX9zcnNqQc76z8p6akEFdyAKaiIJaiAOIAJqIAwgBEEKdyICcyANc2pBDXcgA2oiBEEKd2o2AgAgAC\
gCECEMIAAgASAVaiAGIApqIAkgDyAgQX9zcnNqQc76z8p6akEGd2ogAyALaiANIAVzIARzakELdyAC\
aiIKajYCECAAIAEgDGogBWogAiAHaiAEIBZzIApzakELd2o2AgwLhCgCMH8BfiMAQcAAayIDQRhqIg\
RCADcDACADQSBqIgVCADcDACADQThqIgZCADcDACADQTBqIgdCADcDACADQShqIghCADcDACADQQhq\
IgkgASkACDcDACADQRBqIgogASkAEDcDACAEIAEoABgiCzYCACAFIAEoACAiBDYCACADIAEpAAA3Aw\
AgAyABKAAcIgU2AhwgAyABKAAkIgw2AiQgCCABKAAoIg02AgAgAyABKAAsIgg2AiwgByABKAAwIg42\
AgAgAyABKAA0Igc2AjQgBiABKAA4Ig82AgAgAyABKAA8IgE2AjwgACAIIAEgBCAFIAcgCCALIAQgDC\
AMIA0gDyABIAQgBCALIAEgDSAPIAggBSAHIAEgBSAIIAsgByAHIA4gBSALIABBJGoiECgCACIRIABB\
FGoiEigCACITamoiBkGZmoPfBXNBEHciFEG66r+qemoiFSARc0EUdyIWIAZqaiIXIBRzQRh3IhggFW\
oiGSAWc0EZdyIaIABBIGoiGygCACIVIABBEGoiHCgCACIdaiAKKAIAIgZqIgogAnNBq7OP/AFzQRB3\
Ih5B8ua74wNqIh8gFXNBFHciICAKaiADKAIUIgJqIiFqaiIiIABBHGoiIygCACIWIABBDGoiJCgCAC\
IlaiAJKAIAIglqIgogACkDACIzQiCIp3NBjNGV2HlzQRB3IhRBhd2e23tqIiYgFnNBFHciJyAKaiAD\
KAIMIgpqIiggFHNBGHciKXNBEHciKiAAQRhqIisoAgAiLCAAKAIIIi1qIAMoAgAiFGoiLiAzp3NB/6\
S5iAVzQRB3Ii9B58yn0AZqIjAgLHNBFHciMSAuaiADKAIEIgNqIi4gL3NBGHciLyAwaiIwaiIyIBpz\
QRR3IhogImpqIiIgKnNBGHciKiAyaiIyIBpzQRl3IhogASAPIBcgMCAxc0EZdyIwamoiFyAhIB5zQR\
h3Ih5zQRB3IiEgKSAmaiImaiIpIDBzQRR3IjAgF2pqIhdqaiIxIAwgBCAmICdzQRl3IiYgLmpqIicg\
GHNBEHciGCAeIB9qIh5qIh8gJnNBFHciJiAnamoiJyAYc0EYdyIYc0EQdyIuIAggDSAeICBzQRl3Ih\
4gKGpqIiAgL3NBEHciKCAZaiIZIB5zQRR3Ih4gIGpqIiAgKHNBGHciKCAZaiIZaiIvIBpzQRR3Ihog\
MWpqIjEgLnNBGHciLiAvaiIvIBpzQRl3IhogASAMICIgGSAec0EZdyIZamoiHiAXICFzQRh3IhdzQR\
B3IiEgGCAfaiIYaiIfIBlzQRR3IhkgHmpqIh5qaiIiIAQgICAYICZzQRl3IhhqIAZqIiAgKnNBEHci\
JiAXIClqIhdqIikgGHNBFHciGCAgamoiICAmc0EYdyImc0EQdyIqIA0gDyAXIDBzQRl3IhcgJ2pqIi\
cgKHNBEHciKCAyaiIwIBdzQRR3IhcgJ2pqIicgKHNBGHciKCAwaiIwaiIyIBpzQRR3IhogImpqIiIg\
KnNBGHciKiAyaiIyIBpzQRl3IhogMSAwIBdzQRl3IhdqIAJqIjAgHiAhc0EYdyIec0EQdyIhICYgKW\
oiJmoiKSAXc0EUdyIXIDBqIApqIjBqaiIxIA4gJiAYc0EZdyIYICdqIANqIiYgLnNBEHciJyAeIB9q\
Ih5qIh8gGHNBFHciGCAmamoiJiAnc0EYdyInc0EQdyIuIB4gGXNBGXciGSAgaiAUaiIeIChzQRB3Ii\
AgL2oiKCAZc0EUdyIZIB5qIAlqIh4gIHNBGHciICAoaiIoaiIvIBpzQRR3IhogMWpqIjEgLnNBGHci\
LiAvaiIvIBpzQRl3IhogIiAoIBlzQRl3IhlqIAJqIiIgMCAhc0EYdyIhc0EQdyIoICcgH2oiH2oiJy\
AZc0EUdyIZICJqIAlqIiJqaiIwIA4gHiAfIBhzQRl3IhhqaiIeICpzQRB3Ih8gISApaiIhaiIpIBhz\
QRR3IhggHmogFGoiHiAfc0EYdyIfc0EQdyIqIAQgCCAhIBdzQRl3IhcgJmpqIiEgIHNBEHciICAyai\
ImIBdzQRR3IhcgIWpqIiEgIHNBGHciICAmaiImaiIyIBpzQRR3IhogMGogA2oiMCAqc0EYdyIqIDJq\
IjIgGnNBGXciGiAMIDEgJiAXc0EZdyIXamoiJiAiIChzQRh3IiJzQRB3IiggHyApaiIfaiIpIBdzQR\
R3IhcgJmogBmoiJmpqIjEgDyANIB8gGHNBGXciGCAhamoiHyAuc0EQdyIhICIgJ2oiImoiJyAYc0EU\
dyIYIB9qaiIfICFzQRh3IiFzQRB3Ii4gCyAiIBlzQRl3IhkgHmogCmoiHiAgc0EQdyIgIC9qIiIgGX\
NBFHciGSAeamoiHiAgc0EYdyIgICJqIiJqIi8gGnNBFHciGiAxamoiMSAuc0EYdyIuIC9qIi8gGnNB\
GXciGiAOIAcgMCAiIBlzQRl3IhlqaiIiICYgKHNBGHciJnNBEHciKCAhICdqIiFqIicgGXNBFHciGS\
AiamoiImogBmoiMCAeICEgGHNBGXciGGogCmoiHiAqc0EQdyIhICYgKWoiJmoiKSAYc0EUdyIYIB5q\
IANqIh4gIXNBGHciIXNBEHciKiAMIAUgJiAXc0EZdyIXIB9qaiIfICBzQRB3IiAgMmoiJiAXc0EUdy\
IXIB9qaiIfICBzQRh3IiAgJmoiJmoiMiAac0EUdyIaIDBqIBRqIjAgKnNBGHciKiAyaiIyIBpzQRl3\
IhogBCABIDEgJiAXc0EZdyIXamoiJiAiIChzQRh3IiJzQRB3IiggISApaiIhaiIpIBdzQRR3IhcgJm\
pqIiZqaiIxIAsgISAYc0EZdyIYIB9qIAlqIh8gLnNBEHciISAiICdqIiJqIicgGHNBFHciGCAfamoi\
HyAhc0EYdyIhc0EQdyIuIA0gIiAZc0EZdyIZIB5qIAJqIh4gIHNBEHciICAvaiIiIBlzQRR3IhkgHm\
pqIh4gIHNBGHciICAiaiIiaiIvIBpzQRR3IhogMWpqIjEgLnNBGHciLiAvaiIvIBpzQRl3IhogMCAi\
IBlzQRl3IhlqIAlqIiIgJiAoc0EYdyImc0EQdyIoICEgJ2oiIWoiJyAZc0EUdyIZICJqIAZqIiJqai\
IwIAUgHiAhIBhzQRl3IhhqIAJqIh4gKnNBEHciISAmIClqIiZqIikgGHNBFHciGCAeamoiHiAhc0EY\
dyIhc0EQdyIqIAwgJiAXc0EZdyIXIB9qaiIfICBzQRB3IiAgMmoiJiAXc0EUdyIXIB9qIBRqIh8gIH\
NBGHciICAmaiImaiIyIBpzQRR3IhogMGpqIjAgKnNBGHciKiAyaiIyIBpzQRl3IhogByAxICYgF3NB\
GXciF2ogCmoiJiAiIChzQRh3IiJzQRB3IiggISApaiIhaiIpIBdzQRR3IhcgJmpqIiZqaiIxIA8gIS\
AYc0EZdyIYIB9qaiIfIC5zQRB3IiEgIiAnaiIiaiInIBhzQRR3IhggH2ogA2oiHyAhc0EYdyIhc0EQ\
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\
ciAJQQh2QYD+A3EgCUEYdnJyNgIQIAMgASgAFCIJQRh0IAlBCHRBgID8B3FyIAlBCHZBgP4DcSAJQR\
h2cnI2AhQgAyABKAAcIglBGHQgCUEIdEGAgPwHcXIgCUEIdkGA/gNxIAlBGHZyciIKNgIcIAMgASgA\
ICIJQRh0IAlBCHRBgID8B3FyIAlBCHZBgP4DcSAJQRh2cnIiCzYCICADIAEoABgiCUEYdCAJQQh0QY\
CA/AdxciAJQQh2QYD+A3EgCUEYdnJyIgw2AhggAygCACENIAMoAgQhDiADKAIIIQ8gAygCECEQIAMo\
AgwhESADKAIUIRIgAyABKAAkIglBGHQgCUEIdEGAgPwHcXIgCUEIdkGA/gNxIAlBGHZyciITNgIkIA\
MgASgAKCIJQRh0IAlBCHRBgID8B3FyIAlBCHZBgP4DcSAJQRh2cnIiFDYCKCADIAEoADAiCUEYdCAJ\
QQh0QYCA/AdxciAJQQh2QYD+A3EgCUEYdnJyIhU2AjAgAyABKAAsIglBGHQgCUEIdEGAgPwHcXIgCU\
EIdkGA/gNxIAlBGHZyciIWNgIsIAMgASgANCIJQRh0IAlBCHRBgID8B3FyIAlBCHZBgP4DcSAJQRh2\
cnIiCTYCNCADIAEoADgiF0EYdCAXQQh0QYCA/AdxciAXQQh2QYD+A3EgF0EYdnJyIhc2AjggAyABKA\
A8IhhBGHQgGEEIdEGAgPwHcXIgGEEIdkGA/gNxIBhBGHZyciIYNgI8IAUgEyAKcyAYcyAMIBBzIBVz\
IBEgDnMgE3MgF3NBAXciGXNBAXciGnNBAXciGyAKIBJzIAlzIBAgD3MgFHMgGHNBAXciHHNBAXciHX\
MgGCAJcyAdcyAVIBRzIBxzIBtzQQF3Ih5zQQF3Ih9zIBogHHMgHnMgGSAYcyAbcyAXIBVzIBpzIBYg\
E3MgGXMgCyAMcyAXcyASIBFzIBZzIA8gDXMgC3MgCXNBAXciIHNBAXciIXNBAXciInNBAXciI3NBAX\
ciJHNBAXciJXNBAXciJnNBAXciJyAdICFzIAkgFnMgIXMgFCALcyAgcyAdc0EBdyIoc0EBdyIpcyAc\
ICBzIChzIB9zQQF3IipzQQF3IitzIB8gKXMgK3MgHiAocyAqcyAnc0EBdyIsc0EBdyItcyAmICpzIC\
xzICUgH3MgJ3MgJCAecyAmcyAjIBtzICVzICIgGnMgJHMgISAZcyAjcyAgIBdzICJzIClzQQF3Ii5z\
QQF3Ii9zQQF3IjBzQQF3IjFzQQF3IjJzQQF3IjNzQQF3IjRzQQF3IjUgKyAvcyApICNzIC9zICggIn\
MgLnMgK3NBAXciNnNBAXciN3MgKiAucyA2cyAtc0EBdyI4c0EBdyI5cyAtIDdzIDlzICwgNnMgOHMg\
NXNBAXciOnNBAXciO3MgNCA4cyA6cyAzIC1zIDVzIDIgLHMgNHMgMSAncyAzcyAwICZzIDJzIC8gJX\
MgMXMgLiAkcyAwcyA3c0EBdyI8c0EBdyI9c0EBdyI+c0EBdyI/c0EBdyJAc0EBdyJBc0EBdyJCc0EB\
dyJDIDkgPXMgNyAxcyA9cyA2IDBzIDxzIDlzQQF3IkRzQQF3IkVzIDggPHMgRHMgO3NBAXciRnNBAX\
ciR3MgOyBFcyBHcyA6IERzIEZzIENzQQF3IkhzQQF3IklzIEIgRnMgSHMgQSA7cyBDcyBAIDpzIEJz\
ID8gNXMgQXMgPiA0cyBAcyA9IDNzID9zIDwgMnMgPnMgRXNBAXciSnNBAXciS3NBAXciTHNBAXciTX\
NBAXciTnNBAXciT3NBAXciUHNBAXdqIEYgSnMgRCA+cyBKcyBHc0EBdyJRcyBJc0EBdyJSIEUgP3Mg\
S3MgUXNBAXciUyBMIEEgOiA5IDwgMSAmIB8gKCAhIBcgEyAQIAVBHnciVGogDiAHIAZBHnciECACcy\
AFcSACc2pqIA0gCCAFQQV3aiACIAdzIAZxIAdzampBmfOJ1AVqIg5BBXdqQZnzidQFaiJVQR53IgUg\
DkEedyINcyACIA9qIA4gVCAQc3EgEHNqIFVBBXdqQZnzidQFaiIOcSANc2ogECARaiBVIA0gVHNxIF\
RzaiAOQQV3akGZ84nUBWoiEEEFd2pBmfOJ1AVqIhFBHnciD2ogBSAMaiARIBBBHnciEyAOQR53Igxz\
cSAMc2ogDSASaiAMIAVzIBBxIAVzaiARQQV3akGZ84nUBWoiEUEFd2pBmfOJ1AVqIhJBHnciBSARQR\
53IhBzIAogDGogESAPIBNzcSATc2ogEkEFd2pBmfOJ1AVqIgpxIBBzaiALIBNqIBAgD3MgEnEgD3Nq\
IApBBXdqQZnzidQFaiIMQQV3akGZ84nUBWoiD0EedyILaiAVIApBHnciF2ogCyAMQR53IhNzIBQgEG\
ogDCAXIAVzcSAFc2ogD0EFd2pBmfOJ1AVqIhRxIBNzaiAWIAVqIA8gEyAXc3EgF3NqIBRBBXdqQZnz\
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\
AEEAQcgBEJMBQdACakEAOgAADBELIAFBCGooAgBBAEHIARCTAUGwAmpBADoAAAwQCyABQQhqKAIAQQ\
BByAEQkwFBkAJqQQA6AAAMDwsgAUEIaigCACIDQv6568XpjpWZEDcDECADQoHGlLqW8ermbzcDCCAD\
QgA3AwAgA0HYAGpBADoAAAwOCyABQQhqKAIAIgNC/rnrxemOlZkQNwMQIANCgcaUupbx6uZvNwMIIA\
NCADcDACADQdgAakEAOgAADA0LIAFBCGooAgAiA0IANwMAIANBACkDkI1ANwMIIANBEGpBACkDmI1A\
NwMAIANBGGpBACgCoI1ANgIAIANB4ABqQQA6AAAMDAsgAUEIaigCACIDQfDDy558NgIYIANC/rnrxe\
mOlZkQNwMQIANCgcaUupbx6uZvNwMIIANCADcDACADQeAAakEAOgAADAsLIAFBCGooAgBBAEHIARCT\
AUHYAmpBADoAAAwKCyABQQhqKAIAQQBByAEQkwFB0AJqQQA6AAAMCQsgAUEIaigCAEEAQcgBEJMBQb\
ACakEAOgAADAgLIAFBCGooAgBBAEHIARCTAUGQAmpBADoAAAwHCyABQQhqKAIAIgNCADcDACADQQAp\
A8iNQDcDCCADQRBqQQApA9CNQDcDACADQRhqQQApA9iNQDcDACADQSBqQQApA+CNQDcDACADQegAak\
EAOgAADAYLIAFBCGooAgAiA0IANwMAIANBACkDqI1ANwMIIANBEGpBACkDsI1ANwMAIANBGGpBACkD\
uI1ANwMAIANBIGpBACkDwI1ANwMAIANB6ABqQQA6AAAMBQsgAUEIaigCACIDQgA3A0AgA0EAKQOojk\
A3AwAgA0HIAGpCADcDACADQQhqQQApA7COQDcDACADQRBqQQApA7iOQDcDACADQRhqQQApA8COQDcD\
ACADQSBqQQApA8iOQDcDACADQShqQQApA9COQDcDACADQTBqQQApA9iOQDcDACADQThqQQApA+COQD\
cDACADQdABakEAOgAADAQLIAFBCGooAgAiA0IANwNAIANBACkD6I1ANwMAIANByABqQgA3AwAgA0EI\
akEAKQPwjUA3AwAgA0EQakEAKQP4jUA3AwAgA0EYakEAKQOAjkA3AwAgA0EgakEAKQOIjkA3AwAgA0\
EoakEAKQOQjkA3AwAgA0EwakEAKQOYjkA3AwAgA0E4akEAKQOgjkA3AwAgA0HQAWpBADoAAAwDCyAB\
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\
BkIhhkKAgICAgOA/gyAGQhGGQoCAgIDwH4OEhCEIAkAgBEE/cyIARQ0AIAVBAWpBACAAEJMBGgsgCC\
AJhCEIAkACQCAEQThxQThGDQAgASAINwA4IANBCGogAUEBEBUMAQsgA0EIaiABQQEQFSADQeAAakEM\
akIANwIAIANB4ABqQRRqQgA3AgAgA0HgAGpBHGpCADcCACADQeAAakEkakIANwIAIANB4ABqQSxqQg\
A3AgAgA0HgAGpBNGpCADcCACADQZwBakIANwIAIANCADcCZCADQQA2AmAgA0HgAGogA0HgAGpBBHJB\
f3NqQcQAakEHSRogA0HAADYCYCADQagBaiADQeAAakHEABCUARogA0HQAGogA0GoAWpBNGopAgA3Aw\
AgA0HIAGogA0GoAWpBLGopAgA3AwAgA0HAAGogA0GoAWpBJGopAgA3AwAgA0E4aiADQagBakEcaikC\
ADcDACADQTBqIANBqAFqQRRqKQIANwMAIANBKGogA0GoAWpBDGopAgA3AwAgAyADKQKsATcDICADIA\
g3A1ggA0EIaiADQSBqQQEQFQsgAUEAOgBAIAIgAygCCCIBQRh0IAFBCHRBgID8B3FyIAFBCHZBgP4D\
cSABQRh2cnI2AAAgAiADKAIMIgFBGHQgAUEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZycjYABCACIA\
MoAhAiAUEYdCABQQh0QYCA/AdxciABQQh2QYD+A3EgAUEYdnJyNgAIIAIgAygCFCIBQRh0IAFBCHRB\
gID8B3FyIAFBCHZBgP4DcSABQRh2cnI2AAwgAiADKAIYIgFBGHQgAUEIdEGAgPwHcXIgAUEIdkGA/g\
NxIAFBGHZycjYAECADQfABaiQAC/8GARd/IwBB0AFrIgIkAAJAAkACQCAAKAKQASIDIAF7pyIETQ0A\
IANBf2ohBSAAQfAAaiEGIANBBXQgAGpB1ABqIQcgAkEgakEoaiEIIAJBIGpBCGohCSACQZABakEgai\
EKIAJBEGohCyACQRhqIQwgA0F+akE3SSENA0AgACAFNgKQASACQQhqIgMgB0EoaikAADcDACALIAdB\
MGopAAA3AwAgDCAHQThqKQAANwMAIAIgB0EgaikAADcDACAFRQ0CIAAgBUF/aiIONgKQASAALQBqIQ\
8gCiACKQMANwAAIApBCGogAykDADcAACAKQRBqIAspAwA3AAAgCkEYaiAMKQMANwAAIAJBkAFqQRhq\
IgMgB0EYaiIQKQAANwMAIAJBkAFqQRBqIhEgB0EQaiISKQAANwMAIAJBkAFqQQhqIhMgB0EIaiIUKQ\
AANwMAIAkgBikDADcDACAJQQhqIAZBCGoiFSkDADcDACAJQRBqIAZBEGoiFikDADcDACAJQRhqIAZB\
GGoiFykDADcDACACIAcpAAA3A5ABIAhBOGogAkGQAWpBOGopAwA3AAAgCEEwaiACQZABakEwaikDAD\
cAACAIQShqIAJBkAFqQShqKQMANwAAIAhBIGogCikDADcAACAIQRhqIAMpAwA3AAAgCEEQaiARKQMA\
NwAAIAhBCGogEykDADcAACAIIAIpA5ABNwAAIAJBwAA6AIgBIAIgD0EEciIPOgCJASACQgA3AyAgAy\
AXKQIANwMAIBEgFikCADcDACATIBUpAgA3AwAgAiAGKQIANwOQASACQZABaiAIQcAAQgAgDxAYIAMo\
AgAhAyARKAIAIREgEygCACETIAIoAqwBIQ8gAigCpAEhFSACKAKcASEWIAIoApQBIRcgAigCkAEhGC\
ANRQ0DIAcgGDYCACAHQRxqIA82AgAgECADNgIAIAdBFGogFTYCACASIBE2AgAgB0EMaiAWNgIAIBQg\
EzYCACAHQQRqIBc2AgAgACAFNgKQASAHQWBqIQcgDiEFIA4gBE8NAAsLIAJB0AFqJAAPC0HYkMAAQS\
tBwIXAABByAAsgAiAPNgKsASACIAM2AqgBIAIgFTYCpAEgAiARNgKgASACIBY2ApwBIAIgEzYCmAEg\
AiAXNgKUASACIBg2ApABQbCRwAAgAkGQAWpBpIfAAEGUh8AAEGEAC5wFAQp/IwBBMGsiAyQAIANBJG\
ogATYCACADQQM6ACggA0KAgICAgAQ3AwggAyAANgIgQQAhBCADQQA2AhggA0EANgIQAkACQAJAAkAg\
AigCCCIFDQAgAkEUaigCACIARQ0BIAIoAhAhASAAQQN0IQYgAEF/akH/////AXFBAWohBCACKAIAIQ\
ADQAJAIABBBGooAgAiB0UNACADKAIgIAAoAgAgByADKAIkKAIMEQgADQQLIAEoAgAgA0EIaiABQQRq\
KAIAEQYADQMgAUEIaiEBIABBCGohACAGQXhqIgYNAAwCCwsgAkEMaigCACIBRQ0AIAFBBXQhCCABQX\
9qQf///z9xQQFqIQQgAigCACEAQQAhBgNAAkAgAEEEaigCACIBRQ0AIAMoAiAgACgCACABIAMoAiQo\
AgwRCAANAwsgAyAFIAZqIgFBHGotAAA6ACggAyABQQRqKQIAQiCJNwMIIAFBGGooAgAhCSACKAIQIQ\
pBACELQQAhBwJAAkACQCABQRRqKAIADgMBAAIBCyAJQQN0IQxBACEHIAogDGoiDEEEaigCAEEERw0B\
IAwoAgAoAgAhCQtBASEHCyADIAk2AhQgAyAHNgIQIAFBEGooAgAhBwJAAkACQCABQQxqKAIADgMBAA\
IBCyAHQQN0IQkgCiAJaiIJQQRqKAIAQQRHDQEgCSgCACgCACEHC0EBIQsLIAMgBzYCHCADIAs2Ahgg\
CiABKAIAQQN0aiIBKAIAIANBCGogASgCBBEGAA0CIABBCGohACAIIAZBIGoiBkcNAAsLAkAgBCACKA\
IETw0AIAMoAiAgAigCACAEQQN0aiIBKAIAIAEoAgQgAygCJCgCDBEIAA0BC0EAIQEMAQtBASEBCyAD\
QTBqJAAgAQuaBAIDfwJ+IwBB8AFrIgMkACAAKQMAIQYgASABLQBAIgRqIgVBgAE6AAAgA0EIakEQai\
AAQRhqKAIANgIAIANBEGogAEEQaikCADcDACADIAApAgg3AwggBkIJhiEGIAStQgOGIQcCQCAEQT9z\
IgBFDQAgBUEBakEAIAAQkwEaCyAGIAeEIQYCQAJAIARBOHFBOEYNACABIAY3ADggA0EIaiABEBMMAQ\
sgA0EIaiABEBMgA0HgAGpBDGpCADcCACADQeAAakEUakIANwIAIANB4ABqQRxqQgA3AgAgA0HgAGpB\
JGpCADcCACADQeAAakEsakIANwIAIANB4ABqQTRqQgA3AgAgA0GcAWpCADcCACADQgA3AmQgA0EANg\
JgIANB4ABqIANB4ABqQQRyQX9zakHEAGpBB0kaIANBwAA2AmAgA0GoAWogA0HgAGpBxAAQlAEaIANB\
0ABqIANBqAFqQTRqKQIANwMAIANByABqIANBqAFqQSxqKQIANwMAIANBwABqIANBqAFqQSRqKQIANw\
MAIANBOGogA0GoAWpBHGopAgA3AwAgA0EwaiADQagBakEUaikCADcDACADQShqIANBqAFqQQxqKQIA\
NwMAIAMgAykCrAE3AyAgAyAGNwNYIANBCGogA0EgahATCyABQQA6AEAgAiADKAIINgAAIAIgAykCDD\
cABCACIAMpAhQ3AAwgA0HwAWokAAuKBAEKfyMAQTBrIgYkAEEAIQcgBkEANgIIAkAgAUFAcSIIRQ0A\
QQEhByAGQQE2AgggBiAANgIAIAhBwABGDQBBAiEHIAZBAjYCCCAGIABBwABqNgIEIAhBgAFGDQAgBi\
AAQYABajYCEEGwkcAAIAZBEGpBoIbAAEGUh8AAEGEACyABQT9xIQkCQCAHIAVBBXYiASAHIAFJGyIB\
RQ0AIANBBHIhCiABQQV0IQtBACEDIAYhDANAIAwoAgAhASAGQRBqQRhqIg0gAkEYaikCADcDACAGQR\
BqQRBqIg4gAkEQaikCADcDACAGQRBqQQhqIg8gAkEIaikCADcDACAGIAIpAgA3AxAgBkEQaiABQcAA\
QgAgChAYIAQgA2oiAUEYaiANKQMANwAAIAFBEGogDikDADcAACABQQhqIA8pAwA3AAAgASAGKQMQNw\
AAIAxBBGohDCALIANBIGoiA0cNAAsLAkACQAJAAkAgCUUNACAHQQV0IgIgBUsNASAFIAJrIgFBH00N\
AiAJQSBHDQMgBCACaiICIAAgCGoiASkAADcAACACQRhqIAFBGGopAAA3AAAgAkEQaiABQRBqKQAANw\
AAIAJBCGogAUEIaikAADcAACAHQQFqIQcLIAZBMGokACAHDwsgAiAFQcCEwAAQjAEAC0EgIAFBwITA\
ABCLAQALQSAgCUHQhMAAEGoAC/IDAgN/An4jAEHgAWsiAyQAIAApAwAhBiABIAEtAEAiBGoiBUGAAT\
oAACADQQhqIABBEGopAgA3AwAgAyAAKQIINwMAIAZCCYYhBiAErUIDhiEHAkAgBEE/cyIARQ0AIAVB\
AWpBACAAEJMBGgsgBiAHhCEGAkACQCAEQThxQThGDQAgASAGNwA4IAMgARAdDAELIAMgARAdIANB0A\
BqQQxqQgA3AgAgA0HQAGpBFGpCADcCACADQdAAakEcakIANwIAIANB0ABqQSRqQgA3AgAgA0HQAGpB\
LGpCADcCACADQdAAakE0akIANwIAIANBjAFqQgA3AgAgA0IANwJUIANBADYCUCADQdAAaiADQdAAak\
EEckF/c2pBxABqQQdJGiADQcAANgJQIANBmAFqIANB0ABqQcQAEJQBGiADQcAAaiADQZgBakE0aikC\
ADcDACADQThqIANBmAFqQSxqKQIANwMAIANBMGogA0GYAWpBJGopAgA3AwAgA0EoaiADQZgBakEcai\
kCADcDACADQSBqIANBmAFqQRRqKQIANwMAIANBGGogA0GYAWpBDGopAgA3AwAgAyADKQKcATcDECAD\
IAY3A0ggAyADQRBqEB0LIAFBADoAQCACIAMpAwA3AAAgAiADKQMINwAIIANB4AFqJAAL8gMCA38Cfi\
MAQeABayIDJAAgACkDACEGIAEgAS0AQCIEaiIFQYABOgAAIANBCGogAEEQaikCADcDACADIAApAgg3\
AwAgBkIJhiEGIAStQgOGIQcCQCAEQT9zIgBFDQAgBUEBakEAIAAQkwEaCyAGIAeEIQYCQAJAIARBOH\
FBOEYNACABIAY3ADggAyABEBsMAQsgAyABEBsgA0HQAGpBDGpCADcCACADQdAAakEUakIANwIAIANB\
0ABqQRxqQgA3AgAgA0HQAGpBJGpCADcCACADQdAAakEsakIANwIAIANB0ABqQTRqQgA3AgAgA0GMAW\
pCADcCACADQgA3AlQgA0EANgJQIANB0ABqIANB0ABqQQRyQX9zakHEAGpBB0kaIANBwAA2AlAgA0GY\
AWogA0HQAGpBxAAQlAEaIANBwABqIANBmAFqQTRqKQIANwMAIANBOGogA0GYAWpBLGopAgA3AwAgA0\
EwaiADQZgBakEkaikCADcDACADQShqIANBmAFqQRxqKQIANwMAIANBIGogA0GYAWpBFGopAgA3AwAg\
A0EYaiADQZgBakEMaikCADcDACADIAMpApwBNwMQIAMgBjcDSCADIANBEGoQGwsgAUEAOgBAIAIgAy\
kDADcAACACIAMpAwg3AAggA0HgAWokAAvnAwIEfwJ+IwBB0AFrIgMkACABIAEtAEAiBGoiBUEBOgAA\
IAApAwBCCYYhByAErUIDhiEIAkAgBEE/cyIGRQ0AIAVBAWpBACAGEJMBGgsgByAIhCEHAkACQCAEQT\
hxQThGDQAgASAHNwA4IABBCGogARAWDAELIABBCGoiBCABEBYgA0HAAGpBDGpCADcCACADQcAAakEU\
akIANwIAIANBwABqQRxqQgA3AgAgA0HAAGpBJGpCADcCACADQcAAakEsakIANwIAIANBwABqQTRqQg\
A3AgAgA0H8AGpCADcCACADQgA3AkQgA0EANgJAIANBwABqIANBwABqQQRyQX9zakHEAGpBB0kaIANB\
wAA2AkAgA0GIAWogA0HAAGpBxAAQlAEaIANBMGogA0GIAWpBNGopAgA3AwAgA0EoaiADQYgBakEsai\
kCADcDACADQSBqIANBiAFqQSRqKQIANwMAIANBGGogA0GIAWpBHGopAgA3AwAgA0EQaiADQYgBakEU\
aikCADcDACADQQhqIANBiAFqQQxqKQIANwMAIAMgAykCjAE3AwAgAyAHNwM4IAQgAxAWCyABQQA6AE\
AgAiAAKQMINwAAIAIgAEEQaikDADcACCACIABBGGopAwA3ABAgA0HQAWokAAuAAwEFfwJAAkACQCAB\
QQlJDQBBACECQc3/eyABQRAgAUEQSxsiAWsgAE0NASABQRAgAEELakF4cSAAQQtJGyIDakEMahAZIg\
BFDQEgAEF4aiECAkACQCABQX9qIgQgAHENACACIQEMAQsgAEF8aiIFKAIAIgZBeHEgBCAAakEAIAFr\
cUF4aiIAQQAgASAAIAJrQRBLG2oiASACayIAayEEAkAgBkEDcUUNACABIAEoAgRBAXEgBHJBAnI2Ag\
QgASAEaiIEIAQoAgRBAXI2AgQgBSAFKAIAQQFxIAByQQJyNgIAIAIgAGoiBCAEKAIEQQFyNgIEIAIg\
ABAkDAELIAIoAgAhAiABIAQ2AgQgASACIABqNgIACyABKAIEIgBBA3FFDQIgAEF4cSICIANBEGpNDQ\
IgASAAQQFxIANyQQJyNgIEIAEgA2oiACACIANrIgNBA3I2AgQgASACaiICIAIoAgRBAXI2AgQgACAD\
ECQMAgsgABAZIQILIAIPCyABQQhqC4sDAQJ/IwBBkAFrIgAkAAJAQfAAEBkiAUUNACAAQQxqQgA3Ag\
AgAEEUakIANwIAIABBHGpCADcCACAAQSRqQgA3AgAgAEEsakIANwIAIABBNGpCADcCACAAQTxqQgA3\
AgAgAEIANwIEIABBADYCACAAIABBBHJBf3NqQcQAakEHSRogAEHAADYCACAAQcgAaiAAQcQAEJQBGi\
ABQeAAaiAAQcgAakE8aikCADcAACABQdgAaiAAQcgAakE0aikCADcAACABQdAAaiAAQcgAakEsaikC\
ADcAACABQcgAaiAAQcgAakEkaikCADcAACABQcAAaiAAQcgAakEcaikCADcAACABQThqIABByABqQR\
RqKQIANwAAIAFBMGogAEHIAGpBDGopAgA3AAAgASAAKQJMNwAoIAFCADcDACABQegAakEAOgAAIAFB\
ACkDyI1ANwMIIAFBEGpBACkD0I1ANwMAIAFBGGpBACkD2I1ANwMAIAFBIGpBACkD4I1ANwMAIABBkA\
FqJAAgAQ8LAAuLAwECfyMAQZABayIAJAACQEHwABAZIgFFDQAgAEEMakIANwIAIABBFGpCADcCACAA\
QRxqQgA3AgAgAEEkakIANwIAIABBLGpCADcCACAAQTRqQgA3AgAgAEE8akIANwIAIABCADcCBCAAQQ\
A2AgAgACAAQQRyQX9zakHEAGpBB0kaIABBwAA2AgAgAEHIAGogAEHEABCUARogAUHgAGogAEHIAGpB\
PGopAgA3AAAgAUHYAGogAEHIAGpBNGopAgA3AAAgAUHQAGogAEHIAGpBLGopAgA3AAAgAUHIAGogAE\
HIAGpBJGopAgA3AAAgAUHAAGogAEHIAGpBHGopAgA3AAAgAUE4aiAAQcgAakEUaikCADcAACABQTBq\
IABByABqQQxqKQIANwAAIAEgACkCTDcAKCABQgA3AwAgAUHoAGpBADoAACABQQApA6iNQDcDCCABQR\
BqQQApA7CNQDcDACABQRhqQQApA7iNQDcDACABQSBqQQApA8CNQDcDACAAQZABaiQAIAEPCwAL+wIB\
An8jAEGQAWsiACQAAkBB6AAQGSIBRQ0AIABBDGpCADcCACAAQRRqQgA3AgAgAEEcakIANwIAIABBJG\
pCADcCACAAQSxqQgA3AgAgAEE0akIANwIAIABBPGpCADcCACAAQgA3AgQgAEEANgIAIAAgAEEEckF/\
c2pBxABqQQdJGiAAQcAANgIAIABByABqIABBxAAQlAEaIAFB2ABqIABByABqQTxqKQIANwAAIAFB0A\
BqIABByABqQTRqKQIANwAAIAFByABqIABByABqQSxqKQIANwAAIAFBwABqIABByABqQSRqKQIANwAA\
IAFBOGogAEHIAGpBHGopAgA3AAAgAUEwaiAAQcgAakEUaikCADcAACABQShqIABByABqQQxqKQIANw\
AAIAEgACkCTDcAICABQgA3AwAgAUHgAGpBADoAACABQQApA5CNQDcDCCABQRBqQQApA5iNQDcDACAB\
QRhqQQAoAqCNQDYCACAAQZABaiQAIAEPCwAL+wIBAn8jAEGQAWsiACQAAkBB6AAQGSIBRQ0AIAFCAD\
cDACABQQApA+DRQDcDCCABQRBqQQApA+jRQDcDACABQRhqQQApA/DRQDcDACAAQQxqQgA3AgAgAEEU\
akIANwIAIABBHGpCADcCACAAQSRqQgA3AgAgAEEsakIANwIAIABBNGpCADcCACAAQTxqQgA3AgAgAE\
IANwIEIABBADYCACAAIABBBHJBf3NqQcQAakEHSRogAEHAADYCACAAQcgAaiAAQcQAEJQBGiABQdgA\
aiAAQcgAakE8aikCADcAACABQdAAaiAAQcgAakE0aikCADcAACABQcgAaiAAQcgAakEsaikCADcAAC\
ABQcAAaiAAQcgAakEkaikCADcAACABQThqIABByABqQRxqKQIANwAAIAFBMGogAEHIAGpBFGopAgA3\
AAAgAUEoaiAAQcgAakEMaikCADcAACABIAApAkw3ACAgAUHgAGpBADoAACAAQZABaiQAIAEPCwALqQ\
MBAX8gAiACLQCoASIDakEAQagBIANrEJMBIQMgAkEAOgCoASADQR86AAAgAiACLQCnAUGAAXI6AKcB\
IAEgASkDACACKQAAhTcDACABIAEpAwggAikACIU3AwggASABKQMQIAIpABCFNwMQIAEgASkDGCACKQ\
AYhTcDGCABIAEpAyAgAikAIIU3AyAgASABKQMoIAIpACiFNwMoIAEgASkDMCACKQAwhTcDMCABIAEp\
AzggAikAOIU3AzggASABKQNAIAIpAECFNwNAIAEgASkDSCACKQBIhTcDSCABIAEpA1AgAikAUIU3A1\
AgASABKQNYIAIpAFiFNwNYIAEgASkDYCACKQBghTcDYCABIAEpA2ggAikAaIU3A2ggASABKQNwIAIp\
AHCFNwNwIAEgASkDeCACKQB4hTcDeCABIAEpA4ABIAIpAIABhTcDgAEgASABKQOIASACKQCIAYU3A4\
gBIAEgASkDkAEgAikAkAGFNwOQASABIAEpA5gBIAIpAJgBhTcDmAEgASABKQOgASACKQCgAYU3A6AB\
IAEQJSAAIAFByAEQlAEaC+8CAQN/AkACQAJAAkAgAC0AaCIDRQ0AAkAgA0HBAE8NACAAQShqIgQgA2\
ogAUHAACADayIDIAIgAyACSRsiAxCUARogACAALQBoIANqIgU6AGggASADaiEBAkAgAiADayICDQBB\
ACECDAMLIABBCGogBEHAACAAKQMAIAAtAGogAEHpAGoiAy0AAEVyEBggBEEAQcEAEJMBGiADIAMtAA\
BBAWo6AAAMAQsgA0HAAEGghMAAEIwBAAtBACEDIAJBwQBJDQEgAEEIaiEEIABB6QBqIgMtAAAhBQNA\
IAQgAUHAACAAKQMAIAAtAGogBUH/AXFFchAYIAMgAy0AAEEBaiIFOgAAIAFBwABqIQEgAkFAaiICQc\
AASw0ACyAALQBoIQULIAVB/wFxIgNBwQBPDQELIAAgA2pBKGogAUHAACADayIDIAIgAyACSRsiAhCU\
ARogACAALQBoIAJqOgBoIAAPCyADQcAAQaCEwAAQjAEAC50DAQJ/IwBBEGsiAyQAIAEgAS0AkAEiBG\
pBAEGQASAEaxCTASEEIAFBADoAkAEgBEEBOgAAIAEgAS0AjwFBgAFyOgCPASAAIAApAwAgASkAAIU3\
AwAgACAAKQMIIAEpAAiFNwMIIAAgACkDECABKQAQhTcDECAAIAApAxggASkAGIU3AxggACAAKQMgIA\
EpACCFNwMgIAAgACkDKCABKQAohTcDKCAAIAApAzAgASkAMIU3AzAgACAAKQM4IAEpADiFNwM4IAAg\
ACkDQCABKQBAhTcDQCAAIAApA0ggASkASIU3A0ggACAAKQNQIAEpAFCFNwNQIAAgACkDWCABKQBYhT\
cDWCAAIAApA2AgASkAYIU3A2AgACAAKQNoIAEpAGiFNwNoIAAgACkDcCABKQBwhTcDcCAAIAApA3gg\
ASkAeIU3A3ggACAAKQOAASABKQCAAYU3A4ABIAAgACkDiAEgASkAiAGFNwOIASAAECUgAiAAKQMANw\
AAIAIgACkDCDcACCACIAApAxA3ABAgAiAAKQMYPgAYIANBEGokAAudAwECfyMAQRBrIgMkACABIAEt\
AJABIgRqQQBBkAEgBGsQkwEhBCABQQA6AJABIARBBjoAACABIAEtAI8BQYABcjoAjwEgACAAKQMAIA\
EpAACFNwMAIAAgACkDCCABKQAIhTcDCCAAIAApAxAgASkAEIU3AxAgACAAKQMYIAEpABiFNwMYIAAg\
ACkDICABKQAghTcDICAAIAApAyggASkAKIU3AyggACAAKQMwIAEpADCFNwMwIAAgACkDOCABKQA4hT\
cDOCAAIAApA0AgASkAQIU3A0AgACAAKQNIIAEpAEiFNwNIIAAgACkDUCABKQBQhTcDUCAAIAApA1gg\
ASkAWIU3A1ggACAAKQNgIAEpAGCFNwNgIAAgACkDaCABKQBohTcDaCAAIAApA3AgASkAcIU3A3AgAC\
AAKQN4IAEpAHiFNwN4IAAgACkDgAEgASkAgAGFNwOAASAAIAApA4gBIAEpAIgBhTcDiAEgABAlIAIg\
ACkDADcAACACIAApAwg3AAggAiAAKQMQNwAQIAIgACkDGD4AGCADQRBqJAALlgMBBH8jAEGQBGsiAy\
QAAkAgAkUNACACQagBbCEEIANB4AJqQQRyIQUgA0GwAWogA0GwAWpBBHIiBkF/c2pBrAFqQQdJGgNA\
IAAoAgAhAiADQQA2ArABIAZBAEGoARCTARogA0GoATYCsAEgA0HgAmogA0GwAWpBrAEQlAEaIANBCG\
ogBUGoARCUARogAyACKQMANwMIIAMgAikDCDcDECADIAIpAxA3AxggAyACKQMYNwMgIAMgAikDIDcD\
KCADIAIpAyg3AzAgAyACKQMwNwM4IAMgAikDODcDQCADIAIpA0A3A0ggAyACKQNINwNQIAMgAikDUD\
cDWCADIAIpA1g3A2AgAyACKQNgNwNoIAMgAikDaDcDcCADIAIpA3A3A3ggAyACKQN4NwOAASADIAIp\
A4ABNwOIASADIAIpA4gBNwOQASADIAIpA5ABNwOYASADIAIpA5gBNwOgASADIAIpA6ABNwOoASACEC\
UgASADQQhqQagBEJQBGiABQagBaiEBIARB2H5qIgQNAAsLIANBkARqJAAL+gIBAn8jAEGQAWsiACQA\
AkBB6AAQGSIBRQ0AIABBDGpCADcCACAAQRRqQgA3AgAgAEEcakIANwIAIABBJGpCADcCACAAQSxqQg\
A3AgAgAEE0akIANwIAIABBPGpCADcCACAAQgA3AgQgAEEANgIAIAAgAEEEckF/c2pBxABqQQdJGiAA\
QcAANgIAIABByABqIABBxAAQlAEaIAFB2ABqIABByABqQTxqKQIANwAAIAFB0ABqIABByABqQTRqKQ\
IANwAAIAFByABqIABByABqQSxqKQIANwAAIAFBwABqIABByABqQSRqKQIANwAAIAFBOGogAEHIAGpB\
HGopAgA3AAAgAUEwaiAAQcgAakEUaikCADcAACABQShqIABByABqQQxqKQIANwAAIAEgACkCTDcAIC\
ABQfDDy558NgIYIAFC/rnrxemOlZkQNwMQIAFCgcaUupbx6uZvNwMIIAFCADcDACABQeAAakEAOgAA\
IABBkAFqJAAgAQ8LAAvkAgEEfyMAQZAEayIDJAAgAyAANgIEIABByAFqIQQCQAJAAkACQAJAIABB8A\
JqLQAAIgVFDQBBqAEgBWsiBiACSw0BIAEgBCAFaiAGEJQBIAZqIQEgAiAGayECCyACIAJBqAFuIgZB\
qAFsIgVJDQEgA0EEaiABIAYQOgJAIAIgBWsiAg0AQQAhAgwECyADQQA2ArABIANBsAFqIANBsAFqQQ\
RyQQBBqAEQkwFBf3NqQawBakEHSRogA0GoATYCsAEgA0HgAmogA0GwAWpBrAEQlAEaIANBCGogA0Hg\
AmpBBHJBqAEQlAEaIANBBGogA0EIakEBEDogAkGpAU8NAiABIAVqIANBCGogAhCUARogBCADQQhqQa\
gBEJQBGgwDCyABIAQgBWogAhCUARogBSACaiECDAILQeiMwABBI0HIjMAAEHIACyACQagBQdiMwAAQ\
iwEACyAAIAI6APACIANBkARqJAAL5AIBBH8jAEGwA2siAyQAIAMgADYCBCAAQcgBaiEEAkACQAJAAk\
ACQCAAQdACai0AACIFRQ0AQYgBIAVrIgYgAksNASABIAQgBWogBhCUASAGaiEBIAIgBmshAgsgAiAC\
QYgBbiIGQYgBbCIFSQ0BIANBBGogASAGEEMCQCACIAVrIgINAEEAIQIMBAsgA0EANgKQASADQZABai\
ADQZABakEEckEAQYgBEJMBQX9zakGMAWpBB0kaIANBiAE2ApABIANBoAJqIANBkAFqQYwBEJQBGiAD\
QQhqIANBoAJqQQRyQYgBEJQBGiADQQRqIANBCGpBARBDIAJBiQFPDQIgASAFaiADQQhqIAIQlAEaIA\
QgA0EIakGIARCUARoMAwsgASAEIAVqIAIQlAEaIAUgAmohAgwCC0HojMAAQSNByIzAABByAAsgAkGI\
AUHYjMAAEIsBAAsgACACOgDQAiADQbADaiQAC5EDAQF/AkAgAkUNACABIAJBqAFsaiEDIAAoAgAhAg\
NAIAIgAikDACABKQAAhTcDACACIAIpAwggASkACIU3AwggAiACKQMQIAEpABCFNwMQIAIgAikDGCAB\
KQAYhTcDGCACIAIpAyAgASkAIIU3AyAgAiACKQMoIAEpACiFNwMoIAIgAikDMCABKQAwhTcDMCACIA\
IpAzggASkAOIU3AzggAiACKQNAIAEpAECFNwNAIAIgAikDSCABKQBIhTcDSCACIAIpA1AgASkAUIU3\
A1AgAiACKQNYIAEpAFiFNwNYIAIgAikDYCABKQBghTcDYCACIAIpA2ggASkAaIU3A2ggAiACKQNwIA\
EpAHCFNwNwIAIgAikDeCABKQB4hTcDeCACIAIpA4ABIAEpAIABhTcDgAEgAiACKQOIASABKQCIAYU3\
A4gBIAIgAikDkAEgASkAkAGFNwOQASACIAIpA5gBIAEpAJgBhTcDmAEgAiACKQOgASABKQCgAYU3A6\
ABIAIQJSABQagBaiIBIANHDQALCwvuAgECfyMAQZABayIAJAACQEHgABAZIgFFDQAgAEEMakIANwIA\
IABBFGpCADcCACAAQRxqQgA3AgAgAEEkakIANwIAIABBLGpCADcCACAAQTRqQgA3AgAgAEE8akIANw\
IAIABCADcCBCAAQQA2AgAgACAAQQRyQX9zakHEAGpBB0kaIABBwAA2AgAgAEHIAGogAEHEABCUARog\
AUHQAGogAEHIAGpBPGopAgA3AAAgAUHIAGogAEHIAGpBNGopAgA3AAAgAUHAAGogAEHIAGpBLGopAg\
A3AAAgAUE4aiAAQcgAakEkaikCADcAACABQTBqIABByABqQRxqKQIANwAAIAFBKGogAEHIAGpBFGop\
AgA3AAAgAUEgaiAAQcgAakEMaikCADcAACABIAApAkw3ABggAUL+uevF6Y6VmRA3AxAgAUKBxpS6lv\
Hq5m83AwggAUIANwMAIAFB2ABqQQA6AAAgAEGQAWokACABDwsAC7wCAQh/AkACQCACQQ9LDQAgACED\
DAELIABBACAAa0EDcSIEaiEFAkAgBEUNACAAIQMgASEGA0AgAyAGLQAAOgAAIAZBAWohBiADQQFqIg\
MgBUkNAAsLIAUgAiAEayIHQXxxIghqIQMCQAJAIAEgBGoiCUEDcSIGRQ0AIAhBAUgNASAJQXxxIgpB\
BGohAUEAIAZBA3QiAmtBGHEhBCAKKAIAIQYDQCAFIAYgAnYgASgCACIGIAR0cjYCACABQQRqIQEgBU\
EEaiIFIANJDQAMAgsLIAhBAUgNACAJIQEDQCAFIAEoAgA2AgAgAUEEaiEBIAVBBGoiBSADSQ0ACwsg\
B0EDcSECIAkgCGohAQsCQCACRQ0AIAMgAmohBQNAIAMgAS0AADoAACABQQFqIQEgA0EBaiIDIAVJDQ\
ALCyAAC/oCAQF/IAEgAS0AiAEiA2pBAEGIASADaxCTASEDIAFBADoAiAEgA0EBOgAAIAEgAS0AhwFB\
gAFyOgCHASAAIAApAwAgASkAAIU3AwAgACAAKQMIIAEpAAiFNwMIIAAgACkDECABKQAQhTcDECAAIA\
ApAxggASkAGIU3AxggACAAKQMgIAEpACCFNwMgIAAgACkDKCABKQAohTcDKCAAIAApAzAgASkAMIU3\
AzAgACAAKQM4IAEpADiFNwM4IAAgACkDQCABKQBAhTcDQCAAIAApA0ggASkASIU3A0ggACAAKQNQIA\
EpAFCFNwNQIAAgACkDWCABKQBYhTcDWCAAIAApA2AgASkAYIU3A2AgACAAKQNoIAEpAGiFNwNoIAAg\
ACkDcCABKQBwhTcDcCAAIAApA3ggASkAeIU3A3ggACAAKQOAASABKQCAAYU3A4ABIAAQJSACIAApAw\
A3AAAgAiAAKQMINwAIIAIgACkDEDcAECACIAApAxg3ABgL+gIBAX8gASABLQCIASIDakEAQYgBIANr\
EJMBIQMgAUEAOgCIASADQQY6AAAgASABLQCHAUGAAXI6AIcBIAAgACkDACABKQAAhTcDACAAIAApAw\
ggASkACIU3AwggACAAKQMQIAEpABCFNwMQIAAgACkDGCABKQAYhTcDGCAAIAApAyAgASkAIIU3AyAg\
ACAAKQMoIAEpACiFNwMoIAAgACkDMCABKQAwhTcDMCAAIAApAzggASkAOIU3AzggACAAKQNAIAEpAE\
CFNwNAIAAgACkDSCABKQBIhTcDSCAAIAApA1AgASkAUIU3A1AgACAAKQNYIAEpAFiFNwNYIAAgACkD\
YCABKQBghTcDYCAAIAApA2ggASkAaIU3A2ggACAAKQNwIAEpAHCFNwNwIAAgACkDeCABKQB4hTcDeC\
AAIAApA4ABIAEpAIABhTcDgAEgABAlIAIgACkDADcAACACIAApAwg3AAggAiAAKQMQNwAQIAIgACkD\
GDcAGAvmAgEEfyMAQbADayIDJAACQCACRQ0AIAJBiAFsIQQgA0GgAmpBBHIhBSADQZABaiADQZABak\
EEciIGQX9zakGMAWpBB0kaA0AgACgCACECIANBADYCkAEgBkEAQYgBEJMBGiADQYgBNgKQASADQaAC\
aiADQZABakGMARCUARogA0EIaiAFQYgBEJQBGiADIAIpAwA3AwggAyACKQMINwMQIAMgAikDEDcDGC\
ADIAIpAxg3AyAgAyACKQMgNwMoIAMgAikDKDcDMCADIAIpAzA3AzggAyACKQM4NwNAIAMgAikDQDcD\
SCADIAIpA0g3A1AgAyACKQNQNwNYIAMgAikDWDcDYCADIAIpA2A3A2ggAyACKQNoNwNwIAMgAikDcD\
cDeCADIAIpA3g3A4ABIAMgAikDgAE3A4gBIAIQJSABIANBCGpBiAEQlAEaIAFBiAFqIQEgBEH4fmoi\
BA0ACwsgA0GwA2okAAvYAgEBfwJAIAJFDQAgASACQZABbGohAyAAKAIAIQIDQCACIAIpAwAgASkAAI\
U3AwAgAiACKQMIIAEpAAiFNwMIIAIgAikDECABKQAQhTcDECACIAIpAxggASkAGIU3AxggAiACKQMg\
IAEpACCFNwMgIAIgAikDKCABKQAohTcDKCACIAIpAzAgASkAMIU3AzAgAiACKQM4IAEpADiFNwM4IA\
IgAikDQCABKQBAhTcDQCACIAIpA0ggASkASIU3A0ggAiACKQNQIAEpAFCFNwNQIAIgAikDWCABKQBY\
hTcDWCACIAIpA2AgASkAYIU3A2AgAiACKQNoIAEpAGiFNwNoIAIgAikDcCABKQBwhTcDcCACIAIpA3\
ggASkAeIU3A3ggAiACKQOAASABKQCAAYU3A4ABIAIgAikDiAEgASkAiAGFNwOIASACECUgAUGQAWoi\
ASADRw0ACwsL3QIBAX8gAiACLQCIASIDakEAQYgBIANrEJMBIQMgAkEAOgCIASADQR86AAAgAiACLQ\
CHAUGAAXI6AIcBIAEgASkDACACKQAAhTcDACABIAEpAwggAikACIU3AwggASABKQMQIAIpABCFNwMQ\
IAEgASkDGCACKQAYhTcDGCABIAEpAyAgAikAIIU3AyAgASABKQMoIAIpACiFNwMoIAEgASkDMCACKQ\
AwhTcDMCABIAEpAzggAikAOIU3AzggASABKQNAIAIpAECFNwNAIAEgASkDSCACKQBIhTcDSCABIAEp\
A1AgAikAUIU3A1AgASABKQNYIAIpAFiFNwNYIAEgASkDYCACKQBghTcDYCABIAEpA2ggAikAaIU3A2\
ggASABKQNwIAIpAHCFNwNwIAEgASkDeCACKQB4hTcDeCABIAEpA4ABIAIpAIABhTcDgAEgARAlIAAg\
AUHIARCUARoLswIBBH9BHyECAkAgAUH///8HSw0AIAFBBiABQQh2ZyICa3ZBAXEgAkEBdGtBPmohAg\
sgAEIANwIQIAAgAjYCHCACQQJ0QfzUwABqIQMCQAJAAkACQAJAQQAoAvDSQCIEQQEgAnQiBXFFDQAg\
AygCACIEKAIEQXhxIAFHDQEgBCECDAILQQAgBCAFcjYC8NJAIAMgADYCACAAIAM2AhgMAwsgAUEAQR\
kgAkEBdmtBH3EgAkEfRht0IQMDQCAEIANBHXZBBHFqQRBqIgUoAgAiAkUNAiADQQF0IQMgAiEEIAIo\
AgRBeHEgAUcNAAsLIAIoAggiAyAANgIMIAIgADYCCCAAQQA2AhggACACNgIMIAAgAzYCCA8LIAUgAD\
YCACAAIAQ2AhgLIAAgADYCDCAAIAA2AggLugIBBX8gACgCGCEBAkACQAJAIAAoAgwiAiAARw0AIABB\
FEEQIABBFGoiAigCACIDG2ooAgAiBA0BQQAhAgwCCyAAKAIIIgQgAjYCDCACIAQ2AggMAQsgAiAAQR\
BqIAMbIQMDQCADIQUCQCAEIgJBFGoiAygCACIEDQAgAkEQaiEDIAIoAhAhBAsgBA0ACyAFQQA2AgAL\
AkAgAUUNAAJAAkAgACgCHEECdEH81MAAaiIEKAIAIABGDQAgAUEQQRQgASgCECAARhtqIAI2AgAgAg\
0BDAILIAQgAjYCACACDQBBAEEAKALw0kBBfiAAKAIcd3E2AvDSQA8LIAIgATYCGAJAIAAoAhAiBEUN\
ACACIAQ2AhAgBCACNgIYCyAAQRRqKAIAIgRFDQAgAkEUaiAENgIAIAQgAjYCGA8LC8UCAQF/AkAgAk\
UNACABIAJBiAFsaiEDIAAoAgAhAgNAIAIgAikDACABKQAAhTcDACACIAIpAwggASkACIU3AwggAiAC\
KQMQIAEpABCFNwMQIAIgAikDGCABKQAYhTcDGCACIAIpAyAgASkAIIU3AyAgAiACKQMoIAEpACiFNw\
MoIAIgAikDMCABKQAwhTcDMCACIAIpAzggASkAOIU3AzggAiACKQNAIAEpAECFNwNAIAIgAikDSCAB\
KQBIhTcDSCACIAIpA1AgASkAUIU3A1AgAiACKQNYIAEpAFiFNwNYIAIgAikDYCABKQBghTcDYCACIA\
IpA2ggASkAaIU3A2ggAiACKQNwIAEpAHCFNwNwIAIgAikDeCABKQB4hTcDeCACIAIpA4ABIAEpAIAB\
hTcDgAEgAhAlIAFBiAFqIgEgA0cNAAsLC8cCAQF/IAEgAS0AaCIDakEAQegAIANrEJMBIQMgAUEAOg\
BoIANBAToAACABIAEtAGdBgAFyOgBnIAAgACkDACABKQAAhTcDACAAIAApAwggASkACIU3AwggACAA\
KQMQIAEpABCFNwMQIAAgACkDGCABKQAYhTcDGCAAIAApAyAgASkAIIU3AyAgACAAKQMoIAEpACiFNw\
MoIAAgACkDMCABKQAwhTcDMCAAIAApAzggASkAOIU3AzggACAAKQNAIAEpAECFNwNAIAAgACkDSCAB\
KQBIhTcDSCAAIAApA1AgASkAUIU3A1AgACAAKQNYIAEpAFiFNwNYIAAgACkDYCABKQBghTcDYCAAEC\
UgAiAAKQMANwAAIAIgACkDCDcACCACIAApAxA3ABAgAiAAKQMYNwAYIAIgACkDIDcAICACIAApAyg3\
ACgLxwIBAX8gASABLQBoIgNqQQBB6AAgA2sQkwEhAyABQQA6AGggA0EGOgAAIAEgAS0AZ0GAAXI6AG\
cgACAAKQMAIAEpAACFNwMAIAAgACkDCCABKQAIhTcDCCAAIAApAxAgASkAEIU3AxAgACAAKQMYIAEp\
ABiFNwMYIAAgACkDICABKQAghTcDICAAIAApAyggASkAKIU3AyggACAAKQMwIAEpADCFNwMwIAAgAC\
kDOCABKQA4hTcDOCAAIAApA0AgASkAQIU3A0AgACAAKQNIIAEpAEiFNwNIIAAgACkDUCABKQBQhTcD\
UCAAIAApA1ggASkAWIU3A1ggACAAKQNgIAEpAGCFNwNgIAAQJSACIAApAwA3AAAgAiAAKQMINwAIIA\
IgACkDEDcAECACIAApAxg3ABggAiAAKQMgNwAgIAIgACkDKDcAKAubAgEBfyABIAEtAEgiA2pBAEHI\
ACADaxCTASEDIAFBADoASCADQQE6AAAgASABLQBHQYABcjoARyAAIAApAwAgASkAAIU3AwAgACAAKQ\
MIIAEpAAiFNwMIIAAgACkDECABKQAQhTcDECAAIAApAxggASkAGIU3AxggACAAKQMgIAEpACCFNwMg\
IAAgACkDKCABKQAohTcDKCAAIAApAzAgASkAMIU3AzAgACAAKQM4IAEpADiFNwM4IAAgACkDQCABKQ\
BAhTcDQCAAECUgAiAAKQMANwAAIAIgACkDCDcACCACIAApAxA3ABAgAiAAKQMYNwAYIAIgACkDIDcA\
ICACIAApAyg3ACggAiAAKQMwNwAwIAIgACkDODcAOAubAgEBfyABIAEtAEgiA2pBAEHIACADaxCTAS\
EDIAFBADoASCADQQY6AAAgASABLQBHQYABcjoARyAAIAApAwAgASkAAIU3AwAgACAAKQMIIAEpAAiF\
NwMIIAAgACkDECABKQAQhTcDECAAIAApAxggASkAGIU3AxggACAAKQMgIAEpACCFNwMgIAAgACkDKC\
ABKQAohTcDKCAAIAApAzAgASkAMIU3AzAgACAAKQM4IAEpADiFNwM4IAAgACkDQCABKQBAhTcDQCAA\
ECUgAiAAKQMANwAAIAIgACkDCDcACCACIAApAxA3ABAgAiAAKQMYNwAYIAIgACkDIDcAICACIAApAy\
g3ACggAiAAKQMwNwAwIAIgACkDODcAOAuIAgECfyMAQZACayIAJAACQEHYARAZIgFFDQAgAEEANgIA\
IAAgAEEEckEAQYABEJMBQX9zakGEAWpBB0kaIABBgAE2AgAgAEGIAWogAEGEARCUARogAUHQAGogAE\
GIAWpBBHJBgAEQlAEaIAFByABqQgA3AwAgAUIANwNAIAFB0AFqQQA6AAAgAUEAKQPojUA3AwAgAUEI\
akEAKQPwjUA3AwAgAUEQakEAKQP4jUA3AwAgAUEYakEAKQOAjkA3AwAgAUEgakEAKQOIjkA3AwAgAU\
EoakEAKQOQjkA3AwAgAUEwakEAKQOYjkA3AwAgAUE4akEAKQOgjkA3AwAgAEGQAmokACABDwsAC4gC\
AQJ/IwBBkAJrIgAkAAJAQdgBEBkiAUUNACAAQQA2AgAgACAAQQRyQQBBgAEQkwFBf3NqQYQBakEHSR\
ogAEGAATYCACAAQYgBaiAAQYQBEJQBGiABQdAAaiAAQYgBakEEckGAARCUARogAUHIAGpCADcDACAB\
QgA3A0AgAUHQAWpBADoAACABQQApA6iOQDcDACABQQhqQQApA7COQDcDACABQRBqQQApA7iOQDcDAC\
ABQRhqQQApA8COQDcDACABQSBqQQApA8iOQDcDACABQShqQQApA9COQDcDACABQTBqQQApA9iOQDcD\
ACABQThqQQApA+COQDcDACAAQZACaiQAIAEPCwALggIBAX8CQCACRQ0AIAEgAkHoAGxqIQMgACgCAC\
ECA0AgAiACKQMAIAEpAACFNwMAIAIgAikDCCABKQAIhTcDCCACIAIpAxAgASkAEIU3AxAgAiACKQMY\
IAEpABiFNwMYIAIgAikDICABKQAghTcDICACIAIpAyggASkAKIU3AyggAiACKQMwIAEpADCFNwMwIA\
IgAikDOCABKQA4hTcDOCACIAIpA0AgASkAQIU3A0AgAiACKQNIIAEpAEiFNwNIIAIgAikDUCABKQBQ\
hTcDUCACIAIpA1ggASkAWIU3A1ggAiACKQNgIAEpAGCFNwNgIAIQJSABQegAaiIBIANHDQALCwvnAQ\
EHfyMAQRBrIgMkACACEAIhBCACEAMhBSACEAQhBgJAAkAgBEGBgARJDQBBACEHIAQhCANAIAMgBiAF\
IAdqIAhBgIAEIAhBgIAESRsQBSIJEF0CQCAJQSRJDQAgCRABCyAAIAEgAygCACIJIAMoAggQESAHQY\
CABGohBwJAIAMoAgRFDQAgCRAiCyAIQYCAfGohCCAEIAdLDQAMAgsLIAMgAhBdIAAgASADKAIAIgcg\
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\
AiQAQQAhAyACQQA2AgADQCACIANqQQRqIAEgA2ooAAA2AgAgAiADQQRqIgM2AgAgA0GAAUcNAAsgAk\
GIAWogAkGEARCUARogACACQYgBakEEckGAARCUASABLQCAAToAgAEgAkGQAmokAAt1AQJ/IwBBsAJr\
IgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIAIAIgA0EEaiIDNgIAIANBkAFHDQALIA\
JBmAFqIAJBlAEQlAEaIAAgAkGYAWpBBHJBkAEQlAEgAS0AkAE6AJABIAJBsAJqJAALdQECfyMAQaAC\
ayICJABBACEDIAJBADYCAANAIAIgA2pBBGogASADaigAADYCACACIANBBGoiAzYCACADQYgBRw0ACy\
ACQZABaiACQYwBEJQBGiAAIAJBkAFqQQRyQYgBEJQBIAEtAIgBOgCIASACQaACaiQAC3MBAn8jAEHg\
AWsiAiQAQQAhAyACQQA2AgADQCACIANqQQRqIAEgA2ooAAA2AgAgAiADQQRqIgM2AgAgA0HoAEcNAA\
sgAkHwAGogAkHsABCUARogACACQfAAakEEckHoABCUASABLQBoOgBoIAJB4AFqJAALcwECfyMAQaAB\
ayICJABBACEDIAJBADYCAANAIAIgA2pBBGogASADaigAADYCACACIANBBGoiAzYCACADQcgARw0ACy\
ACQdAAaiACQcwAEJQBGiAAIAJB0ABqQQRyQcgAEJQBIAEtAEg6AEggAkGgAWokAAt1AQJ/IwBB4AJr\
IgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIAIAIgA0EEaiIDNgIAIANBqAFHDQALIA\
JBsAFqIAJBrAEQlAEaIAAgAkGwAWpBBHJBqAEQlAEgAS0AqAE6AKgBIAJB4AJqJAALewECfyMAQTBr\
IgIkACACQRRqQQI2AgAgAkH0h8AANgIQIAJBAjYCDCACQdSHwAA2AgggAUEcaigCACEDIAEoAhghAS\
ACQQI2AiwgAkICNwIcIAJB1IjAADYCGCACIAJBCGo2AiggASADIAJBGGoQKyEBIAJBMGokACABC3sB\
An8jAEEwayICJAAgAkEUakECNgIAIAJB9IfAADYCECACQQI2AgwgAkHUh8AANgIIIAFBHGooAgAhAy\
ABKAIYIQEgAkECNgIsIAJCAjcCHCACQdSIwAA2AhggAiACQQhqNgIoIAEgAyACQRhqECshASACQTBq\
JAAgAQtsAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBAzYCACADQgM3Ag\
wgA0HQi8AANgIIIANBAzYCJCADIANBIGo2AhggAyADNgIoIAMgA0EEajYCICADQQhqIAIQdwALbAEB\
fyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQM2AgAgA0ICNwIMIANBsIjAAD\
YCCCADQQM2AiQgAyADQSBqNgIYIAMgAzYCKCADIANBBGo2AiAgA0EIaiACEHcAC2wBAX8jAEEwayID\
JAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEDNgIAIANCAjcCDCADQeCKwAA2AgggA0EDNg\
IkIAMgA0EgajYCGCADIANBBGo2AiggAyADNgIgIANBCGogAhB3AAtsAQF/IwBBMGsiAyQAIAMgATYC\
BCADIAA2AgAgA0EcakECNgIAIANBLGpBAzYCACADQgI3AgwgA0GAi8AANgIIIANBAzYCJCADIANBIG\
o2AhggAyADQQRqNgIoIAMgAzYCICADQQhqIAIQdwALVwECfwJAAkAgAEUNACAAKAIADQEgAEEANgIA\
IAAoAgghASAAKAIEIQIgABAiAkAgAkEERw0AIAEoApABRQ0AIAFBADYCkAELIAEQIg8LEJABAAsQkQ\
EAC1gBAn9BAEEAKALo0kAiAUEBajYC6NJAQQBBACgCsNZAQQFqIgI2ArDWQAJAIAFBAEgNACACQQJL\
DQBBACgC5NJAQX9MDQAgAkEBSw0AIABFDQAQlwEACwALSgEDf0EAIQMCQCACRQ0AAkADQCAALQAAIg\
QgAS0AACIFRw0BIABBAWohACABQQFqIQEgAkF/aiICRQ0CDAALCyAEIAVrIQMLIAMLRgACQAJAIAFF\
DQAgASgCAA0BIAFBfzYCACABQQRqKAIAIAFBCGooAgAgAhBQIAFBADYCACAAQgA3AwAPCxCQAQALEJ\
EBAAtHAQF/IwBBIGsiAyQAIANBFGpBADYCACADQdiQwAA2AhAgA0IBNwIEIAMgATYCHCADIAA2Ahgg\
AyADQRhqNgIAIAMgAhB3AAuLAQAgAEIANwNAIABC+cL4m5Gjs/DbADcDOCAAQuv6htq/tfbBHzcDMC\
AAQp/Y+dnCkdqCm383AyggAELRhZrv+s+Uh9EANwMgIABC8e30+KWn/aelfzcDGCAAQqvw0/Sv7ry3\
PDcDECAAQrvOqqbY0Ouzu383AwggACABrUKIkveV/8z5hOoAhTcDAAtFAQJ/IwBBEGsiASQAAkAgAC\
gCCCICDQBB2JDAAEErQaCRwAAQcgALIAEgACgCDDYCCCABIAA2AgQgASACNgIAIAEQewALQgEBfwJA\
AkACQCACQYCAxABGDQBBASEEIAAgAiABKAIQEQYADQELIAMNAUEAIQQLIAQPCyAAIANBACABKAIMEQ\
gACz8BAX8jAEEgayIAJAAgAEEcakEANgIAIABB2JDAADYCGCAAQgE3AgwgAEGUgsAANgIIIABBCGpB\
nILAABB3AAs+AQF/IwBBIGsiAiQAIAJBAToAGCACIAE2AhQgAiAANgIQIAJBwIjAADYCDCACQdiQwA\
A2AgggAkEIahB0AAs9AQJ/IAAoAgAiAUEUaigCACECAkACQCABKAIEDgIAAAELIAINACAAKAIELQAQ\
EG8ACyAAKAIELQAQEG8ACzMAAkAgAEH8////B0sNAAJAIAANAEEEDwsgACAAQf3///8HSUECdBAxIg\
BFDQAgAA8LAAtSACAAQsfMo9jW0Ouzu383AwggAEIANwMAIABBIGpCq7OP/JGjs/DbADcDACAAQRhq\
Qv+kuYjFkdqCm383AwAgAEEQakLy5rvjo6f9p6V/NwMACywBAX8jAEEQayIBJAAgAUEIaiAAQQhqKA\
IANgIAIAEgACkCADcDACABEHgACyYAAkAgAA0AQeiOwABBMBCSAQALIAAgAiADIAQgBSABKAIQEQwA\
CyQAAkAgAA0AQeiOwABBMBCSAQALIAAgAiADIAQgASgCEBEKAAskAAJAIAANAEHojsAAQTAQkgEACy\
AAIAIgAyAEIAEoAhARCQALJAACQCAADQBB6I7AAEEwEJIBAAsgACACIAMgBCABKAIQEQoACyQAAkAg\
AA0AQeiOwABBMBCSAQALIAAgAiADIAQgASgCEBEJAAskAAJAIAANAEHojsAAQTAQkgEACyAAIAIgAy\
AEIAEoAhARCQALJAACQCAADQBB6I7AAEEwEJIBAAsgACACIAMgBCABKAIQERcACyQAAkAgAA0AQeiO\
wABBMBCSAQALIAAgAiADIAQgASgCEBEYAAskAAJAIAANAEHojsAAQTAQkgEACyAAIAIgAyAEIAEoAh\
ARFgALIgACQCAADQBB6I7AAEEwEJIBAAsgACACIAMgASgCEBEHAAsgAAJAAkAgAUH8////B0sNACAA\
IAIQJiIBDQELAAsgAQsgAAJAIAANAEHojsAAQTAQkgEACyAAIAIgASgCEBEGAAsUACAAKAIAIAEgAC\
gCBCgCDBEGAAsQACABIAAoAgAgACgCBBAcCw4AAkAgAUUNACAAECILCwsAIAAgASACEG0ACwsAIAAg\
ASACEGwACxEAQayCwABBL0G4g8AAEHIACw0AIAAoAgAaA38MAAsLCwAgACMAaiQAIwALDQBB+NHAAE\
EbEJIBAAsOAEGT0sAAQc8AEJIBAAsJACAAIAEQCwALCgAgACABIAIQUwsKACAAIAEgAhBACwoAIAAg\
ASACEHALDABCuInPl4nG0fhMCwMAAAsCAAsL7NKAgAABAEGAgMAAC+JS6AUQAF0AAACVAAAACQAAAE\
JMQUtFMkJCTEFLRTJCLTI1NkJMQUtFMkItMzg0QkxBS0UyU0JMQUtFM0tFQ0NBSy0yMjRLRUNDQUst\
MjU2S0VDQ0FLLTM4NEtFQ0NBSy01MTJNRDRNRDVSSVBFTUQtMTYwU0hBLTFTSEEtMjI0U0hBLTI1Nl\
NIQS0zODRTSEEtNTEyVElHRVJ1bnN1cHBvcnRlZCBhbGdvcml0aG1ub24tZGVmYXVsdCBsZW5ndGgg\
c3BlY2lmaWVkIGZvciBub24tZXh0ZW5kYWJsZSBhbGdvcml0aG1saWJyYXJ5L2FsbG9jL3NyYy9yYX\
dfdmVjLnJzY2FwYWNpdHkgb3ZlcmZsb3cAAgEQABEAAADmABAAHAAAAAYCAAAFAAAAQXJyYXlWZWM6\
IGNhcGFjaXR5IGV4Y2VlZGVkIGluIGV4dGVuZC9mcm9tX2l0ZXJDOlxVc2Vyc1xheWFtZVwuY2FyZ2\
9ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xhcnJheXZlYy0wLjcuMlxz\
cmNcYXJyYXl2ZWMucnNbARAAXQAAAAEEAAAFAAAAQzpcVXNlcnNcYXlhbWVcLmNhcmdvXHJlZ2lzdH\
J5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcYmxha2UzLTEuMy4xXHNyY1xsaWIucnMA\
AMgBEABWAAAAuQEAAAkAAADIARAAVgAAAF8CAAAKAAAAyAEQAFYAAACNAgAACQAAAMgBEABWAAAAjQ\
IAADQAAADIARAAVgAAALkCAAAfAAAAyAEQAFYAAADdAgAACgAAAMgBEABWAAAA1gIAAAkAAADIARAA\
VgAAAAEDAAAZAAAAyAEQAFYAAAADAwAACQAAAMgBEABWAAAAAwMAADgAAADIARAAVgAAAPgDAAAeAA\
AAyAEQAFYAAACqBAAAFgAAAMgBEABWAAAAvAQAABYAAADIARAAVgAAAO0EAAASAAAAyAEQAFYAAAD3\
BAAAEgAAAMgBEABWAAAAaQUAACEAAAARAAAABAAAAAQAAAASAAAAQzpcVXNlcnNcYXlhbWVcLmNhcm\
dvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcYXJyYXl2ZWMtMC43LjJc\
c3JjXGFycmF5dmVjX2ltcGwucnMAADADEABiAAAAJwAAAAkAAAARAAAAIAAAAAEAAAATAAAAEQAAAA\
QAAAAEAAAAEgAAAENhcGFjaXR5RXJyb3IAAADEAxAADQAAAGluc3VmZmljaWVudCBjYXBhY2l0eQAA\
ANwDEAAVAAAAKWluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaX\
MgAP0DEAAgAAAAHQQQABIAAAARAAAAAAAAAAEAAAAUAAAAOiAAAFgIEAAAAAAAUAQQAAIAAAAwMDAx\
MDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMD\
MxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2\
MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4OD\
k5MDkxOTI5Mzk0OTU5Njk3OTg5OXJhbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2YgcmFuZ2UgZm9yIHNs\
aWNlIG9mIGxlbmd0aCAsBRAAEgAAAD4FEAAiAAAAcmFuZ2UgZW5kIGluZGV4IHAFEAAQAAAAPgUQAC\
IAAABzb3VyY2Ugc2xpY2UgbGVuZ3RoICgpIGRvZXMgbm90IG1hdGNoIGRlc3RpbmF0aW9uIHNsaWNl\
IGxlbmd0aCAokAUQABUAAAClBRAAKwAAAPwDEAABAAAAQzpcVXNlcnNcYXlhbWVcLmNhcmdvXHJlZ2\
lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcYmxvY2stYnVmZmVyLTAuMTAuMFxz\
cmNcbGliLnJzAAAA6AUQAF0AAAA/AQAAHgAAAOgFEABdAAAA/AAAACcAAABhc3NlcnRpb24gZmFpbG\
VkOiBtaWQgPD0gc2VsZi5sZW4oKQAAAAAAASNFZ4mrze/+3LqYdlQyEPDh0sMAAAAAZ+YJaoWuZ7ty\
8248OvVPpX9SDlGMaAWbq9mDHxnN4FvYngXBB9V8NhfdcDA5WQ73MQvA/xEVWGinj/lkpE/6vgjJvP\
Nn5glqO6fKhIWuZ7sr+JT+cvNuPPE2HV869U+l0YLmrX9SDlEfbD4rjGgFm2u9Qfur2YMfeSF+ExnN\
4FvYngXBXZ27ywfVfDYqKZpiF91wMFoBWZE5WQ732OwvFTELwP9nJjNnERVYaIdKtI6nj/lkDS4M26\
RP+r4dSLVHY2xvc3VyZSBpbnZva2VkIHJlY3Vyc2l2ZWx5IG9yIGRlc3Ryb3llZCBhbHJlYWR5AQAA\
AAAAAACCgAAAAAAAAIqAAAAAAACAAIAAgAAAAICLgAAAAAAAAAEAAIAAAAAAgYAAgAAAAIAJgAAAAA\
AAgIoAAAAAAAAAiAAAAAAAAAAJgACAAAAAAAoAAIAAAAAAi4AAgAAAAACLAAAAAAAAgImAAAAAAACA\
A4AAAAAAAIACgAAAAAAAgIAAAAAAAACACoAAAAAAAAAKAACAAAAAgIGAAIAAAACAgIAAAAAAAIABAA\
CAAAAAAAiAAIAAAACAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWxp\
YnJhcnkvc3RkL3NyYy9wYW5pY2tpbmcucnMAgwgQABwAAABHAgAADwAAAGNhbGxlZCBgUmVzdWx0Oj\
p1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUAAAAAAF4M6fd8saoC7KhD4gNLQqzT/NUN41vNcjp/\
+faTmwFtk5Ef0v94mc3iKYBwyaFzdcODKpJrMmSxcFiRBO4+iEbm7ANxBeOs6lxTowi4aUHFfMTejZ\
FU50wM9A3c3/SiCvq+TacYb7cQaqvRWiO2zMb/4i9XIWFyEx6SnRlvjEgaygcA2vT5yUvHQVLo9ub1\
JrZHWerbeZCFkoyeycWFGE9Lhm+pHnaO133BtVKMQjaOwWMwNydoz2luxbSbPckHtuq1dg52DoJ9Qt\
x/8MacXGTgQjMkeKA4vwR9Lp08NGtfxg4LYOuKwvKsvFRyX9gObOVP26SBIllxn+0Pzmn6ZxnbRWW5\
+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\
+dhJMmP7iOPtm8+AnvFsEZpTgRhXJNVr9/MDUaj3R6715rcVz5x+1N7G19sauygCQVzlRJlO214l1E\
e2MPyquCuIEV0qIdMpu4sJ9bOWAukU6rWPWgLdVyGUe2e1rJCjwOdY+wFKvYNMZ9OJO7nzS9+kLZ4p\
SKuMMh7E/FIsWLqWjPMDsl3Yf7290cqDroJgwUK0u7Ca2qVr6F+5P6lxN2cELrLYUjFJyVhThB5UtJ\
eGSCq+ZmmO0y3copUrhTySrBEswHuo8g2ZsYgjvjdPG/oIgHwD5VRNyNBwH9RXzn7srZBUOjoG2Sc8\
KwC/ojCAhKOufsADIO1tMgLGhkCpaX0op4OKevUwy196xXnn63nkRGi16bzcBQ+0c6PiDleIbnga16\
D26L3NupyHL6NkwbzRapeL12aWXuIhqzzD5eWqYxCQkI1pSESzGJi7ih4+rodk47TcO4kx+b2vGdW7\
X9ygRWPKZZSbJv4ohuxRnD9gAV0et0lQoQZA5E2xy3b35XBsv+0rVe/yGBJBozZacAgHDMtEYJhPdR\
RN5w4oqA5D2VbNZVBfU9eRJcGW7wpy8SMyyB+lY3NvOaDD782riWdFIwEQMlR2mLrc/ofhssO0pZbw\
bnVsbCBwb2ludGVyIHBhc3NlZCB0byBydXN0cmVjdXJzaXZlIHVzZSBvZiBhbiBvYmplY3QgZGV0ZW\
N0ZWQgd2hpY2ggd291bGQgbGVhZCB0byB1bnNhZmUgYWxpYXNpbmcgaW4gcnVzdADnz4CAAARuYW1l\
AdzPgIAAmQEARWpzX3N5czo6VHlwZUVycm9yOjpuZXc6Ol9fd2JnX25ld19kYjI1NGFlMGExYmIwZm\
Y1OjpoYTI0ZWExODBiNTMzNGVmMAE7d2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX29iamVjdF9kcm9w\
X3JlZjo6aDE5ZDUwMGYzZTBmNDllNTECVWpzX3N5czo6VWludDhBcnJheTo6Ynl0ZV9sZW5ndGg6Ol\
9fd2JnX2J5dGVMZW5ndGhfODdhMDQzNmE3NGFkYzI2Yzo6aDIzYjEzYTM1M2UzNzgwNDIDVWpzX3N5\
czo6VWludDhBcnJheTo6Ynl0ZV9vZmZzZXQ6Ol9fd2JnX2J5dGVPZmZzZXRfNDQ3N2Q1NDcxMGFmNm\
Y5Yjo6aGU4ZWUxMDAwODAyY2Y4ZDQETGpzX3N5czo6VWludDhBcnJheTo6YnVmZmVyOjpfX3diZ19i\
dWZmZXJfMjEzMTBlYTE3MjU3YjBiNDo6aGQyODBkYTQzODQ1ZDc4NGEFeWpzX3N5czo6VWludDhBcn\
JheTo6bmV3X3dpdGhfYnl0ZV9vZmZzZXRfYW5kX2xlbmd0aDo6X193YmdfbmV3d2l0aGJ5dGVvZmZz\
ZXRhbmRsZW5ndGhfZDlhYTI2NjcwM2NiOThiZTo6aDIyMDMxMzZjNzkxZGI0ZWEGTGpzX3N5czo6VW\
ludDhBcnJheTo6bGVuZ3RoOjpfX3diZ19sZW5ndGhfOWUxYWUxOTAwY2IwZmJkNTo6aDFlYmRmMmI3\
NWFkMTNiNWIHMndhc21fYmluZGdlbjo6X193YmluZGdlbl9tZW1vcnk6Omg0ZGMyNzVjOGQxYzk5NT\
cyCFVqc19zeXM6OldlYkFzc2VtYmx5OjpNZW1vcnk6OmJ1ZmZlcjo6X193YmdfYnVmZmVyXzNmM2Q3\
NjRkNDc0N2Q1NjQ6OmhmYjkxMmFkZTU5OTgwMjI5CUZqc19zeXM6OlVpbnQ4QXJyYXk6Om5ldzo6X1\
93YmdfbmV3XzhjM2YwMDUyMjcyYTQ1N2E6Omg3OWM2MDkzMmI0ZGIzMjc4CkZqc19zeXM6OlVpbnQ4\
QXJyYXk6OnNldDo6X193Ymdfc2V0XzgzZGI5NjkwZjkzNTNlNzk6Omg3ODI5MjAwOTM4ODkwMzFkCz\
F3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fdGhyb3c6OmgwY2ExZmFiODliODNiMzgzDEBkZW5vX3N0\
ZF93YXNtX2NyeXB0bzo6ZGlnZXN0OjpDb250ZXh0OjpkaWdlc3Q6OmhmMTg3OTkzNzQ4MmU1ODQ3DS\
xzaGEyOjpzaGE1MTI6OmNvbXByZXNzNTEyOjpoZWM3NGU0Nzc0YTdlMDQwYQ5KZGVub19zdGRfd2Fz\
bV9jcnlwdG86OmRpZ2VzdDo6Q29udGV4dDo6ZGlnZXN0X2FuZF9yZXNldDo6aDZhNGZkMjI1ZjY3ND\
ljMGQPLHNoYTI6OnNoYTI1Njo6Y29tcHJlc3MyNTY6Omg0NjllNDIyNzljM2Y4MmQ1EBNkaWdlc3Rj\
b250ZXh0X2Nsb25lEUBkZW5vX3N0ZF93YXNtX2NyeXB0bzo6ZGlnZXN0OjpDb250ZXh0Ojp1cGRhdG\
U6OmhhNmVkYjg4YTFmMDk0OGYxEjNibGFrZTI6OkJsYWtlMmJWYXJDb3JlOjpjb21wcmVzczo6aGIw\
YmNjYTI1NzQzZTJiZGQTKXJpcGVtZDo6YzE2MDo6Y29tcHJlc3M6OmgwMjMzNjA1NjhlMTc3ZWE5FD\
NibGFrZTI6OkJsYWtlMnNWYXJDb3JlOjpjb21wcmVzczo6aDdhOTlhN2EzMWUwNTc2ZGQVK3NoYTE6\
OmNvbXByZXNzOjpjb21wcmVzczo6aDY3NmE4YzFhODBiMDA2Y2QWLHRpZ2VyOjpjb21wcmVzczo6Y2\
9tcHJlc3M6Omg4ZTkxMGYxOTdiYjdkYjc5Fy1ibGFrZTM6Ok91dHB1dFJlYWRlcjo6ZmlsbDo6aDBm\
NDU2NzBlZDUyOWE3ODgYNmJsYWtlMzo6cG9ydGFibGU6OmNvbXByZXNzX2luX3BsYWNlOjpoODJhND\
gzNWJhNzhhZTk5ORk6ZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6bWFsbG9jOjpoYTk2\
ZmNlZmJiNDRkNmRhNRplPGRpZ2VzdDo6Y29yZV9hcGk6OndyYXBwZXI6OkNvcmVXcmFwcGVyPFQ+IG\
FzIGRpZ2VzdDo6VXBkYXRlPjo6dXBkYXRlOjp7e2Nsb3N1cmV9fTo6aDdkOGMwMGE0OWNjNTAyYTkb\
aDxtZDU6Ok1kNUNvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYW\
xpemVfZml4ZWRfY29yZTo6e3tjbG9zdXJlfX06OmgyZWRlNTY0ZDNiOWQ5YWE1HCxjb3JlOjpmbXQ6\
OkZvcm1hdHRlcjo6cGFkOjpoOGM3NTNlNDk0ZjdiNTY5ZB0gbWQ0Ojpjb21wcmVzczo6aGEwODdhNj\
g2M2E2ZDVkNjceMGJsYWtlMzo6Y29tcHJlc3Nfc3VidHJlZV93aWRlOjpoNGUwOTU3MTJmOGIxNGVj\
NB8vYmxha2UzOjpIYXNoZXI6OmZpbmFsaXplX3hvZjo6aDFkYmIzNWJlN2MzYTViYjMgPWRlbm9fc3\
RkX3dhc21fY3J5cHRvOjpkaWdlc3Q6OkNvbnRleHQ6Om5ldzo6aGMxMDI1YzRlNmI0MDc0YTYhE2Rp\
Z2VzdGNvbnRleHRfcmVzZXQiOGRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46OmZyZWU6Om\
hhNDczN2I3Zjg0OTcwYWRkI3I8c2hhMjo6Y29yZV9hcGk6OlNoYTUxMlZhckNvcmUgYXMgZGlnZXN0\
Ojpjb3JlX2FwaTo6VmFyaWFibGVPdXRwdXRDb3JlPjo6ZmluYWxpemVfdmFyaWFibGVfY29yZTo6aD\
k3OGVkYTNlNWJmNGQ4NWMkQWRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46OmRpc3Bvc2Vf\
Y2h1bms6OmgzYjZjNGU3NGZhOGFhMDRiJSBrZWNjYWs6OmYxNjAwOjpoZmUyMWFkMGU3YjIxYzU5Zi\
YOX19ydXN0X3JlYWxsb2MncjxzaGEyOjpjb3JlX2FwaTo6U2hhMjU2VmFyQ29yZSBhcyBkaWdlc3Q6\
OmNvcmVfYXBpOjpWYXJpYWJsZU91dHB1dENvcmU+OjpmaW5hbGl6ZV92YXJpYWJsZV9jb3JlOjpoZG\
Y0OWFhZTRhMjkzNDMwMihOY29yZTo6Zm10OjpudW06OmltcDo6PGltcGwgY29yZTo6Zm10OjpEaXNw\
bGF5IGZvciB1MzI+OjpmbXQ6OmhjNTBhMWM5YjgyZWI0NDQ2KV08c2hhMTo6U2hhMUNvcmUgYXMgZG\
lnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aDE2\
OGNiNTBiZmNiMDBjMjIqMWJsYWtlMzo6SGFzaGVyOjptZXJnZV9jdl9zdGFjazo6aDBhOWM0YzI2ZT\
NhMjQwNjIrI2NvcmU6OmZtdDo6d3JpdGU6OmhlZDhmZTdkMDk1NDc5ZWEyLGQ8cmlwZW1kOjpSaXBl\
bWQxNjBDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2\
ZpeGVkX2NvcmU6Omg2ZDgyNWIxODgxMDU1NzYxLTRibGFrZTM6OmNvbXByZXNzX3BhcmVudHNfcGFy\
YWxsZWw6OmhiNmY2ZWMwODM2NzU5MTdkLls8bWQ0OjpNZDRDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcG\
k6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6Omg3Y2Q3OTY3ZGQ2NmYzYjE2\
L1s8bWQ1OjpNZDVDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbm\
FsaXplX2ZpeGVkX2NvcmU6OmhkMDc3MjcxM2EyZjQxMjRjMF88dGlnZXI6OlRpZ2VyQ29yZSBhcyBk\
aWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoMT\
MyMDkyM2MxNjg2NDg5NDEwZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjptYWxsb2M6OmgwMDU3MzU2N2Ez\
MzM4ZGY4Mkw8YWxsb2M6OmJveGVkOjpCb3g8VD4gYXMgY29yZTo6ZGVmYXVsdDo6RGVmYXVsdD46Om\
RlZmF1bHQ6OmhmYzgzZjY4NGNmNDdhNDk5M0w8YWxsb2M6OmJveGVkOjpCb3g8VD4gYXMgY29yZTo6\
ZGVmYXVsdDo6RGVmYXVsdD46OmRlZmF1bHQ6OmhkNDBmYWU0Njk0NWI4YmRiNEw8YWxsb2M6OmJveG\
VkOjpCb3g8VD4gYXMgY29yZTo6ZGVmYXVsdDo6RGVmYXVsdD46OmRlZmF1bHQ6Omg3ODlhOGRmODA0\
N2Q5OTI2NUw8YWxsb2M6OmJveGVkOjpCb3g8VD4gYXMgY29yZTo6ZGVmYXVsdDo6RGVmYXVsdD46Om\
RlZmF1bHQ6OmhjZmY3OWViMDgzNzBkN2Q3NmQ8c2hhMzo6U2hha2UxMjhDb3JlIGFzIGRpZ2VzdDo6\
Y29yZV9hcGk6OkV4dGVuZGFibGVPdXRwdXRDb3JlPjo6ZmluYWxpemVfeG9mX2NvcmU6OmhlZTc0Mz\
IyYjBmN2JkZGUzNy1ibGFrZTM6OkNodW5rU3RhdGU6OnVwZGF0ZTo6aDkwMmE0MzQyNTZlMTU2YTg4\
YjxzaGEzOjpLZWNjYWsyMjRDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT\
46OmZpbmFsaXplX2ZpeGVkX2NvcmU6OmhhM2Q0YmJkOTdmMTliNDc0OWE8c2hhMzo6U2hhM18yMjRD\
b3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2\
NvcmU6Omg2YzUxODIxMTA2ZjRkY2I3OnI8ZGlnZXN0Ojpjb3JlX2FwaTo6eG9mX3JlYWRlcjo6WG9m\
UmVhZGVyQ29yZVdyYXBwZXI8VD4gYXMgZGlnZXN0OjpYb2ZSZWFkZXI+OjpyZWFkOjp7e2Nsb3N1cm\
V9fTo6aDA2NGY5YTJkMDBkYTMxYjc7TDxhbGxvYzo6Ym94ZWQ6OkJveDxUPiBhcyBjb3JlOjpkZWZh\
dWx0OjpEZWZhdWx0Pjo6ZGVmYXVsdDo6aGJlOTBmMmE5NTExZmExMjI8ZTxkaWdlc3Q6OmNvcmVfYX\
BpOjp4b2ZfcmVhZGVyOjpYb2ZSZWFkZXJDb3JlV3JhcHBlcjxUPiBhcyBkaWdlc3Q6OlhvZlJlYWRl\
cj46OnJlYWQ6OmgwNmVkNDFlZjliZTlkN2UyPWU8ZGlnZXN0Ojpjb3JlX2FwaTo6eG9mX3JlYWRlcj\
o6WG9mUmVhZGVyQ29yZVdyYXBwZXI8VD4gYXMgZGlnZXN0OjpYb2ZSZWFkZXI+OjpyZWFkOjpoODlk\
ODFhYjFhNzA2ZjM0ZT5lPGRpZ2VzdDo6Y29yZV9hcGk6OndyYXBwZXI6OkNvcmVXcmFwcGVyPFQ+IG\
FzIGRpZ2VzdDo6VXBkYXRlPjo6dXBkYXRlOjp7e2Nsb3N1cmV9fTo6aDVlYzI3NGIxNDg2YmExZDU/\
TDxhbGxvYzo6Ym94ZWQ6OkJveDxUPiBhcyBjb3JlOjpkZWZhdWx0OjpEZWZhdWx0Pjo6ZGVmYXVsdD\
o6aDdmY2U4YTYzZWRhYTJhOWJAMWNvbXBpbGVyX2J1aWx0aW5zOjptZW06Om1lbWNweTo6aDQ1ZWI1\
MzYwMWQ5ZDZiZjBBYjxzaGEzOjpLZWNjYWsyNTZDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeG\
VkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6Omg3ZTJhZGJiN2E5ZDdmYjg5QmE8c2hh\
Mzo6U2hhM18yNTZDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbm\
FsaXplX2ZpeGVkX2NvcmU6OmgyMDg1ZWRlMDE5ZmMzYTBmQ3I8ZGlnZXN0Ojpjb3JlX2FwaTo6eG9m\
X3JlYWRlcjo6WG9mUmVhZGVyQ29yZVdyYXBwZXI8VD4gYXMgZGlnZXN0OjpYb2ZSZWFkZXI+OjpyZW\
FkOjp7e2Nsb3N1cmV9fTo6aGQyM2ExZTdiODUwNTA5ZGFEZTxkaWdlc3Q6OmNvcmVfYXBpOjp3cmFw\
cGVyOjpDb3JlV3JhcHBlcjxUPiBhcyBkaWdlc3Q6OlVwZGF0ZT46OnVwZGF0ZTo6e3tjbG9zdXJlfX\
06OmgzMDMxY2Q2MjU1Mjg0ZjJjRWQ8c2hhMzo6U2hha2UyNTZDb3JlIGFzIGRpZ2VzdDo6Y29yZV9h\
cGk6OkV4dGVuZGFibGVPdXRwdXRDb3JlPjo6ZmluYWxpemVfeG9mX2NvcmU6Omg2NGM2NDQxNjZkZT\
UzOGEwRkZkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjppbnNlcnRfbGFyZ2VfY2h1bms6\
OmhiMTI5OTBmOTI1MzhmYmJmR0ZkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+Ojp1bmxpbm\
tfbGFyZ2VfY2h1bms6OmhiZThkMzZhOWY0MDYwY2VlSGU8ZGlnZXN0Ojpjb3JlX2FwaTo6d3JhcHBl\
cjo6Q29yZVdyYXBwZXI8VD4gYXMgZGlnZXN0OjpVcGRhdGU+Ojp1cGRhdGU6Ont7Y2xvc3VyZX19Oj\
poMmViZGVhYWU5NjQ4MjIzNEliPHNoYTM6OktlY2NhazM4NENvcmUgYXMgZGlnZXN0Ojpjb3JlX2Fw\
aTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aDNhNDNlOTFlYzE3NDQ1OT\
lKYTxzaGEzOjpTaGEzXzM4NENvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3Jl\
Pjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aGJhNjUxNDU3MWI2Y2RjNmZLYjxzaGEzOjpLZWNjYWs1MT\
JDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVk\
X2NvcmU6OmhlNzk0NWIzODYxYWMzOTQ1TGE8c2hhMzo6U2hhM181MTJDb3JlIGFzIGRpZ2VzdDo6Y2\
9yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6Omg1YTJlMGFiNjNh\
NWU0ZjdkTUw8YWxsb2M6OmJveGVkOjpCb3g8VD4gYXMgY29yZTo6ZGVmYXVsdDo6RGVmYXVsdD46Om\
RlZmF1bHQ6OmhhODkyMWQ4NTQxNWI0NjFmTkw8YWxsb2M6OmJveGVkOjpCb3g8VD4gYXMgY29yZTo6\
ZGVmYXVsdDo6RGVmYXVsdD46OmRlZmF1bHQ6OmgwOGVmYWY3YTE5NjNlODFkT2U8ZGlnZXN0Ojpjb3\
JlX2FwaTo6d3JhcHBlcjo6Q29yZVdyYXBwZXI8VD4gYXMgZGlnZXN0OjpVcGRhdGU+Ojp1cGRhdGU6\
Ont7Y2xvc3VyZX19OjpoMzdiMDQ1ZmVkZGI1MGJiN1A+ZGVub19zdGRfd2FzbV9jcnlwdG86OkRpZ2\
VzdENvbnRleHQ6OnVwZGF0ZTo6aDc1NWQzNWU2MWE1Nzk4NWJRWzxibG9ja19idWZmZXI6OkJsb2Nr\
QnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDYzN2\
MxYzYyY2EwMTU4YjZSBmRpZ2VzdFMxY29tcGlsZXJfYnVpbHRpbnM6Om1lbTo6bWVtc2V0OjpoNWI4\
Yjk5OGE0YjJmYjIwNVRlPGRpZ2VzdDo6Y29yZV9hcGk6OndyYXBwZXI6OkNvcmVXcmFwcGVyPFQ+IG\
FzIGRpZ2VzdDo6VXBkYXRlPjo6dXBkYXRlOjp7e2Nsb3N1cmV9fTo6aGNiMzJhYzkzM2VjMjU3NjJV\
FGRpZ2VzdGNvbnRleHRfZGlnZXN0VhFkaWdlc3Rjb250ZXh0X25ld1ccZGlnZXN0Y29udGV4dF9kaW\
dlc3RBbmRSZXNldFhMPGFsbG9jOjpib3hlZDo6Qm94PFQ+IGFzIGNvcmU6OmRlZmF1bHQ6OkRlZmF1\
bHQ+OjpkZWZhdWx0OjpoN2M1MjFjNjZmY2M1ZjBlMFlMPGFsbG9jOjpib3hlZDo6Qm94PFQ+IGFzIG\
NvcmU6OmRlZmF1bHQ6OkRlZmF1bHQ+OjpkZWZhdWx0OjpoNmNhZTQ4Yzk0ZTYxNTBjMlpMPGFsbG9j\
Ojpib3hlZDo6Qm94PFQ+IGFzIGNvcmU6OmRlZmF1bHQ6OkRlZmF1bHQ+OjpkZWZhdWx0OjpoMzMwZj\
QzMmYxYjk4MWI2M1tMPGFsbG9jOjpib3hlZDo6Qm94PFQ+IGFzIGNvcmU6OmRlZmF1bHQ6OkRlZmF1\
bHQ+OjpkZWZhdWx0OjpoZmI3NmVkNGYzYTc0YmQ4MVxMPGFsbG9jOjpib3hlZDo6Qm94PFQ+IGFzIG\
NvcmU6OmRlZmF1bHQ6OkRlZmF1bHQ+OjpkZWZhdWx0OjpoNzg0ZDY4ZGM2YjUxYzk4YV0tanNfc3lz\
OjpVaW50OEFycmF5Ojp0b192ZWM6Omg3NWRkMjNlM2E1NTk4ZDYwXhtkaWdlc3Rjb250ZXh0X2RpZ2\
VzdEFuZERyb3BfP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0Ojpo\
YzlhM2Q4ZWUxMDQzNGU1ZGBHZGVub19zdGRfd2FzbV9jcnlwdG86OkRpZ2VzdENvbnRleHQ6OmRpZ2\
VzdF9hbmRfZHJvcDo6aGExMmMwYTFmNzcwYTAyMTNhLmNvcmU6OnJlc3VsdDo6dW53cmFwX2ZhaWxl\
ZDo6aDJkYzcwNmQ5NDhjMjI5NjBiWzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZS\
xLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aGVjZWMwNDk3NDVlZDQxNDFjWzxi\
bG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2\
xvbmU+OjpjbG9uZTo6aDcxNGFjYzM4NDMzYTExOGRkWzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVy\
PEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDczNjBkYjk1OG\
EzNThjODVlWzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3Jl\
OjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDkwZTQwNmVmZjNkZDIxMDRmWzxibG9ja19idWZmZXI6Ok\
Jsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6\
aGM3OWM0NTFlMDkyY2I5ZDFnWzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW\
5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDJmODE4MGNiMDg5YzJmOThoUDxhcnJh\
eXZlYzo6ZXJyb3JzOjpDYXBhY2l0eUVycm9yPFQ+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Om\
gxY2JhMzA5MjAwMTQ1OThlaVA8YXJyYXl2ZWM6OmVycm9yczo6Q2FwYWNpdHlFcnJvcjxUPiBhcyBj\
b3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoOWMwZWJhZDlkMDgyZTU1OGpOY29yZTo6c2xpY2U6OjxpbX\
BsIFtUXT46OmNvcHlfZnJvbV9zbGljZTo6bGVuX21pc21hdGNoX2ZhaWw6OmhmM2JiYWJjMDIwNDg2\
NGJjazZjb3JlOjpwYW5pY2tpbmc6OnBhbmljX2JvdW5kc19jaGVjazo6aDFmYjdhNmRmMTAzMzEyNz\
lsRGNvcmU6OnNsaWNlOjppbmRleDo6c2xpY2Vfc3RhcnRfaW5kZXhfbGVuX2ZhaWxfcnQ6OmhiMzE3\
Y2E4MzMyMDQ2NWE2bUJjb3JlOjpzbGljZTo6aW5kZXg6OnNsaWNlX2VuZF9pbmRleF9sZW5fZmFpbF\
9ydDo6aGZjZjkzZGQzNWYwMTEyYmRuGF9fd2JnX2RpZ2VzdGNvbnRleHRfZnJlZW83c3RkOjpwYW5p\
Y2tpbmc6OnJ1c3RfcGFuaWNfd2l0aF9ob29rOjpoNzBhMGUxOTVmNGRiMmEyOXAxY29tcGlsZXJfYn\
VpbHRpbnM6Om1lbTo6bWVtY21wOjpoMTI4NWI4NDEyMGRmNWRjZHEUZGlnZXN0Y29udGV4dF91cGRh\
dGVyKWNvcmU6OnBhbmlja2luZzo6cGFuaWM6Omg4YWYwNDYzOTdhMmJmNjVkczpibGFrZTI6OkJsYW\
tlMmJWYXJDb3JlOjpuZXdfd2l0aF9wYXJhbXM6Omg0NGYxNTNlOTYwYjIwOTM5dBFydXN0X2JlZ2lu\
X3Vud2luZHVDY29yZTo6Zm10OjpGb3JtYXR0ZXI6OnBhZF9pbnRlZ3JhbDo6d3JpdGVfcHJlZml4Oj\
poNjBiMWI1MDNlNjZmMzJiMXY0YWxsb2M6OnJhd192ZWM6OmNhcGFjaXR5X292ZXJmbG93OjpoNGIy\
NzVjYjNjMTBiMGE3OHctY29yZTo6cGFuaWNraW5nOjpwYW5pY19mbXQ6Omg3NTFiZTgwNzc5ZDQyYj\
UzeENzdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWNfaGFuZGxlcjo6e3tjbG9zdXJlfX06OmhkY2Zj\
ODE5Y2U4MzY4MjlleRFfX3diaW5kZ2VuX21hbGxvY3o6Ymxha2UyOjpCbGFrZTJzVmFyQ29yZTo6bm\
V3X3dpdGhfcGFyYW1zOjpoMjNlMzIwMWM5ZmYyMzMyOXtJc3RkOjpzeXNfY29tbW9uOjpiYWNrdHJh\
Y2U6Ol9fcnVzdF9lbmRfc2hvcnRfYmFja3RyYWNlOjpoNTNjYWJhZmFiNWIwOWFkYXw/d2FzbV9iaW\
5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlNF9tdXQ6Omg5NjlhZjNlZGJiNzM4YjVmfT93\
YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDA1OTZjYWRlZDYzNz\
JlYWZ+P3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoNDIxN2Nj\
NDEwYzk0OWE2YX8/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6Om\
hiYzBkZTg4ZTYzNTRlYTJigAE/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tl\
M19tdXQ6OmgxOGYyY2JiNjE4MmUwZmYwgQE/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlcz\
o6aW52b2tlM19tdXQ6Omg0MmUzZjhmYjQzNjIwOGU0ggE/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0Ojpj\
bG9zdXJlczo6aW52b2tlM19tdXQ6OmhjYTZjYzM2N2Y0OWE3MjM2gwE/d2FzbV9iaW5kZ2VuOjpjb2\
52ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6OmgzZjliODQxZjE0MmQ5OGU4hAE/d2FzbV9iaW5k\
Z2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6Omg3MDhjYmY5YTQyNWUzMDM5hQE/d2\
FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlMl9tdXQ6Omg3ZjAxNzJhNWUyYjY1\
YzY5hgESX193YmluZGdlbl9yZWFsbG9jhwE/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlcz\
o6aW52b2tlMV9tdXQ6OmgxZmMwOTdmZjY0ZTNhOTY5iAEwPCZUIGFzIGNvcmU6OmZtdDo6RGVidWc+\
OjpmbXQ6OmhmZjRhZjFiNGE4MTM5OTZhiQEyPCZUIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdD\
o6aDY0ZGQyZjhhMzhjZWIxMDOKAQ9fX3diaW5kZ2VuX2ZyZWWLAT9jb3JlOjpzbGljZTo6aW5kZXg6\
OnNsaWNlX2VuZF9pbmRleF9sZW5fZmFpbDo6aDNkYjQ3NmIwZDA5OTk0ZDKMAUFjb3JlOjpzbGljZT\
o6aW5kZXg6OnNsaWNlX3N0YXJ0X2luZGV4X2xlbl9mYWlsOjpoMTM2Y2NhZDc2NDEzNjgxMI0BM2Fy\
cmF5dmVjOjphcnJheXZlYzo6ZXh0ZW5kX3BhbmljOjpoNjRmY2MxNjMwYmVhY2NhN44BOWNvcmU6Om\
9wczo6ZnVuY3Rpb246OkZuT25jZTo6Y2FsbF9vbmNlOjpoZTAyMWRiYmY2ZmFhYTA2ZI8BH19fd2Jp\
bmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXKQATF3YXNtX2JpbmRnZW46Ol9fcnQ6OnRocm93X251bG\
w6OmgxYWMxZTJjMTFkOWRlMDlikQEyd2FzbV9iaW5kZ2VuOjpfX3J0Ojpib3Jyb3dfZmFpbDo6aDc4\
ZDIwNzFkNmMwNWI5ODSSASp3YXNtX2JpbmRnZW46OnRocm93X3N0cjo6aDNmMjIyOWZlMzAzMjI2OW\
STAQZtZW1zZXSUAQZtZW1jcHmVAQZtZW1jbXCWATE8VCBhcyBjb3JlOjphbnk6OkFueT46OnR5cGVf\
aWQ6OmgxM2M3ODU5NjY4OGY2N2IylwEKcnVzdF9wYW5pY5gBb2NvcmU6OnB0cjo6ZHJvcF9pbl9wbG\
FjZTwmY29yZTo6aXRlcjo6YWRhcHRlcnM6OmNvcGllZDo6Q29waWVkPGNvcmU6OnNsaWNlOjppdGVy\
OjpJdGVyPHU4Pj4+OjpoMDVmYTBmOTcxYjQ2YjBlNwDvgICAAAlwcm9kdWNlcnMCCGxhbmd1YWdlAQ\
RSdXN0AAxwcm9jZXNzZWQtYnkDBXJ1c3RjHTEuNjUuMCAoODk3ZTM3NTUzIDIwMjItMTEtMDIpBndh\
bHJ1cwYwLjE5LjAMd2FzbS1iaW5kZ2VuBjAuMi44Mw==\
");
    const wasmModule = new WebAssembly.Module(wasmBytes);
    return new WebAssembly.Instance(wasmModule, imports);
}
function base64decode(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
const hexTable1 = new TextEncoder().encode("0123456789abcdef");
function encode4(src) {
    const dst = new Uint8Array(src.length * 2);
    for(let i = 0; i < dst.length; i++){
        const v = src[i];
        dst[i * 2] = hexTable1[v >> 4];
        dst[i * 2 + 1] = hexTable1[v & 0x0f];
    }
    return dst;
}
const getArrayBufferOrView = hideStackFrames((buffer, name, encoding)=>{
    if (isAnyArrayBuffer1(buffer)) {
        return buffer;
    }
    if (typeof buffer === "string") {
        if (encoding === "buffer") {
            encoding = "utf8";
        }
        return Buffer1.from(buffer, encoding);
    }
    if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE(name, [
            "string",
            "ArrayBuffer",
            "Buffer",
            "TypedArray",
            "DataView"
        ], buffer);
    }
    return buffer;
});
function isKeyObject1(obj) {
    return isKeyObject(obj);
}
function isCryptoKey1(obj) {
    return isCryptoKey(obj);
}
class KeyObject {
    [kKeyType];
    [kHandle];
    constructor(type, handle){
        if (type !== "secret" && type !== "public" && type !== "private") {
            throw new ERR_INVALID_ARG_VALUE("type", type);
        }
        if (typeof handle !== "object") {
            throw new ERR_INVALID_ARG_TYPE("handle", "object", handle);
        }
        this[kKeyType] = type;
        Object.defineProperty(this, kHandle, {
            value: handle,
            enumerable: false,
            configurable: false,
            writable: false
        });
    }
    get type() {
        return this[kKeyType];
    }
    get asymmetricKeyDetails() {
        notImplemented("crypto.KeyObject.prototype.asymmetricKeyDetails");
        return undefined;
    }
    get asymmetricKeyType() {
        notImplemented("crypto.KeyObject.prototype.asymmetricKeyType");
        return undefined;
    }
    get symmetricKeySize() {
        notImplemented("crypto.KeyObject.prototype.symmetricKeySize");
        return undefined;
    }
    static from(key) {
        if (!isCryptoKey1(key)) {
            throw new ERR_INVALID_ARG_TYPE("key", "CryptoKey", key);
        }
        notImplemented("crypto.KeyObject.prototype.from");
    }
    equals(otherKeyObject) {
        if (!isKeyObject1(otherKeyObject)) {
            throw new ERR_INVALID_ARG_TYPE("otherKeyObject", "KeyObject", otherKeyObject);
        }
        notImplemented("crypto.KeyObject.prototype.equals");
    }
    export(_options) {
        notImplemented("crypto.KeyObject.prototype.asymmetricKeyType");
    }
}
function createPrivateKey(_key) {
    notImplemented("crypto.createPrivateKey");
}
function createPublicKey(_key) {
    notImplemented("crypto.createPublicKey");
}
function getKeyTypes(allowKeyObject, bufferOnly = false) {
    const types = [
        "ArrayBuffer",
        "Buffer",
        "TypedArray",
        "DataView",
        "string",
        "KeyObject",
        "CryptoKey"
    ];
    if (bufferOnly) {
        return types.slice(0, 4);
    } else if (!allowKeyObject) {
        return types.slice(0, 5);
    }
    return types;
}
function prepareSecretKey(key, encoding, bufferOnly = false) {
    if (!bufferOnly) {
        if (isKeyObject1(key)) {
            if (key.type !== "secret") {
                throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type, "secret");
            }
            return key[kHandle];
        } else if (isCryptoKey1(key)) {
            if (key.type !== "secret") {
                throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type, "secret");
            }
            return key[kKeyObject][kHandle];
        }
    }
    if (typeof key !== "string" && !isArrayBufferView(key) && !isAnyArrayBuffer1(key)) {
        throw new ERR_INVALID_ARG_TYPE("key", getKeyTypes(!bufferOnly, bufferOnly), key);
    }
    return getArrayBufferOrView(key, "key", encoding);
}
function createSecretKey(_key, _encoding) {
    notImplemented("crypto.createSecretKey");
}
const __default37 = {
    createPrivateKey,
    createPublicKey,
    createSecretKey,
    isKeyObject: isKeyObject1,
    isCryptoKey: isCryptoKey1,
    KeyObject,
    prepareSecretKey
};
const coerceToBytes = (data)=>{
    if (data instanceof Uint8Array) {
        return data;
    } else if (typeof data === "string") {
        return new TextEncoder().encode(data);
    } else if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    } else if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
    } else {
        throw new TypeError("expected data to be string | BufferSource");
    }
};
class Hash extends Iu {
    #context;
    constructor(algorithm, _opts){
        super({
            transform (chunk, _encoding, callback) {
                context.update(coerceToBytes(chunk));
                callback();
            },
            flush (callback) {
                this.push(context.digest(undefined));
                callback();
            }
        });
        if (typeof algorithm === "string") {
            algorithm = algorithm.toUpperCase();
            if (opensslToWebCryptoDigestNames[algorithm]) {
                algorithm = opensslToWebCryptoDigestNames[algorithm];
            }
            this.#context = new (instantiate()).DigestContext(algorithm);
        } else {
            this.#context = algorithm;
        }
        const context = this.#context;
    }
    copy() {
        return new Hash(this.#context.clone());
    }
    update(data, _encoding) {
        let bytes;
        if (typeof data === "string") {
            data = new TextEncoder().encode(data);
            bytes = coerceToBytes(data);
        } else {
            bytes = coerceToBytes(data);
        }
        this.#context.update(bytes);
        return this;
    }
    digest(encoding) {
        const digest = this.#context.digest(undefined);
        if (encoding === undefined) {
            return Buffer1.from(digest);
        }
        switch(encoding){
            case "hex":
                return new TextDecoder().decode(encode4(new Uint8Array(digest)));
            case "binary":
                return String.fromCharCode(...digest);
            case "base64":
                return encode(digest);
            case "base64url":
                return encode1(digest);
            case "buffer":
                return Buffer1.from(digest);
            default:
                return Buffer1.from(digest).toString(encoding);
        }
    }
}
function Hmac(hmac, key, options) {
    return new HmacImpl(hmac, key, options);
}
class HmacImpl extends Iu {
    #ipad;
    #opad;
    #ZEROES = Buffer1.alloc(128);
    #algorithm;
    #hash;
    constructor(hmac, key, options){
        super({
            transform (chunk, encoding, callback) {
                self.update(coerceToBytes(chunk), encoding);
                callback();
            },
            flush (callback) {
                this.push(self.digest());
                callback();
            }
        });
        const self = this;
        if (key instanceof KeyObject) {
            notImplemented("Hmac: KeyObject key is not implemented");
        }
        validateString(hmac, "hmac");
        const u8Key = prepareSecretKey(key, options?.encoding);
        const alg = hmac.toLowerCase();
        this.#hash = new Hash(alg, options);
        this.#algorithm = alg;
        const blockSize = alg === "sha512" || alg === "sha384" ? 128 : 64;
        const keySize = u8Key.length;
        let bufKey;
        if (keySize > blockSize) {
            bufKey = this.#hash.update(u8Key).digest();
        } else {
            bufKey = Buffer1.concat([
                u8Key,
                this.#ZEROES
            ], blockSize);
        }
        this.#ipad = Buffer1.allocUnsafe(blockSize);
        this.#opad = Buffer1.allocUnsafe(blockSize);
        for(let i = 0; i < blockSize; i++){
            this.#ipad[i] = bufKey[i] ^ 0x36;
            this.#opad[i] = bufKey[i] ^ 0x5C;
        }
        this.#hash = new Hash(alg);
        this.#hash.update(this.#ipad);
    }
    digest(encoding) {
        const result = this.#hash.digest();
        return new Hash(this.#algorithm).update(this.#opad).update(result).digest(encoding);
    }
    update(data, inputEncoding) {
        this.#hash.update(data, inputEncoding);
        return this;
    }
}
Hmac.prototype = HmacImpl.prototype;
const opensslToWebCryptoDigestNames = {
    BLAKE2B256: "BLAKE2B-256",
    BLAKE2B384: "BLAKE2B-384",
    BLAKE2B512: "BLAKE2B",
    BLAKE2S256: "BLAKE2S",
    RIPEMD160: "RIPEMD-160",
    RMD160: "RIPEMD-160",
    SHA1: "SHA-1",
    SHA224: "SHA-224",
    SHA256: "SHA-256",
    SHA384: "SHA-384",
    SHA512: "SHA-512"
};
function createHash(algorithm, opts) {
    return new Hash(algorithm, opts);
}
const __default38 = {
    Hash,
    Hmac,
    createHash
};
const MAX_ALLOC = Math.pow(2, 30) - 1;
const createHasher = (algorithm)=>(value)=>Buffer1.from(createHash(algorithm).update(value).digest());
function getZeroes(zeros) {
    return Buffer1.alloc(zeros);
}
const sizes = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
};
function toBuffer(bufferable) {
    if (bufferable instanceof Uint8Array || typeof bufferable === "string") {
        return Buffer1.from(bufferable);
    } else {
        return Buffer1.from(bufferable.buffer);
    }
}
class Hmac1 {
    hash;
    ipad1;
    opad;
    alg;
    blocksize;
    size;
    ipad2;
    constructor(alg, key, saltLen){
        this.hash = createHasher(alg);
        const blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
        if (key.length > blocksize) {
            key = this.hash(key);
        } else if (key.length < blocksize) {
            key = Buffer1.concat([
                key,
                getZeroes(blocksize - key.length)
            ], blocksize);
        }
        const ipad = Buffer1.allocUnsafe(blocksize + sizes[alg]);
        const opad = Buffer1.allocUnsafe(blocksize + sizes[alg]);
        for(let i = 0; i < blocksize; i++){
            ipad[i] = key[i] ^ 0x36;
            opad[i] = key[i] ^ 0x5c;
        }
        const ipad1 = Buffer1.allocUnsafe(blocksize + saltLen + 4);
        ipad.copy(ipad1, 0, 0, blocksize);
        this.ipad1 = ipad1;
        this.ipad2 = ipad;
        this.opad = opad;
        this.alg = alg;
        this.blocksize = blocksize;
        this.size = sizes[alg];
    }
    run(data, ipad) {
        data.copy(ipad, this.blocksize);
        const h = this.hash(ipad);
        h.copy(this.opad, this.blocksize);
        return this.hash(this.opad);
    }
}
function pbkdf2Sync(password, salt, iterations, keylen, digest = "sha1") {
    if (typeof iterations !== "number" || iterations < 0) {
        throw new TypeError("Bad iterations");
    }
    if (typeof keylen !== "number" || keylen < 0 || keylen > MAX_ALLOC) {
        throw new TypeError("Bad key length");
    }
    const bufferedPassword = toBuffer(password);
    const bufferedSalt = toBuffer(salt);
    const hmac = new Hmac1(digest, bufferedPassword, bufferedSalt.length);
    const DK = Buffer1.allocUnsafe(keylen);
    const block1 = Buffer1.allocUnsafe(bufferedSalt.length + 4);
    bufferedSalt.copy(block1, 0, 0, bufferedSalt.length);
    let destPos = 0;
    const hLen = sizes[digest];
    const l = Math.ceil(keylen / hLen);
    for(let i = 1; i <= l; i++){
        block1.writeUInt32BE(i, bufferedSalt.length);
        const T = hmac.run(block1, hmac.ipad1);
        let U = T;
        for(let j = 1; j < iterations; j++){
            U = hmac.run(U, hmac.ipad2);
            for(let k = 0; k < hLen; k++)T[k] ^= U[k];
        }
        T.copy(DK, destPos);
        destPos += hLen;
    }
    return DK;
}
function pbkdf2(password, salt, iterations, keylen, digest = "sha1", callback) {
    setTimeout(()=>{
        let err = null, res;
        try {
            res = pbkdf2Sync(password, salt, iterations, keylen, digest);
        } catch (e) {
            err = e;
        }
        if (err) {
            callback(err instanceof Error ? err : new Error("[non-error thrown]"));
        } else {
            callback(null, res);
        }
    }, 0);
}
const __default39 = {
    Hmac: Hmac1,
    MAX_ALLOC,
    pbkdf2,
    pbkdf2Sync
};
const fixOpts = (opts)=>{
    const out = {
        N: 16384,
        p: 1,
        r: 8,
        maxmem: 32 << 20
    };
    if (!opts) return out;
    if (opts.N) out.N = opts.N;
    else if (opts.cost) out.N = opts.cost;
    if (opts.p) out.p = opts.p;
    else if (opts.parallelization) out.p = opts.parallelization;
    if (opts.r) out.r = opts.r;
    else if (opts.blockSize) out.r = opts.blockSize;
    if (opts.maxmem) out.maxmem = opts.maxmem;
    return out;
};
function blockxor(S, Si, D, Di, len) {
    let i = -1;
    while(++i < len)D[Di + i] ^= S[Si + i];
}
function arraycopy(src, srcPos, dest, destPos, length) {
    src.copy(dest, destPos, srcPos, srcPos + length);
}
const R = (a, b)=>a << b | a >>> 32 - b;
class ScryptRom {
    B;
    r;
    N;
    p;
    XY;
    V;
    B32;
    x;
    _X;
    constructor(b, r, N, p){
        this.B = b;
        this.r = r;
        this.N = N;
        this.p = p;
        this.XY = Buffer1.allocUnsafe(256 * r);
        this.V = Buffer1.allocUnsafe(128 * r * N);
        this.B32 = new Int32Array(16);
        this.x = new Int32Array(16);
        this._X = Buffer1.allocUnsafe(64);
    }
    run() {
        const p = this.p | 0;
        const r = this.r | 0;
        for(let i = 0; i < p; i++)this.scryptROMix(i, r);
        return this.B;
    }
    scryptROMix(i, r) {
        const blockStart = i * 128 * r;
        const offset = (2 * r - 1) * 64;
        const blockLen = 128 * r;
        const B = this.B;
        const N = this.N | 0;
        const V = this.V;
        const XY = this.XY;
        B.copy(XY, 0, blockStart, blockStart + blockLen);
        for(let i1 = 0; i1 < N; i1++){
            XY.copy(V, i1 * blockLen, 0, blockLen);
            this.blockmix_salsa8(blockLen);
        }
        let j;
        for(let i2 = 0; i2 < N; i2++){
            j = XY.readUInt32LE(offset) & N - 1;
            blockxor(V, j * blockLen, XY, 0, blockLen);
            this.blockmix_salsa8(blockLen);
        }
        XY.copy(B, blockStart, 0, blockLen);
    }
    blockmix_salsa8(blockLen) {
        const BY = this.XY;
        const r = this.r;
        const _X = this._X;
        arraycopy(BY, (2 * r - 1) * 64, _X, 0, 64);
        let i;
        for(i = 0; i < 2 * r; i++){
            blockxor(BY, i * 64, _X, 0, 64);
            this.salsa20_8();
            arraycopy(_X, 0, BY, blockLen + i * 64, 64);
        }
        for(i = 0; i < r; i++){
            arraycopy(BY, blockLen + i * 2 * 64, BY, i * 64, 64);
            arraycopy(BY, blockLen + (i * 2 + 1) * 64, BY, (i + r) * 64, 64);
        }
    }
    salsa20_8() {
        const B32 = this.B32;
        const B = this._X;
        const x = this.x;
        let i;
        for(i = 0; i < 16; i++){
            B32[i] = (B[i * 4 + 0] & 0xff) << 0;
            B32[i] |= (B[i * 4 + 1] & 0xff) << 8;
            B32[i] |= (B[i * 4 + 2] & 0xff) << 16;
            B32[i] |= (B[i * 4 + 3] & 0xff) << 24;
        }
        for(i = 0; i < 16; i++)x[i] = B32[i];
        for(i = 0; i < 4; i++){
            x[4] ^= R(x[0] + x[12], 7);
            x[8] ^= R(x[4] + x[0], 9);
            x[12] ^= R(x[8] + x[4], 13);
            x[0] ^= R(x[12] + x[8], 18);
            x[9] ^= R(x[5] + x[1], 7);
            x[13] ^= R(x[9] + x[5], 9);
            x[1] ^= R(x[13] + x[9], 13);
            x[5] ^= R(x[1] + x[13], 18);
            x[14] ^= R(x[10] + x[6], 7);
            x[2] ^= R(x[14] + x[10], 9);
            x[6] ^= R(x[2] + x[14], 13);
            x[10] ^= R(x[6] + x[2], 18);
            x[3] ^= R(x[15] + x[11], 7);
            x[7] ^= R(x[3] + x[15], 9);
            x[11] ^= R(x[7] + x[3], 13);
            x[15] ^= R(x[11] + x[7], 18);
            x[1] ^= R(x[0] + x[3], 7);
            x[2] ^= R(x[1] + x[0], 9);
            x[3] ^= R(x[2] + x[1], 13);
            x[0] ^= R(x[3] + x[2], 18);
            x[6] ^= R(x[5] + x[4], 7);
            x[7] ^= R(x[6] + x[5], 9);
            x[4] ^= R(x[7] + x[6], 13);
            x[5] ^= R(x[4] + x[7], 18);
            x[11] ^= R(x[10] + x[9], 7);
            x[8] ^= R(x[11] + x[10], 9);
            x[9] ^= R(x[8] + x[11], 13);
            x[10] ^= R(x[9] + x[8], 18);
            x[12] ^= R(x[15] + x[14], 7);
            x[13] ^= R(x[12] + x[15], 9);
            x[14] ^= R(x[13] + x[12], 13);
            x[15] ^= R(x[14] + x[13], 18);
        }
        for(i = 0; i < 16; i++)B32[i] += x[i];
        let bi;
        for(i = 0; i < 16; i++){
            bi = i * 4;
            B[bi + 0] = B32[i] >> 0 & 0xff;
            B[bi + 1] = B32[i] >> 8 & 0xff;
            B[bi + 2] = B32[i] >> 16 & 0xff;
            B[bi + 3] = B32[i] >> 24 & 0xff;
        }
    }
    clean() {
        this.XY.fill(0);
        this.V.fill(0);
        this._X.fill(0);
        this.B.fill(0);
        for(let i = 0; i < 16; i++){
            this.B32[i] = 0;
            this.x[i] = 0;
        }
    }
}
function scryptSync(password, salt, keylen, _opts) {
    const { N , r , p , maxmem  } = fixOpts(_opts);
    const blen = p * 128 * r;
    if (32 * r * (N + 2) * 4 + blen > maxmem) {
        throw new Error("excedes max memory");
    }
    const b = pbkdf2Sync(password, salt, 1, blen, "sha256");
    const scryptRom = new ScryptRom(b, r, N, p);
    const out = scryptRom.run();
    const fin = pbkdf2Sync(password, out, 1, keylen, "sha256");
    scryptRom.clean();
    return fin;
}
function scrypt(password, salt, keylen, _opts, cb) {
    if (!cb) {
        cb = _opts;
        _opts = null;
    }
    const { N , r , p , maxmem  } = fixOpts(_opts);
    const blen = p * 128 * r;
    if (32 * r * (N + 2) * 4 + blen > maxmem) {
        throw new Error("excedes max memory");
    }
    try {
        const b = pbkdf2Sync(password, salt, 1, blen, "sha256");
        const scryptRom = new ScryptRom(b, r, N, p);
        const out = scryptRom.run();
        const result = pbkdf2Sync(password, out, 1, keylen, "sha256");
        scryptRom.clean();
        cb(null, result);
    } catch (err) {
        return cb(err);
    }
}
const __default40 = {
    scrypt,
    scryptSync
};
const encrypt = function(self, block) {
    return self._cipher.encryptBlock(block);
};
const decrypt = function(self, block) {
    return self._cipher.decryptBlock(block);
};
const mod54 = {
    encrypt: encrypt,
    decrypt: decrypt
};
function xor(a, b) {
    const length = Math.min(a.length, b.length);
    const buffer = Buffer1.allocUnsafe(length);
    for(let i = 0; i < length; ++i){
        buffer[i] = a[i] ^ b[i];
    }
    return buffer;
}
const encrypt1 = function(self, block) {
    const data = xor(block, self._prev);
    self._prev = self._cipher.encryptBlock(data);
    return self._prev;
};
const decrypt1 = function(self, block) {
    const pad = self._prev;
    self._prev = block;
    const out = self._cipher.decryptBlock(block);
    return xor(out, pad);
};
const mod55 = {
    encrypt: encrypt1,
    decrypt: decrypt1
};
function encryptStart(self, data, decrypt) {
    const len = data.length;
    const out = xor(data, self._cache);
    self._cache = self._cache.slice(len);
    self._prev = Buffer1.concat([
        self._prev,
        decrypt ? data : out
    ]);
    return out;
}
const encrypt2 = function(self, data, decrypt) {
    let out = Buffer1.allocUnsafe(0);
    let len;
    while(data.length){
        if (self._cache.length === 0) {
            self._cache = self._cipher.encryptBlock(self._prev);
            self._prev = Buffer1.allocUnsafe(0);
        }
        if (self._cache.length <= data.length) {
            len = self._cache.length;
            out = Buffer1.concat([
                out,
                encryptStart(self, data.slice(0, len), decrypt)
            ]);
            data = data.slice(len);
        } else {
            out = Buffer1.concat([
                out,
                encryptStart(self, data, decrypt)
            ]);
            break;
        }
    }
    return out;
};
const mod56 = {
    encrypt: encrypt2
};
function encryptByte(self, byteParam, decrypt) {
    const pad = self._cipher.encryptBlock(self._prev);
    const out = pad[0] ^ byteParam;
    self._prev = Buffer1.concat([
        self._prev.slice(1),
        Buffer1.from([
            decrypt ? byteParam : out
        ])
    ]);
    return out;
}
const encrypt3 = function(self, chunk, decrypt) {
    const len = chunk.length;
    const out = Buffer1.allocUnsafe(len);
    let i = -1;
    while(++i < len){
        out[i] = encryptByte(self, chunk[i], decrypt);
    }
    return out;
};
const mod57 = {
    encrypt: encrypt3
};
function encryptByte1(self, byteParam, decrypt) {
    let pad;
    let i = -1;
    let out = 0;
    let bit, value;
    while(++i < 8){
        pad = self._cipher.encryptBlock(self._prev);
        bit = byteParam & 1 << 7 - i ? 0x80 : 0;
        value = pad[0] ^ bit;
        out += (value & 0x80) >> i % 8;
        self._prev = shiftIn(self._prev, decrypt ? bit : value);
    }
    return out;
}
function shiftIn(buffer, value) {
    const len = buffer.length;
    let i = -1;
    const out = Buffer1.allocUnsafe(buffer.length);
    buffer = Buffer1.concat([
        buffer,
        Buffer1.from([
            value
        ])
    ]);
    while(++i < len){
        out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;
    }
    return out;
}
const encrypt4 = function(self, chunk, decrypt) {
    const len = chunk.length;
    const out = Buffer1.allocUnsafe(len);
    let i = -1;
    while(++i < len){
        out[i] = encryptByte1(self, chunk[i], decrypt);
    }
    return out;
};
const mod58 = {
    encrypt: encrypt4
};
function getBlock(self) {
    self._prev = self._cipher.encryptBlock(self._prev);
    return self._prev;
}
const encrypt5 = function(self, chunk) {
    while(self._cache.length < chunk.length){
        self._cache = Buffer1.concat([
            self._cache,
            getBlock(self)
        ]);
    }
    const pad = self._cache.slice(0, chunk.length);
    self._cache = self._cache.slice(chunk.length);
    return xor(chunk, pad);
};
const mod59 = {
    encrypt: encrypt5
};
function incr32(iv) {
    let len = iv.length;
    let item;
    while(len--){
        item = iv.readUInt8(len);
        if (item === 255) {
            iv.writeUInt8(0, len);
        } else {
            item++;
            iv.writeUInt8(item, len);
            break;
        }
    }
}
function getBlock1(self) {
    const out = self._cipher.encryptBlockRaw(self._prev);
    incr32(self._prev);
    return out;
}
const blockSize = 16;
const encrypt6 = function(self, chunk) {
    const chunkNum = Math.ceil(chunk.length / 16);
    const start = self._cache.length;
    self._cache = Buffer1.concat([
        self._cache,
        Buffer1.allocUnsafe(chunkNum * blockSize)
    ]);
    for(let i = 0; i < chunkNum; i++){
        const out = getBlock1(self);
        const offset = start + i * 16;
        self._cache.writeUInt32BE(out[0], offset + 0);
        self._cache.writeUInt32BE(out[1], offset + 4);
        self._cache.writeUInt32BE(out[2], offset + 8);
        self._cache.writeUInt32BE(out[3], offset + 12);
    }
    const pad = self._cache.slice(0, chunk.length);
    self._cache = self._cache.slice(chunk.length);
    return xor(chunk, pad);
};
const mod60 = {
    encrypt: encrypt6
};
const modeModules = {
    ECB: mod54,
    CBC: mod55,
    CFB: mod56,
    CFB8: mod57,
    CFB1: mod58,
    OFB: mod59,
    CTR: mod60,
    GCM: mod60
};
const MODES = {
    "aes-128-ecb": {
        "cipher": "AES",
        "key": 128,
        "iv": 0,
        "mode": "ECB",
        "type": "block"
    },
    "aes-192-ecb": {
        "cipher": "AES",
        "key": 192,
        "iv": 0,
        "mode": "ECB",
        "type": "block"
    },
    "aes-256-ecb": {
        "cipher": "AES",
        "key": 256,
        "iv": 0,
        "mode": "ECB",
        "type": "block"
    },
    "aes-128-cbc": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes-192-cbc": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes-256-cbc": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes128": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes192": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes256": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes-128-cfb": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB",
        "type": "stream"
    },
    "aes-192-cfb": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB",
        "type": "stream"
    },
    "aes-256-cfb": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB",
        "type": "stream"
    },
    "aes-128-cfb8": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream"
    },
    "aes-192-cfb8": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream"
    },
    "aes-256-cfb8": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream"
    },
    "aes-128-cfb1": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream"
    },
    "aes-192-cfb1": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream"
    },
    "aes-256-cfb1": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream"
    },
    "aes-128-ofb": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "OFB",
        "type": "stream"
    },
    "aes-192-ofb": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "OFB",
        "type": "stream"
    },
    "aes-256-ofb": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "OFB",
        "type": "stream"
    },
    "aes-128-ctr": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CTR",
        "type": "stream"
    },
    "aes-192-ctr": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CTR",
        "type": "stream"
    },
    "aes-256-ctr": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CTR",
        "type": "stream"
    },
    "aes-128-gcm": {
        "cipher": "AES",
        "key": 128,
        "iv": 12,
        "mode": "GCM",
        "type": "auth"
    },
    "aes-192-gcm": {
        "cipher": "AES",
        "key": 192,
        "iv": 12,
        "mode": "GCM",
        "type": "auth"
    },
    "aes-256-gcm": {
        "cipher": "AES",
        "key": 256,
        "iv": 12,
        "mode": "GCM",
        "type": "auth"
    }
};
for (const mode of Object.values(MODES)){
    mode.module = modeModules[mode.mode];
}
function asUInt32Array(buf) {
    if (!Buffer1.isBuffer(buf)) buf = Buffer1.from(buf);
    var len = buf.length / 4 | 0;
    var out = new Array(len);
    for(var i = 0; i < len; i++){
        out[i] = buf.readUInt32BE(i * 4);
    }
    return out;
}
function scrubVec(v) {
    for(var i = 0; i < v.length; v++){
        v[i] = 0;
    }
}
function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
    var SUB_MIX0 = SUB_MIX[0];
    var SUB_MIX1 = SUB_MIX[1];
    var SUB_MIX2 = SUB_MIX[2];
    var SUB_MIX3 = SUB_MIX[3];
    var s0 = M[0] ^ keySchedule[0];
    var s1 = M[1] ^ keySchedule[1];
    var s2 = M[2] ^ keySchedule[2];
    var s3 = M[3] ^ keySchedule[3];
    var t0, t1, t2, t3;
    var ksRow = 4;
    for(var round = 1; round < nRounds; round++){
        t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 0xff] ^ SUB_MIX2[s2 >>> 8 & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++];
        t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 0xff] ^ SUB_MIX2[s3 >>> 8 & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++];
        t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 0xff] ^ SUB_MIX2[s0 >>> 8 & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++];
        t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 0xff] ^ SUB_MIX2[s1 >>> 8 & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++];
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
    }
    t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 0xff] << 16 | SBOX[s2 >>> 8 & 0xff] << 8 | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
    t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 0xff] << 16 | SBOX[s3 >>> 8 & 0xff] << 8 | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
    t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 0xff] << 16 | SBOX[s0 >>> 8 & 0xff] << 8 | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
    t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 0xff] << 16 | SBOX[s1 >>> 8 & 0xff] << 8 | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
    t0 = t0 >>> 0;
    t1 = t1 >>> 0;
    t2 = t2 >>> 0;
    t3 = t3 >>> 0;
    return [
        t0,
        t1,
        t2,
        t3
    ];
}
var RCON = [
    0x00,
    0x01,
    0x02,
    0x04,
    0x08,
    0x10,
    0x20,
    0x40,
    0x80,
    0x1b,
    0x36
];
var G = function() {
    var d = new Array(256);
    for(var j = 0; j < 256; j++){
        if (j < 128) {
            d[j] = j << 1;
        } else {
            d[j] = j << 1 ^ 0x11b;
        }
    }
    var SBOX = [];
    var INV_SBOX = [];
    var SUB_MIX = [
        [],
        [],
        [],
        []
    ];
    var INV_SUB_MIX = [
        [],
        [],
        [],
        []
    ];
    var x = 0;
    var xi = 0;
    for(var i = 0; i < 256; ++i){
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        SBOX[x] = sx;
        INV_SBOX[sx] = x;
        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4];
        var t = d[sx] * 0x101 ^ sx * 0x1010100;
        SUB_MIX[0][x] = t << 24 | t >>> 8;
        SUB_MIX[1][x] = t << 16 | t >>> 16;
        SUB_MIX[2][x] = t << 8 | t >>> 24;
        SUB_MIX[3][x] = t;
        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
        INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
        INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
        INV_SUB_MIX[3][sx] = t;
        if (x === 0) {
            x = xi = 1;
        } else {
            x = x2 ^ d[d[d[x8 ^ x2]]];
            xi ^= d[d[xi]];
        }
    }
    return {
        SBOX: SBOX,
        INV_SBOX: INV_SBOX,
        SUB_MIX: SUB_MIX,
        INV_SUB_MIX: INV_SUB_MIX
    };
}();
function AES(key) {
    this._key = asUInt32Array(key);
    this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
    var keyWords = this._key;
    var keySize = keyWords.length;
    var nRounds = keySize + 6;
    var ksRows = (nRounds + 1) * 4;
    var keySchedule = [];
    for(var k = 0; k < keySize; k++){
        keySchedule[k] = keyWords[k];
    }
    for(k = keySize; k < ksRows; k++){
        var t = keySchedule[k - 1];
        if (k % keySize === 0) {
            t = t << 8 | t >>> 24;
            t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 0xff] << 16 | G.SBOX[t >>> 8 & 0xff] << 8 | G.SBOX[t & 0xff];
            t ^= RCON[k / keySize | 0] << 24;
        } else if (keySize > 6 && k % keySize === 4) {
            t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 0xff] << 16 | G.SBOX[t >>> 8 & 0xff] << 8 | G.SBOX[t & 0xff];
        }
        keySchedule[k] = keySchedule[k - keySize] ^ t;
    }
    var invKeySchedule = [];
    for(var ik = 0; ik < ksRows; ik++){
        var ksR = ksRows - ik;
        var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
        if (ik < 4 || ksR <= 4) {
            invKeySchedule[ik] = tt;
        } else {
            invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]];
        }
    }
    this._nRounds = nRounds;
    this._keySchedule = keySchedule;
    this._invKeySchedule = invKeySchedule;
};
AES.prototype.encryptBlockRaw = function(M) {
    M = asUInt32Array(M);
    return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(M) {
    var out = this.encryptBlockRaw(M);
    var buf = Buffer1.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[1], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[3], 12);
    return buf;
};
AES.prototype.decryptBlock = function(M) {
    M = asUInt32Array(M);
    var m1 = M[1];
    M[1] = M[3];
    M[3] = m1;
    var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
    var buf = Buffer1.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[3], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[1], 12);
    return buf;
};
AES.prototype.scrub = function() {
    scrubVec(this._keySchedule);
    scrubVec(this._invKeySchedule);
    scrubVec(this._key);
};
function CipherBase(hashMode) {
    Iu.call(this);
    this.hashMode = typeof hashMode === "string";
    if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
    } else {
        this.final = this._finalOrDigest;
    }
    if (this._final) {
        this.__final = this._final;
        this._final = null;
    }
    this._decoder = null;
    this._encoding = null;
}
CipherBase.prototype = Object.create(Iu.prototype, {
    constructor: {
        value: CipherBase,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
    if (typeof data === "string") {
        data = Buffer1.from(data, inputEnc);
    }
    var outData = this._update(data);
    if (this.hashMode) return this;
    if (outputEnc) {
        outData = this._toString(outData, outputEnc);
    }
    return outData;
};
CipherBase.prototype.setAutoPadding = function() {};
CipherBase.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
};
CipherBase.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
};
CipherBase.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
};
CipherBase.prototype._transform = function(data, _, next) {
    var err;
    try {
        if (this.hashMode) {
            this._update(data);
        } else {
            this.push(this._update(data));
        }
    } catch (e) {
        err = e;
    } finally{
        next(err);
    }
};
CipherBase.prototype._flush = function(done) {
    var err;
    try {
        this.push(this.__final());
    } catch (e) {
        err = e;
    }
    done(err);
};
CipherBase.prototype._finalOrDigest = function(outputEnc) {
    var outData = this.__final() || Buffer1.alloc(0);
    if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
    }
    return outData;
};
CipherBase.prototype._toString = function(value, enc, fin) {
    if (!this._decoder) {
        this._decoder = new StringDecoder(enc);
        this._encoding = enc;
    }
    if (this._encoding !== enc) throw new Error("can't switch encodings");
    var out = this._decoder.write(value);
    if (fin) {
        out += this._decoder.end();
    }
    return out;
};
var ZEROES = Buffer1.alloc(16, 0);
function toArray(buf) {
    return [
        buf.readUInt32BE(0),
        buf.readUInt32BE(4),
        buf.readUInt32BE(8),
        buf.readUInt32BE(12)
    ];
}
function fromArray(out) {
    var buf = Buffer1.allocUnsafe(16);
    buf.writeUInt32BE(out[0] >>> 0, 0);
    buf.writeUInt32BE(out[1] >>> 0, 4);
    buf.writeUInt32BE(out[2] >>> 0, 8);
    buf.writeUInt32BE(out[3] >>> 0, 12);
    return buf;
}
function GHASH(key) {
    this.h = key;
    this.state = Buffer1.alloc(16, 0);
    this.cache = Buffer1.allocUnsafe(0);
}
GHASH.prototype.ghash = function(block) {
    var i = -1;
    while(++i < block.length){
        this.state[i] ^= block[i];
    }
    this._multiply();
};
GHASH.prototype._multiply = function() {
    var Vi = toArray(this.h);
    var Zi = [
        0,
        0,
        0,
        0
    ];
    var j, xi, lsbVi;
    var i = -1;
    while(++i < 128){
        xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;
        if (xi) {
            Zi[0] ^= Vi[0];
            Zi[1] ^= Vi[1];
            Zi[2] ^= Vi[2];
            Zi[3] ^= Vi[3];
        }
        lsbVi = (Vi[3] & 1) !== 0;
        for(j = 3; j > 0; j--){
            Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
        }
        Vi[0] = Vi[0] >>> 1;
        if (lsbVi) {
            Vi[0] = Vi[0] ^ 0xe1 << 24;
        }
    }
    this.state = fromArray(Zi);
};
GHASH.prototype.update = function(buf) {
    this.cache = Buffer1.concat([
        this.cache,
        buf
    ]);
    var chunk;
    while(this.cache.length >= 16){
        chunk = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        this.ghash(chunk);
    }
};
GHASH.prototype.final = function(abl, bl) {
    if (this.cache.length) {
        this.ghash(Buffer1.concat([
            this.cache,
            ZEROES
        ], 16));
    }
    this.ghash(fromArray([
        0,
        abl,
        0,
        bl
    ]));
    return this.state;
};
function xorTest(a, b) {
    var out = 0;
    if (a.length !== b.length) out++;
    var len = Math.min(a.length, b.length);
    for(var i = 0; i < len; ++i){
        out += a[i] ^ b[i];
    }
    return out;
}
function calcIv(self, iv, ck) {
    if (iv.length === 12) {
        self._finID = Buffer1.concat([
            iv,
            Buffer1.from([
                0,
                0,
                0,
                1
            ])
        ]);
        return Buffer1.concat([
            iv,
            Buffer1.from([
                0,
                0,
                0,
                2
            ])
        ]);
    }
    var ghash = new GHASH(ck);
    var len = iv.length;
    var toPad = len % 16;
    ghash.update(iv);
    if (toPad) {
        toPad = 16 - toPad;
        ghash.update(Buffer1.alloc(toPad, 0));
    }
    ghash.update(Buffer1.alloc(8, 0));
    var ivBits = len * 8;
    var tail = Buffer1.alloc(8);
    tail.writeUIntBE(ivBits, 2, 6);
    ghash.update(tail);
    self._finID = ghash.state;
    var out = Buffer1.from(self._finID);
    incr32(out);
    return out;
}
function StreamCipher(mode, key, iv, decrypt) {
    CipherBase.call(this);
    var h = Buffer1.alloc(4, 0);
    this._cipher = new AES(key);
    var ck = this._cipher.encryptBlock(h);
    this._ghash = new GHASH(ck);
    iv = calcIv(this, iv, ck);
    this._prev = Buffer1.from(iv);
    this._cache = Buffer1.allocUnsafe(0);
    this._secCache = Buffer1.allocUnsafe(0);
    this._decrypt = decrypt;
    this._alen = 0;
    this._len = 0;
    this._mode = mode;
    this._authTag = null;
    this._called = false;
}
StreamCipher.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: StreamCipher,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
StreamCipher.prototype._update = function(chunk) {
    if (!this._called && this._alen) {
        var rump = 16 - this._alen % 16;
        if (rump < 16) {
            rump = Buffer1.alloc(rump, 0);
            this._ghash.update(rump);
        }
    }
    this._called = true;
    var out = this._mode.encrypt(this, chunk);
    if (this._decrypt) {
        this._ghash.update(chunk);
    } else {
        this._ghash.update(out);
    }
    this._len += chunk.length;
    return out;
};
StreamCipher.prototype._final = function() {
    if (this._decrypt && !this._authTag) {
        throw new Error("Unsupported state or unable to authenticate data");
    }
    var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && xorTest(tag, this._authTag)) {
        throw new Error("Unsupported state or unable to authenticate data");
    }
    this._authTag = tag;
    this._cipher.scrub();
};
StreamCipher.prototype.getAuthTag = function getAuthTag() {
    if (this._decrypt || !Buffer1.isBuffer(this._authTag)) {
        throw new Error("Attempting to get auth tag in unsupported state");
    }
    return this._authTag;
};
StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
    if (!this._decrypt) {
        throw new Error("Attempting to set auth tag in unsupported state");
    }
    this._authTag = tag;
};
StreamCipher.prototype.setAAD = function setAAD(buf) {
    if (this._called) {
        throw new Error("Attempting to set AAD in unsupported state");
    }
    this._ghash.update(buf);
    this._alen += buf.length;
};
function StreamCipher1(mode, key, iv, decrypt) {
    CipherBase.call(this);
    this._cipher = new AES(key);
    this._prev = Buffer1.from(iv);
    this._cache = Buffer1.allocUnsafe(0);
    this._secCache = Buffer1.allocUnsafe(0);
    this._decrypt = decrypt;
    this._mode = mode;
}
StreamCipher1.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: StreamCipher1,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
StreamCipher1.prototype._update = function(chunk) {
    return this._mode.encrypt(this, chunk, this._decrypt);
};
StreamCipher1.prototype._final = function() {
    this._cipher.scrub();
};
function EVP_BytesToKey(password, salt, keyBits, ivLen) {
    if (!Buffer1.isBuffer(password)) password = Buffer1.from(password, "binary");
    if (salt) {
        if (!Buffer1.isBuffer(salt)) salt = Buffer1.from(salt, "binary");
        if (salt.length !== 8) {
            throw new RangeError("salt should be Buffer with 8 byte length");
        }
    }
    let keyLen = keyBits / 8;
    const key = Buffer1.alloc(keyLen);
    const iv = Buffer1.alloc(ivLen || 0);
    let tmp = Buffer1.alloc(0);
    while(keyLen > 0 || ivLen > 0){
        const hash = createHash("md5");
        hash.update(tmp);
        hash.update(password);
        if (salt) hash.update(salt);
        tmp = hash.digest();
        let used = 0;
        if (keyLen > 0) {
            const keyStart = key.length - keyLen;
            used = Math.min(keyLen, tmp.length);
            tmp.copy(key, keyStart, 0, used);
            keyLen -= used;
        }
        if (used < tmp.length && ivLen > 0) {
            const ivStart = iv.length - ivLen;
            const length = Math.min(ivLen, tmp.length - used);
            tmp.copy(iv, ivStart, used, used + length);
            ivLen -= length;
        }
    }
    tmp.fill(0);
    return {
        key,
        iv
    };
}
function Cipher(mode, key, iv) {
    CipherBase.call(this);
    this._cache = new Splitter();
    this._cipher = new AES(key);
    this._prev = Buffer1.from(iv);
    this._mode = mode;
    this._autopadding = true;
}
Cipher.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: Cipher,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
Cipher.prototype._update = function(data) {
    this._cache.add(data);
    var chunk;
    var thing;
    var out = [];
    while(chunk = this._cache.get()){
        thing = this._mode.encrypt(this, chunk);
        out.push(thing);
    }
    return Buffer1.concat(out);
};
var PADDING = Buffer1.alloc(16, 0x10);
Cipher.prototype._final = function() {
    var chunk = this._cache.flush();
    if (this._autopadding) {
        chunk = this._mode.encrypt(this, chunk);
        this._cipher.scrub();
        return chunk;
    }
    if (!chunk.equals(PADDING)) {
        this._cipher.scrub();
        throw new Error("data not multiple of block length");
    }
};
Cipher.prototype.setAutoPadding = function(setTo) {
    this._autopadding = !!setTo;
    return this;
};
function Splitter() {
    this.cache = Buffer1.allocUnsafe(0);
}
Splitter.prototype.add = function(data) {
    this.cache = Buffer1.concat([
        this.cache,
        data
    ]);
};
Splitter.prototype.get = function() {
    if (this.cache.length > 15) {
        const out = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        return out;
    }
    return null;
};
Splitter.prototype.flush = function() {
    var len = 16 - this.cache.length;
    var padBuff = Buffer1.allocUnsafe(len);
    var i = -1;
    while(++i < len){
        padBuff.writeUInt8(len, i);
    }
    return Buffer1.concat([
        this.cache,
        padBuff
    ]);
};
function Decipher(mode, key, iv) {
    CipherBase.call(this);
    this._cache = new Splitter1();
    this._last = void 0;
    this._cipher = new AES(key);
    this._prev = Buffer1.from(iv);
    this._mode = mode;
    this._autopadding = true;
}
Decipher.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: Decipher,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
Decipher.prototype._update = function(data) {
    this._cache.add(data);
    var chunk;
    var thing;
    var out = [];
    while(chunk = this._cache.get(this._autopadding)){
        thing = this._mode.decrypt(this, chunk);
        out.push(thing);
    }
    return Buffer1.concat(out);
};
Decipher.prototype._final = function() {
    var chunk = this._cache.flush();
    if (this._autopadding) {
        return unpad(this._mode.decrypt(this, chunk));
    } else if (chunk) {
        throw new Error("data not multiple of block length");
    }
};
Decipher.prototype.setAutoPadding = function(setTo) {
    this._autopadding = !!setTo;
    return this;
};
function Splitter1() {
    this.cache = Buffer1.allocUnsafe(0);
}
Splitter1.prototype.add = function(data) {
    this.cache = Buffer1.concat([
        this.cache,
        data
    ]);
};
Splitter1.prototype.get = function(autoPadding) {
    var out;
    if (autoPadding) {
        if (this.cache.length > 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
        }
    } else {
        if (this.cache.length >= 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
        }
    }
    return null;
};
Splitter1.prototype.flush = function() {
    if (this.cache.length) return this.cache;
};
function unpad(last) {
    var padded = last[15];
    if (padded < 1 || padded > 16) {
        throw new Error("unable to decrypt data");
    }
    var i = -1;
    while(++i < padded){
        if (last[i + (16 - padded)] !== padded) {
            throw new Error("unable to decrypt data");
        }
    }
    if (padded === 16) return;
    return last.slice(0, 16 - padded);
}
function createDecipheriv(suite, password, iv) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    if (typeof iv === "string") iv = Buffer1.from(iv);
    if (config.mode !== "GCM" && iv.length !== config.iv) {
        throw new TypeError("invalid iv length " + iv.length);
    }
    if (typeof password === "string") password = Buffer1.from(password);
    if (password.length !== config.key / 8) {
        throw new TypeError("invalid key length " + password.length);
    }
    if (config.type === "stream") {
        return new StreamCipher1(config.module, password, iv, true);
    } else if (config.type === "auth") {
        return new StreamCipher(config.module, password, iv, true);
    }
    return new Decipher(config.module, password, iv);
}
function getCiphers() {
    return Object.keys(MODES);
}
const digestAlgorithms = [
    "blake2b256",
    "blake2b384",
    "blake2b",
    "blake2s",
    "blake3",
    "keccak-224",
    "keccak-256",
    "keccak-384",
    "keccak-512",
    "sha384",
    "sha3-224",
    "sha3-256",
    "sha3-384",
    "sha3-512",
    "shake128",
    "shake256",
    "tiger",
    "rmd160",
    "sha224",
    "sha256",
    "sha512",
    "md4",
    "md5",
    "sha1"
];
let defaultEncoding = "buffer";
function setDefaultEncoding(val) {
    defaultEncoding = val;
}
function getDefaultEncoding() {
    return defaultEncoding;
}
function toBuf(val, encoding) {
    if (typeof val === "string") {
        if (encoding === "buffer") {
            encoding = "utf8";
        }
        return Buffer1.from(val, encoding);
    }
    return val;
}
const validateByteSource = hideStackFrames((val, name)=>{
    val = toBuf(val);
    if (isAnyArrayBuffer1(val) || isArrayBufferView(val)) {
        return;
    }
    throw new ERR_INVALID_ARG_TYPE(name, [
        "string",
        "ArrayBuffer",
        "TypedArray",
        "DataView",
        "Buffer"
    ], val);
});
function getHashes() {
    return digestAlgorithms;
}
function getCurves() {
    notImplemented("crypto.getCurves");
}
function secureHeapUsed() {
    notImplemented("crypto.secureHeapUsed");
}
function setEngine(_engine, _flags) {
    notImplemented("crypto.setEngine");
}
const __default41 = {
    getDefaultEncoding,
    getHashes,
    setDefaultEncoding,
    getCiphers,
    getCurves,
    secureHeapUsed,
    setEngine,
    validateByteSource,
    toBuf,
    kHandle,
    kKeyObject
};
const validateParameters = hideStackFrames((hash, key, salt, info, length)=>{
    key = prepareKey(key);
    salt = toBuf(salt);
    info = toBuf(info);
    validateString(hash, "digest");
    validateByteSource(salt, "salt");
    validateByteSource(info, "info");
    validateInteger(length, "length", 0, 2147483647);
    if (info.byteLength > 1024) {
        throw new ERR_OUT_OF_RANGE("info", "must not contain more than 1024 bytes", info.byteLength);
    }
    return {
        hash,
        key,
        salt,
        info,
        length
    };
});
function prepareKey(key) {
    if (isKeyObject1(key)) {
        return key;
    }
    if (isAnyArrayBuffer1(key)) {
        return createSecretKey(new Uint8Array(key));
    }
    key = toBuf(key);
    if (!isArrayBufferView(key)) {
        throw new ERR_INVALID_ARG_TYPE("ikm", [
            "string",
            "SecretKeyObject",
            "ArrayBuffer",
            "TypedArray",
            "DataView",
            "Buffer"
        ], key);
    }
    return createSecretKey(key);
}
function hkdf(hash, key, salt, info, length, callback) {
    ({ hash , key , salt , info , length  } = validateParameters(hash, key, salt, info, length));
    validateFunction(callback, "callback");
    notImplemented("crypto.hkdf");
}
function hkdfSync(hash, key, salt, info, length) {
    ({ hash , key , salt , info , length  } = validateParameters(hash, key, salt, info, length));
    notImplemented("crypto.hkdfSync");
}
const __default42 = {
    hkdf,
    hkdfSync
};
function generateKey(_type, _options, _callback) {
    notImplemented("crypto.generateKey");
}
function generateKeyPair(_type, _options, _callback) {
    notImplemented("crypto.generateKeyPair");
}
function generateKeyPairSync(_type, _options) {
    notImplemented("crypto.generateKeyPairSync");
}
function generateKeySync(_type, _options) {
    notImplemented("crypto.generateKeySync");
}
const __default43 = {
    generateKey,
    generateKeySync,
    generateKeyPair,
    generateKeyPairSync
};
const DH_GENERATOR = 2;
class DiffieHellman {
    verifyError;
    constructor(sizeOrKey, keyEncoding, generator, genEncoding){
        if (typeof sizeOrKey !== "number" && typeof sizeOrKey !== "string" && !isArrayBufferView(sizeOrKey) && !isAnyArrayBuffer1(sizeOrKey)) {
            throw new ERR_INVALID_ARG_TYPE("sizeOrKey", [
                "number",
                "string",
                "ArrayBuffer",
                "Buffer",
                "TypedArray",
                "DataView"
            ], sizeOrKey);
        }
        if (typeof sizeOrKey === "number") {
            validateInt32(sizeOrKey, "sizeOrKey");
        }
        if (keyEncoding && !Buffer1.isEncoding(keyEncoding) && keyEncoding !== "buffer") {
            genEncoding = generator;
            generator = keyEncoding;
            keyEncoding = false;
        }
        const encoding = getDefaultEncoding();
        keyEncoding = keyEncoding || encoding;
        genEncoding = genEncoding || encoding;
        if (typeof sizeOrKey !== "number") {
            sizeOrKey = toBuf(sizeOrKey, keyEncoding);
        }
        if (!generator) {
            generator = DH_GENERATOR;
        } else if (typeof generator === "number") {
            validateInt32(generator, "generator");
        } else if (typeof generator === "string") {
            generator = toBuf(generator, genEncoding);
        } else if (!isArrayBufferView(generator) && !isAnyArrayBuffer1(generator)) {
            throw new ERR_INVALID_ARG_TYPE("generator", [
                "number",
                "string",
                "ArrayBuffer",
                "Buffer",
                "TypedArray",
                "DataView"
            ], generator);
        }
        notImplemented("crypto.DiffieHellman");
    }
    computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
        notImplemented("crypto.DiffieHellman.prototype.computeSecret");
    }
    generateKeys(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.generateKeys");
    }
    getGenerator(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getGenerator");
    }
    getPrime(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPrime");
    }
    getPrivateKey(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPrivateKey");
    }
    getPublicKey(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPublicKey");
    }
    setPrivateKey(_privateKey, _encoding) {
        notImplemented("crypto.DiffieHellman.prototype.setPrivateKey");
    }
    setPublicKey(_publicKey, _encoding) {
        notImplemented("crypto.DiffieHellman.prototype.setPublicKey");
    }
}
class DiffieHellmanGroup {
    verifyError;
    constructor(_name){
        notImplemented("crypto.DiffieHellmanGroup");
    }
    computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
        notImplemented("crypto.DiffieHellman.prototype.computeSecret");
    }
    generateKeys(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.generateKeys");
    }
    getGenerator(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getGenerator");
    }
    getPrime(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPrime");
    }
    getPrivateKey(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPrivateKey");
    }
    getPublicKey(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPublicKey");
    }
}
class ECDH {
    constructor(curve){
        validateString(curve, "curve");
        notImplemented("crypto.ECDH");
    }
    static convertKey(_key, _curve, _inputEncoding, _outputEncoding, _format) {
        notImplemented("crypto.ECDH.prototype.convertKey");
    }
    computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
        notImplemented("crypto.ECDH.prototype.computeSecret");
    }
    generateKeys(_encoding, _format) {
        notImplemented("crypto.ECDH.prototype.generateKeys");
    }
    getPrivateKey(_encoding) {
        notImplemented("crypto.ECDH.prototype.getPrivateKey");
    }
    getPublicKey(_encoding, _format) {
        notImplemented("crypto.ECDH.prototype.getPublicKey");
    }
    setPrivateKey(_privateKey, _encoding) {
        notImplemented("crypto.ECDH.prototype.setPrivateKey");
    }
}
function diffieHellman(_options) {
    notImplemented("crypto.diffieHellman");
}
const __default44 = {
    DiffieHellman,
    DiffieHellmanGroup,
    ECDH,
    diffieHellman
};
function assert6(val, msg) {
    if (!val) throw new Error(msg || "Assertion failed");
}
function inherits1(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
}
function BN(number, base, endian) {
    if (BN.isBN(number)) {
        return number;
    }
    this.negative = 0;
    this.words = null;
    this.length = 0;
    this.red = null;
    if (number !== null) {
        if (base === "le" || base === "be") {
            endian = base;
            base = 10;
        }
        this._init(number || 0, base || 10, endian || "be");
    }
}
BN.BN = BN;
BN.wordSize = 26;
BN.isBN = function isBN(num) {
    if (num instanceof BN) {
        return true;
    }
    return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
};
BN.max = function max(left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
};
BN.min = function min(left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
};
BN.prototype._init = function init(number, base, endian) {
    if (typeof number === "number") {
        return this._initNumber(number, base, endian);
    }
    if (typeof number === "object") {
        return this._initArray(number, base, endian);
    }
    if (base === "hex") {
        base = 16;
    }
    assert6(base === (base | 0) && base >= 2 && base <= 36);
    number = number.toString().replace(/\s+/g, "");
    var start = 0;
    if (number[0] === "-") {
        start++;
        this.negative = 1;
    }
    if (start < number.length) {
        if (base === 16) {
            this._parseHex(number, start, endian);
        } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
            }
        }
    }
};
BN.prototype._initNumber = function _initNumber(number, base, endian) {
    if (number < 0) {
        this.negative = 1;
        number = -number;
    }
    if (number < 0x4000000) {
        this.words = [
            number & 0x3ffffff
        ];
        this.length = 1;
    } else if (number < 0x10000000000000) {
        this.words = [
            number & 0x3ffffff,
            number / 0x4000000 & 0x3ffffff
        ];
        this.length = 2;
    } else {
        assert6(number < 0x20000000000000);
        this.words = [
            number & 0x3ffffff,
            number / 0x4000000 & 0x3ffffff,
            1
        ];
        this.length = 3;
    }
    if (endian !== "le") return;
    this._initArray(this.toArray(), base, endian);
};
BN.prototype._initArray = function _initArray(number, base, endian) {
    assert6(typeof number.length === "number");
    if (number.length <= 0) {
        this.words = [
            0
        ];
        this.length = 1;
        return this;
    }
    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for(var i = 0; i < this.length; i++){
        this.words[i] = 0;
    }
    var j, w;
    var off = 0;
    if (endian === "be") {
        for(i = number.length - 1, j = 0; i >= 0; i -= 3){
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
    } else if (endian === "le") {
        for(i = 0, j = 0; i < number.length; i += 3){
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
    }
    return this._strip();
};
function parseHex4Bits(string, index) {
    var c = string.charCodeAt(index);
    if (c >= 48 && c <= 57) {
        return c - 48;
    } else if (c >= 65 && c <= 70) {
        return c - 55;
    } else if (c >= 97 && c <= 102) {
        return c - 87;
    } else {
        assert6(false, "Invalid character in " + string);
    }
}
function parseHexByte(string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
}
BN.prototype._parseHex = function _parseHex(number, start, endian) {
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for(var i = 0; i < this.length; i++){
        this.words[i] = 0;
    }
    var off = 0;
    var j = 0;
    var w;
    if (endian === "be") {
        for(i = number.length - 1; i >= start; i -= 2){
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
            } else {
                off += 8;
            }
        }
    } else {
        var parseLength = number.length - start;
        for(i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2){
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
            } else {
                off += 8;
            }
        }
    }
    this._strip();
};
function parseBase(str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for(var i = start; i < len; i++){
        var c = str.charCodeAt(i) - 48;
        r *= mul;
        if (c >= 49) {
            b = c - 49 + 0xa;
        } else if (c >= 17) {
            b = c - 17 + 0xa;
        } else {
            b = c;
        }
        assert6(c >= 0 && b < mul, "Invalid character");
        r += b;
    }
    return r;
}
BN.prototype._parseBase = function _parseBase(number, base, start) {
    this.words = [
        0
    ];
    this.length = 1;
    for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base){
        limbLen++;
    }
    limbLen--;
    limbPow = limbPow / base | 0;
    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;
    var word = 0;
    for(var i = start; i < end; i += limbLen){
        word = parseBase(number, i, i + limbLen, base);
        this.imuln(limbPow);
        if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
        } else {
            this._iaddn(word);
        }
    }
    if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base);
        for(i = 0; i < mod; i++){
            pow *= base;
        }
        this.imuln(pow);
        if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
        } else {
            this._iaddn(word);
        }
    }
    this._strip();
};
BN.prototype.copy = function copy(dest) {
    dest.words = new Array(this.length);
    for(var i = 0; i < this.length; i++){
        dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
};
function move(dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
}
BN.prototype._move = function _move(dest) {
    move(dest, this);
};
BN.prototype.clone = function clone() {
    var r = new BN(null);
    this.copy(r);
    return r;
};
BN.prototype._expand = function _expand(size) {
    while(this.length < size){
        this.words[this.length++] = 0;
    }
    return this;
};
BN.prototype._strip = function strip() {
    while(this.length > 1 && this.words[this.length - 1] === 0){
        this.length--;
    }
    return this._normSign();
};
BN.prototype._normSign = function _normSign() {
    if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
    }
    return this;
};
if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
    try {
        BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect1;
    } catch (e) {
        BN.prototype.inspect = inspect1;
    }
} else {
    BN.prototype.inspect = inspect1;
}
function inspect1() {
    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
}
var zeros = [
    "",
    "0",
    "00",
    "000",
    "0000",
    "00000",
    "000000",
    "0000000",
    "00000000",
    "000000000",
    "0000000000",
    "00000000000",
    "000000000000",
    "0000000000000",
    "00000000000000",
    "000000000000000",
    "0000000000000000",
    "00000000000000000",
    "000000000000000000",
    "0000000000000000000",
    "00000000000000000000",
    "000000000000000000000",
    "0000000000000000000000",
    "00000000000000000000000",
    "000000000000000000000000",
    "0000000000000000000000000"
];
var groupSizes = [
    0,
    0,
    25,
    16,
    12,
    11,
    10,
    9,
    8,
    8,
    7,
    7,
    7,
    7,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5
];
var groupBases = [
    0,
    0,
    33554432,
    43046721,
    16777216,
    48828125,
    60466176,
    40353607,
    16777216,
    43046721,
    10000000,
    19487171,
    35831808,
    62748517,
    7529536,
    11390625,
    16777216,
    24137569,
    34012224,
    47045881,
    64000000,
    4084101,
    5153632,
    6436343,
    7962624,
    9765625,
    11881376,
    14348907,
    17210368,
    20511149,
    24300000,
    28629151,
    33554432,
    39135393,
    45435424,
    52521875,
    60466176
];
BN.prototype.toString = function toString(base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;
    var out;
    if (base === 16 || base === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for(var i = 0; i < this.length; i++){
            var w = this.words[i];
            var word = ((w << off | carry) & 0xffffff).toString(16);
            carry = w >>> 24 - off & 0xffffff;
            if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
            } else {
                out = word + out;
            }
            off += 2;
            if (off >= 26) {
                off -= 26;
                i--;
            }
        }
        if (carry !== 0) {
            out = carry.toString(16) + out;
        }
        while(out.length % padding !== 0){
            out = "0" + out;
        }
        if (this.negative !== 0) {
            out = "-" + out;
        }
        return out;
    }
    if (base === (base | 0) && base >= 2 && base <= 36) {
        var groupSize = groupSizes[base];
        var groupBase = groupBases[base];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while(!c.isZero()){
            var r = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
            } else {
                out = r + out;
            }
        }
        if (this.isZero()) {
            out = "0" + out;
        }
        while(out.length % padding !== 0){
            out = "0" + out;
        }
        if (this.negative !== 0) {
            out = "-" + out;
        }
        return out;
    }
    assert6(false, "Base should be between 2 and 36");
};
BN.prototype.toNumber = function toNumber() {
    var ret = this.words[0];
    if (this.length === 2) {
        ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
        ret += 0x10000000000000 + this.words[1] * 0x4000000;
    } else if (this.length > 2) {
        assert6(false, "Number can only safely store up to 53 bits");
    }
    return this.negative !== 0 ? -ret : ret;
};
BN.prototype.toJSON = function toJSON() {
    return this.toString(16, 2);
};
if (Buffer1) {
    BN.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer1, endian, length);
    };
}
BN.prototype.toArray = function toArray(endian, length) {
    return this.toArrayLike(Array, endian, length);
};
var allocate = function allocate(ArrayType, size) {
    if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
};
BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
    this._strip();
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert6(byteLength <= reqLength, "byte array longer than desired length");
    assert6(reqLength > 0, "Requested array length <= 0");
    var res = allocate(ArrayType, reqLength);
    var postfix = endian === "le" ? "LE" : "BE";
    this["_toArrayLike" + postfix](res, byteLength);
    return res;
};
BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
    var position = 0;
    var carry = 0;
    for(var i = 0, shift = 0; i < this.length; i++){
        var word = this.words[i] << shift | carry;
        res[position++] = word & 0xff;
        if (position < res.length) {
            res[position++] = word >> 8 & 0xff;
        }
        if (position < res.length) {
            res[position++] = word >> 16 & 0xff;
        }
        if (shift === 6) {
            if (position < res.length) {
                res[position++] = word >> 24 & 0xff;
            }
            carry = 0;
            shift = 0;
        } else {
            carry = word >>> 24;
            shift += 2;
        }
    }
    if (position < res.length) {
        res[position++] = carry;
        while(position < res.length){
            res[position++] = 0;
        }
    }
};
BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
    var position = res.length - 1;
    var carry = 0;
    for(var i = 0, shift = 0; i < this.length; i++){
        var word = this.words[i] << shift | carry;
        res[position--] = word & 0xff;
        if (position >= 0) {
            res[position--] = word >> 8 & 0xff;
        }
        if (position >= 0) {
            res[position--] = word >> 16 & 0xff;
        }
        if (shift === 6) {
            if (position >= 0) {
                res[position--] = word >> 24 & 0xff;
            }
            carry = 0;
            shift = 0;
        } else {
            carry = word >>> 24;
            shift += 2;
        }
    }
    if (position >= 0) {
        res[position--] = carry;
        while(position >= 0){
            res[position--] = 0;
        }
    }
};
if (Math.clz32) {
    BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
    };
} else {
    BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
        }
        if (t >= 0x40) {
            r += 7;
            t >>>= 7;
        }
        if (t >= 0x8) {
            r += 4;
            t >>>= 4;
        }
        if (t >= 0x02) {
            r += 2;
            t >>>= 2;
        }
        return r + t;
    };
}
BN.prototype._zeroBits = function _zeroBits(w) {
    if (w === 0) return 26;
    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
        r += 13;
        t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
        r += 7;
        t >>>= 7;
    }
    if ((t & 0xf) === 0) {
        r += 4;
        t >>>= 4;
    }
    if ((t & 0x3) === 0) {
        r += 2;
        t >>>= 2;
    }
    if ((t & 0x1) === 0) {
        r++;
    }
    return r;
};
BN.prototype.bitLength = function bitLength() {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
};
function toBitArray(num) {
    var w = new Array(num.bitLength());
    for(var bit = 0; bit < w.length; bit++){
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = num.words[off] >>> wbit & 0x01;
    }
    return w;
}
BN.prototype.zeroBits = function zeroBits() {
    if (this.isZero()) return 0;
    var r = 0;
    for(var i = 0; i < this.length; i++){
        var b = this._zeroBits(this.words[i]);
        r += b;
        if (b !== 26) break;
    }
    return r;
};
BN.prototype.byteLength = function byteLength() {
    return Math.ceil(this.bitLength() / 8);
};
BN.prototype.toTwos = function toTwos(width) {
    if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
};
BN.prototype.fromTwos = function fromTwos(width) {
    if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
};
BN.prototype.isNeg = function isNeg() {
    return this.negative !== 0;
};
BN.prototype.neg = function neg() {
    return this.clone().ineg();
};
BN.prototype.ineg = function ineg() {
    if (!this.isZero()) {
        this.negative ^= 1;
    }
    return this;
};
BN.prototype.iuor = function iuor(num) {
    while(this.length < num.length){
        this.words[this.length++] = 0;
    }
    for(var i = 0; i < num.length; i++){
        this.words[i] = this.words[i] | num.words[i];
    }
    return this._strip();
};
BN.prototype.ior = function ior(num) {
    assert6((this.negative | num.negative) === 0);
    return this.iuor(num);
};
BN.prototype.or = function or(num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
};
BN.prototype.uor = function uor(num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
};
BN.prototype.iuand = function iuand(num) {
    var b;
    if (this.length > num.length) {
        b = num;
    } else {
        b = this;
    }
    for(var i = 0; i < b.length; i++){
        this.words[i] = this.words[i] & num.words[i];
    }
    this.length = b.length;
    return this._strip();
};
BN.prototype.iand = function iand(num) {
    assert6((this.negative | num.negative) === 0);
    return this.iuand(num);
};
BN.prototype.and = function and(num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
};
BN.prototype.uand = function uand(num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
};
BN.prototype.iuxor = function iuxor(num) {
    var a;
    var b;
    if (this.length > num.length) {
        a = this;
        b = num;
    } else {
        a = num;
        b = this;
    }
    for(var i = 0; i < b.length; i++){
        this.words[i] = a.words[i] ^ b.words[i];
    }
    if (this !== a) {
        for(; i < a.length; i++){
            this.words[i] = a.words[i];
        }
    }
    this.length = a.length;
    return this._strip();
};
BN.prototype.ixor = function ixor(num) {
    assert6((this.negative | num.negative) === 0);
    return this.iuxor(num);
};
BN.prototype.xor = function xor(num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
};
BN.prototype.uxor = function uxor(num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
};
BN.prototype.inotn = function inotn(width) {
    assert6(typeof width === "number" && width >= 0);
    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;
    this._expand(bytesNeeded);
    if (bitsLeft > 0) {
        bytesNeeded--;
    }
    for(var i = 0; i < bytesNeeded; i++){
        this.words[i] = ~this.words[i] & 0x3ffffff;
    }
    if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
    }
    return this._strip();
};
BN.prototype.notn = function notn(width) {
    return this.clone().inotn(width);
};
BN.prototype.setn = function setn(bit, val) {
    assert6(typeof bit === "number" && bit >= 0);
    var off = bit / 26 | 0;
    var wbit = bit % 26;
    this._expand(off + 1);
    if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
    } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
    }
    return this._strip();
};
BN.prototype.iadd = function iadd(num) {
    var r;
    if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
    } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
    }
    var a, b;
    if (this.length > num.length) {
        a = this;
        b = num;
    } else {
        a = num;
        b = this;
    }
    var carry = 0;
    for(var i = 0; i < b.length; i++){
        r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r & 0x3ffffff;
        carry = r >>> 26;
    }
    for(; carry !== 0 && i < a.length; i++){
        r = (a.words[i] | 0) + carry;
        this.words[i] = r & 0x3ffffff;
        carry = r >>> 26;
    }
    this.length = a.length;
    if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
    } else if (a !== this) {
        for(; i < a.length; i++){
            this.words[i] = a.words[i];
        }
    }
    return this;
};
BN.prototype.add = function add(num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
    } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
    }
    if (this.length > num.length) return this.clone().iadd(num);
    return num.clone().iadd(this);
};
BN.prototype.isub = function isub(num) {
    if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign();
    } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
    }
    var cmp = this.cmp(num);
    if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
    }
    var a, b;
    if (cmp > 0) {
        a = this;
        b = num;
    } else {
        a = num;
        b = this;
    }
    var carry = 0;
    for(var i = 0; i < b.length; i++){
        r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 0x3ffffff;
    }
    for(; carry !== 0 && i < a.length; i++){
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 0x3ffffff;
    }
    if (carry === 0 && i < a.length && a !== this) {
        for(; i < a.length; i++){
            this.words[i] = a.words[i];
        }
    }
    this.length = Math.max(this.length, i);
    if (a !== this) {
        this.negative = 1;
    }
    return this._strip();
};
BN.prototype.sub = function sub(num) {
    return this.clone().isub(num);
};
function smallMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = self.length + num.length | 0;
    out.length = len;
    len = len - 1 | 0;
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;
    var lo = r & 0x3ffffff;
    var carry = r / 0x4000000 | 0;
    out.words[0] = lo;
    for(var k = 1; k < len; k++){
        var ncarry = carry >>> 26;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k, num.length - 1);
        for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
            var i = k - j | 0;
            a = self.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 0x4000000 | 0;
            rword = r & 0x3ffffff;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
    }
    if (carry !== 0) {
        out.words[k] = carry | 0;
    } else {
        out.length--;
    }
    return out._strip();
}
var comb10MulTo = function comb10MulTo(self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;
    out.negative = self.negative ^ num.negative;
    out.length = 19;
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = mid + Math.imul(ah0, bl0) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
    w0 &= 0x3ffffff;
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = mid + Math.imul(ah1, bl0) | 0;
    hi = Math.imul(ah1, bh0);
    lo = lo + Math.imul(al0, bl1) | 0;
    mid = mid + Math.imul(al0, bh1) | 0;
    mid = mid + Math.imul(ah0, bl1) | 0;
    hi = hi + Math.imul(ah0, bh1) | 0;
    var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
    w1 &= 0x3ffffff;
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = mid + Math.imul(ah2, bl0) | 0;
    hi = Math.imul(ah2, bh0);
    lo = lo + Math.imul(al1, bl1) | 0;
    mid = mid + Math.imul(al1, bh1) | 0;
    mid = mid + Math.imul(ah1, bl1) | 0;
    hi = hi + Math.imul(ah1, bh1) | 0;
    lo = lo + Math.imul(al0, bl2) | 0;
    mid = mid + Math.imul(al0, bh2) | 0;
    mid = mid + Math.imul(ah0, bl2) | 0;
    hi = hi + Math.imul(ah0, bh2) | 0;
    var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
    w2 &= 0x3ffffff;
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = mid + Math.imul(ah3, bl0) | 0;
    hi = Math.imul(ah3, bh0);
    lo = lo + Math.imul(al2, bl1) | 0;
    mid = mid + Math.imul(al2, bh1) | 0;
    mid = mid + Math.imul(ah2, bl1) | 0;
    hi = hi + Math.imul(ah2, bh1) | 0;
    lo = lo + Math.imul(al1, bl2) | 0;
    mid = mid + Math.imul(al1, bh2) | 0;
    mid = mid + Math.imul(ah1, bl2) | 0;
    hi = hi + Math.imul(ah1, bh2) | 0;
    lo = lo + Math.imul(al0, bl3) | 0;
    mid = mid + Math.imul(al0, bh3) | 0;
    mid = mid + Math.imul(ah0, bl3) | 0;
    hi = hi + Math.imul(ah0, bh3) | 0;
    var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
    w3 &= 0x3ffffff;
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = mid + Math.imul(ah4, bl0) | 0;
    hi = Math.imul(ah4, bh0);
    lo = lo + Math.imul(al3, bl1) | 0;
    mid = mid + Math.imul(al3, bh1) | 0;
    mid = mid + Math.imul(ah3, bl1) | 0;
    hi = hi + Math.imul(ah3, bh1) | 0;
    lo = lo + Math.imul(al2, bl2) | 0;
    mid = mid + Math.imul(al2, bh2) | 0;
    mid = mid + Math.imul(ah2, bl2) | 0;
    hi = hi + Math.imul(ah2, bh2) | 0;
    lo = lo + Math.imul(al1, bl3) | 0;
    mid = mid + Math.imul(al1, bh3) | 0;
    mid = mid + Math.imul(ah1, bl3) | 0;
    hi = hi + Math.imul(ah1, bh3) | 0;
    lo = lo + Math.imul(al0, bl4) | 0;
    mid = mid + Math.imul(al0, bh4) | 0;
    mid = mid + Math.imul(ah0, bl4) | 0;
    hi = hi + Math.imul(ah0, bh4) | 0;
    var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
    w4 &= 0x3ffffff;
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = mid + Math.imul(ah5, bl0) | 0;
    hi = Math.imul(ah5, bh0);
    lo = lo + Math.imul(al4, bl1) | 0;
    mid = mid + Math.imul(al4, bh1) | 0;
    mid = mid + Math.imul(ah4, bl1) | 0;
    hi = hi + Math.imul(ah4, bh1) | 0;
    lo = lo + Math.imul(al3, bl2) | 0;
    mid = mid + Math.imul(al3, bh2) | 0;
    mid = mid + Math.imul(ah3, bl2) | 0;
    hi = hi + Math.imul(ah3, bh2) | 0;
    lo = lo + Math.imul(al2, bl3) | 0;
    mid = mid + Math.imul(al2, bh3) | 0;
    mid = mid + Math.imul(ah2, bl3) | 0;
    hi = hi + Math.imul(ah2, bh3) | 0;
    lo = lo + Math.imul(al1, bl4) | 0;
    mid = mid + Math.imul(al1, bh4) | 0;
    mid = mid + Math.imul(ah1, bl4) | 0;
    hi = hi + Math.imul(ah1, bh4) | 0;
    lo = lo + Math.imul(al0, bl5) | 0;
    mid = mid + Math.imul(al0, bh5) | 0;
    mid = mid + Math.imul(ah0, bl5) | 0;
    hi = hi + Math.imul(ah0, bh5) | 0;
    var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
    w5 &= 0x3ffffff;
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = mid + Math.imul(ah6, bl0) | 0;
    hi = Math.imul(ah6, bh0);
    lo = lo + Math.imul(al5, bl1) | 0;
    mid = mid + Math.imul(al5, bh1) | 0;
    mid = mid + Math.imul(ah5, bl1) | 0;
    hi = hi + Math.imul(ah5, bh1) | 0;
    lo = lo + Math.imul(al4, bl2) | 0;
    mid = mid + Math.imul(al4, bh2) | 0;
    mid = mid + Math.imul(ah4, bl2) | 0;
    hi = hi + Math.imul(ah4, bh2) | 0;
    lo = lo + Math.imul(al3, bl3) | 0;
    mid = mid + Math.imul(al3, bh3) | 0;
    mid = mid + Math.imul(ah3, bl3) | 0;
    hi = hi + Math.imul(ah3, bh3) | 0;
    lo = lo + Math.imul(al2, bl4) | 0;
    mid = mid + Math.imul(al2, bh4) | 0;
    mid = mid + Math.imul(ah2, bl4) | 0;
    hi = hi + Math.imul(ah2, bh4) | 0;
    lo = lo + Math.imul(al1, bl5) | 0;
    mid = mid + Math.imul(al1, bh5) | 0;
    mid = mid + Math.imul(ah1, bl5) | 0;
    hi = hi + Math.imul(ah1, bh5) | 0;
    lo = lo + Math.imul(al0, bl6) | 0;
    mid = mid + Math.imul(al0, bh6) | 0;
    mid = mid + Math.imul(ah0, bl6) | 0;
    hi = hi + Math.imul(ah0, bh6) | 0;
    var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
    w6 &= 0x3ffffff;
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = mid + Math.imul(ah7, bl0) | 0;
    hi = Math.imul(ah7, bh0);
    lo = lo + Math.imul(al6, bl1) | 0;
    mid = mid + Math.imul(al6, bh1) | 0;
    mid = mid + Math.imul(ah6, bl1) | 0;
    hi = hi + Math.imul(ah6, bh1) | 0;
    lo = lo + Math.imul(al5, bl2) | 0;
    mid = mid + Math.imul(al5, bh2) | 0;
    mid = mid + Math.imul(ah5, bl2) | 0;
    hi = hi + Math.imul(ah5, bh2) | 0;
    lo = lo + Math.imul(al4, bl3) | 0;
    mid = mid + Math.imul(al4, bh3) | 0;
    mid = mid + Math.imul(ah4, bl3) | 0;
    hi = hi + Math.imul(ah4, bh3) | 0;
    lo = lo + Math.imul(al3, bl4) | 0;
    mid = mid + Math.imul(al3, bh4) | 0;
    mid = mid + Math.imul(ah3, bl4) | 0;
    hi = hi + Math.imul(ah3, bh4) | 0;
    lo = lo + Math.imul(al2, bl5) | 0;
    mid = mid + Math.imul(al2, bh5) | 0;
    mid = mid + Math.imul(ah2, bl5) | 0;
    hi = hi + Math.imul(ah2, bh5) | 0;
    lo = lo + Math.imul(al1, bl6) | 0;
    mid = mid + Math.imul(al1, bh6) | 0;
    mid = mid + Math.imul(ah1, bl6) | 0;
    hi = hi + Math.imul(ah1, bh6) | 0;
    lo = lo + Math.imul(al0, bl7) | 0;
    mid = mid + Math.imul(al0, bh7) | 0;
    mid = mid + Math.imul(ah0, bl7) | 0;
    hi = hi + Math.imul(ah0, bh7) | 0;
    var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
    w7 &= 0x3ffffff;
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = mid + Math.imul(ah8, bl0) | 0;
    hi = Math.imul(ah8, bh0);
    lo = lo + Math.imul(al7, bl1) | 0;
    mid = mid + Math.imul(al7, bh1) | 0;
    mid = mid + Math.imul(ah7, bl1) | 0;
    hi = hi + Math.imul(ah7, bh1) | 0;
    lo = lo + Math.imul(al6, bl2) | 0;
    mid = mid + Math.imul(al6, bh2) | 0;
    mid = mid + Math.imul(ah6, bl2) | 0;
    hi = hi + Math.imul(ah6, bh2) | 0;
    lo = lo + Math.imul(al5, bl3) | 0;
    mid = mid + Math.imul(al5, bh3) | 0;
    mid = mid + Math.imul(ah5, bl3) | 0;
    hi = hi + Math.imul(ah5, bh3) | 0;
    lo = lo + Math.imul(al4, bl4) | 0;
    mid = mid + Math.imul(al4, bh4) | 0;
    mid = mid + Math.imul(ah4, bl4) | 0;
    hi = hi + Math.imul(ah4, bh4) | 0;
    lo = lo + Math.imul(al3, bl5) | 0;
    mid = mid + Math.imul(al3, bh5) | 0;
    mid = mid + Math.imul(ah3, bl5) | 0;
    hi = hi + Math.imul(ah3, bh5) | 0;
    lo = lo + Math.imul(al2, bl6) | 0;
    mid = mid + Math.imul(al2, bh6) | 0;
    mid = mid + Math.imul(ah2, bl6) | 0;
    hi = hi + Math.imul(ah2, bh6) | 0;
    lo = lo + Math.imul(al1, bl7) | 0;
    mid = mid + Math.imul(al1, bh7) | 0;
    mid = mid + Math.imul(ah1, bl7) | 0;
    hi = hi + Math.imul(ah1, bh7) | 0;
    lo = lo + Math.imul(al0, bl8) | 0;
    mid = mid + Math.imul(al0, bh8) | 0;
    mid = mid + Math.imul(ah0, bl8) | 0;
    hi = hi + Math.imul(ah0, bh8) | 0;
    var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
    w8 &= 0x3ffffff;
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = mid + Math.imul(ah9, bl0) | 0;
    hi = Math.imul(ah9, bh0);
    lo = lo + Math.imul(al8, bl1) | 0;
    mid = mid + Math.imul(al8, bh1) | 0;
    mid = mid + Math.imul(ah8, bl1) | 0;
    hi = hi + Math.imul(ah8, bh1) | 0;
    lo = lo + Math.imul(al7, bl2) | 0;
    mid = mid + Math.imul(al7, bh2) | 0;
    mid = mid + Math.imul(ah7, bl2) | 0;
    hi = hi + Math.imul(ah7, bh2) | 0;
    lo = lo + Math.imul(al6, bl3) | 0;
    mid = mid + Math.imul(al6, bh3) | 0;
    mid = mid + Math.imul(ah6, bl3) | 0;
    hi = hi + Math.imul(ah6, bh3) | 0;
    lo = lo + Math.imul(al5, bl4) | 0;
    mid = mid + Math.imul(al5, bh4) | 0;
    mid = mid + Math.imul(ah5, bl4) | 0;
    hi = hi + Math.imul(ah5, bh4) | 0;
    lo = lo + Math.imul(al4, bl5) | 0;
    mid = mid + Math.imul(al4, bh5) | 0;
    mid = mid + Math.imul(ah4, bl5) | 0;
    hi = hi + Math.imul(ah4, bh5) | 0;
    lo = lo + Math.imul(al3, bl6) | 0;
    mid = mid + Math.imul(al3, bh6) | 0;
    mid = mid + Math.imul(ah3, bl6) | 0;
    hi = hi + Math.imul(ah3, bh6) | 0;
    lo = lo + Math.imul(al2, bl7) | 0;
    mid = mid + Math.imul(al2, bh7) | 0;
    mid = mid + Math.imul(ah2, bl7) | 0;
    hi = hi + Math.imul(ah2, bh7) | 0;
    lo = lo + Math.imul(al1, bl8) | 0;
    mid = mid + Math.imul(al1, bh8) | 0;
    mid = mid + Math.imul(ah1, bl8) | 0;
    hi = hi + Math.imul(ah1, bh8) | 0;
    lo = lo + Math.imul(al0, bl9) | 0;
    mid = mid + Math.imul(al0, bh9) | 0;
    mid = mid + Math.imul(ah0, bl9) | 0;
    hi = hi + Math.imul(ah0, bh9) | 0;
    var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
    w9 &= 0x3ffffff;
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = mid + Math.imul(ah9, bl1) | 0;
    hi = Math.imul(ah9, bh1);
    lo = lo + Math.imul(al8, bl2) | 0;
    mid = mid + Math.imul(al8, bh2) | 0;
    mid = mid + Math.imul(ah8, bl2) | 0;
    hi = hi + Math.imul(ah8, bh2) | 0;
    lo = lo + Math.imul(al7, bl3) | 0;
    mid = mid + Math.imul(al7, bh3) | 0;
    mid = mid + Math.imul(ah7, bl3) | 0;
    hi = hi + Math.imul(ah7, bh3) | 0;
    lo = lo + Math.imul(al6, bl4) | 0;
    mid = mid + Math.imul(al6, bh4) | 0;
    mid = mid + Math.imul(ah6, bl4) | 0;
    hi = hi + Math.imul(ah6, bh4) | 0;
    lo = lo + Math.imul(al5, bl5) | 0;
    mid = mid + Math.imul(al5, bh5) | 0;
    mid = mid + Math.imul(ah5, bl5) | 0;
    hi = hi + Math.imul(ah5, bh5) | 0;
    lo = lo + Math.imul(al4, bl6) | 0;
    mid = mid + Math.imul(al4, bh6) | 0;
    mid = mid + Math.imul(ah4, bl6) | 0;
    hi = hi + Math.imul(ah4, bh6) | 0;
    lo = lo + Math.imul(al3, bl7) | 0;
    mid = mid + Math.imul(al3, bh7) | 0;
    mid = mid + Math.imul(ah3, bl7) | 0;
    hi = hi + Math.imul(ah3, bh7) | 0;
    lo = lo + Math.imul(al2, bl8) | 0;
    mid = mid + Math.imul(al2, bh8) | 0;
    mid = mid + Math.imul(ah2, bl8) | 0;
    hi = hi + Math.imul(ah2, bh8) | 0;
    lo = lo + Math.imul(al1, bl9) | 0;
    mid = mid + Math.imul(al1, bh9) | 0;
    mid = mid + Math.imul(ah1, bl9) | 0;
    hi = hi + Math.imul(ah1, bh9) | 0;
    var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
    w10 &= 0x3ffffff;
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = mid + Math.imul(ah9, bl2) | 0;
    hi = Math.imul(ah9, bh2);
    lo = lo + Math.imul(al8, bl3) | 0;
    mid = mid + Math.imul(al8, bh3) | 0;
    mid = mid + Math.imul(ah8, bl3) | 0;
    hi = hi + Math.imul(ah8, bh3) | 0;
    lo = lo + Math.imul(al7, bl4) | 0;
    mid = mid + Math.imul(al7, bh4) | 0;
    mid = mid + Math.imul(ah7, bl4) | 0;
    hi = hi + Math.imul(ah7, bh4) | 0;
    lo = lo + Math.imul(al6, bl5) | 0;
    mid = mid + Math.imul(al6, bh5) | 0;
    mid = mid + Math.imul(ah6, bl5) | 0;
    hi = hi + Math.imul(ah6, bh5) | 0;
    lo = lo + Math.imul(al5, bl6) | 0;
    mid = mid + Math.imul(al5, bh6) | 0;
    mid = mid + Math.imul(ah5, bl6) | 0;
    hi = hi + Math.imul(ah5, bh6) | 0;
    lo = lo + Math.imul(al4, bl7) | 0;
    mid = mid + Math.imul(al4, bh7) | 0;
    mid = mid + Math.imul(ah4, bl7) | 0;
    hi = hi + Math.imul(ah4, bh7) | 0;
    lo = lo + Math.imul(al3, bl8) | 0;
    mid = mid + Math.imul(al3, bh8) | 0;
    mid = mid + Math.imul(ah3, bl8) | 0;
    hi = hi + Math.imul(ah3, bh8) | 0;
    lo = lo + Math.imul(al2, bl9) | 0;
    mid = mid + Math.imul(al2, bh9) | 0;
    mid = mid + Math.imul(ah2, bl9) | 0;
    hi = hi + Math.imul(ah2, bh9) | 0;
    var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
    w11 &= 0x3ffffff;
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = mid + Math.imul(ah9, bl3) | 0;
    hi = Math.imul(ah9, bh3);
    lo = lo + Math.imul(al8, bl4) | 0;
    mid = mid + Math.imul(al8, bh4) | 0;
    mid = mid + Math.imul(ah8, bl4) | 0;
    hi = hi + Math.imul(ah8, bh4) | 0;
    lo = lo + Math.imul(al7, bl5) | 0;
    mid = mid + Math.imul(al7, bh5) | 0;
    mid = mid + Math.imul(ah7, bl5) | 0;
    hi = hi + Math.imul(ah7, bh5) | 0;
    lo = lo + Math.imul(al6, bl6) | 0;
    mid = mid + Math.imul(al6, bh6) | 0;
    mid = mid + Math.imul(ah6, bl6) | 0;
    hi = hi + Math.imul(ah6, bh6) | 0;
    lo = lo + Math.imul(al5, bl7) | 0;
    mid = mid + Math.imul(al5, bh7) | 0;
    mid = mid + Math.imul(ah5, bl7) | 0;
    hi = hi + Math.imul(ah5, bh7) | 0;
    lo = lo + Math.imul(al4, bl8) | 0;
    mid = mid + Math.imul(al4, bh8) | 0;
    mid = mid + Math.imul(ah4, bl8) | 0;
    hi = hi + Math.imul(ah4, bh8) | 0;
    lo = lo + Math.imul(al3, bl9) | 0;
    mid = mid + Math.imul(al3, bh9) | 0;
    mid = mid + Math.imul(ah3, bl9) | 0;
    hi = hi + Math.imul(ah3, bh9) | 0;
    var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
    w12 &= 0x3ffffff;
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = mid + Math.imul(ah9, bl4) | 0;
    hi = Math.imul(ah9, bh4);
    lo = lo + Math.imul(al8, bl5) | 0;
    mid = mid + Math.imul(al8, bh5) | 0;
    mid = mid + Math.imul(ah8, bl5) | 0;
    hi = hi + Math.imul(ah8, bh5) | 0;
    lo = lo + Math.imul(al7, bl6) | 0;
    mid = mid + Math.imul(al7, bh6) | 0;
    mid = mid + Math.imul(ah7, bl6) | 0;
    hi = hi + Math.imul(ah7, bh6) | 0;
    lo = lo + Math.imul(al6, bl7) | 0;
    mid = mid + Math.imul(al6, bh7) | 0;
    mid = mid + Math.imul(ah6, bl7) | 0;
    hi = hi + Math.imul(ah6, bh7) | 0;
    lo = lo + Math.imul(al5, bl8) | 0;
    mid = mid + Math.imul(al5, bh8) | 0;
    mid = mid + Math.imul(ah5, bl8) | 0;
    hi = hi + Math.imul(ah5, bh8) | 0;
    lo = lo + Math.imul(al4, bl9) | 0;
    mid = mid + Math.imul(al4, bh9) | 0;
    mid = mid + Math.imul(ah4, bl9) | 0;
    hi = hi + Math.imul(ah4, bh9) | 0;
    var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
    w13 &= 0x3ffffff;
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = mid + Math.imul(ah9, bl5) | 0;
    hi = Math.imul(ah9, bh5);
    lo = lo + Math.imul(al8, bl6) | 0;
    mid = mid + Math.imul(al8, bh6) | 0;
    mid = mid + Math.imul(ah8, bl6) | 0;
    hi = hi + Math.imul(ah8, bh6) | 0;
    lo = lo + Math.imul(al7, bl7) | 0;
    mid = mid + Math.imul(al7, bh7) | 0;
    mid = mid + Math.imul(ah7, bl7) | 0;
    hi = hi + Math.imul(ah7, bh7) | 0;
    lo = lo + Math.imul(al6, bl8) | 0;
    mid = mid + Math.imul(al6, bh8) | 0;
    mid = mid + Math.imul(ah6, bl8) | 0;
    hi = hi + Math.imul(ah6, bh8) | 0;
    lo = lo + Math.imul(al5, bl9) | 0;
    mid = mid + Math.imul(al5, bh9) | 0;
    mid = mid + Math.imul(ah5, bl9) | 0;
    hi = hi + Math.imul(ah5, bh9) | 0;
    var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
    w14 &= 0x3ffffff;
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = mid + Math.imul(ah9, bl6) | 0;
    hi = Math.imul(ah9, bh6);
    lo = lo + Math.imul(al8, bl7) | 0;
    mid = mid + Math.imul(al8, bh7) | 0;
    mid = mid + Math.imul(ah8, bl7) | 0;
    hi = hi + Math.imul(ah8, bh7) | 0;
    lo = lo + Math.imul(al7, bl8) | 0;
    mid = mid + Math.imul(al7, bh8) | 0;
    mid = mid + Math.imul(ah7, bl8) | 0;
    hi = hi + Math.imul(ah7, bh8) | 0;
    lo = lo + Math.imul(al6, bl9) | 0;
    mid = mid + Math.imul(al6, bh9) | 0;
    mid = mid + Math.imul(ah6, bl9) | 0;
    hi = hi + Math.imul(ah6, bh9) | 0;
    var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
    w15 &= 0x3ffffff;
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = mid + Math.imul(ah9, bl7) | 0;
    hi = Math.imul(ah9, bh7);
    lo = lo + Math.imul(al8, bl8) | 0;
    mid = mid + Math.imul(al8, bh8) | 0;
    mid = mid + Math.imul(ah8, bl8) | 0;
    hi = hi + Math.imul(ah8, bh8) | 0;
    lo = lo + Math.imul(al7, bl9) | 0;
    mid = mid + Math.imul(al7, bh9) | 0;
    mid = mid + Math.imul(ah7, bl9) | 0;
    hi = hi + Math.imul(ah7, bh9) | 0;
    var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
    w16 &= 0x3ffffff;
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = mid + Math.imul(ah9, bl8) | 0;
    hi = Math.imul(ah9, bh8);
    lo = lo + Math.imul(al8, bl9) | 0;
    mid = mid + Math.imul(al8, bh9) | 0;
    mid = mid + Math.imul(ah8, bl9) | 0;
    hi = hi + Math.imul(ah8, bh9) | 0;
    var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
    w17 &= 0x3ffffff;
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = mid + Math.imul(ah9, bl9) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
        o[19] = c;
        out.length++;
    }
    return out;
};
if (!Math.imul) {
    comb10MulTo = smallMulTo;
}
function bigMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;
    var carry = 0;
    var hncarry = 0;
    for(var k = 0; k < out.length - 1; k++){
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k, num.length - 1);
        for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
            var i = k - j;
            var a = self.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 0x3ffffff;
            ncarry = ncarry + (r / 0x4000000 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 0x3ffffff;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 0x3ffffff;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
    }
    if (carry !== 0) {
        out.words[k] = carry;
    } else {
        out.length--;
    }
    return out._strip();
}
function jumboMulTo(self, num, out) {
    return bigMulTo(self, num, out);
}
BN.prototype.mulTo = function mulTo(num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
    } else if (len < 63) {
        res = smallMulTo(this, num, out);
    } else if (len < 1024) {
        res = bigMulTo(this, num, out);
    } else {
        res = jumboMulTo(this, num, out);
    }
    return res;
};
function FFTM(x, y) {
    this.x = x;
    this.y = y;
}
FFTM.prototype.makeRBT = function makeRBT(N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for(var i = 0; i < N; i++){
        t[i] = this.revBin(i, l, N);
    }
    return t;
};
FFTM.prototype.revBin = function revBin(x, l, N) {
    if (x === 0 || x === N - 1) return x;
    var rb = 0;
    for(var i = 0; i < l; i++){
        rb |= (x & 1) << l - i - 1;
        x >>= 1;
    }
    return rb;
};
FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
    for(var i = 0; i < N; i++){
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
    }
};
FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);
    for(var s = 1; s < N; s <<= 1){
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);
        for(var p = 0; p < N; p += l){
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for(var j = 0; j < s; j++){
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                    rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                    itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                    rtwdf_ = rx;
                }
            }
        }
    }
};
FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for(N = N / 2 | 0; N; N = N >>> 1){
        i++;
    }
    return 1 << i + 1 + odd;
};
FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
    if (N <= 1) return;
    for(var i = 0; i < N / 2; i++){
        var t = rws[i];
        rws[i] = rws[N - i - 1];
        rws[N - i - 1] = t;
        t = iws[i];
        iws[i] = -iws[N - i - 1];
        iws[N - i - 1] = -t;
    }
};
FFTM.prototype.normalize13b = function normalize13b(ws, N) {
    var carry = 0;
    for(var i = 0; i < N / 2; i++){
        var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
        ws[i] = w & 0x3ffffff;
        if (w < 0x4000000) {
            carry = 0;
        } else {
            carry = w / 0x4000000 | 0;
        }
    }
    return ws;
};
FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
    var carry = 0;
    for(var i = 0; i < len; i++){
        carry = carry + (ws[i] | 0);
        rws[2 * i] = carry & 0x1fff;
        carry = carry >>> 13;
        rws[2 * i + 1] = carry & 0x1fff;
        carry = carry >>> 13;
    }
    for(i = 2 * len; i < N; ++i){
        rws[i] = 0;
    }
    assert6(carry === 0);
    assert6((carry & ~0x1fff) === 0);
};
FFTM.prototype.stub = function stub(N) {
    var ph = new Array(N);
    for(var i = 0; i < N; i++){
        ph[i] = 0;
    }
    return ph;
};
FFTM.prototype.mulp = function mulp(x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);
    var rbt = this.makeRBT(N);
    var _ = this.stub(N);
    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);
    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);
    var rmws = out.words;
    rmws.length = N;
    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);
    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);
    for(var i = 0; i < N; i++){
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
    }
    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);
    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
};
BN.prototype.mul = function mul(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
};
BN.prototype.mulf = function mulf(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
};
BN.prototype.imul = function imul(num) {
    return this.clone().mulTo(num, this);
};
BN.prototype.imuln = function imuln(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert6(typeof num === "number");
    assert6(num < 0x4000000);
    var carry = 0;
    for(var i = 0; i < this.length; i++){
        var w = (this.words[i] | 0) * num;
        var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
        carry >>= 26;
        carry += w / 0x4000000 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 0x3ffffff;
    }
    if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
    }
    return isNegNum ? this.ineg() : this;
};
BN.prototype.muln = function muln(num) {
    return this.clone().imuln(num);
};
BN.prototype.sqr = function sqr() {
    return this.mul(this);
};
BN.prototype.isqr = function isqr() {
    return this.imul(this.clone());
};
BN.prototype.pow = function pow(num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);
    var res = this;
    for(var i = 0; i < w.length; i++, res = res.sqr()){
        if (w[i] !== 0) break;
    }
    if (++i < w.length) {
        for(var q = res.sqr(); i < w.length; i++, q = q.sqr()){
            if (w[i] === 0) continue;
            res = res.mul(q);
        }
    }
    return res;
};
BN.prototype.iushln = function iushln(bits) {
    assert6(typeof bits === "number" && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
    var i;
    if (r !== 0) {
        var carry = 0;
        for(i = 0; i < this.length; i++){
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
        }
        if (carry) {
            this.words[i] = carry;
            this.length++;
        }
    }
    if (s !== 0) {
        for(i = this.length - 1; i >= 0; i--){
            this.words[i + s] = this.words[i];
        }
        for(i = 0; i < s; i++){
            this.words[i] = 0;
        }
        this.length += s;
    }
    return this._strip();
};
BN.prototype.ishln = function ishln(bits) {
    assert6(this.negative === 0);
    return this.iushln(bits);
};
BN.prototype.iushrn = function iushrn(bits, hint, extended) {
    assert6(typeof bits === "number" && bits >= 0);
    var h;
    if (hint) {
        h = (hint - hint % 26) / 26;
    } else {
        h = 0;
    }
    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
    var maskedWords = extended;
    h -= s;
    h = Math.max(0, h);
    if (maskedWords) {
        for(var i = 0; i < s; i++){
            maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s;
    }
    if (s === 0) {} else if (this.length > s) {
        this.length -= s;
        for(i = 0; i < this.length; i++){
            this.words[i] = this.words[i + s];
        }
    } else {
        this.words[0] = 0;
        this.length = 1;
    }
    var carry = 0;
    for(i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--){
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r | word >>> r;
        carry = word & mask;
    }
    if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
    }
    if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
    }
    return this._strip();
};
BN.prototype.ishrn = function ishrn(bits, hint, extended) {
    assert6(this.negative === 0);
    return this.iushrn(bits, hint, extended);
};
BN.prototype.shln = function shln(bits) {
    return this.clone().ishln(bits);
};
BN.prototype.ushln = function ushln(bits) {
    return this.clone().iushln(bits);
};
BN.prototype.shrn = function shrn(bits) {
    return this.clone().ishrn(bits);
};
BN.prototype.ushrn = function ushrn(bits) {
    return this.clone().iushrn(bits);
};
BN.prototype.testn = function testn(bit) {
    assert6(typeof bit === "number" && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;
    if (this.length <= s) return false;
    var w = this.words[s];
    return !!(w & q);
};
BN.prototype.imaskn = function imaskn(bits) {
    assert6(typeof bits === "number" && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    assert6(this.negative === 0, "imaskn works only with positive numbers");
    if (this.length <= s) {
        return this;
    }
    if (r !== 0) {
        s++;
    }
    this.length = Math.min(s, this.length);
    if (r !== 0) {
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        this.words[this.length - 1] &= mask;
    }
    return this._strip();
};
BN.prototype.maskn = function maskn(bits) {
    return this.clone().imaskn(bits);
};
BN.prototype.iaddn = function iaddn(num) {
    assert6(typeof num === "number");
    assert6(num < 0x4000000);
    if (num < 0) return this.isubn(-num);
    if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
    }
    return this._iaddn(num);
};
BN.prototype._iaddn = function _iaddn(num) {
    this.words[0] += num;
    for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++){
        this.words[i] -= 0x4000000;
        if (i === this.length - 1) {
            this.words[i + 1] = 1;
        } else {
            this.words[i + 1]++;
        }
    }
    this.length = Math.max(this.length, i + 1);
    return this;
};
BN.prototype.isubn = function isubn(num) {
    assert6(typeof num === "number");
    assert6(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);
    if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
    }
    this.words[0] -= num;
    if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
    } else {
        for(var i = 0; i < this.length && this.words[i] < 0; i++){
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
        }
    }
    return this._strip();
};
BN.prototype.addn = function addn(num) {
    return this.clone().iaddn(num);
};
BN.prototype.subn = function subn(num) {
    return this.clone().isubn(num);
};
BN.prototype.iabs = function iabs() {
    this.negative = 0;
    return this;
};
BN.prototype.abs = function abs() {
    return this.clone().iabs();
};
BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
    var len = num.length + shift;
    var i;
    this._expand(len);
    var w;
    var carry = 0;
    for(i = 0; i < num.length; i++){
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul;
        w -= right & 0x3ffffff;
        carry = (w >> 26) - (right / 0x4000000 | 0);
        this.words[i + shift] = w & 0x3ffffff;
    }
    for(; i < this.length - shift; i++){
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 0x3ffffff;
    }
    if (carry === 0) return this._strip();
    assert6(carry === -1);
    carry = 0;
    for(i = 0; i < this.length; i++){
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;
    return this._strip();
};
BN.prototype._wordDiv = function _wordDiv(num, mode) {
    var shift = this.length - num.length;
    var a = this.clone();
    var b = num;
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
    }
    var m = a.length - b.length;
    var q;
    if (mode !== "mod") {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for(var i = 0; i < q.length; i++){
            q.words[i] = 0;
        }
    }
    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
        a = diff;
        if (q) {
            q.words[m] = 1;
        }
    }
    for(var j = m - 1; j >= 0; j--){
        var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 0x3ffffff);
        a._ishlnsubmul(b, qj, j);
        while(a.negative !== 0){
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
                a.negative ^= 1;
            }
        }
        if (q) {
            q.words[j] = qj;
        }
    }
    if (q) {
        q._strip();
    }
    a._strip();
    if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
    }
    return {
        div: q || null,
        mod: a
    };
};
BN.prototype.divmod = function divmod(num, mode, positive) {
    assert6(!num.isZero());
    if (this.isZero()) {
        return {
            div: new BN(0),
            mod: new BN(0)
        };
    }
    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
            div = res.div.neg();
        }
        if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
                mod.iadd(num);
            }
        }
        return {
            div: div,
            mod: mod
        };
    }
    if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
            div = res.div.neg();
        }
        return {
            div: div,
            mod: res.mod
        };
    }
    if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
                mod.isub(num);
            }
        }
        return {
            div: res.div,
            mod: mod
        };
    }
    if (num.length > this.length || this.cmp(num) < 0) {
        return {
            div: new BN(0),
            mod: this
        };
    }
    if (num.length === 1) {
        if (mode === "div") {
            return {
                div: this.divn(num.words[0]),
                mod: null
            };
        }
        if (mode === "mod") {
            return {
                div: null,
                mod: new BN(this.modrn(num.words[0]))
            };
        }
        return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0]))
        };
    }
    return this._wordDiv(num, mode);
};
BN.prototype.div = function div(num) {
    return this.divmod(num, "div", false).div;
};
BN.prototype.mod = function mod(num) {
    return this.divmod(num, "mod", false).mod;
};
BN.prototype.umod = function umod(num) {
    return this.divmod(num, "mod", true).mod;
};
BN.prototype.divRound = function divRound(num) {
    var dm = this.divmod(num);
    if (dm.mod.isZero()) return dm.div;
    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
};
BN.prototype.modrn = function modrn(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert6(num <= 0x3ffffff);
    var p = (1 << 26) % num;
    var acc = 0;
    for(var i = this.length - 1; i >= 0; i--){
        acc = (p * acc + (this.words[i] | 0)) % num;
    }
    return isNegNum ? -acc : acc;
};
BN.prototype.modn = function modn(num) {
    return this.modrn(num);
};
BN.prototype.idivn = function idivn(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert6(num <= 0x3ffffff);
    var carry = 0;
    for(var i = this.length - 1; i >= 0; i--){
        var w = (this.words[i] | 0) + carry * 0x4000000;
        this.words[i] = w / num | 0;
        carry = w % num;
    }
    this._strip();
    return isNegNum ? this.ineg() : this;
};
BN.prototype.divn = function divn(num) {
    return this.clone().idivn(num);
};
BN.prototype.egcd = function egcd(p) {
    assert6(p.negative === 0);
    assert6(!p.isZero());
    var x = this;
    var y = p.clone();
    if (x.negative !== 0) {
        x = x.umod(p);
    } else {
        x = x.clone();
    }
    var A = new BN(1);
    var B = new BN(0);
    var C = new BN(0);
    var D = new BN(1);
    var g = 0;
    while(x.isEven() && y.isEven()){
        x.iushrn(1);
        y.iushrn(1);
        ++g;
    }
    var yp = y.clone();
    var xp = x.clone();
    while(!x.isZero()){
        for(var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
        if (i > 0) {
            x.iushrn(i);
            while(i-- > 0){
                if (A.isOdd() || B.isOdd()) {
                    A.iadd(yp);
                    B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
            }
        }
        for(var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
        if (j > 0) {
            y.iushrn(j);
            while(j-- > 0){
                if (C.isOdd() || D.isOdd()) {
                    C.iadd(yp);
                    D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
            }
        }
        if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
        } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
        }
    }
    return {
        a: C,
        b: D,
        gcd: y.iushln(g)
    };
};
BN.prototype._invmp = function _invmp(p) {
    assert6(p.negative === 0);
    assert6(!p.isZero());
    var a = this;
    var b = p.clone();
    if (a.negative !== 0) {
        a = a.umod(p);
    } else {
        a = a.clone();
    }
    var x1 = new BN(1);
    var x2 = new BN(0);
    var delta = b.clone();
    while(a.cmpn(1) > 0 && b.cmpn(1) > 0){
        for(var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
        if (i > 0) {
            a.iushrn(i);
            while(i-- > 0){
                if (x1.isOdd()) {
                    x1.iadd(delta);
                }
                x1.iushrn(1);
            }
        }
        for(var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
        if (j > 0) {
            b.iushrn(j);
            while(j-- > 0){
                if (x2.isOdd()) {
                    x2.iadd(delta);
                }
                x2.iushrn(1);
            }
        }
        if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
        } else {
            b.isub(a);
            x2.isub(x1);
        }
    }
    var res;
    if (a.cmpn(1) === 0) {
        res = x1;
    } else {
        res = x2;
    }
    if (res.cmpn(0) < 0) {
        res.iadd(p);
    }
    return res;
};
BN.prototype.gcd = function gcd(num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();
    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;
    for(var shift = 0; a.isEven() && b.isEven(); shift++){
        a.iushrn(1);
        b.iushrn(1);
    }
    do {
        while(a.isEven()){
            a.iushrn(1);
        }
        while(b.isEven()){
            b.iushrn(1);
        }
        var r = a.cmp(b);
        if (r < 0) {
            var t = a;
            a = b;
            b = t;
        } else if (r === 0 || b.cmpn(1) === 0) {
            break;
        }
        a.isub(b);
    }while (true)
    return b.iushln(shift);
};
BN.prototype.invm = function invm(num) {
    return this.egcd(num).a.umod(num);
};
BN.prototype.isEven = function isEven() {
    return (this.words[0] & 1) === 0;
};
BN.prototype.isOdd = function isOdd() {
    return (this.words[0] & 1) === 1;
};
BN.prototype.andln = function andln(num) {
    return this.words[0] & num;
};
BN.prototype.bincn = function bincn(bit) {
    assert6(typeof bit === "number");
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;
    if (this.length <= s) {
        this._expand(s + 1);
        this.words[s] |= q;
        return this;
    }
    var carry = q;
    for(var i = s; carry !== 0 && i < this.length; i++){
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 0x3ffffff;
        this.words[i] = w;
    }
    if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
    }
    return this;
};
BN.prototype.isZero = function isZero() {
    return this.length === 1 && this.words[0] === 0;
};
BN.prototype.cmpn = function cmpn(num) {
    var negative = num < 0;
    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;
    this._strip();
    var res;
    if (this.length > 1) {
        res = 1;
    } else {
        if (negative) {
            num = -num;
        }
        assert6(num <= 0x3ffffff, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
};
BN.prototype.cmp = function cmp(num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;
    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
};
BN.prototype.ucmp = function ucmp(num) {
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;
    var res = 0;
    for(var i = this.length - 1; i >= 0; i--){
        var a = this.words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b) continue;
        if (a < b) {
            res = -1;
        } else if (a > b) {
            res = 1;
        }
        break;
    }
    return res;
};
BN.prototype.gtn = function gtn(num) {
    return this.cmpn(num) === 1;
};
BN.prototype.gt = function gt(num) {
    return this.cmp(num) === 1;
};
BN.prototype.gten = function gten(num) {
    return this.cmpn(num) >= 0;
};
BN.prototype.gte = function gte(num) {
    return this.cmp(num) >= 0;
};
BN.prototype.ltn = function ltn(num) {
    return this.cmpn(num) === -1;
};
BN.prototype.lt = function lt(num) {
    return this.cmp(num) === -1;
};
BN.prototype.lten = function lten(num) {
    return this.cmpn(num) <= 0;
};
BN.prototype.lte = function lte(num) {
    return this.cmp(num) <= 0;
};
BN.prototype.eqn = function eqn(num) {
    return this.cmpn(num) === 0;
};
BN.prototype.eq = function eq(num) {
    return this.cmp(num) === 0;
};
BN.red = function red(num) {
    return new Red(num);
};
BN.prototype.toRed = function toRed(ctx) {
    assert6(!this.red, "Already a number in reduction context");
    assert6(this.negative === 0, "red works only with positives");
    return ctx.convertTo(this)._forceRed(ctx);
};
BN.prototype.fromRed = function fromRed() {
    assert6(this.red, "fromRed works only with numbers in reduction context");
    return this.red.convertFrom(this);
};
BN.prototype._forceRed = function _forceRed(ctx) {
    this.red = ctx;
    return this;
};
BN.prototype.forceRed = function forceRed(ctx) {
    assert6(!this.red, "Already a number in reduction context");
    return this._forceRed(ctx);
};
BN.prototype.redAdd = function redAdd(num) {
    assert6(this.red, "redAdd works only with red numbers");
    return this.red.add(this, num);
};
BN.prototype.redIAdd = function redIAdd(num) {
    assert6(this.red, "redIAdd works only with red numbers");
    return this.red.iadd(this, num);
};
BN.prototype.redSub = function redSub(num) {
    assert6(this.red, "redSub works only with red numbers");
    return this.red.sub(this, num);
};
BN.prototype.redISub = function redISub(num) {
    assert6(this.red, "redISub works only with red numbers");
    return this.red.isub(this, num);
};
BN.prototype.redShl = function redShl(num) {
    assert6(this.red, "redShl works only with red numbers");
    return this.red.shl(this, num);
};
BN.prototype.redMul = function redMul(num) {
    assert6(this.red, "redMul works only with red numbers");
    this.red._verify2(this, num);
    return this.red.mul(this, num);
};
BN.prototype.redIMul = function redIMul(num) {
    assert6(this.red, "redMul works only with red numbers");
    this.red._verify2(this, num);
    return this.red.imul(this, num);
};
BN.prototype.redSqr = function redSqr() {
    assert6(this.red, "redSqr works only with red numbers");
    this.red._verify1(this);
    return this.red.sqr(this);
};
BN.prototype.redISqr = function redISqr() {
    assert6(this.red, "redISqr works only with red numbers");
    this.red._verify1(this);
    return this.red.isqr(this);
};
BN.prototype.redSqrt = function redSqrt() {
    assert6(this.red, "redSqrt works only with red numbers");
    this.red._verify1(this);
    return this.red.sqrt(this);
};
BN.prototype.redInvm = function redInvm() {
    assert6(this.red, "redInvm works only with red numbers");
    this.red._verify1(this);
    return this.red.invm(this);
};
BN.prototype.redNeg = function redNeg() {
    assert6(this.red, "redNeg works only with red numbers");
    this.red._verify1(this);
    return this.red.neg(this);
};
BN.prototype.redPow = function redPow(num) {
    assert6(this.red && !num.red, "redPow(normalNum)");
    this.red._verify1(this);
    return this.red.pow(this, num);
};
var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
};
function MPrime(name, p) {
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);
    this.tmp = this._tmp();
}
MPrime.prototype._tmp = function _tmp() {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
};
MPrime.prototype.ireduce = function ireduce(num) {
    var r = num;
    var rlen;
    do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
    }while (rlen > this.n)
    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
    } else if (cmp > 0) {
        r.isub(this.p);
    } else {
        if (r.strip !== undefined) {
            r.strip();
        } else {
            r._strip();
        }
    }
    return r;
};
MPrime.prototype.split = function split(input, out) {
    input.iushrn(this.n, 0, out);
};
MPrime.prototype.imulK = function imulK(num) {
    return num.imul(this.k);
};
function K256() {
    MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
}
inherits1(K256, MPrime);
K256.prototype.split = function split(input, output) {
    var mask = 0x3fffff;
    var outLen = Math.min(input.length, 9);
    for(var i = 0; i < outLen; i++){
        output.words[i] = input.words[i];
    }
    output.length = outLen;
    if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
    }
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;
    for(i = 10; i < input.length; i++){
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
        input.length -= 10;
    } else {
        input.length -= 9;
    }
};
K256.prototype.imulK = function imulK(num) {
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;
    var lo = 0;
    for(var i = 0; i < num.length; i++){
        var w = num.words[i] | 0;
        lo += w * 0x3d1;
        num.words[i] = lo & 0x3ffffff;
        lo = w * 0x40 + (lo / 0x4000000 | 0);
    }
    if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
            num.length--;
        }
    }
    return num;
};
function P224() {
    MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
}
inherits1(P224, MPrime);
function P192() {
    MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
}
inherits1(P192, MPrime);
function P25519() {
    MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
}
inherits1(P25519, MPrime);
P25519.prototype.imulK = function imulK(num) {
    var carry = 0;
    for(var i = 0; i < num.length; i++){
        var hi = (num.words[i] | 0) * 0x13 + carry;
        var lo = hi & 0x3ffffff;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
    }
    if (carry !== 0) {
        num.words[num.length++] = carry;
    }
    return num;
};
BN._prime = function prime(name) {
    if (primes[name]) return primes[name];
    var prime;
    if (name === "k256") {
        prime = new K256();
    } else if (name === "p224") {
        prime = new P224();
    } else if (name === "p192") {
        prime = new P192();
    } else if (name === "p25519") {
        prime = new P25519();
    } else {
        throw new Error("Unknown prime " + name);
    }
    primes[name] = prime;
    return prime;
};
function Red(m) {
    if (typeof m === "string") {
        var prime = BN._prime(m);
        this.m = prime.p;
        this.prime = prime;
    } else {
        assert6(m.gtn(1), "modulus must be greater than 1");
        this.m = m;
        this.prime = null;
    }
}
Red.prototype._verify1 = function _verify1(a) {
    assert6(a.negative === 0, "red works only with positives");
    assert6(a.red, "red works only with red numbers");
};
Red.prototype._verify2 = function _verify2(a, b) {
    assert6((a.negative | b.negative) === 0, "red works only with positives");
    assert6(a.red && a.red === b.red, "red works only with red numbers");
};
Red.prototype.imod = function imod(a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    move(a, a.umod(this.m)._forceRed(this));
    return a;
};
Red.prototype.neg = function neg(a) {
    if (a.isZero()) {
        return a.clone();
    }
    return this.m.sub(a)._forceRed(this);
};
Red.prototype.add = function add(a, b) {
    this._verify2(a, b);
    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
    }
    return res._forceRed(this);
};
Red.prototype.iadd = function iadd(a, b) {
    this._verify2(a, b);
    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
    }
    return res;
};
Red.prototype.sub = function sub(a, b) {
    this._verify2(a, b);
    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
        res.iadd(this.m);
    }
    return res._forceRed(this);
};
Red.prototype.isub = function isub(a, b) {
    this._verify2(a, b);
    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
        res.iadd(this.m);
    }
    return res;
};
Red.prototype.shl = function shl(a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
};
Red.prototype.imul = function imul(a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
};
Red.prototype.mul = function mul(a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
};
Red.prototype.isqr = function isqr(a) {
    return this.imul(a, a.clone());
};
Red.prototype.sqr = function sqr(a) {
    return this.mul(a, a);
};
Red.prototype.sqrt = function sqrt(a) {
    if (a.isZero()) return a.clone();
    var mod3 = this.m.andln(3);
    assert6(mod3 % 2 === 1);
    if (mod3 === 3) {
        var pow = this.m.add(new BN(1)).iushrn(2);
        return this.pow(a, pow);
    }
    var q = this.m.subn(1);
    var s = 0;
    while(!q.isZero() && q.andln(1) === 0){
        s++;
        q.iushrn(1);
    }
    assert6(!q.isZero());
    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);
    while(this.pow(z, lpow).cmp(nOne) !== 0){
        z.redIAdd(nOne);
    }
    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while(t.cmp(one) !== 0){
        var tmp = t;
        for(var i = 0; tmp.cmp(one) !== 0; i++){
            tmp = tmp.redSqr();
        }
        assert6(i < m);
        var b = this.pow(c, new BN(1).iushln(m - i - 1));
        r = r.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
    }
    return r;
};
Red.prototype.invm = function invm(a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
    } else {
        return this.imod(inv);
    }
};
Red.prototype.pow = function pow(a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();
    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for(var i = 2; i < wnd.length; i++){
        wnd[i] = this.mul(wnd[i - 1], a);
    }
    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
        start = 26;
    }
    for(i = num.length - 1; i >= 0; i--){
        var word = num.words[i];
        for(var j = start - 1; j >= 0; j--){
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
                res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
        }
        start = 26;
    }
    return res;
};
Red.prototype.convertTo = function convertTo(num) {
    var r = num.umod(this.m);
    return r === num ? r.clone() : r;
};
Red.prototype.convertFrom = function convertFrom(num) {
    var res = num.clone();
    res.red = null;
    return res;
};
BN.mont = function mont(num) {
    return new Mont(num);
};
function Mont(m) {
    Red.call(this, m);
    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
    }
    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);
    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
}
inherits1(Mont, Red);
Mont.prototype.convertTo = function convertTo(num) {
    return this.imod(num.ushln(this.shift));
};
Mont.prototype.convertFrom = function convertFrom(num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
};
Mont.prototype.imul = function imul(a, b) {
    if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
    }
    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
    }
    return res._forceRed(this);
};
Mont.prototype.mul = function mul(a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
    }
    return res._forceRed(this);
};
Mont.prototype.invm = function invm(a) {
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
};
function Reporter(options) {
    this._reporterState = {
        obj: null,
        path: [],
        options: options || {},
        errors: []
    };
}
Reporter.prototype.isError = function isError(obj) {
    return obj instanceof ReporterError;
};
Reporter.prototype.save = function save() {
    const state = this._reporterState;
    return {
        obj: state.obj,
        pathLen: state.path.length
    };
};
Reporter.prototype.restore = function restore(data) {
    const state = this._reporterState;
    state.obj = data.obj;
    state.path = state.path.slice(0, data.pathLen);
};
Reporter.prototype.enterKey = function enterKey(key) {
    return this._reporterState.path.push(key);
};
Reporter.prototype.exitKey = function exitKey(index) {
    const state = this._reporterState;
    state.path = state.path.slice(0, index - 1);
};
Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
    const state = this._reporterState;
    this.exitKey(index);
    if (state.obj !== null) {
        state.obj[key] = value;
    }
};
Reporter.prototype.path = function path() {
    return this._reporterState.path.join("/");
};
Reporter.prototype.enterObject = function enterObject() {
    const state = this._reporterState;
    const prev = state.obj;
    state.obj = {};
    return prev;
};
Reporter.prototype.leaveObject = function leaveObject(prev) {
    const state = this._reporterState;
    const now = state.obj;
    state.obj = prev;
    return now;
};
Reporter.prototype.error = function error(msg) {
    let err;
    const state = this._reporterState;
    const inherited = msg instanceof ReporterError;
    if (inherited) {
        err = msg;
    } else {
        err = new ReporterError(state.path.map(function(elem) {
            return "[" + JSON.stringify(elem) + "]";
        }).join(""), msg.message || msg, msg.stack);
    }
    if (!state.options.partial) {
        throw err;
    }
    if (!inherited) {
        state.errors.push(err);
    }
    return err;
};
Reporter.prototype.wrapResult = function wrapResult(result) {
    const state = this._reporterState;
    if (!state.options.partial) {
        return result;
    }
    return {
        result: this.isError(result) ? null : result,
        errors: state.errors
    };
};
function ReporterError(path, msg) {
    this.path = path;
    this.rethrow(msg);
}
ReporterError.prototype = Object.create(Error.prototype, {
    constructor: {
        value: ReporterError,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
ReporterError.prototype.rethrow = function rethrow(msg) {
    this.message = msg + " at: " + (this.path || "(shallow)");
    if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ReporterError);
    }
    if (!this.stack) {
        try {
            throw new Error(this.message);
        } catch (e) {
            this.stack = e.stack;
        }
    }
    return this;
};
function DecoderBuffer(base, options) {
    Reporter.call(this, options);
    if (!Buffer1.isBuffer(base)) {
        this.error("Input not Buffer");
        return;
    }
    this.base = base;
    this.offset = 0;
    this.length = base.length;
}
DecoderBuffer.prototype = Object.create(Reporter.prototype, {
    constructor: {
        value: DecoderBuffer,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
    if (data instanceof DecoderBuffer) {
        return true;
    }
    const isCompatible = typeof data === "object" && Buffer1.isBuffer(data.base) && data.constructor.name === "DecoderBuffer" && typeof data.offset === "number" && typeof data.length === "number" && typeof data.save === "function" && typeof data.restore === "function" && typeof data.isEmpty === "function" && typeof data.readUInt8 === "function" && typeof data.skip === "function" && typeof data.raw === "function";
    return isCompatible;
};
DecoderBuffer.prototype.save = function save() {
    return {
        offset: this.offset,
        reporter: Reporter.prototype.save.call(this)
    };
};
DecoderBuffer.prototype.restore = function restore(save) {
    const res = new DecoderBuffer(this.base);
    res.offset = save.offset;
    res.length = this.offset;
    this.offset = save.offset;
    Reporter.prototype.restore.call(this, save.reporter);
    return res;
};
DecoderBuffer.prototype.isEmpty = function isEmpty() {
    return this.offset === this.length;
};
DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
    if (this.offset + 1 <= this.length) {
        return this.base.readUInt8(this.offset++, true);
    } else {
        return this.error(fail || "DecoderBuffer overrun");
    }
};
DecoderBuffer.prototype.skip = function skip(bytes, fail) {
    if (!(this.offset + bytes <= this.length)) {
        return this.error(fail || "DecoderBuffer overrun");
    }
    const res = new DecoderBuffer(this.base);
    res._reporterState = this._reporterState;
    res.offset = this.offset;
    res.length = this.offset + bytes;
    this.offset += bytes;
    return res;
};
DecoderBuffer.prototype.raw = function raw(save) {
    return this.base.slice(save ? save.offset : this.offset, this.length);
};
function EncoderBuffer(value, reporter) {
    if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function(item) {
            if (!EncoderBuffer.isEncoderBuffer(item)) {
                item = new EncoderBuffer(item, reporter);
            }
            this.length += item.length;
            return item;
        }, this);
    } else if (typeof value === "number") {
        if (!(0 <= value && value <= 0xff)) {
            return reporter.error("non-byte EncoderBuffer value");
        }
        this.value = value;
        this.length = 1;
    } else if (typeof value === "string") {
        this.value = value;
        this.length = Buffer1.byteLength(value);
    } else if (Buffer1.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
    } else {
        return reporter.error("Unsupported type: " + typeof value);
    }
}
EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
    if (data instanceof EncoderBuffer) {
        return true;
    }
    const isCompatible = typeof data === "object" && data.constructor.name === "EncoderBuffer" && typeof data.length === "number" && typeof data.join === "function";
    return isCompatible;
};
EncoderBuffer.prototype.join = function join(out, offset) {
    if (!out) {
        out = Buffer1.alloc(this.length);
    }
    if (!offset) {
        offset = 0;
    }
    if (this.length === 0) {
        return out;
    }
    if (Array.isArray(this.value)) {
        this.value.forEach(function(item) {
            item.join(out, offset);
            offset += item.length;
        });
    } else {
        if (typeof this.value === "number") {
            out[offset] = this.value;
        } else if (typeof this.value === "string") {
            out.write(this.value, offset);
        } else if (Buffer1.isBuffer(this.value)) {
            this.value.copy(out, offset);
        }
        offset += this.length;
    }
    return out;
};
const tags = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
];
const methods = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
].concat(tags);
const overrided = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
];
function Node(enc, parent, name) {
    const state = {};
    this._baseState = state;
    state.name = name;
    state.enc = enc;
    state.parent = parent || null;
    state.children = null;
    state.tag = null;
    state.args = null;
    state.reverseArgs = null;
    state.choice = null;
    state.optional = false;
    state.any = false;
    state.obj = false;
    state.use = null;
    state.useDecoder = null;
    state.key = null;
    state["default"] = null;
    state.explicit = null;
    state.implicit = null;
    state.contains = null;
    if (!state.parent) {
        state.children = [];
        this._wrap();
    }
}
const stateProps = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
];
Node.prototype.clone = function clone() {
    const state = this._baseState;
    const cstate = {};
    stateProps.forEach(function(prop) {
        cstate[prop] = state[prop];
    });
    const res = new this.constructor(cstate.parent);
    res._baseState = cstate;
    return res;
};
Node.prototype._wrap = function wrap() {
    const state = this._baseState;
    methods.forEach(function(method) {
        this[method] = function _wrappedMethod() {
            const clone = new this.constructor(this);
            state.children.push(clone);
            return clone[method].apply(clone, arguments);
        };
    }, this);
};
Node.prototype._init = function init(body) {
    const state = this._baseState;
    assert(state.parent === null);
    body.call(this);
    state.children = state.children.filter(function(child) {
        return child._baseState.parent === this;
    }, this);
    assert(state.children.length === 1, "Root node can have only one child");
};
Node.prototype._useArgs = function useArgs(args) {
    const state = this._baseState;
    const children = args.filter(function(arg) {
        return arg instanceof this.constructor;
    }, this);
    args = args.filter(function(arg) {
        return !(arg instanceof this.constructor);
    }, this);
    if (children.length !== 0) {
        assert(state.children === null);
        state.children = children;
        children.forEach(function(child) {
            child._baseState.parent = this;
        }, this);
    }
    if (args.length !== 0) {
        assert(state.args === null);
        state.args = args;
        state.reverseArgs = args.map(function(arg) {
            if (typeof arg !== "object" || arg.constructor !== Object) {
                return arg;
            }
            const res = {};
            Object.keys(arg).forEach(function(key) {
                if (key == (key | 0)) {
                    key |= 0;
                }
                const value = arg[key];
                res[value] = key;
            });
            return res;
        });
    }
};
overrided.forEach(function(method) {
    Node.prototype[method] = function _overrided() {
        const state = this._baseState;
        throw new Error(method + " not implemented for encoding: " + state.enc);
    };
});
tags.forEach(function(tag) {
    Node.prototype[tag] = function _tagMethod() {
        const state = this._baseState;
        const args = Array.prototype.slice.call(arguments);
        assert(state.tag === null);
        state.tag = tag;
        this._useArgs(args);
        return this;
    };
});
Node.prototype.use = function use(item) {
    assert(item);
    const state = this._baseState;
    assert(state.use === null);
    state.use = item;
    return this;
};
Node.prototype.optional = function optional() {
    const state = this._baseState;
    state.optional = true;
    return this;
};
Node.prototype.def = function def(val) {
    const state = this._baseState;
    assert(state["default"] === null);
    state["default"] = val;
    state.optional = true;
    return this;
};
Node.prototype.explicit = function explicit(num) {
    const state = this._baseState;
    assert(state.explicit === null && state.implicit === null);
    state.explicit = num;
    return this;
};
Node.prototype.implicit = function implicit(num) {
    const state = this._baseState;
    assert(state.explicit === null && state.implicit === null);
    state.implicit = num;
    return this;
};
Node.prototype.obj = function obj() {
    const state = this._baseState;
    const args = Array.prototype.slice.call(arguments);
    state.obj = true;
    if (args.length !== 0) {
        this._useArgs(args);
    }
    return this;
};
Node.prototype.key = function key(newKey) {
    const state = this._baseState;
    assert(state.key === null);
    state.key = newKey;
    return this;
};
Node.prototype.any = function any() {
    const state = this._baseState;
    state.any = true;
    return this;
};
Node.prototype.choice = function choice(obj) {
    const state = this._baseState;
    assert(state.choice === null);
    state.choice = obj;
    this._useArgs(Object.keys(obj).map(function(key) {
        return obj[key];
    }));
    return this;
};
Node.prototype.contains = function contains(item) {
    const state = this._baseState;
    assert(state.use === null);
    state.contains = item;
    return this;
};
Node.prototype._decode = function decode(input, options) {
    const state = this._baseState;
    if (state.parent === null) {
        return input.wrapResult(state.children[0]._decode(input, options));
    }
    let result = state["default"];
    let present = true;
    let prevKey = null;
    if (state.key !== null) {
        prevKey = input.enterKey(state.key);
    }
    if (state.optional) {
        let tag = null;
        if (state.explicit !== null) {
            tag = state.explicit;
        } else if (state.implicit !== null) {
            tag = state.implicit;
        } else if (state.tag !== null) {
            tag = state.tag;
        }
        if (tag === null && !state.any) {
            const save = input.save();
            try {
                if (state.choice === null) {
                    this._decodeGeneric(state.tag, input, options);
                } else {
                    this._decodeChoice(input, options);
                }
                present = true;
            } catch (_e) {
                present = false;
            }
            input.restore(save);
        } else {
            present = this._peekTag(input, tag, state.any);
            if (input.isError(present)) {
                return present;
            }
        }
    }
    let prevObj;
    if (state.obj && present) {
        prevObj = input.enterObject();
    }
    if (present) {
        if (state.explicit !== null) {
            const explicit = this._decodeTag(input, state.explicit);
            if (input.isError(explicit)) {
                return explicit;
            }
            input = explicit;
        }
        const start = input.offset;
        if (state.use === null && state.choice === null) {
            let save;
            if (state.any) {
                save = input.save();
            }
            const body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
            if (input.isError(body)) {
                return body;
            }
            if (state.any) {
                result = input.raw(save);
            } else {
                input = body;
            }
        }
        if (options && options.track && state.tag !== null) {
            options.track(input.path(), start, input.length, "tagged");
        }
        if (options && options.track && state.tag !== null) {
            options.track(input.path(), input.offset, input.length, "content");
        }
        if (state.any) {} else if (state.choice === null) {
            result = this._decodeGeneric(state.tag, input, options);
        } else {
            result = this._decodeChoice(input, options);
        }
        if (input.isError(result)) {
            return result;
        }
        if (!state.any && state.choice === null && state.children !== null) {
            state.children.forEach(function decodeChildren(child) {
                child._decode(input, options);
            });
        }
        if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
            const data = new DecoderBuffer(result);
            result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
        }
    }
    if (state.obj && present) {
        result = input.leaveObject(prevObj);
    }
    if (state.key !== null && (result !== null || present === true)) {
        input.leaveKey(prevKey, state.key, result);
    } else if (prevKey !== null) {
        input.exitKey(prevKey);
    }
    return result;
};
Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
    const state = this._baseState;
    if (tag === "seq" || tag === "set") {
        return null;
    }
    if (tag === "seqof" || tag === "setof") {
        return this._decodeList(input, tag, state.args[0], options);
    } else if (/str$/.test(tag)) {
        return this._decodeStr(input, tag, options);
    } else if (tag === "objid" && state.args) {
        return this._decodeObjid(input, state.args[0], state.args[1], options);
    } else if (tag === "objid") {
        return this._decodeObjid(input, null, null, options);
    } else if (tag === "gentime" || tag === "utctime") {
        return this._decodeTime(input, tag, options);
    } else if (tag === "null_") {
        return this._decodeNull(input, options);
    } else if (tag === "bool") {
        return this._decodeBool(input, options);
    } else if (tag === "objDesc") {
        return this._decodeStr(input, tag, options);
    } else if (tag === "int" || tag === "enum") {
        return this._decodeInt(input, state.args && state.args[0], options);
    }
    if (state.use !== null) {
        return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
    } else {
        return input.error("unknown tag: " + tag);
    }
};
Node.prototype._getUse = function _getUse(entity, obj) {
    const state = this._baseState;
    state.useDecoder = this._use(entity, obj);
    assert(state.useDecoder._baseState.parent === null);
    state.useDecoder = state.useDecoder._baseState.children[0];
    if (state.implicit !== state.useDecoder._baseState.implicit) {
        state.useDecoder = state.useDecoder.clone();
        state.useDecoder._baseState.implicit = state.implicit;
    }
    return state.useDecoder;
};
Node.prototype._decodeChoice = function decodeChoice(input, options) {
    const state = this._baseState;
    let result = null;
    let match = false;
    Object.keys(state.choice).some(function(key) {
        const save = input.save();
        const node = state.choice[key];
        try {
            const value = node._decode(input, options);
            if (input.isError(value)) {
                return false;
            }
            result = {
                type: key,
                value: value
            };
            match = true;
        } catch (_e) {
            input.restore(save);
            return false;
        }
        return true;
    }, this);
    if (!match) {
        return input.error("Choice not matched");
    }
    return result;
};
Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
    return new EncoderBuffer(data, this.reporter);
};
Node.prototype._encode = function encode(data, reporter, parent) {
    const state = this._baseState;
    if (state["default"] !== null && state["default"] === data) {
        return;
    }
    const result = this._encodeValue(data, reporter, parent);
    if (result === undefined) {
        return;
    }
    if (this._skipDefault(result, reporter, parent)) {
        return;
    }
    return result;
};
Node.prototype._encodeValue = function encode(data, reporter, parent) {
    const state = this._baseState;
    if (state.parent === null) {
        return state.children[0]._encode(data, reporter || new Reporter());
    }
    let result = null;
    this.reporter = reporter;
    if (state.optional && data === undefined) {
        if (state["default"] !== null) {
            data = state["default"];
        } else {
            return;
        }
    }
    let content = null;
    let primitive = false;
    if (state.any) {
        result = this._createEncoderBuffer(data);
    } else if (state.choice) {
        result = this._encodeChoice(data, reporter);
    } else if (state.contains) {
        content = this._getUse(state.contains, parent)._encode(data, reporter);
        primitive = true;
    } else if (state.children) {
        content = state.children.map(function(child) {
            if (child._baseState.tag === "null_") {
                return child._encode(null, reporter, data);
            }
            if (child._baseState.key === null) {
                return reporter.error("Child should have a key");
            }
            const prevKey = reporter.enterKey(child._baseState.key);
            if (typeof data !== "object") {
                return reporter.error("Child expected, but input is not object");
            }
            const res = child._encode(data[child._baseState.key], reporter, data);
            reporter.leaveKey(prevKey);
            return res;
        }, this).filter(function(child) {
            return child;
        });
        content = this._createEncoderBuffer(content);
    } else {
        if (state.tag === "seqof" || state.tag === "setof") {
            if (!(state.args && state.args.length === 1)) {
                return reporter.error("Too many args for : " + state.tag);
            }
            if (!Array.isArray(data)) {
                return reporter.error("seqof/setof, but data is not Array");
            }
            const child = this.clone();
            child._baseState.implicit = null;
            content = this._createEncoderBuffer(data.map(function(item) {
                const state = this._baseState;
                return this._getUse(state.args[0], data)._encode(item, reporter);
            }, child));
        } else if (state.use !== null) {
            result = this._getUse(state.use, parent)._encode(data, reporter);
        } else {
            content = this._encodePrimitive(state.tag, data);
            primitive = true;
        }
    }
    if (!state.any && state.choice === null) {
        const tag = state.implicit !== null ? state.implicit : state.tag;
        const cls = state.implicit === null ? "universal" : "context";
        if (tag === null) {
            if (state.use === null) {
                reporter.error("Tag could be omitted only for .use()");
            }
        } else {
            if (state.use === null) {
                result = this._encodeComposite(tag, primitive, cls, content);
            }
        }
    }
    if (state.explicit !== null) {
        result = this._encodeComposite(state.explicit, false, "context", result);
    }
    return result;
};
Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
    const state = this._baseState;
    const node = state.choice[data.type];
    if (!node) {
        assert(false, data.type + " not found in " + JSON.stringify(Object.keys(state.choice)));
    }
    return node._encode(data.value, reporter);
};
Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
    const state = this._baseState;
    if (/str$/.test(tag)) {
        return this._encodeStr(data, tag);
    } else if (tag === "objid" && state.args) {
        return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
    } else if (tag === "objid") {
        return this._encodeObjid(data, null, null);
    } else if (tag === "gentime" || tag === "utctime") {
        return this._encodeTime(data, tag);
    } else if (tag === "null_") {
        return this._encodeNull();
    } else if (tag === "int" || tag === "enum") {
        return this._encodeInt(data, state.args && state.reverseArgs[0]);
    } else if (tag === "bool") {
        return this._encodeBool(data);
    } else if (tag === "objDesc") {
        return this._encodeStr(data, tag);
    } else {
        throw new Error("Unsupported tag: " + tag);
    }
};
Node.prototype._isNumstr = function isNumstr(str) {
    return /^[0-9 ]*$/.test(str);
};
Node.prototype._isPrintstr = function isPrintstr(str) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
};
function reverse2(map) {
    const res = {};
    Object.keys(map).forEach(function(key) {
        if ((key | 0) == key) {
            key = key | 0;
        }
        const value = map[key];
        res[value] = key;
    });
    return res;
}
const tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
};
const tagClassByName = reverse2(tagClass);
const tag = {
    0x00: "end",
    0x01: "bool",
    0x02: "int",
    0x03: "bitstr",
    0x04: "octstr",
    0x05: "null_",
    0x06: "objid",
    0x07: "objDesc",
    0x08: "external",
    0x09: "real",
    0x0a: "enum",
    0x0b: "embed",
    0x0c: "utf8str",
    0x0d: "relativeOid",
    0x10: "seq",
    0x11: "set",
    0x12: "numstr",
    0x13: "printstr",
    0x14: "t61str",
    0x15: "videostr",
    0x16: "ia5str",
    0x17: "utctime",
    0x18: "gentime",
    0x19: "graphstr",
    0x1a: "iso646str",
    0x1b: "genstr",
    0x1c: "unistr",
    0x1d: "charstr",
    0x1e: "bmpstr"
};
const tagByName = reverse2(tag);
const mod61 = {
    tagClass: tagClass,
    tagClassByName: tagClassByName,
    tag: tag,
    tagByName: tagByName
};
function DEREncoder(entity) {
    this.enc = "der";
    this.name = entity.name;
    this.entity = entity;
    this.tree = new DERNode();
    this.tree._init(entity.body);
}
DEREncoder.prototype.encode = function encode(data, reporter) {
    return this.tree._encode(data, reporter).join();
};
function DERNode(parent) {
    Node.call(this, "der", parent);
}
DERNode.prototype = Object.create(Node.prototype, {
    constructor: {
        value: DERNode,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
    const encodedTag = encodeTag(tag, primitive, cls, this.reporter);
    if (content.length < 0x80) {
        const header = Buffer1.alloc(2);
        header[0] = encodedTag;
        header[1] = content.length;
        return this._createEncoderBuffer([
            header,
            content
        ]);
    }
    let lenOctets = 1;
    for(let i = content.length; i >= 0x100; i >>= 8){
        lenOctets++;
    }
    const header = Buffer1.alloc(1 + 1 + lenOctets);
    header[0] = encodedTag;
    header[1] = 0x80 | lenOctets;
    for(let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8){
        header[i] = j & 0xff;
    }
    return this._createEncoderBuffer([
        header,
        content
    ]);
};
DERNode.prototype._encodeStr = function encodeStr(str, tag) {
    if (tag === "bitstr") {
        return this._createEncoderBuffer([
            str.unused | 0,
            str.data
        ]);
    } else if (tag === "bmpstr") {
        const buf = Buffer1.alloc(str.length * 2);
        for(let i = 0; i < str.length; i++){
            buf.writeUInt16BE(str.charCodeAt(i), i * 2);
        }
        return this._createEncoderBuffer(buf);
    } else if (tag === "numstr") {
        if (!this._isNumstr(str)) {
            return this.reporter.error("Encoding of string type: numstr supports " + "only digits and space");
        }
        return this._createEncoderBuffer(str);
    } else if (tag === "printstr") {
        if (!this._isPrintstr(str)) {
            return this.reporter.error("Encoding of string type: printstr supports " + "only latin upper and lower case letters, " + "digits, space, apostrophe, left and rigth " + "parenthesis, plus sign, comma, hyphen, " + "dot, slash, colon, equal sign, " + "question mark");
        }
        return this._createEncoderBuffer(str);
    } else if (/str$/.test(tag)) {
        return this._createEncoderBuffer(str);
    } else if (tag === "objDesc") {
        return this._createEncoderBuffer(str);
    } else {
        return this.reporter.error("Encoding of string type: " + tag + " unsupported");
    }
};
DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
    if (typeof id === "string") {
        if (!values) {
            return this.reporter.error("string objid given, but no values map found");
        }
        if (!values.hasOwnProperty(id)) {
            return this.reporter.error("objid not found in values map");
        }
        id = values[id].split(/[\s.]+/g);
        for(let i = 0; i < id.length; i++){
            id[i] |= 0;
        }
    } else if (Array.isArray(id)) {
        id = id.slice();
        for(let i = 0; i < id.length; i++){
            id[i] |= 0;
        }
    }
    if (!Array.isArray(id)) {
        return this.reporter.error("objid() should be either array or string, " + "got: " + JSON.stringify(id));
    }
    if (!relative) {
        if (id[1] >= 40) {
            return this.reporter.error("Second objid identifier OOB");
        }
        id.splice(0, 2, id[0] * 40 + id[1]);
    }
    let size = 0;
    for(let i = 0; i < id.length; i++){
        let ident = id[i];
        for(size++; ident >= 0x80; ident >>= 7){
            size++;
        }
    }
    const objid = Buffer1.alloc(size);
    let offset = objid.length - 1;
    for(let i = id.length - 1; i >= 0; i--){
        let ident = id[i];
        objid[offset--] = ident & 0x7f;
        while((ident >>= 7) > 0){
            objid[offset--] = 0x80 | ident & 0x7f;
        }
    }
    return this._createEncoderBuffer(objid);
};
function two(num) {
    if (num < 10) {
        return "0" + num;
    } else {
        return num;
    }
}
DERNode.prototype._encodeTime = function encodeTime(time, tag) {
    let str;
    const date = new Date(time);
    if (tag === "gentime") {
        str = [
            two(date.getUTCFullYear()),
            two(date.getUTCMonth() + 1),
            two(date.getUTCDate()),
            two(date.getUTCHours()),
            two(date.getUTCMinutes()),
            two(date.getUTCSeconds()),
            "Z"
        ].join("");
    } else if (tag === "utctime") {
        str = [
            two(date.getUTCFullYear() % 100),
            two(date.getUTCMonth() + 1),
            two(date.getUTCDate()),
            two(date.getUTCHours()),
            two(date.getUTCMinutes()),
            two(date.getUTCSeconds()),
            "Z"
        ].join("");
    } else {
        this.reporter.error("Encoding " + tag + " time is not supported yet");
    }
    return this._encodeStr(str, "octstr");
};
DERNode.prototype._encodeNull = function encodeNull() {
    return this._createEncoderBuffer("");
};
DERNode.prototype._encodeInt = function encodeInt(num, values) {
    if (typeof num === "string") {
        if (!values) {
            return this.reporter.error("String int or enum given, but no values map");
        }
        if (!values.hasOwnProperty(num)) {
            return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
        }
        num = values[num];
    }
    if (typeof num !== "number" && !Buffer1.isBuffer(num)) {
        const numArray = num.toArray();
        if (!num.sign && numArray[0] & 0x80) {
            numArray.unshift(0);
        }
        num = Buffer1.from(numArray);
    }
    if (Buffer1.isBuffer(num)) {
        let size = num.length;
        if (num.length === 0) {
            size++;
        }
        const out = Buffer1.alloc(size);
        num.copy(out);
        if (num.length === 0) {
            out[0] = 0;
        }
        return this._createEncoderBuffer(out);
    }
    if (num < 0x80) {
        return this._createEncoderBuffer(num);
    }
    if (num < 0x100) {
        return this._createEncoderBuffer([
            0,
            num
        ]);
    }
    let size = 1;
    for(let i = num; i >= 0x100; i >>= 8){
        size++;
    }
    const out = new Array(size);
    for(let i = out.length - 1; i >= 0; i--){
        out[i] = num & 0xff;
        num >>= 8;
    }
    if (out[0] & 0x80) {
        out.unshift(0);
    }
    return this._createEncoderBuffer(Buffer1.from(out));
};
DERNode.prototype._encodeBool = function encodeBool(value) {
    return this._createEncoderBuffer(value ? 0xff : 0);
};
DERNode.prototype._use = function use(entity, obj) {
    if (typeof entity === "function") {
        entity = entity(obj);
    }
    return entity._getEncoder("der").tree;
};
DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
    const state = this._baseState;
    let i;
    if (state["default"] === null) {
        return false;
    }
    const data = dataBuffer.join();
    if (state.defaultBuffer === undefined) {
        state.defaultBuffer = this._encodeValue(state["default"], reporter, parent).join();
    }
    if (data.length !== state.defaultBuffer.length) {
        return false;
    }
    for(i = 0; i < data.length; i++){
        if (data[i] !== state.defaultBuffer[i]) {
            return false;
        }
    }
    return true;
};
function encodeTag(tag, primitive, cls, reporter) {
    let res;
    if (tag === "seqof") {
        tag = "seq";
    } else if (tag === "setof") {
        tag = "set";
    }
    if (tagByName.hasOwnProperty(tag)) {
        res = tagByName[tag];
    } else if (typeof tag === "number" && (tag | 0) === tag) {
        res = tag;
    } else {
        return reporter.error("Unknown tag: " + tag);
    }
    if (res >= 0x1f) {
        return reporter.error("Multi-octet tag encoding unsupported");
    }
    if (!primitive) {
        res |= 0x20;
    }
    res |= tagClassByName[cls || "universal"] << 6;
    return res;
}
function PEMEncoder(entity) {
    DEREncoder.call(this, entity);
    this.enc = "pem";
}
PEMEncoder.prototype = Object.create(DEREncoder.prototype, {
    constructor: {
        value: PEMEncoder,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
PEMEncoder.prototype.encode = function encode(data, options) {
    const buf = DEREncoder.prototype.encode.call(this, data);
    const p = buf.toString("base64");
    const out = [
        "-----BEGIN " + options.label + "-----"
    ];
    for(let i = 0; i < p.length; i += 64){
        out.push(p.slice(i, i + 64));
    }
    out.push("-----END " + options.label + "-----");
    return out.join("\n");
};
function DERDecoder(entity) {
    this.enc = "der";
    this.name = entity.name;
    this.entity = entity;
    this.tree = new DERNode1();
    this.tree._init(entity.body);
}
DERDecoder.prototype.decode = function decode(data, options) {
    if (!DecoderBuffer.isDecoderBuffer(data)) {
        data = new DecoderBuffer(data, options);
    }
    return this.tree._decode(data, options);
};
function DERNode1(parent) {
    Node.call(this, "der", parent);
}
DERNode1.prototype = Object.create(Node.prototype, {
    constructor: {
        value: DERNode1,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
DERNode1.prototype._peekTag = function peekTag(buffer, tag, any) {
    if (buffer.isEmpty()) {
        return false;
    }
    const state = buffer.save();
    const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
    if (buffer.isError(decodedTag)) {
        return decodedTag;
    }
    buffer.restore(state);
    return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any;
};
DERNode1.prototype._decodeTag = function decodeTag(buffer, tag, any) {
    const decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
    if (buffer.isError(decodedTag)) {
        return decodedTag;
    }
    let len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"');
    if (buffer.isError(len)) {
        return len;
    }
    if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
        return buffer.error('Failed to match tag: "' + tag + '"');
    }
    if (decodedTag.primitive || len !== null) {
        return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
    }
    const state = buffer.save();
    const res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
    if (buffer.isError(res)) {
        return res;
    }
    len = buffer.offset - state.offset;
    buffer.restore(state);
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};
DERNode1.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
    for(;;){
        const tag = derDecodeTag(buffer, fail);
        if (buffer.isError(tag)) {
            return tag;
        }
        const len = derDecodeLen(buffer, tag.primitive, fail);
        if (buffer.isError(len)) {
            return len;
        }
        let res;
        if (tag.primitive || len !== null) {
            res = buffer.skip(len);
        } else {
            res = this._skipUntilEnd(buffer, fail);
        }
        if (buffer.isError(res)) {
            return res;
        }
        if (tag.tagStr === "end") {
            break;
        }
    }
};
DERNode1.prototype._decodeList = function decodeList(buffer, _tag, decoder, options) {
    const result = [];
    while(!buffer.isEmpty()){
        const possibleEnd = this._peekTag(buffer, "end");
        if (buffer.isError(possibleEnd)) {
            return possibleEnd;
        }
        const res = decoder.decode(buffer, "der", options);
        if (buffer.isError(res) && possibleEnd) {
            break;
        }
        result.push(res);
    }
    return result;
};
DERNode1.prototype._decodeStr = function decodeStr(buffer, tag) {
    if (tag === "bitstr") {
        const unused = buffer.readUInt8();
        if (buffer.isError(unused)) {
            return unused;
        }
        return {
            unused: unused,
            data: buffer.raw()
        };
    } else if (tag === "bmpstr") {
        const raw = buffer.raw();
        if (raw.length % 2 === 1) {
            return buffer.error("Decoding of string type: bmpstr length mismatch");
        }
        let str = "";
        for(let i = 0; i < raw.length / 2; i++){
            str += String.fromCharCode(raw.readUInt16BE(i * 2));
        }
        return str;
    } else if (tag === "numstr") {
        const numstr = buffer.raw().toString("ascii");
        if (!this._isNumstr(numstr)) {
            return buffer.error("Decoding of string type: " + "numstr unsupported characters");
        }
        return numstr;
    } else if (tag === "octstr") {
        return buffer.raw();
    } else if (tag === "objDesc") {
        return buffer.raw();
    } else if (tag === "printstr") {
        const printstr = buffer.raw().toString("ascii");
        if (!this._isPrintstr(printstr)) {
            return buffer.error("Decoding of string type: " + "printstr unsupported characters");
        }
        return printstr;
    } else if (/str$/.test(tag)) {
        return buffer.raw().toString();
    } else {
        return buffer.error("Decoding of string type: " + tag + " unsupported");
    }
};
DERNode1.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
    let result;
    const identifiers = [];
    let ident = 0;
    let subident = 0;
    while(!buffer.isEmpty()){
        subident = buffer.readUInt8();
        ident <<= 7;
        ident |= subident & 0x7f;
        if ((subident & 0x80) === 0) {
            identifiers.push(ident);
            ident = 0;
        }
    }
    if (subident & 0x80) {
        identifiers.push(ident);
    }
    const first = identifiers[0] / 40 | 0;
    const second = identifiers[0] % 40;
    if (relative) {
        result = identifiers;
    } else {
        result = [
            first,
            second
        ].concat(identifiers.slice(1));
    }
    if (values) {
        let tmp = values[result.join(" ")];
        if (tmp === undefined) {
            tmp = values[result.join(".")];
        }
        if (tmp !== undefined) {
            result = tmp;
        }
    }
    return result;
};
DERNode1.prototype._decodeTime = function decodeTime(buffer, tag) {
    const str = buffer.raw().toString();
    let year;
    let mon;
    let day;
    let hour;
    let min;
    let sec;
    if (tag === "gentime") {
        year = str.slice(0, 4) | 0;
        mon = str.slice(4, 6) | 0;
        day = str.slice(6, 8) | 0;
        hour = str.slice(8, 10) | 0;
        min = str.slice(10, 12) | 0;
        sec = str.slice(12, 14) | 0;
    } else if (tag === "utctime") {
        year = str.slice(0, 2) | 0;
        mon = str.slice(2, 4) | 0;
        day = str.slice(4, 6) | 0;
        hour = str.slice(6, 8) | 0;
        min = str.slice(8, 10) | 0;
        sec = str.slice(10, 12) | 0;
        if (year < 70) {
            year = 2000 + year;
        } else {
            year = 1900 + year;
        }
    } else {
        return buffer.error("Decoding " + tag + " time is not supported yet");
    }
    return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};
DERNode1.prototype._decodeNull = function decodeNull() {
    return null;
};
DERNode1.prototype._decodeBool = function decodeBool(buffer) {
    const res = buffer.readUInt8();
    if (buffer.isError(res)) {
        return res;
    } else {
        return res !== 0;
    }
};
DERNode1.prototype._decodeInt = function decodeInt(buffer, values) {
    const raw = buffer.raw();
    let res = new BN(raw);
    if (values) {
        res = values[res.toString(10)] || res;
    }
    return res;
};
DERNode1.prototype._use = function use(entity, obj) {
    if (typeof entity === "function") {
        entity = entity(obj);
    }
    return entity._getDecoder("der").tree;
};
function derDecodeTag(buf, fail) {
    let tag1 = buf.readUInt8(fail);
    if (buf.isError(tag1)) {
        return tag1;
    }
    const cls = tagClass[tag1 >> 6];
    const primitive = (tag1 & 0x20) === 0;
    if ((tag1 & 0x1f) === 0x1f) {
        let oct = tag1;
        tag1 = 0;
        while((oct & 0x80) === 0x80){
            oct = buf.readUInt8(fail);
            if (buf.isError(oct)) {
                return oct;
            }
            tag1 <<= 7;
            tag1 |= oct & 0x7f;
        }
    } else {
        tag1 &= 0x1f;
    }
    const tagStr = tag[tag1];
    return {
        cls: cls,
        primitive: primitive,
        tag: tag1,
        tagStr: tagStr
    };
}
function derDecodeLen(buf, primitive, fail) {
    let len = buf.readUInt8(fail);
    if (buf.isError(len)) {
        return len;
    }
    if (!primitive && len === 0x80) {
        return null;
    }
    if ((len & 0x80) === 0) {
        return len;
    }
    const num = len & 0x7f;
    if (num > 4) {
        return buf.error("length octect is too long");
    }
    len = 0;
    for(let i = 0; i < num; i++){
        len <<= 8;
        const j = buf.readUInt8(fail);
        if (buf.isError(j)) {
            return j;
        }
        len |= j;
    }
    return len;
}
function PEMDecoder(entity) {
    DERDecoder.call(this, entity);
    this.enc = "pem";
}
PEMDecoder.prototype = Object.create(DERDecoder.prototype, {
    constructor: {
        value: PEMDecoder,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
PEMDecoder.prototype.decode = function decode(data, options) {
    const lines = data.toString().split(/[\r\n]+/g);
    const label = options.label.toUpperCase();
    const re = /^-----(BEGIN|END) ([^-]+)-----$/;
    let start = -1;
    let end = -1;
    for(let i = 0; i < lines.length; i++){
        const match = lines[i].match(re);
        if (match === null) {
            continue;
        }
        if (match[2] !== label) {
            continue;
        }
        if (start === -1) {
            if (match[1] !== "BEGIN") {
                break;
            }
            start = i;
        } else {
            if (match[1] !== "END") {
                break;
            }
            end = i;
            break;
        }
    }
    if (start === -1 || end === -1) {
        throw new Error("PEM section not found for: " + label);
    }
    const base64 = lines.slice(start + 1, end).join("");
    base64.replace(/[^a-z0-9+/=]+/gi, "");
    const input = Buffer1.from(base64, "base64");
    return DERDecoder.prototype.decode.call(this, input, options);
};
const base1 = {
    DecoderBuffer,
    EncoderBuffer,
    Node,
    Reporter
};
const encoders = {
    der: DEREncoder,
    pem: PEMEncoder
};
const decoders = {
    der: DERDecoder,
    pem: PEMDecoder
};
const constants6 = {
    der: mod61
};
function define(name, body) {
    return new Entity(name, body);
}
function Entity(name, body) {
    this.name = name;
    this.body = body;
    this.decoders = {};
    this.encoders = {};
}
Entity.prototype._createNamed = function createNamed(Base) {
    const name = this.name;
    function Generated(entity) {
        this._initNamed(entity, name);
    }
    Generated.prototype = Object.create(Base.prototype, {
        constructor: {
            value: Generated,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    Generated.prototype._initNamed = function _initNamed(entity, name) {
        Base.call(this, entity, name);
    };
    return new Generated(this);
};
Entity.prototype._getDecoder = function _getDecoder(enc) {
    enc = enc || "der";
    if (!this.decoders.hasOwnProperty(enc)) {
        this.decoders[enc] = this._createNamed(decoders[enc]);
    }
    return this.decoders[enc];
};
Entity.prototype.decode = function decode(data, enc, options) {
    return this._getDecoder(enc).decode(data, options);
};
Entity.prototype._getEncoder = function _getEncoder(enc) {
    enc = enc || "der";
    if (!this.encoders.hasOwnProperty(enc)) {
        this.encoders[enc] = this._createNamed(encoders[enc]);
    }
    return this.encoders[enc];
};
Entity.prototype.encode = function encode(data, enc, reporter) {
    return this._getEncoder(enc).encode(data, reporter);
};
const __default45 = {
    base: base1,
    bignum: BN,
    constants: constants6,
    decoders,
    define,
    encoders
};
const Time = define("Time", function() {
    this.choice({
        utcTime: this.utctime(),
        generalTime: this.gentime()
    });
});
const AttributeTypeValue = define("AttributeTypeValue", function() {
    this.seq().obj(this.key("type").objid(), this.key("value").any());
});
const AlgorithmIdentifier = define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
});
const SubjectPublicKeyInfo = define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
});
const RelativeDistinguishedName = define("RelativeDistinguishedName", function() {
    this.setof(AttributeTypeValue);
});
const RDNSequence = define("RDNSequence", function() {
    this.seqof(RelativeDistinguishedName);
});
const Name = define("Name", function() {
    this.choice({
        rdnSequence: this.use(RDNSequence)
    });
});
const Validity = define("Validity", function() {
    this.seq().obj(this.key("notBefore").use(Time), this.key("notAfter").use(Time));
});
const Extension = define("Extension", function() {
    this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
});
const TBSCertificate = define("TBSCertificate", function() {
    this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(AlgorithmIdentifier), this.key("issuer").use(Name), this.key("validity").use(Validity), this.key("subject").use(Name), this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(Extension).optional());
});
const X509Certificate = define("X509Certificate", function() {
    this.seq().obj(this.key("tbsCertificate").use(TBSCertificate), this.key("signatureAlgorithm").use(AlgorithmIdentifier), this.key("signatureValue").bitstr());
});
const RSAPrivateKey = __default45.define("RSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
});
const RSAPublicKey = __default45.define("RSAPublicKey", function() {
    this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
});
const PublicKey = __default45.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier1), this.key("subjectPublicKey").bitstr());
});
const AlgorithmIdentifier1 = __default45.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
});
const PrivateKey = __default45.define("PrivateKeyInfo", function() {
    this.seq().obj(this.key("version").int(), this.key("algorithm").use(AlgorithmIdentifier1), this.key("subjectPrivateKey").octstr());
});
const EncryptedPrivateKey = __default45.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
});
const DSAPrivateKey = __default45.define("DSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
});
const DSAparam = __default45.define("DSAparam", function() {
    this.int();
});
const ECPrivateKey = __default45.define("ECPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ECParameters), this.key("publicKey").optional().explicit(1).bitstr());
});
const ECParameters = __default45.define("ECParameters", function() {
    this.choice({
        namedCurve: this.objid()
    });
});
const signature = __default45.define("signature", function() {
    this.seq().obj(this.key("r").int(), this.key("s").int());
});
const findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
const startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
const fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
function __default46(okey, password) {
    const key = okey.toString();
    const match = key.match(findProc);
    let decrypted;
    if (!match) {
        const match2 = key.match(fullRegex);
        decrypted = Buffer1.from(match2[2].replace(/[\r\n]/g, ""), "base64");
    } else {
        const suite = "aes" + match[1];
        const iv = Buffer1.from(match[2], "hex");
        const cipherText = Buffer1.from(match[3].replace(/[\r\n]/g, ""), "base64");
        const cipherKey = EVP_BytesToKey(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
        const out = [];
        const cipher = createDecipheriv(suite, cipherKey, iv);
        out.push(cipher.update(cipherText));
        out.push(cipher.final());
        decrypted = Buffer1.concat(out);
    }
    const tag = key.match(startRegex)[1];
    return {
        tag: tag,
        data: decrypted
    };
}
const aesid = {
    "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
    "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
    "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
    "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
    "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
    "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
    "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
    "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
    "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
    "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
    "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
    "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
function parseKeys(buffer) {
    let password;
    if (typeof buffer === "object" && !Buffer1.isBuffer(buffer)) {
        password = buffer.passphrase;
        buffer = buffer.key;
    }
    if (typeof buffer === "string") {
        buffer = Buffer1.from(buffer);
    }
    const stripped = __default46(buffer, password);
    const type = stripped.tag;
    let data = stripped.data;
    let subtype, ndata;
    switch(type){
        case "CERTIFICATE":
            ndata = X509Certificate.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
            if (!ndata) {
                ndata = PublicKey.decode(data, "der");
            }
            subtype = ndata.algorithm.algorithm.join(".");
            switch(subtype){
                case "1.2.840.113549.1.1.1":
                    return RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
                case "1.2.840.10045.2.1":
                    ndata.subjectPrivateKey = ndata.subjectPublicKey;
                    return {
                        type: "ec",
                        data: ndata
                    };
                case "1.2.840.10040.4.1":
                    ndata.algorithm.params.pub_key = DSAparam.decode(ndata.subjectPublicKey.data, "der");
                    return {
                        type: "dsa",
                        data: ndata.algorithm.params
                    };
                default:
                    throw new Error("unknown key id " + subtype);
            }
        case "ENCRYPTED PRIVATE KEY":
            data = EncryptedPrivateKey.decode(data, "der");
            data = decrypt2(data, password);
        case "PRIVATE KEY":
            ndata = PrivateKey.decode(data, "der");
            subtype = ndata.algorithm.algorithm.join(".");
            switch(subtype){
                case "1.2.840.113549.1.1.1":
                    return RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
                case "1.2.840.10045.2.1":
                    return {
                        curve: ndata.algorithm.curve,
                        privateKey: ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
                    };
                case "1.2.840.10040.4.1":
                    ndata.algorithm.params.priv_key = DSAparam.decode(ndata.subjectPrivateKey, "der");
                    return {
                        type: "dsa",
                        params: ndata.algorithm.params
                    };
                default:
                    throw new Error("unknown key id " + subtype);
            }
        case "RSA PUBLIC KEY":
            return RSAPublicKey.decode(data, "der");
        case "RSA PRIVATE KEY":
            return RSAPrivateKey.decode(data, "der");
        case "DSA PRIVATE KEY":
            return {
                type: "dsa",
                params: DSAPrivateKey.decode(data, "der")
            };
        case "EC PRIVATE KEY":
            data = ECPrivateKey.decode(data, "der");
            return {
                curve: data.parameters.value,
                privateKey: data.privateKey
            };
        default:
            throw new Error("unknown key type " + type);
    }
}
parseKeys.signature = signature;
function decrypt2(data, password) {
    const salt = data.algorithm.decrypt.kde.kdeparams.salt;
    const iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
    const algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")];
    const iv = data.algorithm.decrypt.cipher.iv;
    const cipherText = data.subjectPrivateKey;
    const keylen = parseInt(algo.split("-")[1], 10) / 8;
    const key = pbkdf2Sync(password, salt, iters, keylen, "sha1");
    const cipher = createDecipheriv(algo, key, iv);
    const out = [];
    out.push(cipher.update(cipherText));
    out.push(cipher.final());
    return Buffer1.concat(out);
}
const MAX_BYTES = 65536;
function randomBytes1(size, cb) {
    if (size > 4294967295) {
        throw new RangeError("requested too many random bytes");
    }
    const bytes = Buffer1.allocUnsafe(size);
    if (size > 0) {
        if (size > 65536) {
            for(let generated = 0; generated < size; generated += MAX_BYTES){
                globalThis.crypto.getRandomValues(bytes.slice(generated, generated + 65536));
            }
        } else {
            globalThis.crypto.getRandomValues(bytes);
        }
    }
    if (typeof cb === "function") {
        return nextTick1(function() {
            cb(null, bytes);
        });
    }
    return bytes;
}
function __default47(seed, len) {
    let t = Buffer1.alloc(0);
    let i = 0;
    let c;
    while(t.length < len){
        c = i2ops(i++);
        t = Buffer1.concat([
            t,
            createHash("sha1").update(seed).update(c).digest()
        ]);
    }
    return t.slice(0, len);
}
function i2ops(c) {
    const out = Buffer1.allocUnsafe(4);
    out.writeUInt32BE(c, 0);
    return out;
}
function xor1(a, b) {
    const len = a.length;
    let i = -1;
    while(++i < len){
        a[i] ^= b[i];
    }
    return a;
}
function withPublic(paddedMsg, key) {
    return Buffer1.from(paddedMsg.toRed(BN.mont(key.modulus)).redPow(new BN(key.publicExponent)).fromRed().toArray());
}
function blind(priv) {
    const r = getr(priv);
    const blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
    return {
        blinder: blinder,
        unblinder: r.invm(priv.modulus)
    };
}
function getr(priv) {
    const len = priv.modulus.byteLength();
    let r;
    do {
        r = new BN(randomBytes1(len));
    }while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2))
    return r;
}
function crt(msg, priv) {
    const blinds = blind(priv);
    const len = priv.modulus.byteLength();
    const blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
    const c1 = blinded.toRed(BN.mont(priv.prime1));
    const c2 = blinded.toRed(BN.mont(priv.prime2));
    const qinv = priv.coefficient;
    const p = priv.prime1;
    const q = priv.prime2;
    const m1 = c1.redPow(priv.exponent1).fromRed();
    const m2 = c2.redPow(priv.exponent2).fromRed();
    const h = m1.isub(m2).imul(qinv).umod(p).imul(q);
    return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer1, "be", len);
}
crt.getr = getr;
function publicEncrypt(publicKey, msg, reverse) {
    let padding;
    if (publicKey.padding) {
        padding = publicKey.padding;
    } else if (reverse) {
        padding = 1;
    } else {
        padding = 4;
    }
    const key = parseKeys(publicKey);
    let paddedMsg;
    if (padding === 4) {
        paddedMsg = oaep(key, msg);
    } else if (padding === 1) {
        paddedMsg = pkcs1(key, msg, reverse);
    } else if (padding === 3) {
        paddedMsg = new BN(msg);
        if (paddedMsg.cmp(key.modulus) >= 0) {
            throw new Error("data too long for modulus");
        }
    } else {
        throw new Error("unknown padding");
    }
    if (reverse) {
        return crt(paddedMsg, key);
    } else {
        return withPublic(paddedMsg, key);
    }
}
function oaep(key, msg) {
    const k = key.modulus.byteLength();
    const mLen = msg.length;
    const iHash = createHash("sha1").update(Buffer1.alloc(0)).digest();
    const hLen = iHash.length;
    const hLen2 = 2 * hLen;
    if (mLen > k - hLen2 - 2) {
        throw new Error("message too long");
    }
    const ps = Buffer1.alloc(k - mLen - hLen2 - 2);
    const dblen = k - hLen - 1;
    const seed = randomBytes1(hLen);
    const maskedDb = xor1(Buffer1.concat([
        iHash,
        ps,
        Buffer1.alloc(1, 1),
        msg
    ], dblen), __default47(seed, dblen));
    const maskedSeed = xor1(seed, __default47(maskedDb, hLen));
    return new BN(Buffer1.concat([
        Buffer1.alloc(1),
        maskedSeed,
        maskedDb
    ], k));
}
function pkcs1(key, msg, reverse) {
    const mLen = msg.length;
    const k = key.modulus.byteLength();
    if (mLen > k - 11) {
        throw new Error("message too long");
    }
    let ps;
    if (reverse) {
        ps = Buffer1.alloc(k - mLen - 3, 0xff);
    } else {
        ps = nonZero(k - mLen - 3);
    }
    return new BN(Buffer1.concat([
        Buffer1.from([
            0,
            reverse ? 1 : 2
        ]),
        ps,
        Buffer1.alloc(1),
        msg
    ], k));
}
function nonZero(len) {
    const out = Buffer1.allocUnsafe(len);
    let i = 0;
    let cache = randomBytes1(len * 2);
    let cur = 0;
    let num;
    while(i < len){
        if (cur === cache.length) {
            cache = randomBytes1(len * 2);
            cur = 0;
        }
        num = cache[cur++];
        if (num) {
            out[i++] = num;
        }
    }
    return out;
}
function privateDecrypt(privateKey, enc, reverse) {
    let padding;
    if (privateKey.padding) {
        padding = privateKey.padding;
    } else if (reverse) {
        padding = 1;
    } else {
        padding = 4;
    }
    const key = parseKeys(privateKey);
    const k = key.modulus.byteLength();
    if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
        throw new Error("decryption error");
    }
    let msg;
    if (reverse) {
        msg = withPublic(new BN(enc), key);
    } else {
        msg = crt(enc, key);
    }
    const zBuffer = Buffer1.alloc(k - msg.length);
    msg = Buffer1.concat([
        zBuffer,
        msg
    ], k);
    if (padding === 4) {
        return oaep1(key, msg);
    } else if (padding === 1) {
        return pkcs11(key, msg, reverse);
    } else if (padding === 3) {
        return msg;
    } else {
        throw new Error("unknown padding");
    }
}
function oaep1(key, msg) {
    const k = key.modulus.byteLength();
    const iHash = createHash("sha1").update(Buffer1.alloc(0)).digest();
    const hLen = iHash.length;
    if (msg[0] !== 0) {
        throw new Error("decryption error");
    }
    const maskedSeed = msg.slice(1, hLen + 1);
    const maskedDb = msg.slice(hLen + 1);
    const seed = xor1(maskedSeed, __default47(maskedDb, hLen));
    const db = xor1(maskedDb, __default47(seed, k - hLen - 1));
    if (compare(iHash, db.slice(0, hLen))) {
        throw new Error("decryption error");
    }
    let i = hLen;
    while(db[i] === 0){
        i++;
    }
    if (db[i++] !== 1) {
        throw new Error("decryption error");
    }
    return db.slice(i);
}
function pkcs11(_key, msg, reverse) {
    const p1 = msg.slice(0, 2);
    let i = 2;
    let status = 0;
    while(msg[i++] !== 0){
        if (i >= msg.length) {
            status++;
            break;
        }
    }
    const ps = msg.slice(2, i - 1);
    if (p1.toString("hex") !== "0002" && !reverse || p1.toString("hex") !== "0001" && reverse) {
        status++;
    }
    if (ps.length < 8) {
        status++;
    }
    if (status) {
        throw new Error("decryption error");
    }
    return msg.slice(i);
}
function compare(a, b) {
    a = Buffer1.from(a);
    b = Buffer1.from(b);
    let dif = 0;
    let len = a.length;
    if (a.length !== b.length) {
        dif++;
        len = Math.min(a.length, b.length);
    }
    let i = -1;
    while(++i < len){
        dif += a[i] ^ b[i];
    }
    return dif;
}
function privateEncrypt(key, buf) {
    return publicEncrypt(key, buf, true);
}
function publicDecrypt(key, buf) {
    return privateDecrypt(key, buf, true);
}
class Cipheriv extends Iu {
    constructor(_cipher, _key, _iv, _options){
        super();
        notImplemented("crypto.Cipheriv");
    }
    final(_outputEncoding) {
        notImplemented("crypto.Cipheriv.prototype.final");
    }
    getAuthTag() {
        notImplemented("crypto.Cipheriv.prototype.getAuthTag");
    }
    setAAD(_buffer, _options) {
        notImplemented("crypto.Cipheriv.prototype.setAAD");
    }
    setAutoPadding(_autoPadding) {
        notImplemented("crypto.Cipheriv.prototype.setAutoPadding");
    }
    update(_data, _inputEncoding, _outputEncoding) {
        notImplemented("crypto.Cipheriv.prototype.update");
    }
}
class Decipheriv extends Iu {
    constructor(_cipher, _key, _iv, _options){
        super();
        notImplemented("crypto.Decipheriv");
    }
    final(_outputEncoding) {
        notImplemented("crypto.Decipheriv.prototype.final");
    }
    setAAD(_buffer, _options) {
        notImplemented("crypto.Decipheriv.prototype.setAAD");
    }
    setAuthTag(_buffer, _encoding) {
        notImplemented("crypto.Decipheriv.prototype.setAuthTag");
    }
    setAutoPadding(_autoPadding) {
        notImplemented("crypto.Decipheriv.prototype.setAutoPadding");
    }
    update(_data, _inputEncoding, _outputEncoding) {
        notImplemented("crypto.Decipheriv.prototype.update");
    }
}
function getCipherInfo(nameOrNid, options) {
    if (typeof nameOrNid !== "string" && typeof nameOrNid !== "number") {
        throw new ERR_INVALID_ARG_TYPE("nameOrNid", [
            "string",
            "number"
        ], nameOrNid);
    }
    if (typeof nameOrNid === "number") {
        validateInt32(nameOrNid, "nameOrNid");
    }
    let keyLength, ivLength;
    if (options !== undefined) {
        validateObject(options, "options");
        ({ keyLength , ivLength  } = options);
        if (keyLength !== undefined) {
            validateInt32(keyLength, "options.keyLength");
        }
        if (ivLength !== undefined) {
            validateInt32(ivLength, "options.ivLength");
        }
    }
    notImplemented("crypto.getCipherInfo");
}
const __default48 = {
    privateDecrypt,
    privateEncrypt,
    publicDecrypt,
    publicEncrypt,
    Cipheriv,
    Decipheriv,
    getCipherInfo
};
class Sign extends mu {
    constructor(algorithm, _options){
        validateString(algorithm, "algorithm");
        super();
        notImplemented("crypto.Sign");
    }
    sign(_privateKey, _outputEncoding) {
        notImplemented("crypto.Sign.prototype.sign");
    }
    update(_data, _inputEncoding) {
        notImplemented("crypto.Sign.prototype.update");
    }
}
class Verify extends mu {
    constructor(algorithm, _options){
        validateString(algorithm, "algorithm");
        super();
        notImplemented("crypto.Verify");
    }
    update(_data, _inputEncoding) {
        notImplemented("crypto.Sign.prototype.update");
    }
    verify(_object, _signature, _signatureEncoding) {
        notImplemented("crypto.Sign.prototype.sign");
    }
}
function signOneShot(_algorithm, _data, _key, _callback) {
    notImplemented("crypto.sign");
}
function verifyOneShot(_algorithm, _data, _key, _signature, _callback) {
    notImplemented("crypto.verify");
}
const __default49 = {
    signOneShot,
    verifyOneShot,
    Sign,
    Verify
};
class X509Certificate1 {
    constructor(buffer){
        if (typeof buffer === "string") {
            buffer = Buffer1.from(buffer);
        }
        if (!isArrayBufferView(buffer)) {
            throw new ERR_INVALID_ARG_TYPE("buffer", [
                "string",
                "Buffer",
                "TypedArray",
                "DataView"
            ], buffer);
        }
        notImplemented("crypto.X509Certificate");
    }
    get ca() {
        notImplemented("crypto.X509Certificate.prototype.ca");
        return false;
    }
    checkEmail(_email, _options) {
        notImplemented("crypto.X509Certificate.prototype.checkEmail");
    }
    checkHost(_name, _options) {
        notImplemented("crypto.X509Certificate.prototype.checkHost");
    }
    checkIP(_ip) {
        notImplemented("crypto.X509Certificate.prototype.checkIP");
    }
    checkIssued(_otherCert) {
        notImplemented("crypto.X509Certificate.prototype.checkIssued");
    }
    checkPrivateKey(_privateKey) {
        notImplemented("crypto.X509Certificate.prototype.checkPrivateKey");
    }
    get fingerprint() {
        notImplemented("crypto.X509Certificate.prototype.fingerprint");
        return "";
    }
    get fingerprint256() {
        notImplemented("crypto.X509Certificate.prototype.fingerprint256");
        return "";
    }
    get fingerprint512() {
        notImplemented("crypto.X509Certificate.prototype.fingerprint512");
        return "";
    }
    get infoAccess() {
        notImplemented("crypto.X509Certificate.prototype.infoAccess");
        return "";
    }
    get issuer() {
        notImplemented("crypto.X509Certificate.prototype.issuer");
        return "";
    }
    get issuerCertificate() {
        notImplemented("crypto.X509Certificate.prototype.issuerCertificate");
        return {};
    }
    get keyUsage() {
        notImplemented("crypto.X509Certificate.prototype.keyUsage");
        return [];
    }
    get publicKey() {
        notImplemented("crypto.X509Certificate.prototype.publicKey");
        return {};
    }
    get raw() {
        notImplemented("crypto.X509Certificate.prototype.raw");
        return {};
    }
    get serialNumber() {
        notImplemented("crypto.X509Certificate.prototype.serialNumber");
        return "";
    }
    get subject() {
        notImplemented("crypto.X509Certificate.prototype.subject");
        return "";
    }
    get subjectAltName() {
        notImplemented("crypto.X509Certificate.prototype.subjectAltName");
        return "";
    }
    toJSON() {
        return this.toString();
    }
    toLegacyObject() {
        notImplemented("crypto.X509Certificate.prototype.toLegacyObject");
    }
    toString() {
        notImplemented("crypto.X509Certificate.prototype.toString");
    }
    get validFrom() {
        notImplemented("crypto.X509Certificate.prototype.validFrom");
        return "";
    }
    get validTo() {
        notImplemented("crypto.X509Certificate.prototype.validTo");
        return "";
    }
    verify(_publicKey) {
        notImplemented("crypto.X509Certificate.prototype.verify");
    }
}
const __default50 = {
    X509Certificate: X509Certificate1
};
class Certificate {
    static Certificate = Certificate;
    static exportChallenge(_spkac, _encoding) {
        notImplemented("crypto.Certificate.exportChallenge");
    }
    static exportPublicKey(_spkac, _encoding) {
        notImplemented("crypto.Certificate.exportPublicKey");
    }
    static verifySpkac(_spkac, _encoding) {
        notImplemented("crypto.Certificate.verifySpkac");
    }
}
const webcrypto = globalThis.crypto;
const fipsForced = getOptionValue("--force-fips");
function createCipheriv(cipher, key, iv, options) {
    return new Cipheriv(cipher, key, iv, options);
}
function createDecipheriv1(algorithm, key, iv, options) {
    return new Decipheriv(algorithm, key, iv, options);
}
function createDiffieHellman(sizeOrKey, keyEncoding, generator, generatorEncoding) {
    return new DiffieHellman(sizeOrKey, keyEncoding, generator, generatorEncoding);
}
function createDiffieHellmanGroup(name) {
    return new DiffieHellmanGroup(name);
}
function createECDH(curve) {
    return new ECDH(curve);
}
function createHmac(hmac, key, options) {
    return Hmac(hmac, key, options);
}
function createSign1(algorithm, options) {
    return new Sign(algorithm, options);
}
function createVerify(algorithm, options) {
    return new Verify(algorithm, options);
}
function setFipsForced(val) {
    if (val) {
        return;
    }
    throw new ERR_CRYPTO_FIPS_FORCED();
}
function getFipsForced() {
    return 1;
}
Object.defineProperty(crypto1, "defaultCipherList", {
    value: getOptionValue("--tls-cipher-list")
});
const getDiffieHellman = createDiffieHellmanGroup;
const getFips = fipsForced ? getFipsForced : getFipsCrypto;
const setFips = fipsForced ? setFipsForced : setFipsCrypto;
const __default51 = {
    Certificate,
    checkPrime,
    checkPrimeSync,
    Cipheriv,
    constants: crypto1,
    createCipheriv,
    createDecipheriv: createDecipheriv1,
    createDiffieHellman,
    createDiffieHellmanGroup,
    createECDH,
    createHash,
    createHmac,
    createPrivateKey,
    createPublicKey,
    createSecretKey,
    createSign: createSign1,
    createVerify,
    Decipheriv,
    DiffieHellman,
    diffieHellman,
    DiffieHellmanGroup,
    ECDH,
    generateKey,
    generateKeyPair,
    generateKeyPairSync,
    generateKeySync,
    generatePrime,
    generatePrimeSync,
    getCipherInfo,
    getCiphers,
    getCurves,
    getDiffieHellman,
    getFips,
    getHashes,
    Hash,
    hkdf,
    hkdfSync,
    Hmac,
    KeyObject,
    pbkdf2,
    pbkdf2Sync,
    privateDecrypt,
    privateEncrypt,
    publicDecrypt,
    publicEncrypt,
    randomBytes,
    randomFill,
    randomFillSync,
    randomInt,
    randomUUID,
    scrypt,
    scryptSync,
    secureHeapUsed,
    setEngine,
    setFips,
    Sign,
    sign: signOneShot,
    timingSafeEqual: timingSafeEqual1,
    Verify,
    verify: verifyOneShot,
    webcrypto,
    X509Certificate: X509Certificate1
};
const kStateSymbol = Symbol("kStateSymbol");
function lookup4(lookup, address, callback) {
    return lookup(address || "127.0.0.1", 4, callback);
}
function lookup6(lookup, address, callback) {
    return lookup(address || "::1", 6, callback);
}
function newHandle(type, lookup) {
    if (lookup === undefined) {
        lookup = lookup1;
    } else {
        validateFunction(lookup, "lookup");
    }
    if (type === "udp4") {
        const handle = new UDP();
        handle.lookup = lookup4.bind(handle, lookup);
        return handle;
    }
    if (type === "udp6") {
        const handle = new UDP();
        handle.lookup = lookup6.bind(handle, lookup);
        handle.bind = handle.bind6;
        handle.connect = handle.connect6;
        handle.send = handle.send6;
        return handle;
    }
    throw new ERR_SOCKET_BAD_TYPE();
}
function _createSocketHandle(address, port, addressType, fd, flags) {
    const handle = newHandle(addressType);
    let err;
    if (isInt32(fd) && fd > 0) {
        const type = guessHandleType(fd);
        if (type !== "UDP") {
            err = codeMap.get("EINVAL");
        } else {
            err = handle.open(fd);
        }
    } else if (port || address) {
        err = handle.bind(address, port || 0, flags);
    }
    if (err) {
        handle.close();
        return err;
    }
    return handle;
}
const __default52 = {
    kStateSymbol,
    newHandle,
    _createSocketHandle
};
const { UV_UDP_REUSEADDR , UV_UDP_IPV6ONLY  } = os;
const udpSocketChannel = channel("udp.socket");
const BIND_STATE_UNBOUND = 0;
const BIND_STATE_BINDING = 1;
const BIND_STATE_BOUND = 2;
const CONNECT_STATE_DISCONNECTED = 0;
const CONNECT_STATE_CONNECTING = 1;
const CONNECT_STATE_CONNECTED = 2;
const isSocketOptions = (socketOption)=>socketOption !== null && typeof socketOption === "object";
const isUdpHandle = (handle)=>handle !== null && typeof handle === "object" && typeof handle.recvStart === "function";
const isBindOptions = (options)=>options !== null && typeof options === "object";
class Socket1 extends EventEmitter {
    [asyncIdSymbol];
    [kStateSymbol];
    type;
    constructor(type, listener){
        super();
        let lookup;
        let recvBufferSize;
        let sendBufferSize;
        let options;
        if (isSocketOptions(type)) {
            options = type;
            type = options.type;
            lookup = options.lookup;
            recvBufferSize = options.recvBufferSize;
            sendBufferSize = options.sendBufferSize;
        }
        const handle = newHandle(type, lookup);
        handle[ownerSymbol] = this;
        this[asyncIdSymbol] = handle.getAsyncId();
        this.type = type;
        if (typeof listener === "function") {
            this.on("message", listener);
        }
        this[kStateSymbol] = {
            handle,
            receiving: false,
            bindState: BIND_STATE_UNBOUND,
            connectState: CONNECT_STATE_DISCONNECTED,
            queue: undefined,
            reuseAddr: options && options.reuseAddr,
            ipv6Only: options && options.ipv6Only,
            recvBufferSize,
            sendBufferSize
        };
        if (options?.signal !== undefined) {
            const { signal  } = options;
            validateAbortSignal(signal, "options.signal");
            const onAborted = ()=>{
                this.close();
            };
            if (signal.aborted) {
                onAborted();
            } else {
                signal.addEventListener("abort", onAborted);
                this.once("close", ()=>signal.removeEventListener("abort", onAborted));
            }
        }
        if (udpSocketChannel.hasSubscribers) {
            udpSocketChannel.publish({
                socket: this
            });
        }
    }
    addMembership(multicastAddress, interfaceAddress) {
        healthCheck(this);
        if (!multicastAddress) {
            throw new ERR_MISSING_ARGS("multicastAddress");
        }
        const { handle  } = this[kStateSymbol];
        const err = handle.addMembership(multicastAddress, interfaceAddress);
        if (err) {
            throw errnoException(err, "addMembership");
        }
    }
    addSourceSpecificMembership(sourceAddress, groupAddress, interfaceAddress) {
        healthCheck(this);
        validateString(sourceAddress, "sourceAddress");
        validateString(groupAddress, "groupAddress");
        const err = this[kStateSymbol].handle.addSourceSpecificMembership(sourceAddress, groupAddress, interfaceAddress);
        if (err) {
            throw errnoException(err, "addSourceSpecificMembership");
        }
    }
    address() {
        healthCheck(this);
        const out = {};
        const err = this[kStateSymbol].handle.getsockname(out);
        if (err) {
            throw errnoException(err, "getsockname");
        }
        return out;
    }
    bind(port_, address_) {
        let port = typeof port_ === "function" ? null : port_;
        healthCheck(this);
        const state = this[kStateSymbol];
        if (state.bindState !== 0) {
            throw new ERR_SOCKET_ALREADY_BOUND();
        }
        state.bindState = BIND_STATE_BINDING;
        const cb = arguments.length && arguments[arguments.length - 1];
        if (typeof cb === "function") {
            function removeListeners() {
                this.removeListener("error", removeListeners);
                this.removeListener("listening", onListening);
            }
            function onListening() {
                removeListeners.call(this);
                cb.call(this);
            }
            this.on("error", removeListeners);
            this.on("listening", onListening);
        }
        if (isUdpHandle(port)) {
            replaceHandle(this, port);
            startListening(this);
            return this;
        }
        if (isBindOptions(port) && isInt32(port.fd) && port.fd > 0) {
            const fd = port.fd;
            const state = this[kStateSymbol];
            const type = guessHandleType(fd);
            if (type !== "UDP") {
                throw new ERR_INVALID_FD_TYPE(type);
            }
            const err = state.handle.open(fd);
            if (err) {
                throw errnoException(err, "open");
            }
            startListening(this);
            return this;
        }
        let address;
        if (isBindOptions(port)) {
            address = port.address || "";
            port = port.port;
        } else {
            address = typeof address_ === "function" ? "" : address_;
        }
        if (!address) {
            if (this.type === "udp4") {
                address = "0.0.0.0";
            } else {
                address = "::";
            }
        }
        state.handle.lookup(address, (lookupError, ip)=>{
            if (lookupError) {
                state.bindState = BIND_STATE_UNBOUND;
                this.emit("error", lookupError);
                return;
            }
            let flags = 0;
            if (state.reuseAddr) {
                flags |= UV_UDP_REUSEADDR;
            }
            if (state.ipv6Only) {
                flags |= UV_UDP_IPV6ONLY;
            }
            if (!state.handle) {
                return;
            }
            const err = state.handle.bind(ip, port || 0, flags);
            if (err) {
                const ex = exceptionWithHostPort(err, "bind", ip, port);
                state.bindState = BIND_STATE_UNBOUND;
                this.emit("error", ex);
                return;
            }
            startListening(this);
        });
        return this;
    }
    close(callback) {
        const state = this[kStateSymbol];
        const queue = state.queue;
        if (typeof callback === "function") {
            this.on("close", callback);
        }
        if (queue !== undefined) {
            queue.push(this.close.bind(this));
            return this;
        }
        healthCheck(this);
        stopReceiving(this);
        state.handle.close();
        state.handle = null;
        defaultTriggerAsyncIdScope(this[asyncIdSymbol], nextTick1, socketCloseNT, this);
        return this;
    }
    connect(port, address, callback) {
        port = validatePort(port, "Port", false);
        if (typeof address === "function") {
            callback = address;
            address = "";
        } else if (address === undefined) {
            address = "";
        }
        validateString(address, "address");
        const state = this[kStateSymbol];
        if (state.connectState !== 0) {
            throw new ERR_SOCKET_DGRAM_IS_CONNECTED();
        }
        state.connectState = CONNECT_STATE_CONNECTING;
        if (state.bindState === 0) {
            this.bind({
                port: 0,
                exclusive: true
            });
        }
        if (state.bindState !== 2) {
            enqueue(this, _connect.bind(this, port, address, callback));
            return;
        }
        Reflect.apply(_connect, this, [
            port,
            address,
            callback
        ]);
    }
    disconnect() {
        const state = this[kStateSymbol];
        if (state.connectState !== 2) {
            throw new ERR_SOCKET_DGRAM_NOT_CONNECTED();
        }
        const err = state.handle.disconnect();
        if (err) {
            throw errnoException(err, "connect");
        } else {
            state.connectState = CONNECT_STATE_DISCONNECTED;
        }
    }
    dropMembership(multicastAddress, interfaceAddress) {
        healthCheck(this);
        if (!multicastAddress) {
            throw new ERR_MISSING_ARGS("multicastAddress");
        }
        const err = this[kStateSymbol].handle.dropMembership(multicastAddress, interfaceAddress);
        if (err) {
            throw errnoException(err, "dropMembership");
        }
    }
    dropSourceSpecificMembership(sourceAddress, groupAddress, interfaceAddress) {
        healthCheck(this);
        validateString(sourceAddress, "sourceAddress");
        validateString(groupAddress, "groupAddress");
        const err = this[kStateSymbol].handle.dropSourceSpecificMembership(sourceAddress, groupAddress, interfaceAddress);
        if (err) {
            throw errnoException(err, "dropSourceSpecificMembership");
        }
    }
    getRecvBufferSize() {
        return bufferSize(this, 0, true);
    }
    getSendBufferSize() {
        return bufferSize(this, 0, false);
    }
    ref() {
        const handle = this[kStateSymbol].handle;
        if (handle) {
            handle.ref();
        }
        return this;
    }
    remoteAddress() {
        healthCheck(this);
        const state = this[kStateSymbol];
        if (state.connectState !== 2) {
            throw new ERR_SOCKET_DGRAM_NOT_CONNECTED();
        }
        const out = {};
        const err = state.handle.getpeername(out);
        if (err) {
            throw errnoException(err, "getpeername");
        }
        return out;
    }
    send(buffer, offset, length, port, address, callback) {
        let list;
        const state = this[kStateSymbol];
        const connected = state.connectState === 2;
        if (!connected) {
            if (address || port && typeof port !== "function") {
                buffer = sliceBuffer(buffer, offset, length);
            } else {
                callback = port;
                port = offset;
                address = length;
            }
        } else {
            if (typeof length === "number") {
                buffer = sliceBuffer(buffer, offset, length);
                if (typeof port === "function") {
                    callback = port;
                    port = null;
                }
            } else {
                callback = offset;
            }
            if (port || address) {
                throw new ERR_SOCKET_DGRAM_IS_CONNECTED();
            }
        }
        if (!Array.isArray(buffer)) {
            if (typeof buffer === "string") {
                list = [
                    Buffer1.from(buffer)
                ];
            } else if (!isArrayBufferView(buffer)) {
                throw new ERR_INVALID_ARG_TYPE("buffer", [
                    "Buffer",
                    "TypedArray",
                    "DataView",
                    "string"
                ], buffer);
            } else {
                list = [
                    buffer
                ];
            }
        } else if (!(list = fixBufferList(buffer))) {
            throw new ERR_INVALID_ARG_TYPE("buffer list arguments", [
                "Buffer",
                "TypedArray",
                "DataView",
                "string"
            ], buffer);
        }
        if (!connected) {
            port = validatePort(port, "Port", false);
        }
        if (typeof callback !== "function") {
            callback = undefined;
        }
        if (typeof address === "function") {
            callback = address;
            address = undefined;
        } else if (address && typeof address !== "string") {
            throw new ERR_INVALID_ARG_TYPE("address", [
                "string",
                "falsy"
            ], address);
        }
        healthCheck(this);
        if (state.bindState === 0) {
            this.bind({
                port: 0,
                exclusive: true
            });
        }
        if (list.length === 0) {
            list.push(Buffer1.alloc(0));
        }
        if (state.bindState !== 2) {
            enqueue(this, this.send.bind(this, list, port, address, callback));
            return;
        }
        const afterDns = (ex, ip)=>{
            defaultTriggerAsyncIdScope(this[asyncIdSymbol], doSend, ex, this, ip, list, address, port, callback);
        };
        if (!connected) {
            state.handle.lookup(address, afterDns);
        } else {
            afterDns(null, "");
        }
    }
    setBroadcast(arg) {
        const err = this[kStateSymbol].handle.setBroadcast(arg ? 1 : 0);
        if (err) {
            throw errnoException(err, "setBroadcast");
        }
    }
    setMulticastInterface(interfaceAddress) {
        healthCheck(this);
        validateString(interfaceAddress, "interfaceAddress");
        const err = this[kStateSymbol].handle.setMulticastInterface(interfaceAddress);
        if (err) {
            throw errnoException(err, "setMulticastInterface");
        }
    }
    setMulticastLoopback(arg) {
        const err = this[kStateSymbol].handle.setMulticastLoopback(arg ? 1 : 0);
        if (err) {
            throw errnoException(err, "setMulticastLoopback");
        }
        return arg;
    }
    setMulticastTTL(ttl) {
        validateNumber(ttl, "ttl");
        const err = this[kStateSymbol].handle.setMulticastTTL(ttl);
        if (err) {
            throw errnoException(err, "setMulticastTTL");
        }
        return ttl;
    }
    setRecvBufferSize(size) {
        bufferSize(this, size, true);
    }
    setSendBufferSize(size) {
        bufferSize(this, size, false);
    }
    setTTL(ttl) {
        validateNumber(ttl, "ttl");
        const err = this[kStateSymbol].handle.setTTL(ttl);
        if (err) {
            throw errnoException(err, "setTTL");
        }
        return ttl;
    }
    unref() {
        const handle = this[kStateSymbol].handle;
        if (handle) {
            handle.unref();
        }
        return this;
    }
}
function createSocket(type, listener) {
    return new Socket1(type, listener);
}
function startListening(socket) {
    const state = socket[kStateSymbol];
    state.handle.onmessage = onMessage;
    state.handle.recvStart();
    state.receiving = true;
    state.bindState = BIND_STATE_BOUND;
    if (state.recvBufferSize) {
        bufferSize(socket, state.recvBufferSize, true);
    }
    if (state.sendBufferSize) {
        bufferSize(socket, state.sendBufferSize, false);
    }
    socket.emit("listening");
}
function replaceHandle(self, newHandle) {
    const state = self[kStateSymbol];
    const oldHandle = state.handle;
    newHandle.lookup = oldHandle.lookup;
    newHandle.bind = oldHandle.bind;
    newHandle.send = oldHandle.send;
    newHandle[ownerSymbol] = self;
    oldHandle.close();
    state.handle = newHandle;
}
function bufferSize(self, size, buffer) {
    if (size >>> 0 !== size) {
        throw new ERR_SOCKET_BAD_BUFFER_SIZE();
    }
    const ctx = {};
    const ret = self[kStateSymbol].handle.bufferSize(size, buffer, ctx);
    if (ret === undefined) {
        throw new ERR_SOCKET_BUFFER_SIZE(ctx);
    }
    return ret;
}
function socketCloseNT(self) {
    self.emit("close");
}
function healthCheck(socket) {
    if (!socket[kStateSymbol].handle) {
        throw new ERR_SOCKET_DGRAM_NOT_RUNNING();
    }
}
function stopReceiving(socket) {
    const state = socket[kStateSymbol];
    if (!state.receiving) {
        return;
    }
    state.handle.recvStop();
    state.receiving = false;
}
function onMessage(nread, handle, buf, rinfo) {
    const self = handle[ownerSymbol];
    if (nread < 0) {
        self.emit("error", errnoException(nread, "recvmsg"));
        return;
    }
    rinfo.size = buf.length;
    self.emit("message", buf, rinfo);
}
function sliceBuffer(buffer, offset, length) {
    if (typeof buffer === "string") {
        buffer = Buffer1.from(buffer);
    } else if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE("buffer", [
            "Buffer",
            "TypedArray",
            "DataView",
            "string"
        ], buffer);
    }
    offset = offset >>> 0;
    length = length >>> 0;
    if (offset > buffer.byteLength) {
        throw new ERR_BUFFER_OUT_OF_BOUNDS("offset");
    }
    if (offset + length > buffer.byteLength) {
        throw new ERR_BUFFER_OUT_OF_BOUNDS("length");
    }
    return Buffer1.from(buffer.buffer, buffer.byteOffset + offset, length);
}
function fixBufferList(list) {
    const newList = new Array(list.length);
    for(let i = 0, l = list.length; i < l; i++){
        const buf = list[i];
        if (typeof buf === "string") {
            newList[i] = Buffer1.from(buf);
        } else if (!isArrayBufferView(buf)) {
            return null;
        } else {
            newList[i] = Buffer1.from(buf.buffer, buf.byteOffset, buf.byteLength);
        }
    }
    return newList;
}
function enqueue(self, toEnqueue) {
    const state = self[kStateSymbol];
    if (state.queue === undefined) {
        state.queue = [];
        self.once(EventEmitter.errorMonitor, onListenError);
        self.once("listening", onListenSuccess);
    }
    state.queue.push(toEnqueue);
}
function onListenSuccess() {
    this.removeListener(EventEmitter.errorMonitor, onListenError);
    clearQueue.call(this);
}
function onListenError() {
    this.removeListener("listening", onListenSuccess);
    this[kStateSymbol].queue = undefined;
}
function clearQueue() {
    const state = this[kStateSymbol];
    const queue = state.queue;
    state.queue = undefined;
    for (const queueEntry of queue){
        queueEntry();
    }
}
function _connect(port, address, callback) {
    const state = this[kStateSymbol];
    if (callback) {
        this.once("connect", callback);
    }
    const afterDns = (ex, ip)=>{
        defaultTriggerAsyncIdScope(this[asyncIdSymbol], doConnect, ex, this, ip, address, port, callback);
    };
    state.handle.lookup(address, afterDns);
}
function doConnect(ex, self, ip, address, port, callback) {
    const state = self[kStateSymbol];
    if (!state.handle) {
        return;
    }
    if (!ex) {
        const err = state.handle.connect(ip, port);
        if (err) {
            ex = exceptionWithHostPort(err, "connect", address, port);
        }
    }
    if (ex) {
        state.connectState = CONNECT_STATE_DISCONNECTED;
        return nextTick1(()=>{
            if (callback) {
                self.removeListener("connect", callback);
                callback(ex);
            } else {
                self.emit("error", ex);
            }
        });
    }
    state.connectState = CONNECT_STATE_CONNECTED;
    nextTick1(()=>self.emit("connect"));
}
function doSend(ex, self, ip, list, address, port, callback) {
    const state = self[kStateSymbol];
    if (ex) {
        if (typeof callback === "function") {
            nextTick1(callback, ex);
            return;
        }
        nextTick1(()=>self.emit("error", ex));
        return;
    } else if (!state.handle) {
        return;
    }
    const req = new SendWrap();
    req.list = list;
    req.address = address;
    req.port = port;
    if (callback) {
        req.callback = callback;
        req.oncomplete = afterSend;
    }
    let err;
    if (port) {
        err = state.handle.send(req, list, list.length, port, ip, !!callback);
    } else {
        err = state.handle.send(req, list, list.length, !!callback);
    }
    if (err >= 1) {
        if (callback) {
            nextTick1(callback, null, err - 1);
        }
        return;
    }
    if (err && callback) {
        const ex = exceptionWithHostPort(err, "send", address, port);
        nextTick1(callback, ex);
    }
}
function afterSend(err, sent) {
    let ex;
    if (err) {
        ex = exceptionWithHostPort(err, "send", this.address, this.port);
    } else {
        ex = null;
    }
    this.callback(ex, sent);
}
const __default53 = {
    createSocket,
    Socket: Socket1
};
const { getServers: getServers2 , lookup: lookup2 , resolve: resolve11 , resolve4: resolve42 , resolve6: resolve62 , resolveAny: resolveAny2 , resolveCaa: resolveCaa2 , resolveCname: resolveCname2 , resolveMx: resolveMx2 , resolveNaptr: resolveNaptr2 , resolveNs: resolveNs2 , resolvePtr: resolvePtr2 , Resolver: Resolver3 , resolveSoa: resolveSoa2 , resolveSrv: resolveSrv2 , resolveTxt: resolveTxt2 , reverse: reverse3 , setDefaultResultOrder: setDefaultResultOrder1 , setServers: setServers1 , NODATA: NODATA1 , FORMERR: FORMERR1 , SERVFAIL: SERVFAIL1 , NOTFOUND: NOTFOUND1 , NOTIMP: NOTIMP1 , REFUSED: REFUSED1 , BADQUERY: BADQUERY1 , BADNAME: BADNAME1 , BADFAMILY: BADFAMILY1 , BADRESP: BADRESP1 , CONNREFUSED: CONNREFUSED1 , TIMEOUT: TIMEOUT1 , EOF: EOF1 , FILE: FILE1 , NOMEM: NOMEM1 , DESTRUCTION: DESTRUCTION1 , BADSTR: BADSTR1 , BADFLAGS: BADFLAGS1 , NONAME: NONAME1 , BADHINTS: BADHINTS1 , NOTINITIALIZED: NOTINITIALIZED1 , LOADIPHLPAPI: LOADIPHLPAPI1 , ADDRGETNETWORKPARAMS: ADDRGETNETWORKPARAMS1 , CANCELLED: CANCELLED1  } = promises;
function create() {
    notImplemented("domain.create");
}
class Domain {
    constructor(){
        notImplemented("domain.Domain.prototype.constructor");
    }
}
const __default54 = {
    create,
    Domain
};
promises1.access;
promises1.copyFile;
promises1.open;
promises1.opendir;
promises1.rename;
promises1.truncate;
promises1.rm;
promises1.rmdir;
promises1.mkdir;
promises1.readdir;
promises1.readlink;
promises1.symlink;
promises1.lstat;
promises1.stat;
promises1.link;
promises1.unlink;
promises1.chmod;
promises1.chown;
promises1.utimes;
promises1.realpath;
promises1.mkdtemp;
promises1.writeFile;
promises1.appendFile;
promises1.readFile;
promises1.watch;
var Status;
(function(Status) {
    Status[Status["Continue"] = 100] = "Continue";
    Status[Status["SwitchingProtocols"] = 101] = "SwitchingProtocols";
    Status[Status["Processing"] = 102] = "Processing";
    Status[Status["EarlyHints"] = 103] = "EarlyHints";
    Status[Status["OK"] = 200] = "OK";
    Status[Status["Created"] = 201] = "Created";
    Status[Status["Accepted"] = 202] = "Accepted";
    Status[Status["NonAuthoritativeInfo"] = 203] = "NonAuthoritativeInfo";
    Status[Status["NoContent"] = 204] = "NoContent";
    Status[Status["ResetContent"] = 205] = "ResetContent";
    Status[Status["PartialContent"] = 206] = "PartialContent";
    Status[Status["MultiStatus"] = 207] = "MultiStatus";
    Status[Status["AlreadyReported"] = 208] = "AlreadyReported";
    Status[Status["IMUsed"] = 226] = "IMUsed";
    Status[Status["MultipleChoices"] = 300] = "MultipleChoices";
    Status[Status["MovedPermanently"] = 301] = "MovedPermanently";
    Status[Status["Found"] = 302] = "Found";
    Status[Status["SeeOther"] = 303] = "SeeOther";
    Status[Status["NotModified"] = 304] = "NotModified";
    Status[Status["UseProxy"] = 305] = "UseProxy";
    Status[Status["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    Status[Status["PermanentRedirect"] = 308] = "PermanentRedirect";
    Status[Status["BadRequest"] = 400] = "BadRequest";
    Status[Status["Unauthorized"] = 401] = "Unauthorized";
    Status[Status["PaymentRequired"] = 402] = "PaymentRequired";
    Status[Status["Forbidden"] = 403] = "Forbidden";
    Status[Status["NotFound"] = 404] = "NotFound";
    Status[Status["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    Status[Status["NotAcceptable"] = 406] = "NotAcceptable";
    Status[Status["ProxyAuthRequired"] = 407] = "ProxyAuthRequired";
    Status[Status["RequestTimeout"] = 408] = "RequestTimeout";
    Status[Status["Conflict"] = 409] = "Conflict";
    Status[Status["Gone"] = 410] = "Gone";
    Status[Status["LengthRequired"] = 411] = "LengthRequired";
    Status[Status["PreconditionFailed"] = 412] = "PreconditionFailed";
    Status[Status["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
    Status[Status["RequestURITooLong"] = 414] = "RequestURITooLong";
    Status[Status["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
    Status[Status["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";
    Status[Status["ExpectationFailed"] = 417] = "ExpectationFailed";
    Status[Status["Teapot"] = 418] = "Teapot";
    Status[Status["MisdirectedRequest"] = 421] = "MisdirectedRequest";
    Status[Status["UnprocessableEntity"] = 422] = "UnprocessableEntity";
    Status[Status["Locked"] = 423] = "Locked";
    Status[Status["FailedDependency"] = 424] = "FailedDependency";
    Status[Status["TooEarly"] = 425] = "TooEarly";
    Status[Status["UpgradeRequired"] = 426] = "UpgradeRequired";
    Status[Status["PreconditionRequired"] = 428] = "PreconditionRequired";
    Status[Status["TooManyRequests"] = 429] = "TooManyRequests";
    Status[Status["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
    Status[Status["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
    Status[Status["InternalServerError"] = 500] = "InternalServerError";
    Status[Status["NotImplemented"] = 501] = "NotImplemented";
    Status[Status["BadGateway"] = 502] = "BadGateway";
    Status[Status["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    Status[Status["GatewayTimeout"] = 504] = "GatewayTimeout";
    Status[Status["HTTPVersionNotSupported"] = 505] = "HTTPVersionNotSupported";
    Status[Status["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
    Status[Status["InsufficientStorage"] = 507] = "InsufficientStorage";
    Status[Status["LoopDetected"] = 508] = "LoopDetected";
    Status[Status["NotExtended"] = 510] = "NotExtended";
    Status[Status["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
})(Status || (Status = {}));
({
    [Status.Accepted]: "Accepted",
    [Status.AlreadyReported]: "Already Reported",
    [Status.BadGateway]: "Bad Gateway",
    [Status.BadRequest]: "Bad Request",
    [Status.Conflict]: "Conflict",
    [Status.Continue]: "Continue",
    [Status.Created]: "Created",
    [Status.EarlyHints]: "Early Hints",
    [Status.ExpectationFailed]: "Expectation Failed",
    [Status.FailedDependency]: "Failed Dependency",
    [Status.Forbidden]: "Forbidden",
    [Status.Found]: "Found",
    [Status.GatewayTimeout]: "Gateway Timeout",
    [Status.Gone]: "Gone",
    [Status.HTTPVersionNotSupported]: "HTTP Version Not Supported",
    [Status.IMUsed]: "IM Used",
    [Status.InsufficientStorage]: "Insufficient Storage",
    [Status.InternalServerError]: "Internal Server Error",
    [Status.LengthRequired]: "Length Required",
    [Status.Locked]: "Locked",
    [Status.LoopDetected]: "Loop Detected",
    [Status.MethodNotAllowed]: "Method Not Allowed",
    [Status.MisdirectedRequest]: "Misdirected Request",
    [Status.MovedPermanently]: "Moved Permanently",
    [Status.MultiStatus]: "Multi Status",
    [Status.MultipleChoices]: "Multiple Choices",
    [Status.NetworkAuthenticationRequired]: "Network Authentication Required",
    [Status.NoContent]: "No Content",
    [Status.NonAuthoritativeInfo]: "Non Authoritative Info",
    [Status.NotAcceptable]: "Not Acceptable",
    [Status.NotExtended]: "Not Extended",
    [Status.NotFound]: "Not Found",
    [Status.NotImplemented]: "Not Implemented",
    [Status.NotModified]: "Not Modified",
    [Status.OK]: "OK",
    [Status.PartialContent]: "Partial Content",
    [Status.PaymentRequired]: "Payment Required",
    [Status.PermanentRedirect]: "Permanent Redirect",
    [Status.PreconditionFailed]: "Precondition Failed",
    [Status.PreconditionRequired]: "Precondition Required",
    [Status.Processing]: "Processing",
    [Status.ProxyAuthRequired]: "Proxy Auth Required",
    [Status.RequestEntityTooLarge]: "Request Entity Too Large",
    [Status.RequestHeaderFieldsTooLarge]: "Request Header Fields Too Large",
    [Status.RequestTimeout]: "Request Timeout",
    [Status.RequestURITooLong]: "Request URI Too Long",
    [Status.RequestedRangeNotSatisfiable]: "Requested Range Not Satisfiable",
    [Status.ResetContent]: "Reset Content",
    [Status.SeeOther]: "See Other",
    [Status.ServiceUnavailable]: "Service Unavailable",
    [Status.SwitchingProtocols]: "Switching Protocols",
    [Status.Teapot]: "I'm a teapot",
    [Status.TemporaryRedirect]: "Temporary Redirect",
    [Status.TooEarly]: "Too Early",
    [Status.TooManyRequests]: "Too Many Requests",
    [Status.Unauthorized]: "Unauthorized",
    [Status.UnavailableForLegalReasons]: "Unavailable For Legal Reasons",
    [Status.UnprocessableEntity]: "Unprocessable Entity",
    [Status.UnsupportedMediaType]: "Unsupported Media Type",
    [Status.UpgradeRequired]: "Upgrade Required",
    [Status.UseProxy]: "Use Proxy",
    [Status.VariantAlsoNegotiates]: "Variant Also Negotiates"
});
const METHODS = [
    "ACL",
    "BIND",
    "CHECKOUT",
    "CONNECT",
    "COPY",
    "DELETE",
    "GET",
    "HEAD",
    "LINK",
    "LOCK",
    "M-SEARCH",
    "MERGE",
    "MKACTIVITY",
    "MKCALENDAR",
    "MKCOL",
    "MOVE",
    "NOTIFY",
    "OPTIONS",
    "PATCH",
    "POST",
    "PROPFIND",
    "PROPPATCH",
    "PURGE",
    "PUT",
    "REBIND",
    "REPORT",
    "SEARCH",
    "SOURCE",
    "SUBSCRIBE",
    "TRACE",
    "UNBIND",
    "UNLINK",
    "UNLOCK",
    "UNSUBSCRIBE"
];
const DenoServe = Deno[Deno.internal]?.nodeUnstable?.serve || Deno.serve;
const DenoUpgradeHttpRaw = Deno[Deno.internal]?.nodeUnstable?.upgradeHttpRaw || Deno.upgradeHttpRaw;
const ENCODER = new TextEncoder();
class ClientRequest extends mu {
    defaultProtocol;
    body;
    controller;
    constructor(opts, cb){
        super();
        this.opts = opts;
        this.cb = cb;
        this.defaultProtocol = "http:";
        this.body = null;
        this.controller = null;
    }
    _write(chunk, _enc, cb) {
        if (this.controller) {
            this.controller.enqueue(chunk);
            cb();
            return;
        }
        this.body = new ReadableStream({
            start: (controller)=>{
                this.controller = controller;
                controller.enqueue(chunk);
                cb();
            }
        });
    }
    async _final() {
        if (this.controller) {
            this.controller.close();
        }
        const body = await this._createBody(this.body, this.opts);
        const client = await this._createCustomClient();
        const opts = {
            body,
            method: this.opts.method,
            client,
            headers: this.opts.headers
        };
        const mayResponse = fetch(this._createUrlStrFromOptions(this.opts), opts).catch((e)=>{
            if (e.message.includes("connection closed before message completed")) {} else {
                this.emit("error", e);
            }
            return undefined;
        });
        const res = new IncomingMessageForClient(await mayResponse, this._createSocket());
        this.emit("response", res);
        if (client) {
            res.on("end", ()=>{
                client.close();
            });
        }
        this.cb?.(res);
    }
    abort() {
        this.destroy();
    }
    async _createBody(body, opts) {
        if (!body) return null;
        if (!opts.headers) return body;
        const headers = Object.fromEntries(Object.entries(opts.headers).map(([k, v])=>[
                k.toLowerCase(),
                v
            ]));
        if (!chunkExpression.test(headers["transfer-encoding"]) && !Number.isNaN(Number.parseInt(headers["content-length"], 10))) {
            const bufferList = [];
            for await (const chunk of body){
                bufferList.push(chunk);
            }
            return Buffer1.concat(bufferList);
        }
        return body;
    }
    _createCustomClient() {
        return Promise.resolve(undefined);
    }
    _createSocket() {
        return new Socket({});
    }
    _createUrlStrFromOptions(opts) {
        if (opts.href) {
            return opts.href;
        }
        const protocol = opts.protocol ?? this.defaultProtocol;
        const auth = opts.auth;
        const host = opts.host ?? opts.hostname ?? "localhost";
        const defaultPort = opts.agent?.defaultPort;
        const port = opts.port ?? defaultPort ?? 80;
        let path = opts.path ?? "/";
        if (!path.startsWith("/")) {
            path = "/" + path;
        }
        return `${protocol}//${auth ? `${auth}@` : ""}${host}${port === 80 ? "" : `:${port}`}${path}`;
    }
    setTimeout() {
        console.log("not implemented: ClientRequest.setTimeout");
    }
    opts;
    cb;
}
class IncomingMessageForClient extends Au {
    reader;
    #statusMessage;
    constructor(response, socket){
        super();
        this.response = response;
        this.socket = socket;
        this.#statusMessage = "";
        this.reader = response?.body?.getReader();
    }
    async _read(_size) {
        if (this.reader === undefined) {
            this.push(null);
            return;
        }
        try {
            const res = await this.reader.read();
            if (res.done) {
                this.push(null);
                return;
            }
            this.push(res.value);
        } catch (e) {
            this.destroy(e);
        }
    }
    get headers() {
        if (this.response) {
            return Object.fromEntries(this.response.headers.entries());
        }
        return {};
    }
    get trailers() {
        return {};
    }
    get statusCode() {
        return this.response?.status || 0;
    }
    get statusMessage() {
        return this.#statusMessage || this.response?.statusText || "";
    }
    set statusMessage(v) {
        this.#statusMessage = v;
    }
    response;
    socket;
}
class ServerResponse extends mu {
    statusCode = undefined;
    statusMessage = undefined;
    #headers = new Headers({});
    #readable;
    writable = true;
    finished = false;
    headersSent = false;
    #firstChunk = null;
    #reqEvent;
    #resolve;
    #isFlashRequest;
    static #enqueue(controller, chunk) {
        if (chunk.length === 0) {
            return;
        }
        if (typeof chunk === "string") {
            controller.enqueue(ENCODER.encode(chunk));
        } else {
            controller.enqueue(chunk);
        }
    }
    static #bodyShouldBeNull(status) {
        return status === 101 || status === 204 || status === 205 || status === 304;
    }
    constructor(reqEvent, resolve){
        let controller;
        const readable = new ReadableStream({
            start (c) {
                controller = c;
            }
        });
        super({
            autoDestroy: true,
            defaultEncoding: "utf-8",
            emitClose: true,
            write: (chunk, _encoding, cb)=>{
                if (!this.headersSent) {
                    if (this.#firstChunk === null) {
                        this.#firstChunk = chunk;
                        return cb();
                    } else {
                        ServerResponse.#enqueue(controller, this.#firstChunk);
                        this.#firstChunk = null;
                        this.respond(false);
                    }
                }
                ServerResponse.#enqueue(controller, chunk);
                return cb();
            },
            final: (cb)=>{
                if (this.#firstChunk) {
                    this.respond(true, this.#firstChunk);
                } else if (!this.headersSent) {
                    this.respond(true);
                }
                controller.close();
                return cb();
            },
            destroy: (err, cb)=>{
                if (err) {
                    controller.error(err);
                }
                return cb(null);
            }
        });
        this.#readable = readable;
        this.#resolve = resolve;
        this.#reqEvent = reqEvent;
        this.#isFlashRequest = typeof resolve !== "undefined";
    }
    setHeader(name, value) {
        this.#headers.set(name, value);
        return this;
    }
    getHeader(name) {
        return this.#headers.get(name);
    }
    removeHeader(name) {
        return this.#headers.delete(name);
    }
    getHeaderNames() {
        return Array.from(this.#headers.keys());
    }
    hasHeader(name) {
        return this.#headers.has(name);
    }
    writeHead(status, headers) {
        this.statusCode = status;
        for(const k in headers){
            this.#headers.set(k, headers[k]);
        }
        return this;
    }
    #ensureHeaders(singleChunk) {
        if (this.statusCode === undefined) {
            this.statusCode = 200;
            this.statusMessage = "OK";
        }
        if (!this.#isFlashRequest && typeof singleChunk === "string" && !this.hasHeader("content-type")) {
            this.setHeader("content-type", "text/plain;charset=UTF-8");
        }
    }
    respond(__final, singleChunk) {
        this.headersSent = true;
        this.#ensureHeaders(singleChunk);
        let body = singleChunk ?? (__final ? null : this.#readable);
        if (ServerResponse.#bodyShouldBeNull(this.statusCode)) {
            body = null;
        }
        if (this.#isFlashRequest) {
            this.#resolve(new Response(body, {
                headers: this.#headers,
                status: this.statusCode,
                statusText: this.statusMessage
            }));
        } else {
            this.#reqEvent.respondWith(new Response(body, {
                headers: this.#headers,
                status: this.statusCode,
                statusText: this.statusMessage
            })).catch(()=>{});
        }
    }
    end(chunk, encoding, cb) {
        this.finished = true;
        if (this.#isFlashRequest) {
            this.#headers.delete("transfer-encoding");
            this.#headers.delete("content-length");
        } else if (!chunk && this.#headers.has("transfer-encoding")) {
            this.#headers.set("content-length", "0");
            this.#headers.delete("transfer-encoding");
        }
        return super.end(chunk, encoding, cb);
    }
}
class IncomingMessageForServer extends Au {
    #req;
    url;
    method;
    constructor(req){
        const reader = req.body?.getReader();
        super({
            autoDestroy: true,
            emitClose: true,
            objectMode: false,
            read: async function(_size) {
                if (!reader) {
                    return this.push(null);
                }
                try {
                    const { value  } = await reader.read();
                    this.push(value !== undefined ? Buffer1.from(value) : null);
                } catch (err) {
                    this.destroy(err);
                }
            },
            destroy: (err, cb)=>{
                reader?.cancel().finally(()=>cb(err));
            }
        });
        this.url = req.url?.slice(req.url.indexOf("/", 8));
        this.method = req.method;
        this.#req = req;
    }
    get aborted() {
        return false;
    }
    get httpVersion() {
        return "1.1";
    }
    get headers() {
        return Object.fromEntries(this.#req.headers.entries());
    }
    get upgrade() {
        return Boolean(this.#req.headers.get("connection")?.toLowerCase().includes("upgrade") && this.#req.headers.get("upgrade"));
    }
}
function Server1(handler) {
    return new ServerImpl(handler);
}
class ServerImpl extends EventEmitter {
    #isFlashServer;
    #httpConnections = new Set();
    #listener;
    #addr;
    #hasClosed = false;
    #ac;
    #servePromise;
    listening = false;
    constructor(handler){
        super();
        this.#isFlashServer = typeof DenoServe == "function";
        if (this.#isFlashServer) {
            this.#servePromise = deferred();
            this.#servePromise.then(()=>this.emit("close"));
        }
        if (handler !== undefined) {
            this.on("request", handler);
        }
    }
    listen(...args) {
        const normalized = _normalizeArgs(args);
        const options = normalized[0];
        const cb = normalized[1];
        if (cb !== null) {
            this.once("listening", cb);
        }
        let port = 0;
        if (typeof options.port === "number" || typeof options.port === "string") {
            validatePort(options.port, "options.port");
            port = options.port | 0;
        }
        if (this.#isFlashServer) {
            const hostname = options.host ?? "0.0.0.0";
            this.#addr = {
                hostname,
                port
            };
            this.listening = true;
            nextTick1(()=>this.#serve());
        } else {
            this.listening = true;
            const hostname = options.host ?? "";
            this.#listener = Deno.listen({
                port,
                hostname
            });
            nextTick1(()=>this.#listenLoop());
        }
        return this;
    }
    async #listenLoop() {
        const go = async (httpConn)=>{
            try {
                for(;;){
                    let reqEvent = null;
                    try {
                        reqEvent = await httpConn.nextRequest();
                    } catch  {}
                    if (reqEvent === null) {
                        break;
                    }
                    const req = new IncomingMessageForServer(reqEvent.request);
                    const res = new ServerResponse(reqEvent, undefined);
                    this.emit("request", req, res);
                }
            } finally{
                this.#httpConnections.delete(httpConn);
            }
        };
        const listener = this.#listener;
        if (listener !== undefined) {
            this.emit("listening");
            for await (const conn of listener){
                let httpConn;
                try {
                    httpConn = Deno.serveHttp(conn);
                } catch  {
                    continue;
                }
                this.#httpConnections.add(httpConn);
                go(httpConn);
            }
        }
    }
    #serve() {
        const ac = new AbortController();
        const handler = (request)=>{
            const req = new IncomingMessageForServer(request);
            if (req.upgrade && this.listenerCount("upgrade") > 0) {
                const [conn, head] = DenoUpgradeHttpRaw(request);
                const socket = new Socket({
                    handle: new TCP(constants3.SERVER, conn)
                });
                this.emit("upgrade", req, socket, Buffer1.from(head));
            } else {
                return new Promise((resolve)=>{
                    const res = new ServerResponse(undefined, resolve);
                    this.emit("request", req, res);
                });
            }
        };
        if (this.#hasClosed) {
            return;
        }
        this.#ac = ac;
        DenoServe({
            handler: handler,
            ...this.#addr,
            signal: ac.signal,
            onListen: ({ port  })=>{
                this.#addr.port = port;
                this.emit("listening");
            }
        }).then(()=>this.#servePromise.resolve());
    }
    setTimeout() {
        console.error("Not implemented: Server.setTimeout()");
    }
    close(cb) {
        const listening = this.listening;
        this.listening = false;
        this.#hasClosed = true;
        if (typeof cb === "function") {
            if (listening) {
                this.once("close", cb);
            } else {
                this.once("close", function close() {
                    cb(new ERR_SERVER_NOT_RUNNING());
                });
            }
        }
        if (this.#isFlashServer) {
            if (listening && this.#ac) {
                this.#ac.abort();
                this.#ac = undefined;
            } else {
                this.#servePromise.resolve();
            }
        } else {
            nextTick1(()=>this.emit("close"));
            if (listening) {
                this.#listener.close();
                this.#listener = undefined;
                for (const httpConn of this.#httpConnections){
                    try {
                        httpConn.close();
                    } catch  {}
                }
                this.#httpConnections.clear();
            }
        }
        return this;
    }
    address() {
        let addr;
        if (this.#isFlashServer) {
            addr = this.#addr;
        } else {
            addr = this.#listener.addr;
        }
        return {
            port: addr.port,
            address: addr.hostname
        };
    }
}
Server1.prototype = ServerImpl.prototype;
function createServer1(handler) {
    return Server1(handler);
}
function request(...args) {
    let options = {};
    if (typeof args[0] === "string") {
        options = urlToHttpOptions1(new URL(args.shift()));
    } else if (args[0] instanceof URL) {
        options = urlToHttpOptions1(args.shift());
    }
    if (args[0] && typeof args[0] !== "function") {
        Object.assign(options, args.shift());
    }
    args.unshift(options);
    return new ClientRequest(args[0], args[1]);
}
function get1(...args) {
    const req = request(args[0], args[1], args[2]);
    req.end();
    return req;
}
const __default55 = {
    Agent,
    ClientRequest,
    STATUS_CODES: Status,
    METHODS,
    createServer: createServer1,
    Server: Server1,
    IncomingMessage: IncomingMessageForServer,
    IncomingMessageForClient,
    IncomingMessageForServer,
    OutgoingMessage,
    ServerResponse,
    request,
    get: get1
};
class Http2Session {
    constructor(){
        notImplemented("Http2Session.prototype.constructor");
    }
}
class ServerHttp2Session {
    constructor(){
        notImplemented("ServerHttp2Session");
    }
}
class ClientHttp2Session {
    constructor(){
        notImplemented("ClientHttp2Session");
    }
}
class Http2Stream {
    constructor(){
        notImplemented("Http2Stream");
    }
}
class ClientHttp2Stream {
    constructor(){
        notImplemented("ClientHttp2Stream");
    }
}
class ServerHttp2Stream {
    constructor(){
        notImplemented("ServerHttp2Stream");
    }
}
class Http2Server {
    constructor(){
        notImplemented("Http2Server");
    }
}
class Http2SecureServer {
    constructor(){
        notImplemented("Http2SecureServer");
    }
}
function createServer2() {}
function createSecureServer() {}
function connect1() {}
const constants7 = {};
function getDefaultSettings() {}
function getPackedSettings() {}
function getUnpackedSettings() {}
const sensitiveHeaders = Symbol("nodejs.http2.sensitiveHeaders");
class Http2ServerRequest {
    constructor(){
        notImplemented("Http2ServerRequest");
    }
}
class Http2ServerResponse {
    constructor(){
        notImplemented("Http2ServerResponse");
    }
}
const __default56 = {
    Http2Session,
    ServerHttp2Session,
    ClientHttp2Session,
    Http2Stream,
    ClientHttp2Stream,
    ServerHttp2Stream,
    Http2Server,
    Http2SecureServer,
    createServer: createServer2,
    createSecureServer,
    connect: connect1,
    constants: constants7,
    getDefaultSettings,
    getPackedSettings,
    getUnpackedSettings,
    sensitiveHeaders,
    Http2ServerRequest,
    Http2ServerResponse
};
class Agent1 extends Agent {
}
class Server2 {
    constructor(){
        notImplemented("https.Server.prototype.constructor");
    }
}
function createServer3() {
    notImplemented("https.createServer");
}
let caCerts;
function get2(...args) {
    const req = request1(args[0], args[1], args[2]);
    req.end();
    return req;
}
const globalAgent1 = undefined;
class HttpsClientRequest extends ClientRequest {
    defaultProtocol = "https:";
    async _createCustomClient() {
        if (caCerts === null) {
            return undefined;
        }
        if (caCerts !== undefined) {
            return Deno.createHttpClient({
                caCerts
            });
        }
        const status = await Deno.permissions.query({
            name: "env",
            variable: "NODE_EXTRA_CA_CERTS"
        });
        if (status.state !== "granted") {
            caCerts = null;
            return undefined;
        }
        const certFilename = Deno.env.get("NODE_EXTRA_CA_CERTS");
        if (!certFilename) {
            caCerts = null;
            return undefined;
        }
        const caCert = await Deno.readTextFile(certFilename);
        caCerts = [
            caCert
        ];
        return Deno.createHttpClient({
            caCerts
        });
    }
    _createSocket() {
        return {
            authorized: true
        };
    }
}
function request1(...args) {
    let options = {};
    if (typeof args[0] === "string") {
        options = urlToHttpOptions1(new URL(args.shift()));
    } else if (args[0] instanceof URL) {
        options = urlToHttpOptions1(args.shift());
    }
    if (args[0] && typeof args[0] !== "function") {
        Object.assign(options, args.shift());
    }
    args.unshift(options);
    return new HttpsClientRequest(args[0], args[1]);
}
const __default57 = {
    Agent: Agent1,
    Server: Server2,
    createServer: createServer3,
    get: get2,
    globalAgent: globalAgent1,
    request: request1
};
const connectionSymbol = Symbol("connectionProperty");
const messageCallbacksSymbol = Symbol("messageCallbacks");
const nextIdSymbol = Symbol("nextId");
const onMessageSymbol = Symbol("onMessage");
class Session extends EventEmitter {
    [connectionSymbol];
    [nextIdSymbol];
    [messageCallbacksSymbol];
    constructor(){
        super();
        notImplemented("inspector.Session.prototype.constructor");
    }
    connect() {
        notImplemented("inspector.Session.prototype.connect");
    }
    connectToMainThread() {
        notImplemented("inspector.Session.prototype.connectToMainThread");
    }
    [onMessageSymbol](_message) {
        notImplemented("inspector.Session.prototype[Symbol('onMessage')]");
    }
    post(_method, _params, _callback) {
        notImplemented("inspector.Session.prototype.post");
    }
    disconnect() {
        notImplemented("inspector.Session.prototype.disconnect");
    }
}
function open1(_port, _host, _wait) {
    notImplemented("inspector.Session.prototype.open");
}
function close2() {
    notImplemented("inspector.Session.prototype.close");
}
function url() {
    return undefined;
}
function waitForDebugger() {
    notImplemented("inspector.wairForDebugger");
}
const console1 = globalThis.console;
const __default58 = {
    close: close2,
    console: console1,
    open: open1,
    Session,
    url,
    waitForDebugger
};
const kIsEventTarget = Symbol.for("nodejs.event_target");
const kIsNodeEventTarget = Symbol("kIsNodeEventTarget");
const { kMaxEventTargetListeners: kMaxEventTargetListeners1 , kMaxEventTargetListenersWarned: kMaxEventTargetListenersWarned1  } = EventEmitter;
const kEvents1 = Symbol("kEvents");
const kIsBeingDispatched = Symbol("kIsBeingDispatched");
const kStop = Symbol("kStop");
const kTarget = Symbol("kTarget");
const kHandlers = Symbol("khandlers");
const kWeakHandler = Symbol("kWeak");
const kHybridDispatch = Symbol.for("nodejs.internal.kHybridDispatch");
const kCreateEvent = Symbol("kCreateEvent");
const kNewListener = Symbol("kNewListener");
const kRemoveListener = Symbol("kRemoveListener");
const kIsNodeStyleListener = Symbol("kIsNodeStyleListener");
const kTrustEvent = Symbol("kTrustEvent");
const kType1 = Symbol("type");
const kDetail = Symbol("detail");
const kDefaultPrevented = Symbol("defaultPrevented");
const kCancelable = Symbol("cancelable");
const kTimestamp = Symbol("timestamp");
const kBubbles = Symbol("bubbles");
const kComposed = Symbol("composed");
const kPropagationStopped = Symbol("propagationStopped");
function isEvent(value) {
    return typeof value?.[kType1] === "string";
}
class Event extends globalThis.Event {
    constructor(type, options = null){
        super(type, options);
        if (arguments.length === 0) {
            throw new ERR_MISSING_ARGS("type");
        }
        validateObject(options, "options", {
            allowArray: true,
            allowFunction: true,
            nullable: true
        });
        const { cancelable , bubbles , composed  } = {
            ...options
        };
        this[kCancelable] = !!cancelable;
        this[kBubbles] = !!bubbles;
        this[kComposed] = !!composed;
        this[kType1] = `${type}`;
        this[kDefaultPrevented] = false;
        this[kTimestamp] = performance.now();
        this[kPropagationStopped] = false;
        this[kTarget] = null;
        this[kIsBeingDispatched] = false;
    }
    [customInspectSymbol1](depth, options) {
        if (!isEvent(this)) {
            throw new ERR_INVALID_THIS("Event");
        }
        const name = this.constructor.name;
        if (depth < 0) {
            return name;
        }
        const opts = Object.assign({}, options, {
            depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth
        });
        return `${name} ${inspect({
            type: this[kType1],
            defaultPrevented: this[kDefaultPrevented],
            cancelable: this[kCancelable],
            timeStamp: this[kTimestamp]
        }, opts)}`;
    }
    stopImmediatePropagation() {
        if (!isEvent(this)) {
            throw new ERR_INVALID_THIS("Event");
        }
        this[kStop] = true;
    }
    preventDefault() {
        if (!isEvent(this)) {
            throw new ERR_INVALID_THIS("Event");
        }
        this[kDefaultPrevented] = true;
    }
    get target() {
        if (!isEvent(this)) {
            throw new ERR_INVALID_THIS("Event");
        }
        return this[kTarget];
    }
    get currentTarget() {
        if (!isEvent(this)) {
            throw new ERR_INVALID_THIS("Event");
        }
        return this[kTarget];
    }
    get srcElement() {
        if (!isEvent(this)) {
            throw new ERR_INVALID_THIS("Event");
        }
        return this[kTarget];
    }
    get type() {
        if (!isEvent(this)) {
            throw new ERR_INVALID_THIS("Event");
        }
        return this[kType1];
    }
    get cancelable() {
        if (!isEvent(this)) {
            throw new ERR_INVALID_THIS("Event");
        }
        return this[kCancelable];
    }
    get defaultPrevented() {
        if (!isEvent(this)) {
            throw new ERR_INVALID_THIS("Event");
        }
        return this[kCancelable] && this[kDefaultPrevented];
    }
    get timeStamp() {
        if (!isEvent(this)) {
            throw new ERR_INVALID_THIS("Event");
        }
        return this[kTimestamp];
    }
    composedPath() {
        if (!isEvent(this)) {
            throw new ERR_INVALID_THIS("Event");
        }
        return this[kIsBeingDispatched] ? [
            this[kTarget]
        ] : [];
    }
    get returnValue() {
        if (!isEvent(this)) {
            throw new ERR_INVALID_THIS("Event");
        }
        return !this.defaultPrevented;
    }
    get bubbles() {
        if (!isEvent(this)) {
            throw new ERR_INVALID_THIS("Event");
        }
        return this[kBubbles];
    }
    get composed() {
        if (!isEvent(this)) {
            throw new ERR_INVALID_THIS("Event");
        }
        return this[kComposed];
    }
    get eventPhase() {
        if (!isEvent(this)) {
            throw new ERR_INVALID_THIS("Event");
        }
        return this[kIsBeingDispatched] ? Event.AT_TARGET : Event.NONE;
    }
    get cancelBubble() {
        if (!isEvent(this)) {
            throw new ERR_INVALID_THIS("Event");
        }
        return this[kPropagationStopped];
    }
    set cancelBubble(value) {
        if (!isEvent(this)) {
            throw new ERR_INVALID_THIS("Event");
        }
        if (value) {
            this.stopPropagation();
        }
    }
    stopPropagation() {
        if (!isEvent(this)) {
            throw new ERR_INVALID_THIS("Event");
        }
        this[kPropagationStopped] = true;
    }
    static NONE = 0;
    static CAPTURING_PHASE = 1;
    static AT_TARGET = 2;
    static BUBBLING_PHASE = 3;
}
Object.defineProperties(Event.prototype, {
    [Symbol.toStringTag]: {
        writable: true,
        enumerable: false,
        configurable: true,
        value: "Event"
    },
    stopImmediatePropagation: kEnumerableProperty,
    preventDefault: kEnumerableProperty,
    target: kEnumerableProperty,
    currentTarget: kEnumerableProperty,
    srcElement: kEnumerableProperty,
    type: kEnumerableProperty,
    cancelable: kEnumerableProperty,
    defaultPrevented: kEnumerableProperty,
    timeStamp: kEnumerableProperty,
    composedPath: kEnumerableProperty,
    returnValue: kEnumerableProperty,
    bubbles: kEnumerableProperty,
    composed: kEnumerableProperty,
    eventPhase: kEnumerableProperty,
    cancelBubble: kEnumerableProperty,
    stopPropagation: kEnumerableProperty
});
function isCustomEvent(value) {
    return isEvent(value) && value?.[kDetail] !== undefined;
}
class CustomEvent extends Event {
    constructor(type, options = kEmptyObject){
        if (arguments.length === 0) {
            throw new ERR_MISSING_ARGS("type");
        }
        super(type, options);
        this[kDetail] = options?.detail ?? null;
    }
    get detail() {
        if (!isCustomEvent(this)) {
            throw new ERR_INVALID_THIS("CustomEvent");
        }
        return this[kDetail];
    }
}
Object.defineProperties(CustomEvent.prototype, {
    [Symbol.toStringTag]: {
        __proto__: null,
        writable: false,
        enumerable: false,
        configurable: true,
        value: "CustomEvent"
    },
    detail: kEnumerableProperty
});
class NodeCustomEvent extends Event {
    constructor(type, options){
        super(type, options);
        if (options?.detail) {
            this.detail = options.detail;
        }
    }
}
let weakListenersState = null;
let objectToWeakListenerMap = null;
function weakListeners() {
    weakListenersState ??= new FinalizationRegistry((listener)=>listener.remove());
    objectToWeakListenerMap ??= new WeakMap();
    return {
        registry: weakListenersState,
        map: objectToWeakListenerMap
    };
}
class Listener {
    constructor(previous, listener, once, capture, passive, isNodeStyleListener, weak){
        this.next = undefined;
        if (previous !== undefined) {
            previous.next = this;
        }
        this.previous = previous;
        this.listener = listener;
        this.once = once;
        this.capture = capture;
        this.passive = passive;
        this.isNodeStyleListener = isNodeStyleListener;
        this.removed = false;
        this.weak = Boolean(weak);
        if (this.weak) {
            this.callback = new WeakRef(listener);
            weakListeners().registry.register(listener, this, this);
            weakListeners().map.set(weak, listener);
            this.listener = this.callback;
        } else if (typeof listener === "function") {
            this.callback = listener;
            this.listener = listener;
        } else {
            this.callback = Function.prototype.bind.call(listener.handleEvent, listener);
            this.listener = listener;
        }
    }
    same(listener, capture) {
        const myListener = this.weak ? this.listener.deref() : this.listener;
        return myListener === listener && this.capture === capture;
    }
    remove() {
        if (this.previous !== undefined) {
            this.previous.next = this.next;
        }
        if (this.next !== undefined) {
            this.next.previous = this.previous;
        }
        this.removed = true;
        if (this.weak) {
            weakListeners().registry.unregister(this);
        }
    }
}
function initEventTarget(self) {
    self[kEvents1] = new Map();
    self[kMaxEventTargetListeners1] = EventEmitter.defaultMaxListeners;
    self[kMaxEventTargetListenersWarned1] = false;
}
class EventTarget1 extends globalThis.EventTarget {
    static [kIsEventTarget] = true;
    constructor(){
        super();
        initEventTarget(this);
    }
    [kNewListener](size, type, _listener, _once, _capture, _passive, _weak) {
        if (this[kMaxEventTargetListeners1] > 0 && size > this[kMaxEventTargetListeners1] && !this[kMaxEventTargetListenersWarned1]) {
            this[kMaxEventTargetListenersWarned1] = true;
            const w = new Error("Possible EventTarget memory leak detected. " + `${size} ${type} listeners ` + `added to ${inspect(this, {
                depth: -1
            })}. Use ` + "events.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.target = this;
            w.type = type;
            w.count = size;
            emitWarning1(w);
        }
    }
    [kRemoveListener](_size, _type, _listener, _capture) {}
    addEventListener(type, listener, options = {}) {
        if (!isEventTarget(this)) {
            throw new ERR_INVALID_THIS("EventTarget");
        }
        if (arguments.length < 2) {
            throw new ERR_MISSING_ARGS("type", "listener");
        }
        const { once , capture , passive , signal , isNodeStyleListener , weak  } = validateEventListenerOptions(options);
        if (!shouldAddListener(listener)) {
            const w = new Error(`addEventListener called with ${listener}` + " which has no effect.");
            w.name = "AddEventListenerArgumentTypeWarning";
            w.target = this;
            w.type = type;
            emitWarning1(w);
            return;
        }
        type = String(type);
        if (signal) {
            if (signal.aborted) {
                return;
            }
            signal.addEventListener("abort", ()=>{
                this.removeEventListener(type, listener, options);
            }, {
                once: true,
                [kWeakHandler]: this
            });
        }
        let root = this[kEvents1].get(type);
        if (root === undefined) {
            root = {
                size: 1,
                next: undefined
            };
            new Listener(root, listener, once, capture, passive, isNodeStyleListener, weak);
            this[kNewListener](root.size, type, listener, once, capture, passive, weak);
            this[kEvents1].set(type, root);
            return;
        }
        let handler = root.next;
        let previous = root;
        while(handler !== undefined && !handler.same(listener, capture)){
            previous = handler;
            handler = handler.next;
        }
        if (handler !== undefined) {
            return;
        }
        new Listener(previous, listener, once, capture, passive, isNodeStyleListener, weak);
        root.size++;
        this[kNewListener](root.size, type, listener, once, capture, passive, weak);
    }
    removeEventListener(type, listener, options = {}) {
        if (!isEventTarget(this)) {
            throw new ERR_INVALID_THIS("EventTarget");
        }
        if (!shouldAddListener(listener)) {
            return;
        }
        type = String(type);
        const capture = options?.capture === true;
        const root = this[kEvents1].get(type);
        if (root === undefined || root.next === undefined) {
            return;
        }
        let handler = root.next;
        while(handler !== undefined){
            if (handler.same(listener, capture)) {
                handler.remove();
                root.size--;
                if (root.size === 0) {
                    this[kEvents1].delete(type);
                }
                this[kRemoveListener](root.size, type, listener, capture);
                break;
            }
            handler = handler.next;
        }
    }
    dispatchEvent(event) {
        if (!isEventTarget(this)) {
            throw new ERR_INVALID_THIS("EventTarget");
        }
        if (!(event instanceof globalThis.Event)) {
            throw new ERR_INVALID_ARG_TYPE("event", "Event", event);
        }
        if (event[kIsBeingDispatched]) {
            throw new ERR_EVENT_RECURSION(event.type);
        }
        this[kHybridDispatch](event, event.type, event);
        return event.defaultPrevented !== true;
    }
    [kHybridDispatch](nodeValue, type, event) {
        const createEvent = ()=>{
            if (event === undefined) {
                event = this[kCreateEvent](nodeValue, type);
                event[kTarget] = this;
                event[kIsBeingDispatched] = true;
            }
            return event;
        };
        if (event !== undefined) {
            event[kTarget] = this;
            event[kIsBeingDispatched] = true;
        }
        const root = this[kEvents1].get(type);
        if (root === undefined || root.next === undefined) {
            if (event !== undefined) {
                event[kIsBeingDispatched] = false;
            }
            return true;
        }
        let handler = root.next;
        let next;
        while(handler !== undefined && (handler.passive || event?.[kStop] !== true)){
            next = handler.next;
            if (handler.removed) {
                handler = next;
                continue;
            }
            if (handler.once) {
                handler.remove();
                root.size--;
                const { listener , capture  } = handler;
                this[kRemoveListener](root.size, type, listener, capture);
            }
            try {
                let arg;
                if (handler.isNodeStyleListener) {
                    arg = nodeValue;
                } else {
                    arg = createEvent();
                }
                const callback = handler.weak ? handler.callback.deref() : handler.callback;
                let result;
                if (callback) {
                    result = callback.call(this, arg);
                    if (!handler.isNodeStyleListener) {
                        arg[kIsBeingDispatched] = false;
                    }
                }
                if (result !== undefined && result !== null) {
                    addCatch1(result);
                }
            } catch (err) {
                emitUncaughtException(err);
            }
            handler = next;
        }
        if (event !== undefined) {
            event[kIsBeingDispatched] = false;
        }
    }
    [kCreateEvent](nodeValue, type) {
        return new NodeCustomEvent(type, {
            detail: nodeValue
        });
    }
    [customInspectSymbol1](depth, options) {
        if (!isEventTarget(this)) {
            throw new ERR_INVALID_THIS("EventTarget");
        }
        const name = this.constructor.name;
        if (depth < 0) {
            return name;
        }
        const opts = ObjectAssign({}, options, {
            depth: Number.isInteger(options.depth) ? options.depth - 1 : options.depth
        });
        return `${name} ${inspect({}, opts)}`;
    }
}
Object.defineProperties(EventTarget1.prototype, {
    addEventListener: kEnumerableProperty,
    removeEventListener: kEnumerableProperty,
    dispatchEvent: kEnumerableProperty,
    [Symbol.toStringTag]: {
        writable: true,
        enumerable: false,
        configurable: true,
        value: "EventTarget"
    }
});
function initNodeEventTarget(self) {
    initEventTarget(self);
}
class NodeEventTarget extends EventTarget1 {
    static [kIsNodeEventTarget] = true;
    static defaultMaxListeners = 10;
    constructor(){
        super();
        initNodeEventTarget(this);
    }
    setMaxListeners(n) {
        if (!isNodeEventTarget(this)) {
            throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        EventEmitter.setMaxListeners(n, this);
    }
    getMaxListeners() {
        if (!isNodeEventTarget(this)) {
            throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        return this[kMaxEventTargetListeners1];
    }
    eventNames() {
        if (!isNodeEventTarget(this)) {
            throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        return Array.from(this[kEvents1].keys());
    }
    listenerCount(type) {
        if (!isNodeEventTarget(this)) {
            throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        const root = this[kEvents1].get(String(type));
        return root !== undefined ? root.size : 0;
    }
    off(type, listener, options) {
        if (!isNodeEventTarget(this)) {
            throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        this.removeEventListener(type, listener, options);
        return this;
    }
    removeListener(type, listener, options) {
        if (!isNodeEventTarget(this)) {
            throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        this.removeEventListener(type, listener, options);
        return this;
    }
    on(type, listener) {
        if (!isNodeEventTarget(this)) {
            throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        this.addEventListener(type, listener, {
            [kIsNodeStyleListener]: true
        });
        return this;
    }
    addListener(type, listener) {
        if (!isNodeEventTarget(this)) {
            throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        this.addEventListener(type, listener, {
            [kIsNodeStyleListener]: true
        });
        return this;
    }
    emit(type, arg) {
        if (!isNodeEventTarget(this)) {
            throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        validateString(type, "type");
        const hadListeners = this.listenerCount(type) > 0;
        this[kHybridDispatch](arg, type);
        return hadListeners;
    }
    once(type, listener) {
        if (!isNodeEventTarget(this)) {
            throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        this.addEventListener(type, listener, {
            once: true,
            [kIsNodeStyleListener]: true
        });
        return this;
    }
    removeAllListeners(type) {
        if (!isNodeEventTarget(this)) {
            throw new ERR_INVALID_THIS("NodeEventTarget");
        }
        if (type !== undefined) {
            this[kEvents1].delete(String(type));
        } else {
            this[kEvents1].clear();
        }
        return this;
    }
}
Object.defineProperties(NodeEventTarget.prototype, {
    setMaxListeners: kEnumerableProperty,
    getMaxListeners: kEnumerableProperty,
    eventNames: kEnumerableProperty,
    listenerCount: kEnumerableProperty,
    off: kEnumerableProperty,
    removeListener: kEnumerableProperty,
    on: kEnumerableProperty,
    addListener: kEnumerableProperty,
    once: kEnumerableProperty,
    emit: kEnumerableProperty,
    removeAllListeners: kEnumerableProperty
});
function shouldAddListener(listener) {
    if (typeof listener === "function" || typeof listener?.handleEvent === "function") {
        return true;
    }
    if (listener == null) {
        return false;
    }
    throw new ERR_INVALID_ARG_TYPE("listener", "EventListener", listener);
}
function validateEventListenerOptions(options) {
    if (typeof options === "boolean") {
        return {
            capture: options
        };
    }
    if (options === null) {
        return {};
    }
    validateObject(options, "options", {
        allowArray: true,
        allowFunction: true
    });
    return {
        once: Boolean(options.once),
        capture: Boolean(options.capture),
        passive: Boolean(options.passive),
        signal: options.signal,
        weak: options[kWeakHandler],
        isNodeStyleListener: Boolean(options[kIsNodeStyleListener])
    };
}
function isEventTarget(obj) {
    return obj instanceof globalThis.EventTarget;
}
function isNodeEventTarget(obj) {
    return obj?.constructor?.[kIsNodeEventTarget];
}
function addCatch1(promise) {
    const then = promise.then;
    if (typeof then === "function") {
        then.call(promise, undefined, function(err) {
            emitUncaughtException(err);
        });
    }
}
function emitUncaughtException(err) {
    nextTick1(()=>{
        throw err;
    });
}
function makeEventHandler(handler) {
    function eventHandler(...args) {
        if (typeof eventHandler.handler !== "function") {
            return;
        }
        return Reflect.apply(eventHandler.handler, this, args);
    }
    eventHandler.handler = handler;
    return eventHandler;
}
function defineEventHandler(emitter, name) {
    Object.defineProperty(emitter, `on${name}`, {
        get () {
            return this[kHandlers]?.get(name)?.handler ?? null;
        },
        set (value) {
            if (!this[kHandlers]) {
                this[kHandlers] = new Map();
            }
            let wrappedHandler = this[kHandlers]?.get(name);
            if (wrappedHandler) {
                if (typeof wrappedHandler.handler === "function") {
                    this[kEvents1].get(name).size--;
                    const size = this[kEvents1].get(name).size;
                    this[kRemoveListener](size, name, wrappedHandler.handler, false);
                }
                wrappedHandler.handler = value;
                if (typeof wrappedHandler.handler === "function") {
                    this[kEvents1].get(name).size++;
                    const size = this[kEvents1].get(name).size;
                    this[kNewListener](size, name, value, false, false, false, false);
                }
            } else {
                wrappedHandler = makeEventHandler(value);
                this.addEventListener(name, wrappedHandler);
            }
            this[kHandlers].set(name, wrappedHandler);
        },
        configurable: true,
        enumerable: true
    });
}
const EventEmitterMixin = (Superclass)=>{
    class MixedEventEmitter extends Superclass {
        constructor(...args){
            super(...args);
            EventEmitter.call(this);
        }
    }
    const protoProps = Object.getOwnPropertyDescriptors(EventEmitter.prototype);
    delete protoProps.constructor;
    Object.defineProperties(MixedEventEmitter.prototype, protoProps);
    return MixedEventEmitter;
};
const __default59 = {
    CustomEvent,
    Event,
    EventEmitterMixin,
    EventTarget: EventTarget1,
    NodeEventTarget,
    defineEventHandler,
    initEventTarget,
    initNodeEventTarget,
    kCreateEvent,
    kNewListener,
    kTrustEvent,
    kRemoveListener,
    kEvents: kEvents1,
    kWeakHandler,
    isEventTarget
};
const validateAbortSignal1 = (signal, name)=>{
    if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
};
function isStream(obj) {
    return !!(obj && typeof obj.pipe === "function");
}
function addAbortSignal(signal, stream) {
    validateAbortSignal1(signal, "signal");
    if (!isStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", "stream.Stream", stream);
    }
    return addAbortSignalNoValidate(signal, stream);
}
function addAbortSignalNoValidate(signal, stream) {
    if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
    }
    const onAbort = ()=>{
        stream.destroy(new AbortError());
    };
    if (signal.aborted) {
        onAbort();
    } else {
        signal.addEventListener("abort", onAbort);
        eos(stream, ()=>signal.removeEventListener("abort", onAbort));
    }
    return stream;
}
const __default60 = {
    addAbortSignal,
    addAbortSignalNoValidate
};
class BufferList {
    constructor(){
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    push(v) {
        const entry = {
            data: v,
            next: null
        };
        if (this.length > 0) {
            this.tail.next = entry;
        } else {
            this.head = entry;
        }
        this.tail = entry;
        ++this.length;
    }
    unshift(v) {
        const entry = {
            data: v,
            next: this.head
        };
        if (this.length === 0) {
            this.tail = entry;
        }
        this.head = entry;
        ++this.length;
    }
    shift() {
        if (this.length === 0) {
            return;
        }
        const ret = this.head.data;
        if (this.length === 1) {
            this.head = this.tail = null;
        } else {
            this.head = this.head.next;
        }
        --this.length;
        return ret;
    }
    clear() {
        this.head = this.tail = null;
        this.length = 0;
    }
    join(s) {
        if (this.length === 0) {
            return "";
        }
        let p = this.head;
        let ret = "" + p.data;
        while(p = p.next){
            ret += s + p.data;
        }
        return ret;
    }
    concat(n) {
        if (this.length === 0) {
            return Buffer1.alloc(0);
        }
        const ret = Buffer1.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while(p){
            ret.set(p.data, i);
            i += p.data.length;
            p = p.next;
        }
        return ret;
    }
    consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
            const slice = data.slice(0, n);
            this.head.data = data.slice(n);
            return slice;
        }
        if (n === data.length) {
            return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
    }
    first() {
        return this.head.data;
    }
    *[Symbol.iterator]() {
        for(let p = this.head; p; p = p.next){
            yield p.data;
        }
    }
    _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
            const str = p.data;
            if (n > str.length) {
                ret += str;
                n -= str.length;
            } else {
                if (n === str.length) {
                    ret += str;
                    ++c;
                    if (p.next) {
                        this.head = p.next;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    ret += str.slice(0, n);
                    this.head = p;
                    p.data = str.slice(n);
                }
                break;
            }
            ++c;
        }while (p = p.next)
        this.length -= c;
        return ret;
    }
    _getBuffer(n) {
        const ret = Buffer1.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
            const buf = p.data;
            if (n > buf.length) {
                ret.set(buf, retLen - n);
                n -= buf.length;
            } else {
                if (n === buf.length) {
                    ret.set(buf, retLen - n);
                    ++c;
                    if (p.next) {
                        this.head = p.next;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    ret.set(new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n);
                    this.head = p;
                    p.data = buf.slice(n);
                }
                break;
            }
            ++c;
        }while (p = p.next)
        this.length -= c;
        return ret;
    }
    [inspect.custom](_, options) {
        return inspect(this, {
            ...options,
            depth: 0,
            customInspect: false
        });
    }
}
function LazyTransform(options) {
    this._options = options;
}
Object.setPrototypeOf(LazyTransform.prototype, Lu.Transform.prototype);
Object.setPrototypeOf(LazyTransform, Lu.Transform);
function makeGetter(name) {
    return function() {
        Lu.Transform.call(this, this._options);
        this._writableState.decodeStrings = false;
        if (!this._options || !this._options.defaultEncoding) {
            this._writableState.defaultEncoding = getDefaultEncoding();
        }
        return this[name];
    };
}
function makeSetter(name) {
    return function(val) {
        Object.defineProperty(this, name, {
            value: val,
            enumerable: true,
            configurable: true,
            writable: true
        });
    };
}
Object.defineProperties(LazyTransform.prototype, {
    _readableState: {
        get: makeGetter("_readableState"),
        set: makeSetter("_readableState"),
        configurable: true,
        enumerable: true
    },
    _writableState: {
        get: makeGetter("_writableState"),
        set: makeSetter("_writableState"),
        configurable: true,
        enumerable: true
    }
});
function internalBinding(name) {
    return getBinding(name);
}
const primordials = {};
const __default61 = {
    internalBinding,
    primordials
};
const { PerformanceObserver , PerformanceEntry , performance: shimPerformance  } = globalThis;
const constants8 = {};
const performance1 = {
    clearMarks: (markName)=>shimPerformance.clearMarks(markName),
    eventLoopUtilization: ()=>notImplemented("eventLoopUtilization from performance"),
    mark: (markName)=>shimPerformance.mark(markName),
    measure: (measureName, startMark, endMark)=>{
        if (endMark) {
            return shimPerformance.measure(measureName, startMark, endMark);
        } else {
            return shimPerformance.measure(measureName, startMark);
        }
    },
    nodeTiming: {},
    now: ()=>shimPerformance.now(),
    timerify: ()=>notImplemented("timerify from performance"),
    timeOrigin: shimPerformance.timeOrigin,
    toJSON: ()=>shimPerformance.toJSON(),
    addEventListener: (...args)=>shimPerformance.addEventListener(...args),
    removeEventListener: (...args)=>shimPerformance.removeEventListener(...args),
    dispatchEvent: (...args)=>shimPerformance.dispatchEvent(...args)
};
const monitorEventLoopDelay = ()=>notImplemented("monitorEventLoopDelay from performance");
const __default62 = {
    performance: performance1,
    PerformanceObserver,
    PerformanceEntry,
    monitorEventLoopDelay,
    constants: constants8
};
const __default63 = {
    decode: decode2,
    encode: encode2,
    toASCII,
    toUnicode,
    ucs2
};
const kAddHistory = Symbol("_addHistory");
const kDecoder = Symbol("_decoder");
const kDeleteLeft = Symbol("_deleteLeft");
const kDeleteLineLeft = Symbol("_deleteLineLeft");
const kDeleteLineRight = Symbol("_deleteLineRight");
const kDeleteRight = Symbol("_deleteRight");
const kDeleteWordLeft = Symbol("_deleteWordLeft");
const kDeleteWordRight = Symbol("_deleteWordRight");
const kGetDisplayPos = Symbol("_getDisplayPos");
const kHistoryNext = Symbol("_historyNext");
const kHistoryPrev = Symbol("_historyPrev");
const kInsertString = Symbol("_insertString");
const kLine = Symbol("_line");
const kLine_buffer = Symbol("_line_buffer");
const kMoveCursor = Symbol("_moveCursor");
const kNormalWrite = Symbol("_normalWrite");
const kOldPrompt = Symbol("_oldPrompt");
const kOnLine = Symbol("_onLine");
const kPreviousKey = Symbol("_previousKey");
const kPrompt = Symbol("_prompt");
const kQuestionCallback = Symbol("_questionCallback");
const kRefreshLine = Symbol("_refreshLine");
const kSawKeyPress = Symbol("_sawKeyPress");
const kSawReturnAt = Symbol("_sawReturnAt");
const kSetRawMode = Symbol("_setRawMode");
const kTabComplete = Symbol("_tabComplete");
const kTabCompleter = Symbol("_tabCompleter");
const kTtyWrite = Symbol("_ttyWrite");
const kWordLeft = Symbol("_wordLeft");
const kWordRight = Symbol("_wordRight");
const kWriteToOutput = Symbol("_writeToOutput");
const { kEscape: kEscape1  } = CSI;
const KEYPRESS_DECODER = Symbol("keypress-decoder");
const ESCAPE_DECODER = Symbol("escape-decoder");
function emitKeypressEvents(stream, iface = {}) {
    if (stream[KEYPRESS_DECODER]) return;
    stream[KEYPRESS_DECODER] = new StringDecoder("utf8");
    stream[ESCAPE_DECODER] = emitKeys(stream);
    stream[ESCAPE_DECODER].next();
    const triggerEscape = ()=>stream[ESCAPE_DECODER].next("");
    const { escapeCodeTimeout =500  } = iface;
    let timeoutId;
    function onData(input) {
        if (stream.listenerCount("keypress") > 0) {
            const string = stream[KEYPRESS_DECODER].write(input);
            if (string) {
                clearTimeout1(timeoutId);
                iface[kSawKeyPress] = charLengthAt(string, 0) === string.length;
                iface.isCompletionEnabled = false;
                let length = 0;
                for (const character of string[Symbol.iterator]()){
                    length += character.length;
                    if (length === string.length) {
                        iface.isCompletionEnabled = true;
                    }
                    try {
                        stream[ESCAPE_DECODER].next(character);
                        if (length === string.length && character === kEscape1) {
                            timeoutId = setTimeout1(triggerEscape, escapeCodeTimeout);
                        }
                    } catch (err) {
                        stream[ESCAPE_DECODER] = emitKeys(stream);
                        stream[ESCAPE_DECODER].next();
                        throw err;
                    }
                }
            }
        } else {
            stream.removeListener("data", onData);
            stream.on("newListener", onNewListener);
        }
    }
    function onNewListener(event) {
        if (event === "keypress") {
            stream.on("data", onData);
            stream.removeListener("newListener", onNewListener);
        }
    }
    if (stream.listenerCount("keypress") > 0) {
        stream.on("data", onData);
    } else {
        stream.on("newListener", onNewListener);
    }
}
const { kClearToLineBeginning: kClearToLineBeginning1 , kClearToLineEnd: kClearToLineEnd1 , kClearLine: kClearLine1 , kClearScreenDown: kClearScreenDown1  } = CSI;
class Readline {
    #autoCommit = false;
    #stream;
    #todo = [];
    constructor(stream, options = undefined){
        if (!isWritable1(stream)) {
            throw new ERR_INVALID_ARG_TYPE("stream", "Writable", stream);
        }
        this.#stream = stream;
        if (options?.autoCommit != null) {
            validateBoolean(options.autoCommit, "options.autoCommit");
            this.#autoCommit = options.autoCommit;
        }
    }
    cursorTo(x, y = undefined) {
        validateInteger(x, "x");
        if (y != null) validateInteger(y, "y");
        const data = y == null ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;
        if (this.#autoCommit) process.nextTick(()=>this.#stream.write(data));
        else ArrayPrototypePush(this.#todo, data);
        return this;
    }
    moveCursor(dx, dy) {
        if (dx || dy) {
            validateInteger(dx, "dx");
            validateInteger(dy, "dy");
            let data = "";
            if (dx < 0) {
                data += CSI`${-dx}D`;
            } else if (dx > 0) {
                data += CSI`${dx}C`;
            }
            if (dy < 0) {
                data += CSI`${-dy}A`;
            } else if (dy > 0) {
                data += CSI`${dy}B`;
            }
            if (this.#autoCommit) process.nextTick(()=>this.#stream.write(data));
            else ArrayPrototypePush(this.#todo, data);
        }
        return this;
    }
    clearLine(dir) {
        validateInteger(dir, "dir", -1, 1);
        const data = dir < 0 ? kClearToLineBeginning1 : dir > 0 ? kClearToLineEnd1 : kClearLine1;
        if (this.#autoCommit) process.nextTick(()=>this.#stream.write(data));
        else ArrayPrototypePush(this.#todo, data);
        return this;
    }
    clearScreenDown() {
        if (this.#autoCommit) {
            process.nextTick(()=>this.#stream.write(kClearScreenDown1));
        } else {
            ArrayPrototypePush(this.#todo, kClearScreenDown1);
        }
        return this;
    }
    commit() {
        return new Promise((resolve)=>{
            this.#stream.write(ArrayPrototypeJoin(this.#todo, ""), resolve);
            this.#todo = [];
        });
    }
    rollback() {
        this.#todo = [];
        return this;
    }
}
const kHistorySize = 30;
const kMincrlfDelay = 100;
const lineEnding = /\r?\n|\r(?!\n)/;
const kLineObjectStream = Symbol("line object stream");
const kQuestionCancel = Symbol("kQuestionCancel");
const kQuestion = Symbol("kQuestion");
const ESCAPE_CODE_TIMEOUT = 500;
function InterfaceConstructor(input, output, completer, terminal) {
    this[kSawReturnAt] = 0;
    this.isCompletionEnabled = true;
    this[kSawKeyPress] = false;
    this[kPreviousKey] = null;
    this.escapeCodeTimeout = ESCAPE_CODE_TIMEOUT;
    this.tabSize = 8;
    Function.prototype.call(EventEmitter, this);
    let history;
    let historySize;
    let removeHistoryDuplicates = false;
    let crlfDelay;
    let prompt = "> ";
    let signal;
    if (input?.input) {
        output = input.output;
        completer = input.completer;
        terminal = input.terminal;
        history = input.history;
        historySize = input.historySize;
        signal = input.signal;
        if (input.tabSize !== undefined) {
            validateUint32(input.tabSize, "tabSize", true);
            this.tabSize = input.tabSize;
        }
        removeHistoryDuplicates = input.removeHistoryDuplicates;
        if (input.prompt !== undefined) {
            prompt = input.prompt;
        }
        if (input.escapeCodeTimeout !== undefined) {
            if (Number.isFinite(input.escapeCodeTimeout)) {
                this.escapeCodeTimeout = input.escapeCodeTimeout;
            } else {
                throw new ERR_INVALID_ARG_VALUE("input.escapeCodeTimeout", this.escapeCodeTimeout);
            }
        }
        if (signal) {
            validateAbortSignal(signal, "options.signal");
        }
        crlfDelay = input.crlfDelay;
        input = input.input;
    }
    if (completer !== undefined && typeof completer !== "function") {
        throw new ERR_INVALID_ARG_VALUE("completer", completer);
    }
    if (history === undefined) {
        history = [];
    } else {
        validateArray(history, "history");
    }
    if (historySize === undefined) {
        historySize = kHistorySize;
    }
    if (typeof historySize !== "number" || Number.isNaN(historySize) || historySize < 0) {
        throw new ERR_INVALID_ARG_VALUE.RangeError("historySize", historySize);
    }
    if (terminal === undefined && !(output === null || output === undefined)) {
        terminal = !!output.isTTY;
    }
    const self = this;
    this.line = "";
    this[kSubstringSearch] = null;
    this.output = output;
    this.input = input;
    this.history = history;
    this.historySize = historySize;
    this.removeHistoryDuplicates = !!removeHistoryDuplicates;
    this.crlfDelay = crlfDelay ? Math.max(kMincrlfDelay, crlfDelay) : kMincrlfDelay;
    this.completer = completer;
    this.setPrompt(prompt);
    this.terminal = !!terminal;
    function onerror(err) {
        self.emit("error", err);
    }
    function ondata(data) {
        self[kNormalWrite](data);
    }
    function onend() {
        if (typeof self[kLine_buffer] === "string" && self[kLine_buffer].length > 0) {
            self.emit("line", self[kLine_buffer]);
        }
        self.close();
    }
    function ontermend() {
        if (typeof self.line === "string" && self.line.length > 0) {
            self.emit("line", self.line);
        }
        self.close();
    }
    function onkeypress(s, key) {
        self[kTtyWrite](s, key);
        if (key && key.sequence) {
            const ch = key.sequence.codePointAt(0);
            if (ch >= 0xd800 && ch <= 0xdfff) self[kRefreshLine]();
        }
    }
    function onresize() {
        self[kRefreshLine]();
    }
    this[kLineObjectStream] = undefined;
    input.on("error", onerror);
    if (!this.terminal) {
        function onSelfCloseWithoutTerminal() {
            input.removeListener("data", ondata);
            input.removeListener("error", onerror);
            input.removeListener("end", onend);
        }
        input.on("data", ondata);
        input.on("end", onend);
        self.once("close", onSelfCloseWithoutTerminal);
        this[kDecoder] = new StringDecoder("utf8");
    } else {
        function onSelfCloseWithTerminal() {
            input.removeListener("keypress", onkeypress);
            input.removeListener("error", onerror);
            input.removeListener("end", ontermend);
            if (output !== null && output !== undefined) {
                output.removeListener("resize", onresize);
            }
        }
        emitKeypressEvents(input, this);
        input.on("keypress", onkeypress);
        input.on("end", ontermend);
        this[kSetRawMode](true);
        this.terminal = true;
        this.cursor = 0;
        this.historyIndex = -1;
        if (output !== null && output !== undefined) {
            output.on("resize", onresize);
        }
        self.once("close", onSelfCloseWithTerminal);
    }
    if (signal) {
        const onAborted = ()=>self.close();
        if (signal.aborted) {
            process.nextTick(onAborted);
        } else {
            signal.addEventListener("abort", onAborted, {
                once: true
            });
            self.once("close", ()=>signal.removeEventListener("abort", onAborted));
        }
    }
    this.line = "";
    input.resume();
}
Object.setPrototypeOf(InterfaceConstructor.prototype, EventEmitter.prototype);
Object.setPrototypeOf(InterfaceConstructor, EventEmitter);
class Interface extends InterfaceConstructor {
    constructor(input, output, completer, terminal){
        super(input, output, completer, terminal);
    }
    get columns() {
        if (this.output && this.output.columns) return this.output.columns;
        return Infinity;
    }
    setPrompt(prompt) {
        this[kPrompt] = prompt;
    }
    getPrompt() {
        return this[kPrompt];
    }
    [kSetRawMode](mode) {
        const wasInRawMode = this.input.isRaw;
        if (typeof this.input.setRawMode === "function") {
            this.input.setRawMode(mode);
        }
        return wasInRawMode;
    }
    prompt(preserveCursor) {
        if (this.paused) this.resume();
        if (this.terminal && process.env.TERM !== "dumb") {
            if (!preserveCursor) this.cursor = 0;
            this[kRefreshLine]();
        } else {
            this[kWriteToOutput](this[kPrompt]);
        }
    }
    [kQuestion](query, cb) {
        if (this.closed) {
            throw new ERR_USE_AFTER_CLOSE("readline");
        }
        if (this[kQuestionCallback]) {
            this.prompt();
        } else {
            this[kOldPrompt] = this[kPrompt];
            this.setPrompt(query);
            this[kQuestionCallback] = cb;
            this.prompt();
        }
    }
    [kOnLine](line) {
        if (this[kQuestionCallback]) {
            const cb = this[kQuestionCallback];
            this[kQuestionCallback] = null;
            this.setPrompt(this[kOldPrompt]);
            cb(line);
        } else {
            this.emit("line", line);
        }
    }
    [kQuestionCancel]() {
        if (this[kQuestionCallback]) {
            this[kQuestionCallback] = null;
            this.setPrompt(this[kOldPrompt]);
            this.clearLine();
        }
    }
    [kWriteToOutput](stringToWrite) {
        validateString(stringToWrite, "stringToWrite");
        if (this.output !== null && this.output !== undefined) {
            this.output.write(stringToWrite);
        }
    }
    [kAddHistory]() {
        if (this.line.length === 0) return "";
        if (this.historySize === 0) return this.line;
        if (this.line.trim().length === 0) return this.line;
        if (this.history.length === 0 || this.history[0] !== this.line) {
            if (this.removeHistoryDuplicates) {
                const dupIndex = this.history.indexOf(this.line);
                if (dupIndex !== -1) this.history.splice(dupIndex, 1);
            }
            this.history.unshift(this.line);
            if (this.history.length > this.historySize) {
                this.history.pop();
            }
        }
        this.historyIndex = -1;
        const line = this.history[0];
        this.emit("history", this.history);
        return line;
    }
    [kRefreshLine]() {
        const line = this[kPrompt] + this.line;
        const dispPos = this[kGetDisplayPos](line);
        const lineCols = dispPos.cols;
        const lineRows = dispPos.rows;
        const cursorPos = this.getCursorPos();
        const prevRows = this.prevRows || 0;
        if (prevRows > 0) {
            moveCursor(this.output, 0, -prevRows);
        }
        cursorTo(this.output, 0);
        clearScreenDown(this.output);
        this[kWriteToOutput](line);
        if (lineCols === 0) {
            this[kWriteToOutput](" ");
        }
        cursorTo(this.output, cursorPos.cols);
        const diff = lineRows - cursorPos.rows;
        if (diff > 0) {
            moveCursor(this.output, 0, -diff);
        }
        this.prevRows = cursorPos.rows;
    }
    close() {
        if (this.closed) return;
        this.pause();
        if (this.terminal) {
            this[kSetRawMode](false);
        }
        this.closed = true;
        this.emit("close");
    }
    pause() {
        if (this.paused) return;
        this.input.pause();
        this.paused = true;
        this.emit("pause");
        return this;
    }
    resume() {
        if (!this.paused) return;
        this.input.resume();
        this.paused = false;
        this.emit("resume");
        return this;
    }
    write(d, key) {
        if (this.paused) this.resume();
        if (this.terminal) {
            this[kTtyWrite](d, key);
        } else {
            this[kNormalWrite](d);
        }
    }
    [kNormalWrite](b) {
        if (b === undefined) {
            return;
        }
        let string = this[kDecoder].write(b);
        if (this[kSawReturnAt] && Date.now() - this[kSawReturnAt] <= this.crlfDelay) {
            string = string.replace(/^\n/, "");
            this[kSawReturnAt] = 0;
        }
        const newPartContainsEnding = lineEnding.test(string);
        if (this[kLine_buffer]) {
            string = this[kLine_buffer] + string;
            this[kLine_buffer] = null;
        }
        if (newPartContainsEnding) {
            this[kSawReturnAt] = string.endsWith("\r") ? Date.now() : 0;
            const lines = string.split(lineEnding);
            string = lines.pop();
            this[kLine_buffer] = string;
            for(let n = 0; n < lines.length; n++)this[kOnLine](lines[n]);
        } else if (string) {
            this[kLine_buffer] = string;
        }
    }
    [kInsertString](c) {
        if (this.cursor < this.line.length) {
            const beg = this.line.slice(0, this.cursor);
            const end = this.line.slice(this.cursor, this.line.length);
            this.line = beg + c + end;
            this.cursor += c.length;
            this[kRefreshLine]();
        } else {
            this.line += c;
            this.cursor += c.length;
            if (this.getCursorPos().cols === 0) {
                this[kRefreshLine]();
            } else {
                this[kWriteToOutput](c);
            }
        }
    }
    async [kTabComplete](lastKeypressWasTab) {
        this.pause();
        const string = this.line.slice(0, this.cursor);
        let value;
        try {
            value = await this.completer(string);
        } catch (err) {
            this[kWriteToOutput](`Tab completion error: ${err}`);
            return;
        } finally{
            this.resume();
        }
        this[kTabCompleter](lastKeypressWasTab, value);
    }
    [kTabCompleter](lastKeypressWasTab, { 0: completions , 1: completeOn  }) {
        if (!completions || completions.length === 0) {
            return;
        }
        const prefix = commonPrefix(completions.filter((e)=>e !== ""));
        if (prefix.startsWith(completeOn) && prefix.length > completeOn.length) {
            this[kInsertString](prefix.slice(completeOn.length));
            return;
        } else if (!completeOn.startsWith(prefix)) {
            this.line = this.line.slice(0, this.cursor - completeOn.length) + prefix + this.line.slice(this.cursor, this.line.length);
            this.cursor = this.cursor - completeOn.length + prefix.length;
            this._refreshLine();
            return;
        }
        if (!lastKeypressWasTab) {
            return;
        }
        const completionsWidth = completions.map((e)=>getStringWidth(e));
        const width = Math.max.apply(completionsWidth) + 2;
        let maxColumns = Math.floor(this.columns / width) || 1;
        if (maxColumns === Infinity) {
            maxColumns = 1;
        }
        let output = "\r\n";
        let lineIndex = 0;
        let whitespace = 0;
        for(let i = 0; i < completions.length; i++){
            const completion = completions[i];
            if (completion === "" || lineIndex === maxColumns) {
                output += "\r\n";
                lineIndex = 0;
                whitespace = 0;
            } else {
                output += " ".repeat(whitespace);
            }
            if (completion !== "") {
                output += completion;
                whitespace = width - completionsWidth[i];
                lineIndex++;
            } else {
                output += "\r\n";
            }
        }
        if (lineIndex !== 0) {
            output += "\r\n\r\n";
        }
        this[kWriteToOutput](output);
        this[kRefreshLine]();
    }
    [kWordLeft]() {
        if (this.cursor > 0) {
            const leading = this.line.slice(0, this.cursor);
            const reversed = Array.from(leading).reverse().join("");
            const match = reversed.match(/^\s*(?:[^\w\s]+|\w+)?/);
            this[kMoveCursor](-match[0].length);
        }
    }
    [kWordRight]() {
        if (this.cursor < this.line.length) {
            const trailing = this.line.slice(this.cursor);
            const match = trailing.match(/^(?:\s+|[^\w\s]+|\w+)\s*/);
            this[kMoveCursor](match[0].length);
        }
    }
    [kDeleteLeft]() {
        if (this.cursor > 0 && this.line.length > 0) {
            const charSize = charLengthLeft(this.line, this.cursor);
            this.line = this.line.slice(0, this.cursor - charSize) + this.line.slice(this.cursor, this.line.length);
            this.cursor -= charSize;
            this[kRefreshLine]();
        }
    }
    [kDeleteRight]() {
        if (this.cursor < this.line.length) {
            const charSize = charLengthAt(this.line, this.cursor);
            this.line = this.line.slice(0, this.cursor) + this.line.slice(this.cursor + charSize, this.line.length);
            this[kRefreshLine]();
        }
    }
    [kDeleteWordLeft]() {
        if (this.cursor > 0) {
            let leading = this.line.slice(0, this.cursor);
            const reversed = Array.from(leading).reverse().join("");
            const match = reversed.match(/^\s*(?:[^\w\s]+|\w+)?/);
            leading = leading.slice(0, leading.length - match[0].length);
            this.line = leading + this.line.slice(this.cursor, this.line.length);
            this.cursor = leading.length;
            this[kRefreshLine]();
        }
    }
    [kDeleteWordRight]() {
        if (this.cursor < this.line.length) {
            const trailing = this.line.slice(this.cursor);
            const match = trailing.match(/^(?:\s+|\W+|\w+)\s*/);
            this.line = this.line.slice(0, this.cursor) + trailing.slice(match[0].length);
            this[kRefreshLine]();
        }
    }
    [kDeleteLineLeft]() {
        this.line = this.line.slice(this.cursor);
        this.cursor = 0;
        this[kRefreshLine]();
    }
    [kDeleteLineRight]() {
        this.line = this.line.slice(0, this.cursor);
        this[kRefreshLine]();
    }
    clearLine() {
        this[kMoveCursor](+Infinity);
        this[kWriteToOutput]("\r\n");
        this.line = "";
        this.cursor = 0;
        this.prevRows = 0;
    }
    [kLine]() {
        const line = this[kAddHistory]();
        this.clearLine();
        this[kOnLine](line);
    }
    [kHistoryNext]() {
        if (this.historyIndex >= 0) {
            const search = this[kSubstringSearch] || "";
            let index = this.historyIndex - 1;
            while(index >= 0 && (!this.history[index].startsWith(search) || this.line === this.history[index])){
                index--;
            }
            if (index === -1) {
                this.line = search;
            } else {
                this.line = this.history[index];
            }
            this.historyIndex = index;
            this.cursor = this.line.length;
            this[kRefreshLine]();
        }
    }
    [kHistoryPrev]() {
        if (this.historyIndex < this.history.length && this.history.length) {
            const search = this[kSubstringSearch] || "";
            let index = this.historyIndex + 1;
            while(index < this.history.length && (!this.history[index].startsWith(search) || this.line === this.history[index])){
                index++;
            }
            if (index === this.history.length) {
                this.line = search;
            } else {
                this.line = this.history[index];
            }
            this.historyIndex = index;
            this.cursor = this.line.length;
            this[kRefreshLine]();
        }
    }
    [kGetDisplayPos](str) {
        let offset = 0;
        const col = this.columns;
        let rows = 0;
        str = stripVTControlCharacters(str);
        for (const __char of str[Symbol.iterator]()){
            if (__char === "\n") {
                rows += Math.ceil(offset / col) || 1;
                offset = 0;
                continue;
            }
            if (__char === "\t") {
                offset += this.tabSize - offset % this.tabSize;
                continue;
            }
            const width = getStringWidth(__char);
            if (width === 0 || width === 1) {
                offset += width;
            } else {
                if ((offset + 1) % col === 0) {
                    offset++;
                }
                offset += 2;
            }
        }
        const cols = offset % col;
        rows += (offset - cols) / col;
        return {
            cols,
            rows
        };
    }
    getCursorPos() {
        const strBeforeCursor = this[kPrompt] + this.line.slice(0, this.cursor);
        return this[kGetDisplayPos](strBeforeCursor);
    }
    [kMoveCursor](dx) {
        if (dx === 0) {
            return;
        }
        const oldPos = this.getCursorPos();
        this.cursor += dx;
        if (this.cursor < 0) {
            this.cursor = 0;
        } else if (this.cursor > this.line.length) {
            this.cursor = this.line.length;
        }
        const newPos = this.getCursorPos();
        if (oldPos.rows === newPos.rows) {
            const diffWidth = newPos.cols - oldPos.cols;
            moveCursor(this.output, diffWidth, 0);
        } else {
            this[kRefreshLine]();
        }
    }
    [kTtyWrite](s, key) {
        const previousKey = this[kPreviousKey];
        key = key || {};
        this[kPreviousKey] = key;
        if ((key.name === "up" || key.name === "down") && !key.ctrl && !key.meta && !key.shift) {
            if (this[kSubstringSearch] === null) {
                this[kSubstringSearch] = this.line.slice(0, this.cursor);
            }
        } else if (this[kSubstringSearch] !== null) {
            this[kSubstringSearch] = null;
            if (this.history.length === this.historyIndex) {
                this.historyIndex = -1;
            }
        }
        if (key.name === "escape") return;
        if (key.ctrl && key.shift) {
            switch(key.name){
                case "backspace":
                    this[kDeleteLineLeft]();
                    break;
                case "delete":
                    this[kDeleteLineRight]();
                    break;
            }
        } else if (key.ctrl) {
            switch(key.name){
                case "c":
                    if (this.listenerCount("SIGINT") > 0) {
                        this.emit("SIGINT");
                    } else {
                        this.close();
                    }
                    break;
                case "h":
                    this[kDeleteLeft]();
                    break;
                case "d":
                    if (this.cursor === 0 && this.line.length === 0) {
                        this.close();
                    } else if (this.cursor < this.line.length) {
                        this[kDeleteRight]();
                    }
                    break;
                case "u":
                    this[kDeleteLineLeft]();
                    break;
                case "k":
                    this[kDeleteLineRight]();
                    break;
                case "a":
                    this[kMoveCursor](-Infinity);
                    break;
                case "e":
                    this[kMoveCursor](+Infinity);
                    break;
                case "b":
                    this[kMoveCursor](-charLengthLeft(this.line, this.cursor));
                    break;
                case "f":
                    this[kMoveCursor](+charLengthAt(this.line, this.cursor));
                    break;
                case "l":
                    cursorTo(this.output, 0, 0);
                    clearScreenDown(this.output);
                    this[kRefreshLine]();
                    break;
                case "n":
                    this[kHistoryNext]();
                    break;
                case "p":
                    this[kHistoryPrev]();
                    break;
                case "z":
                    if (process.platform === "win32") break;
                    if (this.listenerCount("SIGTSTP") > 0) {
                        this.emit("SIGTSTP");
                    } else {
                        process.once("SIGCONT", ()=>{
                            if (!this.paused) {
                                this.pause();
                                this.emit("SIGCONT");
                            }
                            this[kSetRawMode](true);
                            this[kRefreshLine]();
                        });
                        this[kSetRawMode](false);
                        process.kill(process.pid, "SIGTSTP");
                    }
                    break;
                case "w":
                case "backspace":
                    this[kDeleteWordLeft]();
                    break;
                case "delete":
                    this[kDeleteWordRight]();
                    break;
                case "left":
                    this[kWordLeft]();
                    break;
                case "right":
                    this[kWordRight]();
                    break;
            }
        } else if (key.meta) {
            switch(key.name){
                case "b":
                    this[kWordLeft]();
                    break;
                case "f":
                    this[kWordRight]();
                    break;
                case "d":
                case "delete":
                    this[kDeleteWordRight]();
                    break;
                case "backspace":
                    this[kDeleteWordLeft]();
                    break;
            }
        } else {
            if (this[kSawReturnAt] && key.name !== "enter") this[kSawReturnAt] = 0;
            switch(key.name){
                case "return":
                    this[kSawReturnAt] = Date.now();
                    this[kLine]();
                    break;
                case "enter":
                    if (this[kSawReturnAt] === 0 || Date.now() - this[kSawReturnAt] > this.crlfDelay) {
                        this[kLine]();
                    }
                    this[kSawReturnAt] = 0;
                    break;
                case "backspace":
                    this[kDeleteLeft]();
                    break;
                case "delete":
                    this[kDeleteRight]();
                    break;
                case "left":
                    this[kMoveCursor](-charLengthLeft(this.line, this.cursor));
                    break;
                case "right":
                    this[kMoveCursor](+charLengthAt(this.line, this.cursor));
                    break;
                case "home":
                    this[kMoveCursor](-Infinity);
                    break;
                case "end":
                    this[kMoveCursor](+Infinity);
                    break;
                case "up":
                    this[kHistoryPrev]();
                    break;
                case "down":
                    this[kHistoryNext]();
                    break;
                case "tab":
                    if (typeof this.completer === "function" && this.isCompletionEnabled) {
                        const lastKeypressWasTab = previousKey && previousKey.name === "tab";
                        this[kTabComplete](lastKeypressWasTab);
                        break;
                    }
                default:
                    if (typeof s === "string" && s) {
                        const lines = s.split(/\r\n|\n|\r/);
                        for(let i = 0, len = lines.length; i < len; i++){
                            if (i > 0) {
                                this[kLine]();
                            }
                            this[kInsertString](lines[i]);
                        }
                    }
            }
        }
    }
    [Symbol.asyncIterator]() {
        if (this[kLineObjectStream] === undefined) {
            const readable = new Au({
                objectMode: true,
                read: ()=>{
                    this.resume();
                },
                destroy: (err, cb)=>{
                    this.off("line", lineListener);
                    this.off("close", closeListener);
                    this.close();
                    cb(err);
                }
            });
            const lineListener = (input)=>{
                if (!readable.push(input)) {
                    this.pause();
                }
            };
            const closeListener = ()=>{
                readable.push(null);
            };
            const errorListener = (err)=>{
                readable.destroy(err);
            };
            this.on("error", errorListener);
            this.on("line", lineListener);
            this.on("close", closeListener);
            this[kLineObjectStream] = readable;
        }
        return this[kLineObjectStream][Symbol.asyncIterator]();
    }
}
class Interface1 extends Interface {
    constructor(input, output, completer, terminal){
        super(input, output, completer, terminal);
    }
    question(query, options = kEmptyObject) {
        return new Promise((resolve, reject)=>{
            let cb = resolve;
            if (options?.signal) {
                validateAbortSignal(options.signal, "options.signal");
                if (options.signal.aborted) {
                    return reject(new AbortError(undefined, {
                        cause: options.signal.reason
                    }));
                }
                const onAbort = ()=>{
                    this[kQuestionCancel]();
                    reject(new AbortError(undefined, {
                        cause: options.signal.reason
                    }));
                };
                options.signal.addEventListener("abort", onAbort, {
                    once: true
                });
                cb = (answer)=>{
                    options.signal.removeEventListener("abort", onAbort);
                    resolve(answer);
                };
            }
            this[kQuestion](query, cb);
        });
    }
}
function createInterface(inputOrOptions, output, completer, terminal) {
    return new Interface1(inputOrOptions, output, completer, terminal);
}
const __default64 = {
    Interface: Interface1,
    Readline,
    createInterface
};
function Interface2(input, output, completer, terminal) {
    if (!(this instanceof Interface2)) {
        return new Interface2(input, output, completer, terminal);
    }
    if (input?.input && typeof input.completer === "function" && input.completer.length !== 2) {
        const { completer  } = input;
        input.completer = (v, cb)=>cb(null, completer(v));
    } else if (typeof completer === "function" && completer.length !== 2) {
        const realCompleter = completer;
        completer = (v, cb)=>cb(null, realCompleter(v));
    }
    InterfaceConstructor.bind(this)(input, output, completer, terminal);
    if (process2.env.TERM === "dumb") {
        this._ttyWrite = _ttyWriteDumb.bind(this);
    }
}
Object.setPrototypeOf(Interface2.prototype, Interface.prototype);
Object.setPrototypeOf(Interface2, Interface);
Interface2.prototype.question = function question(query, options, cb) {
    cb = typeof options === "function" ? options : cb;
    options = typeof options === "object" && options !== null ? options : {};
    if (options.signal) {
        validateAbortSignal(options.signal, "options.signal");
        if (options.signal.aborted) {
            return;
        }
        const onAbort = ()=>{
            this[kQuestionCancel]();
        };
        options.signal.addEventListener("abort", onAbort, {
            once: true
        });
        const cleanup = ()=>{
            options.signal.removeEventListener(onAbort);
        };
        cb = typeof cb === "function" ? (answer)=>{
            cleanup();
            return cb(answer);
        } : cleanup;
    }
    if (typeof cb === "function") {
        this[kQuestion](query, cb);
    }
};
Interface2.prototype.question[promisify.custom] = function question(query, options) {
    options = typeof options === "object" && options !== null ? options : {};
    if (options.signal && options.signal.aborted) {
        return Promise.reject(new AbortError(undefined, {
            cause: options.signal.reason
        }));
    }
    return new Promise((resolve, reject)=>{
        let cb = resolve;
        if (options.signal) {
            const onAbort = ()=>{
                reject(new AbortError(undefined, {
                    cause: options.signal.reason
                }));
            };
            options.signal.addEventListener("abort", onAbort, {
                once: true
            });
            cb = (answer)=>{
                options.signal.removeEventListener("abort", onAbort);
                resolve(answer);
            };
        }
        this.question(query, options, cb);
    });
};
function createInterface1(input, output, completer, terminal) {
    return new Interface2(input, output, completer, terminal);
}
Object.defineProperties(Interface2.prototype, {
    [kSetRawMode]: {
        get () {
            return this._setRawMode;
        }
    },
    [kOnLine]: {
        get () {
            return this._onLine;
        }
    },
    [kWriteToOutput]: {
        get () {
            return this._writeToOutput;
        }
    },
    [kAddHistory]: {
        get () {
            return this._addHistory;
        }
    },
    [kRefreshLine]: {
        get () {
            return this._refreshLine;
        }
    },
    [kNormalWrite]: {
        get () {
            return this._normalWrite;
        }
    },
    [kInsertString]: {
        get () {
            return this._insertString;
        }
    },
    [kTabComplete]: {
        get () {
            return this._tabComplete;
        }
    },
    [kWordLeft]: {
        get () {
            return this._wordLeft;
        }
    },
    [kWordRight]: {
        get () {
            return this._wordRight;
        }
    },
    [kDeleteLeft]: {
        get () {
            return this._deleteLeft;
        }
    },
    [kDeleteRight]: {
        get () {
            return this._deleteRight;
        }
    },
    [kDeleteWordLeft]: {
        get () {
            return this._deleteWordLeft;
        }
    },
    [kDeleteWordRight]: {
        get () {
            return this._deleteWordRight;
        }
    },
    [kDeleteLineLeft]: {
        get () {
            return this._deleteLineLeft;
        }
    },
    [kDeleteLineRight]: {
        get () {
            return this._deleteLineRight;
        }
    },
    [kLine]: {
        get () {
            return this._line;
        }
    },
    [kHistoryNext]: {
        get () {
            return this._historyNext;
        }
    },
    [kHistoryPrev]: {
        get () {
            return this._historyPrev;
        }
    },
    [kGetDisplayPos]: {
        get () {
            return this._getDisplayPos;
        }
    },
    [kMoveCursor]: {
        get () {
            return this._moveCursor;
        }
    },
    [kTtyWrite]: {
        get () {
            return this._ttyWrite;
        }
    },
    _decoder: {
        get () {
            return this[kDecoder];
        },
        set (value) {
            this[kDecoder] = value;
        }
    },
    _line_buffer: {
        get () {
            return this[kLine_buffer];
        },
        set (value) {
            this[kLine_buffer] = value;
        }
    },
    _oldPrompt: {
        get () {
            return this[kOldPrompt];
        },
        set (value) {
            this[kOldPrompt] = value;
        }
    },
    _previousKey: {
        get () {
            return this[kPreviousKey];
        },
        set (value) {
            this[kPreviousKey] = value;
        }
    },
    _prompt: {
        get () {
            return this[kPrompt];
        },
        set (value) {
            this[kPrompt] = value;
        }
    },
    _questionCallback: {
        get () {
            return this[kQuestionCallback];
        },
        set (value) {
            this[kQuestionCallback] = value;
        }
    },
    _sawKeyPress: {
        get () {
            return this[kSawKeyPress];
        },
        set (value) {
            this[kSawKeyPress] = value;
        }
    },
    _sawReturnAt: {
        get () {
            return this[kSawReturnAt];
        },
        set (value) {
            this[kSawReturnAt] = value;
        }
    }
});
Interface2.prototype._setRawMode = Interface.prototype[kSetRawMode];
Interface2.prototype._onLine = Interface.prototype[kOnLine];
Interface2.prototype._writeToOutput = Interface.prototype[kWriteToOutput];
Interface2.prototype._addHistory = Interface.prototype[kAddHistory];
Interface2.prototype._refreshLine = Interface.prototype[kRefreshLine];
Interface2.prototype._normalWrite = Interface.prototype[kNormalWrite];
Interface2.prototype._insertString = Interface.prototype[kInsertString];
Interface2.prototype._tabComplete = function(lastKeypressWasTab) {
    this.pause();
    const string = this.line.slice(0, this.cursor);
    this.completer(string, (err, value)=>{
        this.resume();
        if (err) {
            this._writeToOutput(`Tab completion error: ${err}`);
            return;
        }
        this[kTabCompleter](lastKeypressWasTab, value);
    });
};
Interface2.prototype._wordLeft = Interface.prototype[kWordLeft];
Interface2.prototype._wordRight = Interface.prototype[kWordRight];
Interface2.prototype._deleteLeft = Interface.prototype[kDeleteLeft];
Interface2.prototype._deleteRight = Interface.prototype[kDeleteRight];
Interface2.prototype._deleteWordLeft = Interface.prototype[kDeleteWordLeft];
Interface2.prototype._deleteWordRight = Interface.prototype[kDeleteWordRight];
Interface2.prototype._deleteLineLeft = Interface.prototype[kDeleteLineLeft];
Interface2.prototype._deleteLineRight = Interface.prototype[kDeleteLineRight];
Interface2.prototype._line = Interface.prototype[kLine];
Interface2.prototype._historyNext = Interface.prototype[kHistoryNext];
Interface2.prototype._historyPrev = Interface.prototype[kHistoryPrev];
Interface2.prototype._getDisplayPos = Interface.prototype[kGetDisplayPos];
Interface2.prototype._getCursorPos = Interface.prototype.getCursorPos;
Interface2.prototype._moveCursor = Interface.prototype[kMoveCursor];
Interface2.prototype._ttyWrite = Interface.prototype[kTtyWrite];
function _ttyWriteDumb(s, key) {
    key = key || {};
    if (key.name === "escape") return;
    if (this[kSawReturnAt] && key.name !== "enter") {
        this[kSawReturnAt] = 0;
    }
    if (key.ctrl) {
        if (key.name === "c") {
            if (this.listenerCount("SIGINT") > 0) {
                this.emit("SIGINT");
            } else {
                this.close();
            }
            return;
        } else if (key.name === "d") {
            this.close();
            return;
        }
    }
    switch(key.name){
        case "return":
            this[kSawReturnAt] = Date.now();
            this._line();
            break;
        case "enter":
            if (this[kSawReturnAt] === 0 || Date.now() - this[kSawReturnAt] > this.crlfDelay) {
                this._line();
            }
            this[kSawReturnAt] = 0;
            break;
        default:
            if (typeof s === "string" && s) {
                this.line += s;
                this.cursor += s.length;
                this._writeToOutput(s);
            }
    }
}
const __default65 = {
    Interface: Interface2,
    clearLine,
    clearScreenDown,
    createInterface: createInterface1,
    cursorTo,
    emitKeypressEvents,
    moveCursor,
    promises: __default64
};
class REPLServer {
    constructor(){
        notImplemented("REPLServer.prototype.constructor");
    }
}
const builtinModules = [
    "assert",
    "async_hooks",
    "buffer",
    "child_process",
    "cluster",
    "console",
    "constants",
    "crypto",
    "dgram",
    "diagnostics_channel",
    "dns",
    "domain",
    "events",
    "fs",
    "http",
    "http2",
    "https",
    "inspector",
    "module",
    "net",
    "os",
    "path",
    "perf_hooks",
    "process",
    "punycode",
    "querystring",
    "readline",
    "repl",
    "stream",
    "string_decoder",
    "sys",
    "timers",
    "tls",
    "trace_events",
    "tty",
    "url",
    "util",
    "v8",
    "vm",
    "wasi",
    "worker_threads",
    "zlib"
];
function start() {
    notImplemented("repl.start");
}
const __default66 = {
    REPLServer,
    builtinModules,
    start
};
async function blob(stream) {
    const chunks = [];
    for await (const chunk of stream){
        chunks.push(chunk);
    }
    return new Blob(chunks);
}
async function arrayBuffer(stream) {
    const ret = await blob(stream);
    return ret.arrayBuffer();
}
async function buffer(stream) {
    return Buffer1.from(await arrayBuffer(stream));
}
async function text(stream) {
    const dec = new TextDecoder();
    let str = "";
    for await (const chunk of stream){
        if (typeof chunk === "string") {
            str += chunk;
        } else {
            str += dec.decode(chunk, {
                stream: true
            });
        }
    }
    str += dec.decode(undefined, {
        stream: false
    });
    return str;
}
async function json(stream) {
    const str = await text(stream);
    return JSON.parse(str);
}
const __default67 = {
    arrayBuffer,
    blob,
    buffer,
    json,
    text
};
const { finished , pipeline  } = Pu.promises;
const __default68 = {
    finished,
    pipeline
};
ByteLengthQueuingStrategy, CountQueuingStrategy, ReadableByteStreamController, ReadableStream, ReadableStreamDefaultController, ReadableStreamDefaultReader, TextDecoderStream, TextEncoderStream, TransformStream, TransformStreamDefaultController, WritableStream, WritableStreamDefaultController, WritableStreamDefaultWriter;
const __default69 = {
    ReadableStream,
    ReadableStreamDefaultReader,
    ReadableByteStreamController,
    ReadableStreamDefaultController,
    TransformStream,
    TransformStreamDefaultController,
    WritableStream,
    WritableStreamDefaultWriter,
    WritableStreamDefaultController,
    ByteLengthQueuingStrategy,
    CountQueuingStrategy,
    TextEncoderStream,
    TextDecoderStream
};
const setTimeout2 = promisify(__default10.setTimeout), setImmediate1 = promisify(__default10.setImmediate), setInterval1 = promisify(__default10.setInterval);
const __default70 = {
    setTimeout: setTimeout2,
    setImmediate: setImmediate1,
    setInterval: setInterval1
};
function createSecureContext(options) {
    return {
        ca: options?.ca,
        cert: options?.cert,
        key: options?.key
    };
}
const __default71 = {
    createSecureContext
};
const kConnectOptions = Symbol("connect-options");
const kIsVerified = Symbol("verified");
const kPendingSession = Symbol("pendingSession");
const kRes = Symbol("res");
let debug4 = debuglog("tls", (fn)=>{
    debug4 = fn;
});
function onConnectEnd() {
    if (!this._hadError) {
        const options = this[kConnectOptions];
        this._hadError = true;
        const error = connResetException("Client network socket disconnected " + "before secure TLS connection was " + "established");
        error.path = options.path;
        error.host = options.host;
        error.port = options.port;
        error.localAddress = options.localAddress;
        this.destroy(error);
    }
}
class TLSSocket extends Socket {
    _tlsOptions;
    _secureEstablished;
    _securePending;
    _newSessionPending;
    _controlReleased;
    secureConnecting;
    _SNICallback;
    servername;
    alpnProtocol;
    authorized;
    authorizationError;
    [kRes];
    [kIsVerified];
    [kPendingSession];
    [kConnectOptions];
    ssl;
    _start;
    constructor(socket, opts = kEmptyObject){
        const tlsOptions = {
            ...opts
        };
        let hostname = tlsOptions?.secureContext?.servername;
        hostname = opts.host;
        tlsOptions.hostname = hostname;
        tlsOptions?.secureContext?.cert;
        tlsOptions?.secureContext?.key;
        let caCerts = tlsOptions?.secureContext?.ca;
        if (typeof caCerts === "string") caCerts = [
            caCerts
        ];
        tlsOptions.caCerts = caCerts;
        super({
            handle: _wrapHandle(tlsOptions, socket),
            ...opts,
            manualStart: true
        });
        if (socket) {
            this._parent = socket;
        }
        this._tlsOptions = tlsOptions;
        this._secureEstablished = false;
        this._securePending = false;
        this._newSessionPending = false;
        this._controlReleased = false;
        this.secureConnecting = true;
        this._SNICallback = null;
        this.servername = null;
        this.alpnProtocol = null;
        this.authorized = false;
        this.authorizationError = null;
        this[kRes] = null;
        this[kIsVerified] = false;
        this[kPendingSession] = null;
        this.ssl = new class {
            verifyError() {
                return null;
            }
        }();
        const tlssock = this;
        function _wrapHandle(tlsOptions, wrap) {
            let handle;
            if (wrap) {
                handle = wrap._handle;
            }
            const options = tlsOptions;
            if (!handle) {
                handle = options.pipe ? new Pipe(constants2.SOCKET) : new TCP(constants3.SOCKET);
            }
            const afterConnect = handle.afterConnect;
            handle.afterConnect = async (req, status)=>{
                try {
                    const conn = await Deno.startTls(handle[kStreamBaseField], options);
                    tlssock.emit("secure");
                    tlssock.removeListener("end", onConnectEnd);
                    handle[kStreamBaseField] = conn;
                } catch  {}
                return afterConnect.call(handle, req, status);
            };
            handle.verifyError = function() {
                return null;
            };
            handle._parent = handle;
            handle._parentWrap = wrap;
            return handle;
        }
    }
    _tlsError(err) {
        this.emit("_tlsError", err);
        if (this._controlReleased) {
            return err;
        }
        return null;
    }
    _releaseControl() {
        if (this._controlReleased) {
            return false;
        }
        this._controlReleased = true;
        this.removeListener("error", this._tlsError);
        return true;
    }
    getEphemeralKeyInfo() {
        return {};
    }
    isSessionReused() {
        return false;
    }
    setSession(_session) {}
    setServername(_servername) {}
    getPeerCertificate(_detailed) {
        return {
            subject: "localhost",
            subjectaltname: "IP Address:127.0.0.1, IP Address:::1"
        };
    }
}
function normalizeConnectArgs(listArgs) {
    const args = _normalizeArgs(listArgs);
    const options = args[0];
    const cb = args[1];
    if (listArgs[1] !== null && typeof listArgs[1] === "object") {
        ObjectAssign1(options, listArgs[1]);
    } else if (listArgs[2] !== null && typeof listArgs[2] === "object") {
        ObjectAssign1(options, listArgs[2]);
    }
    return cb ? [
        options,
        cb
    ] : [
        options
    ];
}
let ipServernameWarned = false;
function Server3(options, listener) {
    return new ServerImpl1(options, listener);
}
class ServerImpl1 extends EventEmitter {
    listener;
    #closed;
    constructor(options, listener){
        super();
        this.options = options;
        this.#closed = false;
        if (listener) {
            this.on("secureConnection", listener);
        }
    }
    listen(port, callback) {
        const key = this.options.key?.toString();
        const cert = this.options.cert?.toString();
        const hostname = this.options.host ?? "0.0.0.0";
        this.listener = Deno.listenTls({
            port,
            hostname,
            cert,
            key
        });
        callback?.call(this);
        this.#listen(this.listener);
        return this;
    }
    async #listen(listener) {
        while(!this.#closed){
            try {
                const handle = new TCP(constants3.SOCKET, await listener.accept());
                const socket = new Socket({
                    handle
                });
                this.emit("secureConnection", socket);
            } catch (e) {
                if (e instanceof Deno.errors.BadResource) {
                    this.#closed = true;
                }
            }
        }
    }
    close(cb) {
        if (this.listener) {
            this.listener.close();
        }
        cb?.();
        nextTick1(()=>{
            this.emit("close");
        });
        return this;
    }
    address() {
        const addr = this.listener.addr;
        return {
            port: addr.port,
            address: addr.hostname
        };
    }
    options;
}
Server3.prototype = ServerImpl1.prototype;
function createServer4(options, listener) {
    return new ServerImpl1(options, listener);
}
function onConnectSecure() {
    this.authorized = true;
    this.secureConnecting = false;
    debug4("client emit secureConnect. authorized:", this.authorized);
    this.emit("secureConnect");
    this.removeListener("end", onConnectEnd);
}
function connect2(...args) {
    args = normalizeConnectArgs(args);
    let options = args[0];
    const cb = args[1];
    const allowUnauthorized = getAllowUnauthorized();
    options = {
        rejectUnauthorized: !allowUnauthorized,
        ciphers: DEFAULT_CIPHERS,
        checkServerIdentity,
        minDHSize: 1024,
        ...options
    };
    if (!options.keepAlive) {
        options.singleUse = true;
    }
    assert2(typeof options.checkServerIdentity === "function");
    assert2(typeof options.minDHSize === "number", "options.minDHSize is not a number: " + options.minDHSize);
    assert2(options.minDHSize > 0, "options.minDHSize is not a positive number: " + options.minDHSize);
    const context = options.secureContext || createSecureContext(options);
    const tlssock = new TLSSocket(options.socket, {
        allowHalfOpen: options.allowHalfOpen,
        pipe: !!options.path,
        secureContext: context,
        isServer: false,
        requestCert: true,
        rejectUnauthorized: options.rejectUnauthorized !== false,
        session: options.session,
        ALPNProtocols: options.ALPNProtocols,
        requestOCSP: options.requestOCSP,
        enableTrace: options.enableTrace,
        pskCallback: options.pskCallback,
        highWaterMark: options.highWaterMark,
        onread: options.onread,
        signal: options.signal,
        ...options
    });
    options.rejectUnauthorized = options.rejectUnauthorized !== false;
    tlssock[kConnectOptions] = options;
    if (cb) {
        tlssock.once("secureConnect", cb);
    }
    if (!options.socket) {
        if (options.timeout) {
            tlssock.setTimeout(options.timeout);
        }
        tlssock.connect(options, tlssock._start);
    }
    tlssock._releaseControl();
    if (options.session) {
        tlssock.setSession(options.session);
    }
    if (options.servername) {
        if (!ipServernameWarned && isIP(options.servername)) {
            emitWarning1("Setting the TLS ServerName to an IP address is not permitted by " + "RFC 6066. This will be ignored in a future version.", "DeprecationWarning", "DEP0123");
            ipServernameWarned = true;
        }
        tlssock.setServername(options.servername);
    }
    if (options.socket) {
        tlssock._start();
    }
    tlssock.on("secure", onConnectSecure);
    tlssock.prependListener("end", onConnectEnd);
    return tlssock;
}
function getAllowUnauthorized() {
    return false;
}
function checkServerIdentity(_hostname, _cert) {}
function unfqdn(host) {
    return StringPrototypeReplace(host, /[.]$/, "");
}
const DEFAULT_CIPHERS = [
    "AES256-GCM-SHA384",
    "AES128-GCM-SHA256",
    "TLS_CHACHA20_POLY1305_SHA256",
    "ECDHE-ECDSA-AES256-GCM-SHA384",
    "ECDHE-ECDSA-AES128-GCM-SHA256",
    "ECDHE-ECDSA-CHACHA20-POLY1305",
    "ECDHE-RSA-AES256-GCM-SHA384",
    "ECDHE-RSA-AES128-GCM-SHA256",
    "ECDHE-RSA-CHACHA20-POLY1305"
].join(":");
const __default72 = {
    TLSSocket,
    connect: connect2,
    createServer: createServer4,
    checkServerIdentity,
    DEFAULT_CIPHERS,
    Server: Server3,
    unfqdn
};
const cipherMap = {
    "__proto__": null,
    "AES128-GCM-SHA256": "TLS13_AES_128_GCM_SHA256",
    "AES256-GCM-SHA384": "TLS13_AES_256_GCM_SHA384",
    "ECDHE-ECDSA-AES128-GCM-SHA256": "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
    "ECDHE-ECDSA-AES256-GCM-SHA384": "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
    "ECDHE-ECDSA-CHACHA20-POLY1305": "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
    "ECDHE-RSA-AES128-GCM-SHA256": "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
    "ECDHE-RSA-AES256-GCM-SHA384": "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
    "ECDHE-RSA-CHACHA20-POLY1305": "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
    "TLS_AES_128_GCM_SHA256": "TLS13_AES_128_GCM_SHA256",
    "TLS_AES_256_GCM_SHA384": "TLS13_AES_256_GCM_SHA384",
    "TLS_CHACHA20_POLY1305_SHA256": "TLS13_CHACHA20_POLY1305_SHA256"
};
function getCiphers1() {
    return Object.keys(cipherMap).map((name)=>name.toLowerCase());
}
const rootCertificates = undefined;
const DEFAULT_ECDH_CURVE = "auto";
const DEFAULT_MAX_VERSION = "TLSv1.3";
const DEFAULT_MIN_VERSION = "TLSv1.2";
class CryptoStream {
}
class SecurePair {
}
const Server4 = __default72.Server;
function createSecurePair() {
    notImplemented("tls.createSecurePair");
}
__default72.checkServerIdentity;
__default72.connect;
__default71.createSecureContext;
__default72.createServer;
__default72.DEFAULT_CIPHERS;
__default72.TLSSocket;
const __default73 = {
    CryptoStream,
    SecurePair,
    Server: Server4,
    TLSSocket: __default72.TLSSocket,
    checkServerIdentity: __default72.checkServerIdentity,
    connect: __default72.connect,
    createSecureContext: __default71.createSecureContext,
    createSecurePair,
    createServer: __default72.createServer,
    getCiphers: getCiphers1,
    rootCertificates,
    DEFAULT_CIPHERS: __default72.DEFAULT_CIPHERS,
    DEFAULT_ECDH_CURVE,
    DEFAULT_MAX_VERSION,
    DEFAULT_MIN_VERSION
};
function isatty(fd) {
    if (typeof fd !== "number") {
        return false;
    }
    try {
        return Deno.isatty(fd);
    } catch (_) {
        return false;
    }
}
class ReadStream1 extends Socket {
}
class WriteStream1 extends Socket {
}
const __default74 = {
    isatty,
    WriteStream: WriteStream1,
    ReadStream: ReadStream1
};
function cachedDataVersionTag() {
    notImplemented("v8.cachedDataVersionTag");
}
function getHeapCodeStatistics() {
    notImplemented("v8.getHeapCodeStatistics");
}
function getHeapSnapshot() {
    notImplemented("v8.getHeapSnapshot");
}
function getHeapSpaceStatistics() {
    notImplemented("v8.getHeapSpaceStatistics");
}
function getHeapStatistics() {
    notImplemented("v8.getHeapStatistics");
}
function setFlagsFromString() {
    notImplemented("v8.setFlagsFromString");
}
function stopCoverage() {
    notImplemented("v8.stopCoverage");
}
function takeCoverage() {
    notImplemented("v8.takeCoverage");
}
function writeHeapSnapshot() {
    notImplemented("v8.writeHeapSnapshot");
}
function serialize() {
    notImplemented("v8.serialize");
}
function deserialize() {
    notImplemented("v8.deserialize");
}
class Serializer {
    constructor(){
        notImplemented("v8.Serializer.prototype.constructor");
    }
}
class Deserializer {
    constructor(){
        notImplemented("v8.Deserializer.prototype.constructor");
    }
}
class DefaultSerializer {
    constructor(){
        notImplemented("v8.DefaultSerializer.prototype.constructor");
    }
}
class DefaultDeserializer {
    constructor(){
        notImplemented("v8.DefaultDeserializer.prototype.constructor");
    }
}
const promiseHooks = {
    onInit () {
        notImplemented("v8.promiseHooks.onInit");
    },
    onSettled () {
        notImplemented("v8.promiseHooks.onSetttled");
    },
    onBefore () {
        notImplemented("v8.promiseHooks.onBefore");
    },
    createHook () {
        notImplemented("v8.promiseHooks.createHook");
    }
};
const __default75 = {
    cachedDataVersionTag,
    getHeapCodeStatistics,
    getHeapSnapshot,
    getHeapSpaceStatistics,
    getHeapStatistics,
    setFlagsFromString,
    stopCoverage,
    takeCoverage,
    writeHeapSnapshot,
    serialize,
    deserialize,
    Serializer,
    Deserializer,
    DefaultSerializer,
    DefaultDeserializer,
    promiseHooks
};
class Script {
    code;
    constructor(code, _options = {}){
        this.code = `${code}`;
    }
    runInThisContext(_options) {
        return eval.call(globalThis, this.code);
    }
    runInContext(_contextifiedObject, _options) {
        notImplemented("Script.prototype.runInContext");
    }
    runInNewContext(_contextObject, _options) {
        notImplemented("Script.prototype.runInNewContext");
    }
    createCachedData() {
        notImplemented("Script.prototyp.createCachedData");
    }
}
function createContext(_contextObject, _options) {
    notImplemented("createContext");
}
function createScript(code, options) {
    return new Script(code, options);
}
function runInContext(_code, _contextifiedObject, _options) {
    notImplemented("runInContext");
}
function runInNewContext(_code, _contextObject, _options) {
    notImplemented("runInNewContext");
}
function runInThisContext(code, options) {
    return createScript(code, options).runInThisContext(options);
}
function isContext(_maybeContext) {
    notImplemented("isContext");
}
function compileFunction(_code, _params, _options) {
    notImplemented("compileFunction");
}
function measureMemory(_options) {
    notImplemented("measureMemory");
}
const __default76 = {
    Script,
    createContext,
    createScript,
    runInContext,
    runInNewContext,
    runInThisContext,
    isContext,
    compileFunction,
    measureMemory
};
const environmentData = new Map();
let threads = 0;
const kHandle2 = Symbol("kHandle");
const PRIVATE_WORKER_THREAD_NAME = "$DENO_STD_NODE_WORKER_THREAD";
class _Worker extends EventEmitter {
    threadId;
    resourceLimits = {
        maxYoungGenerationSizeMb: -1,
        maxOldGenerationSizeMb: -1,
        codeRangeSizeMb: -1,
        stackSizeMb: 4
    };
    [kHandle2];
    postMessage;
    constructor(specifier, options){
        notImplemented("Worker");
        super();
        if (options?.eval === true) {
            specifier = `data:text/javascript,${specifier}`;
        } else if (typeof specifier === "string") {
            specifier = toFileUrl2(resolve2(specifier));
        }
        const handle = this[kHandle2] = new Worker(specifier, {
            name: PRIVATE_WORKER_THREAD_NAME,
            type: "module"
        });
        handle.addEventListener("error", (event)=>this.emit("error", event.error || event.message));
        handle.addEventListener("messageerror", (event)=>this.emit("messageerror", event.data));
        handle.addEventListener("message", (event)=>this.emit("message", event.data));
        handle.postMessage({
            environmentData,
            threadId: this.threadId = ++threads,
            workerData: options?.workerData
        }, options?.transferList || []);
        this.postMessage = handle.postMessage.bind(handle);
        this.emit("online");
    }
    terminate() {
        this[kHandle2].terminate();
        this.emit("exit", 0);
    }
    getHeapSnapshot = ()=>notImplemented("Worker.prototype.getHeapSnapshot");
    performance = globalThis.performance;
}
const isMainThread = globalThis.name !== PRIVATE_WORKER_THREAD_NAME;
const resourceLimits = isMainThread ? {} : {
    maxYoungGenerationSizeMb: 48,
    maxOldGenerationSizeMb: 2048,
    codeRangeSizeMb: 0,
    stackSizeMb: 4
};
function getEnvironmentData(key) {
    notImplemented("getEnvironmentData");
    return environmentData.get(key);
}
function setEnvironmentData(key, value) {
    notImplemented("setEnvironmentData");
    if (value === undefined) {
        environmentData.delete(key);
    } else {
        environmentData.set(key, value);
    }
}
const _MessagePort = globalThis.MessagePort;
const _MessageChannel = globalThis.MessageChannel;
const BroadcastChannel = globalThis.BroadcastChannel;
const SHARE_ENV = Symbol.for("nodejs.worker_threads.SHARE_ENV");
function markAsUntransferable() {
    notImplemented("markAsUntransferable");
}
function moveMessagePortToContext() {
    notImplemented("moveMessagePortToContext");
}
function receiveMessageOnPort() {
    notImplemented("receiveMessageOnPort");
}
const __default77 = {
    markAsUntransferable,
    moveMessagePortToContext,
    receiveMessageOnPort,
    MessagePort: _MessagePort,
    MessageChannel: _MessageChannel,
    BroadcastChannel,
    Worker: _Worker,
    getEnvironmentData,
    setEnvironmentData,
    SHARE_ENV,
    threadId: 0,
    workerData: null,
    resourceLimits,
    parentPort: null,
    isMainThread
};
const CLOCKID_REALTIME = 0;
const CLOCKID_MONOTONIC = 1;
const CLOCKID_PROCESS_CPUTIME_ID = 2;
const CLOCKID_THREAD_CPUTIME_ID = 3;
const ERRNO_SUCCESS = 0;
const ERRNO_BADF = 8;
const ERRNO_INVAL = 28;
const ERRNO_NOSYS = 52;
const ERRNO_NOTDIR = 54;
const ERRNO_NOTCAPABLE = 76;
const RIGHTS_FD_DATASYNC = 0x0000000000000001n;
const RIGHTS_FD_READ = 0x0000000000000002n;
const RIGHTS_FD_WRITE = 0x0000000000000040n;
const RIGHTS_FD_ALLOCATE = 0x0000000000000100n;
const RIGHTS_FD_READDIR = 0x0000000000004000n;
const RIGHTS_FD_FILESTAT_SET_SIZE = 0x0000000000400000n;
const FILETYPE_UNKNOWN = 0;
const FILETYPE_CHARACTER_DEVICE = 2;
const FILETYPE_DIRECTORY = 3;
const FILETYPE_REGULAR_FILE = 4;
const FILETYPE_SYMBOLIC_LINK = 7;
const FDFLAGS_APPEND = 0x0001;
const FDFLAGS_DSYNC = 0x0002;
const FDFLAGS_NONBLOCK = 0x0004;
const FDFLAGS_RSYNC = 0x0008;
const FDFLAGS_SYNC = 0x0010;
const FSTFLAGS_ATIM_NOW = 0x0002;
const FSTFLAGS_MTIM_NOW = 0x0008;
const LOOKUPFLAGS_SYMLINK_FOLLOW = 0x0001;
const OFLAGS_CREAT = 0x0001;
const OFLAGS_DIRECTORY = 0x0002;
const OFLAGS_EXCL = 0x0004;
const OFLAGS_TRUNC = 0x0008;
const PREOPENTYPE_DIR = 0;
function syscall(target) {
    return function(...args) {
        try {
            return target(...args);
        } catch (err) {
            if (err instanceof ExitStatus) {
                throw err;
            }
            if (!(err instanceof Error)) {
                return 28;
            }
            switch(err.name){
                case "NotFound":
                    return 44;
                case "PermissionDenied":
                    return 2;
                case "ConnectionRefused":
                    return 14;
                case "ConnectionReset":
                    return 15;
                case "ConnectionAborted":
                    return 13;
                case "NotConnected":
                    return 53;
                case "AddrInUse":
                    return 3;
                case "AddrNotAvailable":
                    return 4;
                case "BrokenPipe":
                    return 64;
                case "InvalidData":
                    return 28;
                case "TimedOut":
                    return 73;
                case "Interrupted":
                    return 27;
                case "BadResource":
                    return 8;
                case "Busy":
                    return 10;
                default:
                    return 28;
            }
        }
    };
}
class ExitStatus {
    code;
    constructor(code){
        this.code = code;
    }
}
class Context {
    #args;
    #env;
    #exitOnReturn;
    #memory;
    #fds;
    #started;
    exports;
    constructor(options = {}){
        this.#args = options.args ?? [];
        this.#env = options.env ?? {};
        this.#exitOnReturn = options.exitOnReturn ?? true;
        this.#memory = null;
        this.#fds = [
            {
                rid: options.stdin ?? Deno.stdin.rid,
                type: FILETYPE_CHARACTER_DEVICE,
                flags: FDFLAGS_APPEND
            },
            {
                rid: options.stdout ?? Deno.stdout.rid,
                type: FILETYPE_CHARACTER_DEVICE,
                flags: FDFLAGS_APPEND
            },
            {
                rid: options.stderr ?? Deno.stderr.rid,
                type: FILETYPE_CHARACTER_DEVICE,
                flags: FDFLAGS_APPEND
            }
        ];
        if (options.preopens) {
            for (const [vpath, path] of Object.entries(options.preopens)){
                const entries = Array.from(Deno.readDirSync(path));
                const entry = {
                    type: 3,
                    entries,
                    path,
                    vpath
                };
                this.#fds.push(entry);
            }
        }
        this.exports = {
            "args_get": syscall((argvOffset, argvBufferOffset)=>{
                const args = this.#args;
                const textEncoder = new TextEncoder();
                const memoryData = new Uint8Array(this.#memory.buffer);
                const memoryView = new DataView(this.#memory.buffer);
                for (const arg of args){
                    memoryView.setUint32(argvOffset, argvBufferOffset, true);
                    argvOffset += 4;
                    const data = textEncoder.encode(`${arg}\0`);
                    memoryData.set(data, argvBufferOffset);
                    argvBufferOffset += data.length;
                }
                return ERRNO_SUCCESS;
            }),
            "args_sizes_get": syscall((argcOffset, argvBufferSizeOffset)=>{
                const args = this.#args;
                const textEncoder = new TextEncoder();
                const memoryView = new DataView(this.#memory.buffer);
                memoryView.setUint32(argcOffset, args.length, true);
                memoryView.setUint32(argvBufferSizeOffset, args.reduce(function(acc, arg) {
                    return acc + textEncoder.encode(`${arg}\0`).length;
                }, 0), true);
                return ERRNO_SUCCESS;
            }),
            "environ_get": syscall((environOffset, environBufferOffset)=>{
                const entries = Object.entries(this.#env);
                const textEncoder = new TextEncoder();
                const memoryData = new Uint8Array(this.#memory.buffer);
                const memoryView = new DataView(this.#memory.buffer);
                for (const [key, value] of entries){
                    memoryView.setUint32(environOffset, environBufferOffset, true);
                    environOffset += 4;
                    const data = textEncoder.encode(`${key}=${value}\0`);
                    memoryData.set(data, environBufferOffset);
                    environBufferOffset += data.length;
                }
                return ERRNO_SUCCESS;
            }),
            "environ_sizes_get": syscall((environcOffset, environBufferSizeOffset)=>{
                const entries = Object.entries(this.#env);
                const textEncoder = new TextEncoder();
                const memoryView = new DataView(this.#memory.buffer);
                memoryView.setUint32(environcOffset, entries.length, true);
                memoryView.setUint32(environBufferSizeOffset, entries.reduce(function(acc, [key, value]) {
                    return acc + textEncoder.encode(`${key}=${value}\0`).length;
                }, 0), true);
                return ERRNO_SUCCESS;
            }),
            "clock_res_get": syscall((id, resolutionOffset)=>{
                const memoryView = new DataView(this.#memory.buffer);
                switch(id){
                    case CLOCKID_REALTIME:
                        {
                            const resolution = BigInt(1e6);
                            memoryView.setBigUint64(resolutionOffset, resolution, true);
                            break;
                        }
                    case CLOCKID_MONOTONIC:
                    case CLOCKID_PROCESS_CPUTIME_ID:
                    case CLOCKID_THREAD_CPUTIME_ID:
                        {
                            const resolution = BigInt(1e3);
                            memoryView.setBigUint64(resolutionOffset, resolution, true);
                            break;
                        }
                    default:
                        return ERRNO_INVAL;
                }
                return ERRNO_SUCCESS;
            }),
            "clock_time_get": syscall((id, precision, timeOffset)=>{
                const memoryView = new DataView(this.#memory.buffer);
                switch(id){
                    case CLOCKID_REALTIME:
                        {
                            const time = BigInt(Date.now()) * BigInt(1e6);
                            memoryView.setBigUint64(timeOffset, time, true);
                            break;
                        }
                    case CLOCKID_MONOTONIC:
                    case CLOCKID_PROCESS_CPUTIME_ID:
                    case CLOCKID_THREAD_CPUTIME_ID:
                        {
                            const t = performance.now();
                            const s = Math.trunc(t);
                            const ms = Math.floor((t - s) * 1e3);
                            const time = BigInt(s) * BigInt(1e9) + BigInt(ms) * BigInt(1e6);
                            memoryView.setBigUint64(timeOffset, time, true);
                            break;
                        }
                    default:
                        return ERRNO_INVAL;
                }
                return ERRNO_SUCCESS;
            }),
            "fd_advise": syscall((_fd, _offset, _length, _advice)=>{
                return ERRNO_NOSYS;
            }),
            "fd_allocate": syscall((_fd, _offset, _length)=>{
                return ERRNO_NOSYS;
            }),
            "fd_close": syscall((fd)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (entry.rid) {
                    Deno.close(entry.rid);
                }
                delete this.#fds[fd];
                return ERRNO_SUCCESS;
            }),
            "fd_datasync": syscall((fd)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                Deno.fdatasyncSync(entry.rid);
                return ERRNO_SUCCESS;
            }),
            "fd_fdstat_get": syscall((fd, offset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                const memoryView = new DataView(this.#memory.buffer);
                memoryView.setUint8(offset, entry.type);
                memoryView.setUint16(offset + 2, entry.flags, true);
                memoryView.setBigUint64(offset + 8, 0n, true);
                memoryView.setBigUint64(offset + 16, 0n, true);
                return ERRNO_SUCCESS;
            }),
            "fd_fdstat_set_flags": syscall((_fd, _flags)=>{
                return ERRNO_NOSYS;
            }),
            "fd_fdstat_set_rights": syscall((_fd, _rightsBase, _rightsInheriting)=>{
                return ERRNO_NOSYS;
            }),
            "fd_filestat_get": syscall((fd, offset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                const memoryView = new DataView(this.#memory.buffer);
                const info = Deno.fstatSync(entry.rid);
                if (entry.type === undefined) {
                    switch(true){
                        case info.isFile:
                            entry.type = FILETYPE_REGULAR_FILE;
                            break;
                        case info.isDirectory:
                            entry.type = FILETYPE_DIRECTORY;
                            break;
                        case info.isSymlink:
                            entry.type = FILETYPE_SYMBOLIC_LINK;
                            break;
                        default:
                            entry.type = FILETYPE_UNKNOWN;
                            break;
                    }
                }
                memoryView.setBigUint64(offset, BigInt(info.dev ? info.dev : 0), true);
                offset += 8;
                memoryView.setBigUint64(offset, BigInt(info.ino ? info.ino : 0), true);
                offset += 8;
                memoryView.setUint8(offset, entry.type);
                offset += 8;
                memoryView.setUint32(offset, Number(info.nlink), true);
                offset += 8;
                memoryView.setBigUint64(offset, BigInt(info.size), true);
                offset += 8;
                memoryView.setBigUint64(offset, BigInt(info.atime ? info.atime.getTime() * 1e6 : 0), true);
                offset += 8;
                memoryView.setBigUint64(offset, BigInt(info.mtime ? info.mtime.getTime() * 1e6 : 0), true);
                offset += 8;
                memoryView.setBigUint64(offset, BigInt(info.birthtime ? info.birthtime.getTime() * 1e6 : 0), true);
                offset += 8;
                return ERRNO_SUCCESS;
            }),
            "fd_filestat_set_size": syscall((fd, size)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                Deno.ftruncateSync(entry.rid, Number(size));
                return ERRNO_SUCCESS;
            }),
            "fd_filestat_set_times": syscall((fd, atim, mtim, flags)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.path) {
                    return ERRNO_INVAL;
                }
                if ((flags & FSTFLAGS_ATIM_NOW) == FSTFLAGS_ATIM_NOW) {
                    atim = BigInt(Date.now() * 1e6);
                }
                if ((flags & FSTFLAGS_MTIM_NOW) == FSTFLAGS_MTIM_NOW) {
                    mtim = BigInt(Date.now() * 1e6);
                }
                Deno.utimeSync(entry.path, Number(atim), Number(mtim));
                return ERRNO_SUCCESS;
            }),
            "fd_pread": syscall((fd, iovsOffset, iovsLength, offset, nreadOffset)=>{
                const entry = this.#fds[fd];
                if (entry == null) {
                    return ERRNO_BADF;
                }
                const seek = Deno.seekSync(entry.rid, 0, Deno.SeekMode.Current);
                const memoryView = new DataView(this.#memory.buffer);
                let nread = 0;
                for(let i = 0; i < iovsLength; i++){
                    const dataOffset = memoryView.getUint32(iovsOffset, true);
                    iovsOffset += 4;
                    const dataLength = memoryView.getUint32(iovsOffset, true);
                    iovsOffset += 4;
                    const data = new Uint8Array(this.#memory.buffer, dataOffset, dataLength);
                    nread += Deno.readSync(entry.rid, data);
                }
                Deno.seekSync(entry.rid, seek, Deno.SeekMode.Start);
                memoryView.setUint32(nreadOffset, nread, true);
                return ERRNO_SUCCESS;
            }),
            "fd_prestat_get": syscall((fd, prestatOffset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.vpath) {
                    return ERRNO_BADF;
                }
                const memoryView = new DataView(this.#memory.buffer);
                memoryView.setUint8(prestatOffset, PREOPENTYPE_DIR);
                memoryView.setUint32(prestatOffset + 4, new TextEncoder().encode(entry.vpath).byteLength, true);
                return ERRNO_SUCCESS;
            }),
            "fd_prestat_dir_name": syscall((fd, pathOffset, pathLength)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.vpath) {
                    return ERRNO_BADF;
                }
                const data = new Uint8Array(this.#memory.buffer, pathOffset, pathLength);
                data.set(new TextEncoder().encode(entry.vpath));
                return ERRNO_SUCCESS;
            }),
            "fd_pwrite": syscall((fd, iovsOffset, iovsLength, offset, nwrittenOffset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                const seek = Deno.seekSync(entry.rid, 0, Deno.SeekMode.Current);
                const memoryView = new DataView(this.#memory.buffer);
                let nwritten = 0;
                for(let i = 0; i < iovsLength; i++){
                    const dataOffset = memoryView.getUint32(iovsOffset, true);
                    iovsOffset += 4;
                    const dataLength = memoryView.getUint32(iovsOffset, true);
                    iovsOffset += 4;
                    const data = new Uint8Array(this.#memory.buffer, dataOffset, dataLength);
                    nwritten += Deno.writeSync(entry.rid, data);
                }
                Deno.seekSync(entry.rid, seek, Deno.SeekMode.Start);
                memoryView.setUint32(nwrittenOffset, nwritten, true);
                return ERRNO_SUCCESS;
            }),
            "fd_read": syscall((fd, iovsOffset, iovsLength, nreadOffset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                const memoryView = new DataView(this.#memory.buffer);
                let nread = 0;
                for(let i = 0; i < iovsLength; i++){
                    const dataOffset = memoryView.getUint32(iovsOffset, true);
                    iovsOffset += 4;
                    const dataLength = memoryView.getUint32(iovsOffset, true);
                    iovsOffset += 4;
                    const data = new Uint8Array(this.#memory.buffer, dataOffset, dataLength);
                    nread += Deno.readSync(entry.rid, data);
                }
                memoryView.setUint32(nreadOffset, nread, true);
                return ERRNO_SUCCESS;
            }),
            "fd_readdir": syscall((fd, bufferOffset, bufferLength, cookie, bufferUsedOffset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                const memoryData = new Uint8Array(this.#memory.buffer);
                const memoryView = new DataView(this.#memory.buffer);
                let bufferUsed = 0;
                const entries = Array.from(Deno.readDirSync(entry.path));
                for(let i = Number(cookie); i < entries.length; i++){
                    const nameData = new TextEncoder().encode(entries[i].name);
                    const entryInfo = Deno.statSync(resolve2(entry.path, entries[i].name));
                    const entryData = new Uint8Array(24 + nameData.byteLength);
                    const entryView = new DataView(entryData.buffer);
                    entryView.setBigUint64(0, BigInt(i + 1), true);
                    entryView.setBigUint64(8, BigInt(entryInfo.ino ? entryInfo.ino : 0), true);
                    entryView.setUint32(16, nameData.byteLength, true);
                    let type;
                    switch(true){
                        case entries[i].isFile:
                            type = FILETYPE_REGULAR_FILE;
                            break;
                        case entries[i].isDirectory:
                            type = FILETYPE_REGULAR_FILE;
                            break;
                        case entries[i].isSymlink:
                            type = FILETYPE_SYMBOLIC_LINK;
                            break;
                        default:
                            type = FILETYPE_REGULAR_FILE;
                            break;
                    }
                    entryView.setUint8(20, type);
                    entryData.set(nameData, 24);
                    const data = entryData.slice(0, Math.min(entryData.length, bufferLength - bufferUsed));
                    memoryData.set(data, bufferOffset + bufferUsed);
                    bufferUsed += data.byteLength;
                }
                memoryView.setUint32(bufferUsedOffset, bufferUsed, true);
                return ERRNO_SUCCESS;
            }),
            "fd_renumber": syscall((fd, to)=>{
                if (!this.#fds[fd]) {
                    return ERRNO_BADF;
                }
                if (!this.#fds[to]) {
                    return ERRNO_BADF;
                }
                if (this.#fds[to].rid) {
                    Deno.close(this.#fds[to].rid);
                }
                this.#fds[to] = this.#fds[fd];
                delete this.#fds[fd];
                return ERRNO_SUCCESS;
            }),
            "fd_seek": syscall((fd, offset, whence, newOffsetOffset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                const memoryView = new DataView(this.#memory.buffer);
                const newOffset = Deno.seekSync(entry.rid, Number(offset), whence);
                memoryView.setBigUint64(newOffsetOffset, BigInt(newOffset), true);
                return ERRNO_SUCCESS;
            }),
            "fd_sync": syscall((fd)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                Deno.fsyncSync(entry.rid);
                return ERRNO_SUCCESS;
            }),
            "fd_tell": syscall((fd, offsetOffset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                const memoryView = new DataView(this.#memory.buffer);
                const offset = Deno.seekSync(entry.rid, 0, Deno.SeekMode.Current);
                memoryView.setBigUint64(offsetOffset, BigInt(offset), true);
                return ERRNO_SUCCESS;
            }),
            "fd_write": syscall((fd, iovsOffset, iovsLength, nwrittenOffset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                const memoryView = new DataView(this.#memory.buffer);
                let nwritten = 0;
                for(let i = 0; i < iovsLength; i++){
                    const dataOffset = memoryView.getUint32(iovsOffset, true);
                    iovsOffset += 4;
                    const dataLength = memoryView.getUint32(iovsOffset, true);
                    iovsOffset += 4;
                    const data = new Uint8Array(this.#memory.buffer, dataOffset, dataLength);
                    nwritten += Deno.writeSync(entry.rid, data);
                }
                memoryView.setUint32(nwrittenOffset, nwritten, true);
                return ERRNO_SUCCESS;
            }),
            "path_create_directory": syscall((fd, pathOffset, pathLength)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.path) {
                    return ERRNO_INVAL;
                }
                const textDecoder = new TextDecoder();
                const data = new Uint8Array(this.#memory.buffer, pathOffset, pathLength);
                const path = resolve2(entry.path, textDecoder.decode(data));
                Deno.mkdirSync(path);
                return ERRNO_SUCCESS;
            }),
            "path_filestat_get": syscall((fd, flags, pathOffset, pathLength, bufferOffset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.path) {
                    return ERRNO_INVAL;
                }
                const textDecoder = new TextDecoder();
                const data = new Uint8Array(this.#memory.buffer, pathOffset, pathLength);
                const path = resolve2(entry.path, textDecoder.decode(data));
                const memoryView = new DataView(this.#memory.buffer);
                const info = (flags & LOOKUPFLAGS_SYMLINK_FOLLOW) != 0 ? Deno.statSync(path) : Deno.lstatSync(path);
                memoryView.setBigUint64(bufferOffset, BigInt(info.dev ? info.dev : 0), true);
                bufferOffset += 8;
                memoryView.setBigUint64(bufferOffset, BigInt(info.ino ? info.ino : 0), true);
                bufferOffset += 8;
                switch(true){
                    case info.isFile:
                        memoryView.setUint8(bufferOffset, FILETYPE_REGULAR_FILE);
                        bufferOffset += 8;
                        break;
                    case info.isDirectory:
                        memoryView.setUint8(bufferOffset, FILETYPE_DIRECTORY);
                        bufferOffset += 8;
                        break;
                    case info.isSymlink:
                        memoryView.setUint8(bufferOffset, FILETYPE_SYMBOLIC_LINK);
                        bufferOffset += 8;
                        break;
                    default:
                        memoryView.setUint8(bufferOffset, FILETYPE_UNKNOWN);
                        bufferOffset += 8;
                        break;
                }
                memoryView.setUint32(bufferOffset, Number(info.nlink), true);
                bufferOffset += 8;
                memoryView.setBigUint64(bufferOffset, BigInt(info.size), true);
                bufferOffset += 8;
                memoryView.setBigUint64(bufferOffset, BigInt(info.atime ? info.atime.getTime() * 1e6 : 0), true);
                bufferOffset += 8;
                memoryView.setBigUint64(bufferOffset, BigInt(info.mtime ? info.mtime.getTime() * 1e6 : 0), true);
                bufferOffset += 8;
                memoryView.setBigUint64(bufferOffset, BigInt(info.birthtime ? info.birthtime.getTime() * 1e6 : 0), true);
                bufferOffset += 8;
                return ERRNO_SUCCESS;
            }),
            "path_filestat_set_times": syscall((fd, flags, pathOffset, pathLength, atim, mtim, fstflags)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.path) {
                    return ERRNO_INVAL;
                }
                const textDecoder = new TextDecoder();
                const data = new Uint8Array(this.#memory.buffer, pathOffset, pathLength);
                const path = resolve2(entry.path, textDecoder.decode(data));
                if ((fstflags & FSTFLAGS_ATIM_NOW) == FSTFLAGS_ATIM_NOW) {
                    atim = BigInt(Date.now()) * BigInt(1e6);
                }
                if ((fstflags & FSTFLAGS_MTIM_NOW) == FSTFLAGS_MTIM_NOW) {
                    mtim = BigInt(Date.now()) * BigInt(1e6);
                }
                Deno.utimeSync(path, Number(atim), Number(mtim));
                return ERRNO_SUCCESS;
            }),
            "path_link": syscall((oldFd, oldFlags, oldPathOffset, oldPathLength, newFd, newPathOffset, newPathLength)=>{
                const oldEntry = this.#fds[oldFd];
                const newEntry = this.#fds[newFd];
                if (!oldEntry || !newEntry) {
                    return ERRNO_BADF;
                }
                if (!oldEntry.path || !newEntry.path) {
                    return ERRNO_INVAL;
                }
                const textDecoder = new TextDecoder();
                const oldData = new Uint8Array(this.#memory.buffer, oldPathOffset, oldPathLength);
                const oldPath = resolve2(oldEntry.path, textDecoder.decode(oldData));
                const newData = new Uint8Array(this.#memory.buffer, newPathOffset, newPathLength);
                const newPath = resolve2(newEntry.path, textDecoder.decode(newData));
                Deno.linkSync(oldPath, newPath);
                return ERRNO_SUCCESS;
            }),
            "path_open": syscall((fd, dirflags, pathOffset, pathLength, oflags, rightsBase, rightsInheriting, fdflags, openedFdOffset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.path) {
                    return ERRNO_INVAL;
                }
                const textDecoder = new TextDecoder();
                const pathData = new Uint8Array(this.#memory.buffer, pathOffset, pathLength);
                const resolvedPath = resolve2(entry.path, textDecoder.decode(pathData));
                if (relative2(entry.path, resolvedPath).startsWith("..")) {
                    return ERRNO_NOTCAPABLE;
                }
                let path;
                if ((dirflags & LOOKUPFLAGS_SYMLINK_FOLLOW) == LOOKUPFLAGS_SYMLINK_FOLLOW) {
                    try {
                        path = Deno.realPathSync(resolvedPath);
                        if (relative2(entry.path, path).startsWith("..")) {
                            return ERRNO_NOTCAPABLE;
                        }
                    } catch (_err) {
                        path = resolvedPath;
                    }
                } else {
                    path = resolvedPath;
                }
                if ((oflags & OFLAGS_DIRECTORY) !== 0) {
                    const entries = Array.from(Deno.readDirSync(path));
                    const openedFd = this.#fds.push({
                        flags: fdflags,
                        path,
                        entries
                    }) - 1;
                    const memoryView = new DataView(this.#memory.buffer);
                    memoryView.setUint32(openedFdOffset, openedFd, true);
                    return ERRNO_SUCCESS;
                }
                const options = {
                    read: false,
                    write: false,
                    append: false,
                    truncate: false,
                    create: false,
                    createNew: false
                };
                if ((oflags & OFLAGS_CREAT) !== 0) {
                    options.create = true;
                    options.write = true;
                }
                if ((oflags & OFLAGS_EXCL) !== 0) {
                    options.createNew = true;
                }
                if ((oflags & OFLAGS_TRUNC) !== 0) {
                    options.truncate = true;
                    options.write = true;
                }
                const read = RIGHTS_FD_READ | RIGHTS_FD_READDIR;
                if ((rightsBase & read) != 0n) {
                    options.read = true;
                }
                const write = RIGHTS_FD_DATASYNC | RIGHTS_FD_WRITE | RIGHTS_FD_ALLOCATE | RIGHTS_FD_FILESTAT_SET_SIZE;
                if ((rightsBase & write) != 0n) {
                    options.write = true;
                }
                if ((fdflags & FDFLAGS_APPEND) != 0) {
                    options.append = true;
                }
                if ((fdflags & FDFLAGS_DSYNC) != 0) {}
                if ((fdflags & FDFLAGS_NONBLOCK) != 0) {}
                if ((fdflags & FDFLAGS_RSYNC) != 0) {}
                if ((fdflags & FDFLAGS_SYNC) != 0) {}
                if (!options.read && !options.write && !options.truncate) {
                    options.read = true;
                }
                const { rid  } = Deno.openSync(path, options);
                const openedFd = this.#fds.push({
                    rid,
                    flags: fdflags,
                    path
                }) - 1;
                const memoryView = new DataView(this.#memory.buffer);
                memoryView.setUint32(openedFdOffset, openedFd, true);
                return ERRNO_SUCCESS;
            }),
            "path_readlink": syscall((fd, pathOffset, pathLength, bufferOffset, bufferLength, bufferUsedOffset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.path) {
                    return ERRNO_INVAL;
                }
                const memoryData = new Uint8Array(this.#memory.buffer);
                const memoryView = new DataView(this.#memory.buffer);
                const pathData = new Uint8Array(this.#memory.buffer, pathOffset, pathLength);
                const path = resolve2(entry.path, new TextDecoder().decode(pathData));
                const link = Deno.readLinkSync(path);
                const linkData = new TextEncoder().encode(link);
                memoryData.set(new Uint8Array(linkData, 0, bufferLength), bufferOffset);
                const bufferUsed = Math.min(linkData.byteLength, bufferLength);
                memoryView.setUint32(bufferUsedOffset, bufferUsed, true);
                return ERRNO_SUCCESS;
            }),
            "path_remove_directory": syscall((fd, pathOffset, pathLength)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.path) {
                    return ERRNO_INVAL;
                }
                const textDecoder = new TextDecoder();
                const data = new Uint8Array(this.#memory.buffer, pathOffset, pathLength);
                const path = resolve2(entry.path, textDecoder.decode(data));
                if (!Deno.statSync(path).isDirectory) {
                    return ERRNO_NOTDIR;
                }
                Deno.removeSync(path);
                return ERRNO_SUCCESS;
            }),
            "path_rename": syscall((fd, oldPathOffset, oldPathLength, newFd, newPathOffset, newPathLength)=>{
                const oldEntry = this.#fds[fd];
                const newEntry = this.#fds[newFd];
                if (!oldEntry || !newEntry) {
                    return ERRNO_BADF;
                }
                if (!oldEntry.path || !newEntry.path) {
                    return ERRNO_INVAL;
                }
                const textDecoder = new TextDecoder();
                const oldData = new Uint8Array(this.#memory.buffer, oldPathOffset, oldPathLength);
                const oldPath = resolve2(oldEntry.path, textDecoder.decode(oldData));
                const newData = new Uint8Array(this.#memory.buffer, newPathOffset, newPathLength);
                const newPath = resolve2(newEntry.path, textDecoder.decode(newData));
                Deno.renameSync(oldPath, newPath);
                return ERRNO_SUCCESS;
            }),
            "path_symlink": syscall((oldPathOffset, oldPathLength, fd, newPathOffset, newPathLength)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.path) {
                    return ERRNO_INVAL;
                }
                const textDecoder = new TextDecoder();
                const oldData = new Uint8Array(this.#memory.buffer, oldPathOffset, oldPathLength);
                const oldPath = textDecoder.decode(oldData);
                const newData = new Uint8Array(this.#memory.buffer, newPathOffset, newPathLength);
                const newPath = resolve2(entry.path, textDecoder.decode(newData));
                Deno.symlinkSync(oldPath, newPath);
                return ERRNO_SUCCESS;
            }),
            "path_unlink_file": syscall((fd, pathOffset, pathLength)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.path) {
                    return ERRNO_INVAL;
                }
                const textDecoder = new TextDecoder();
                const data = new Uint8Array(this.#memory.buffer, pathOffset, pathLength);
                const path = resolve2(entry.path, textDecoder.decode(data));
                Deno.removeSync(path);
                return ERRNO_SUCCESS;
            }),
            "poll_oneoff": syscall((_inOffset, _outOffset, _nsubscriptions, _neventsOffset)=>{
                return ERRNO_NOSYS;
            }),
            "proc_exit": syscall((rval)=>{
                if (this.#exitOnReturn) {
                    Deno.exit(rval);
                }
                throw new ExitStatus(rval);
            }),
            "proc_raise": syscall((_sig)=>{
                return ERRNO_NOSYS;
            }),
            "sched_yield": syscall(()=>{
                return ERRNO_SUCCESS;
            }),
            "random_get": syscall((bufferOffset, bufferLength)=>{
                const buffer = new Uint8Array(this.#memory.buffer, bufferOffset, bufferLength);
                crypto.getRandomValues(buffer);
                return ERRNO_SUCCESS;
            }),
            "sock_recv": syscall((_fd, _riDataOffset, _riDataLength, _riFlags, _roDataLengthOffset, _roFlagsOffset)=>{
                return ERRNO_NOSYS;
            }),
            "sock_send": syscall((_fd, _siDataOffset, _siDataLength, _siFlags, _soDataLengthOffset)=>{
                return ERRNO_NOSYS;
            }),
            "sock_shutdown": syscall((_fd, _how)=>{
                return ERRNO_NOSYS;
            })
        };
        this.#started = false;
    }
    start(instance) {
        if (this.#started) {
            throw new Error("WebAssembly.Instance has already started");
        }
        this.#started = true;
        const { _start , _initialize , memory  } = instance.exports;
        if (!(memory instanceof WebAssembly.Memory)) {
            throw new TypeError("WebAsembly.instance must provide a memory export");
        }
        this.#memory = memory;
        if (typeof _initialize == "function") {
            throw new TypeError("WebAsembly.instance export _initialize must not be a function");
        }
        if (typeof _start != "function") {
            throw new TypeError("WebAssembly.Instance export _start must be a function");
        }
        try {
            _start();
        } catch (err) {
            if (err instanceof ExitStatus) {
                return err.code;
            }
            throw err;
        }
        return null;
    }
    initialize(instance) {
        if (this.#started) {
            throw new Error("WebAssembly.Instance has already started");
        }
        this.#started = true;
        const { _start , _initialize , memory  } = instance.exports;
        if (!(memory instanceof WebAssembly.Memory)) {
            throw new TypeError("WebAsembly.instance must provide a memory export");
        }
        this.#memory = memory;
        if (typeof _start == "function") {
            throw new TypeError("WebAssembly.Instance export _start must not be a function");
        }
        if (_initialize && typeof _initialize != "function") {
            throw new TypeError("WebAssembly.Instance export _initialize must be a function or not be defined");
        }
        _initialize?.();
    }
}
const __default78 = {
    WASI: Context
};
function zero$1(buf) {
    let len = buf.length;
    while(--len >= 0)buf[len] = 0;
}
const LITERALS$1 = 256;
const L_CODES$1 = 256 + 1 + 29;
const D_CODES$1 = 30;
const BL_CODES$1 = 19;
const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
const MAX_BITS$1 = 15;
const Buf_size = 16;
const MAX_BL_BITS = 7;
const END_BLOCK = 256;
const extra_lbits = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0
]);
const extra_dbits = new Uint8Array([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13
]);
const extra_blbits = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    3,
    7
]);
const bl_order = new Uint8Array([
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
]);
const static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(30 * 2);
zero$1(static_dtree);
const _dist_code = new Array(512);
zero$1(_dist_code);
const _length_code = new Array(258 - 3 + 1);
zero$1(_length_code);
const base_length = new Array(29);
zero$1(base_length);
const base_dist = new Array(30);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
}
let static_l_desc;
let static_d_desc;
let static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
}
const d_code = (dist)=>{
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
const put_short = (s, w)=>{
    s.pending_buf[s.pending++] = w & 0xff;
    s.pending_buf[s.pending++] = w >>> 8 & 0xff;
};
const send_bits = (s, value, length)=>{
    if (s.bi_valid > 16 - length) {
        s.bi_buf |= value << s.bi_valid & 0xffff;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
    } else {
        s.bi_buf |= value << s.bi_valid & 0xffff;
        s.bi_valid += length;
    }
};
const send_code = (s, c, tree)=>{
    send_bits(s, tree[c * 2], tree[c * 2 + 1]);
};
const bi_reverse = (code, len)=>{
    let res = 0;
    do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
    }while (--len > 0)
    return res >>> 1;
};
const bi_flush = (s)=>{
    if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 0xff;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
    }
};
const gen_bitlen = (s, desc)=>{
    const tree = desc.dyn_tree;
    const max_code = desc.max_code;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const extra = desc.stat_desc.extra_bits;
    const base = desc.stat_desc.extra_base;
    const max_length = desc.stat_desc.max_length;
    let h;
    let n, m;
    let bits;
    let xbits;
    let f;
    let overflow = 0;
    for(bits = 0; bits <= 15; bits++){
        s.bl_count[bits] = 0;
    }
    tree[s.heap[s.heap_max] * 2 + 1] = 0;
    for(h = s.heap_max + 1; h < HEAP_SIZE$1; h++){
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
            bits = max_length;
            overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) continue;
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
            xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
            s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
    }
    if (overflow === 0) return;
    do {
        bits = max_length - 1;
        while(s.bl_count[bits] === 0)bits--;
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
    }while (overflow > 0)
    for(bits = max_length; bits !== 0; bits--){
        n = s.bl_count[bits];
        while(n !== 0){
            m = s.heap[--h];
            if (m > max_code) continue;
            if (tree[m * 2 + 1] !== bits) {
                s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                tree[m * 2 + 1] = bits;
            }
            n--;
        }
    }
};
const gen_codes = (tree, max_code, bl_count)=>{
    const next_code = new Array(15 + 1);
    let code = 0;
    let bits;
    let n;
    for(bits = 1; bits <= 15; bits++){
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for(n = 0; n <= max_code; n++){
        let len = tree[n * 2 + 1];
        if (len === 0) continue;
        tree[n * 2] = bi_reverse(next_code[len]++, len);
    }
};
const tr_static_init = ()=>{
    let n;
    let bits;
    let length;
    let code;
    let dist;
    const bl_count = new Array(15 + 1);
    length = 0;
    for(code = 0; code < 29 - 1; code++){
        base_length[code] = length;
        for(n = 0; n < 1 << extra_lbits[code]; n++){
            _length_code[length++] = code;
        }
    }
    _length_code[length - 1] = code;
    dist = 0;
    for(code = 0; code < 16; code++){
        base_dist[code] = dist;
        for(n = 0; n < 1 << extra_dbits[code]; n++){
            _dist_code[dist++] = code;
        }
    }
    dist >>= 7;
    for(; code < 30; code++){
        base_dist[code] = dist << 7;
        for(n = 0; n < 1 << extra_dbits[code] - 7; n++){
            _dist_code[256 + dist++] = code;
        }
    }
    for(bits = 0; bits <= 15; bits++){
        bl_count[bits] = 0;
    }
    n = 0;
    while(n <= 143){
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
    }
    while(n <= 255){
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
    }
    while(n <= 279){
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
    }
    while(n <= 287){
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
    for(n = 0; n < 30; n++){
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
const init_block = (s)=>{
    let n;
    for(n = 0; n < L_CODES$1; n++)s.dyn_ltree[n * 2] = 0;
    for(n = 0; n < 30; n++)s.dyn_dtree[n * 2] = 0;
    for(n = 0; n < 19; n++)s.bl_tree[n * 2] = 0;
    s.dyn_ltree[END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
};
const bi_windup = (s)=>{
    if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
};
const copy_block = (s, buf, len, header)=>{
    bi_windup(s);
    if (header) {
        put_short(s, len);
        put_short(s, ~len);
    }
    s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
    s.pending += len;
};
const smaller = (tree, n, m, depth)=>{
    const _n2 = n * 2;
    const _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
};
const pqdownheap = (s, tree, k)=>{
    const v = s.heap[k];
    let j = k << 1;
    while(j <= s.heap_len){
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
            j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) break;
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
    }
    s.heap[k] = v;
};
const compress_block = (s, ltree, dtree)=>{
    let dist;
    let lc;
    let lx = 0;
    let code;
    let extra;
    if (s.last_lit !== 0) {
        do {
            dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
            lc = s.pending_buf[s.l_buf + lx];
            lx++;
            if (dist === 0) {
                send_code(s, lc, ltree);
            } else {
                code = _length_code[lc];
                send_code(s, code + 256 + 1, ltree);
                extra = extra_lbits[code];
                if (extra !== 0) {
                    lc -= base_length[code];
                    send_bits(s, lc, extra);
                }
                dist--;
                code = d_code(dist);
                send_code(s, code, dtree);
                extra = extra_dbits[code];
                if (extra !== 0) {
                    dist -= base_dist[code];
                    send_bits(s, dist, extra);
                }
            }
        }while (lx < s.last_lit)
    }
    send_code(s, 256, ltree);
};
const build_tree = (s, desc)=>{
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE$1;
    for(n = 0; n < elems; n++){
        if (tree[n * 2] !== 0) {
            s.heap[++s.heap_len] = max_code = n;
            s.depth[n] = 0;
        } else {
            tree[n * 2 + 1] = 0;
        }
    }
    while(s.heap_len < 2){
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
            s.static_len -= stree[node * 2 + 1];
        }
    }
    desc.max_code = max_code;
    for(n = s.heap_len >> 1; n >= 1; n--)pqdownheap(s, tree, n);
    node = elems;
    do {
        n = s.heap[1];
        s.heap[1] = s.heap[s.heap_len--];
        pqdownheap(s, tree, 1);
        m = s.heap[1];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[1] = node++;
        pqdownheap(s, tree, 1);
    }while (s.heap_len >= 2)
    s.heap[--s.heap_max] = s.heap[1];
    gen_bitlen(s, desc);
    gen_codes(tree, max_code, s.bl_count);
};
const scan_tree = (s, tree, max_code)=>{
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 0xffff;
    for(n = 0; n <= max_code; n++){
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
            continue;
        } else if (count < min_count) {
            s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
            if (curlen !== prevlen) s.bl_tree[curlen * 2]++;
            s.bl_tree[16 * 2]++;
        } else if (count <= 10) {
            s.bl_tree[17 * 2]++;
        } else {
            s.bl_tree[18 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
        } else {
            max_count = 7;
            min_count = 4;
        }
    }
};
const send_tree = (s, tree, max_code)=>{
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
    }
    for(n = 0; n <= max_code; n++){
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
            continue;
        } else if (count < min_count) {
            do {
                send_code(s, curlen, s.bl_tree);
            }while (--count !== 0)
        } else if (curlen !== 0) {
            if (curlen !== prevlen) {
                send_code(s, curlen, s.bl_tree);
                count--;
            }
            send_code(s, 16, s.bl_tree);
            send_bits(s, count - 3, 2);
        } else if (count <= 10) {
            send_code(s, 17, s.bl_tree);
            send_bits(s, count - 3, 3);
        } else {
            send_code(s, 18, s.bl_tree);
            send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
        } else {
            max_count = 7;
            min_count = 4;
        }
    }
};
const build_bl_tree = (s)=>{
    let max_blindex;
    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    build_tree(s, s.bl_desc);
    for(max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--){
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
            break;
        }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
};
const send_all_trees = (s, lcodes, dcodes, blcodes)=>{
    let rank;
    send_bits(s, lcodes - 257, 5);
    send_bits(s, dcodes - 1, 5);
    send_bits(s, blcodes - 4, 4);
    for(rank = 0; rank < blcodes; rank++){
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
    }
    send_tree(s, s.dyn_ltree, lcodes - 1);
    send_tree(s, s.dyn_dtree, dcodes - 1);
};
const detect_data_type = (s)=>{
    let black_mask = 0xf3ffc07f;
    let n;
    for(n = 0; n <= 31; n++, black_mask >>>= 1){
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
            return 0;
        }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return 1;
    }
    for(n = 32; n < 256; n++){
        if (s.dyn_ltree[n * 2] !== 0) {
            return 1;
        }
    }
    return 0;
};
let static_init_done = false;
const _tr_init$1 = (s)=>{
    if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
    }
    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    init_block(s);
};
const _tr_stored_block$1 = (s, buf, stored_len, last)=>{
    send_bits(s, (0 << 1) + (last ? 1 : 0), 3);
    copy_block(s, buf, stored_len, true);
};
const _tr_align$1 = (s)=>{
    send_bits(s, 1 << 1, 3);
    send_code(s, 256, static_ltree);
    bi_flush(s);
};
const _tr_flush_block$1 = (s, buf, stored_len, last)=>{
    let opt_lenb, static_lenb;
    let max_blindex = 0;
    if (s.level > 0) {
        if (s.strm.data_type === 2) {
            s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
    } else {
        opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block$1(s, buf, stored_len, last);
    } else if (s.strategy === 4 || static_lenb === opt_lenb) {
        send_bits(s, (1 << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
    } else {
        send_bits(s, (2 << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    init_block(s);
    if (last) {
        bi_windup(s);
    }
};
const _tr_tally$1 = (s, dist, lc)=>{
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
    s.last_lit++;
    if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
    } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + 256 + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
    _tr_init: _tr_init_1,
    _tr_stored_block: _tr_stored_block_1,
    _tr_flush_block: _tr_flush_block_1,
    _tr_tally: _tr_tally_1,
    _tr_align: _tr_align_1
};
const adler32 = (adler, buf, len, pos)=>{
    let s1 = adler & 0xffff | 0, s2 = adler >>> 16 & 0xffff | 0, n = 0;
    while(len !== 0){
        n = len > 2000 ? 2000 : len;
        len -= n;
        do {
            s1 = s1 + buf[pos++] | 0;
            s2 = s2 + s1 | 0;
        }while (--n)
        s1 %= 65521;
        s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
const makeTable = ()=>{
    let c, table = [];
    for(var n = 0; n < 256; n++){
        c = n;
        for(var k = 0; k < 8; k++){
            c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
    }
    return table;
};
const crcTable = new Uint32Array(makeTable());
const crc32 = (crc, buf, len, pos)=>{
    const t = crcTable;
    const end = pos + len;
    crc ^= -1;
    for(let i = pos; i < end; i++){
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
    }
    return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
};
var constants$2 = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
};
const { _tr_init , _tr_stored_block , _tr_flush_block , _tr_tally , _tr_align  } = trees;
const { Z_NO_FLUSH: Z_NO_FLUSH$2 , Z_PARTIAL_FLUSH , Z_FULL_FLUSH: Z_FULL_FLUSH$1 , Z_FINISH: Z_FINISH$3 , Z_BLOCK: Z_BLOCK$1 , Z_OK: Z_OK$3 , Z_STREAM_END: Z_STREAM_END$3 , Z_STREAM_ERROR: Z_STREAM_ERROR$2 , Z_DATA_ERROR: Z_DATA_ERROR$2 , Z_BUF_ERROR: Z_BUF_ERROR$1 , Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1 , Z_FILTERED , Z_HUFFMAN_ONLY , Z_RLE , Z_FIXED , Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1 , Z_UNKNOWN , Z_DEFLATED: Z_DEFLATED$2  } = constants$2;
const L_CODES = 256 + 1 + 29;
const D_CODES = 30;
const BL_CODES = 19;
const HEAP_SIZE = 2 * L_CODES + 1;
const MAX_BITS = 15;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = 258 + 3 + 1;
const PRESET_DICT = 0x20;
const INIT_STATE = 42;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const err1 = (strm, errorCode)=>{
    strm.msg = messages[errorCode];
    return errorCode;
};
const rank = (f)=>{
    return (f << 1) - (f > 4 ? 9 : 0);
};
const zero = (buf)=>{
    let len = buf.length;
    while(--len >= 0)buf[len] = 0;
};
let HASH_ZLIB = (s, prev, data)=>(prev << s.hash_shift ^ data) & s.hash_mask;
let HASH = HASH_ZLIB;
const flush_pending = (strm)=>{
    const s = strm.state;
    let len = s.pending;
    if (len > strm.avail_out) {
        len = strm.avail_out;
    }
    if (len === 0) return;
    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
        s.pending_out = 0;
    }
};
const flush_block_only = (s, last)=>{
    _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    flush_pending(s.strm);
};
const put_byte = (s, b)=>{
    s.pending_buf[s.pending++] = b;
};
const putShortMSB = (s, b)=>{
    s.pending_buf[s.pending++] = b >>> 8 & 0xff;
    s.pending_buf[s.pending++] = b & 0xff;
};
const read_buf = (strm, buf, start, size)=>{
    let len = strm.avail_in;
    if (len > size) len = size;
    if (len === 0) return 0;
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
        strm.adler = adler32_1(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
        strm.adler = crc32_1(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
};
const longest_match = (s, cur_match)=>{
    let chain_length = s.max_chain_length;
    let scan = s.strstart;
    let match;
    let len;
    let best_len = s.prev_length;
    let nice_match = s.nice_match;
    const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
    const _win = s.window;
    const wmask = s.w_mask;
    const prev = s.prev;
    const strend = s.strstart + 258;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
    }
    if (nice_match > s.lookahead) nice_match = s.lookahead;
    do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
            continue;
        }
        scan += 2;
        match++;
        do {}while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend)
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
            s.match_start = cur_match;
            best_len = len;
            if (len >= nice_match) {
                break;
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len];
        }
    }while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0)
    if (best_len <= s.lookahead) {
        return best_len;
    }
    return s.lookahead;
};
const fill_window = (s)=>{
    const _w_size = s.w_size;
    let p, n, m, more, str;
    do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
            s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
            s.match_start -= _w_size;
            s.strstart -= _w_size;
            s.block_start -= _w_size;
            n = s.hash_size;
            p = n;
            do {
                m = s.head[--p];
                s.head[p] = m >= _w_size ? m - _w_size : 0;
            }while (--n)
            n = _w_size;
            p = n;
            do {
                m = s.prev[--p];
                s.prev[p] = m >= _w_size ? m - _w_size : 0;
            }while (--n)
            more += _w_size;
        }
        if (s.strm.avail_in === 0) {
            break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= 3) {
            str = s.strstart - s.insert;
            s.ins_h = s.window[str];
            s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
            while(s.insert){
                s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
                s.prev[str & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = str;
                str++;
                s.insert--;
                if (s.lookahead + s.insert < 3) {
                    break;
                }
            }
        }
    }while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0)
};
const deflate_stored = (s, flush)=>{
    let max_block_size = 0xffff;
    if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
    }
    for(;;){
        if (s.lookahead <= 1) {
            fill_window(s);
            if (s.lookahead === 0 && flush === Z_NO_FLUSH$2) {
                return 1;
            }
            if (s.lookahead === 0) {
                break;
            }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        const max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
            s.lookahead = s.strstart - max_start;
            s.strstart = max_start;
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return 1;
            }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return 1;
            }
        }
    }
    s.insert = 0;
    if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
            return 3;
        }
        return 4;
    }
    if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
            return 1;
        }
    }
    return 1;
};
const deflate_fast = (s, flush)=>{
    let hash_head;
    let bflush;
    for(;;){
        if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
                return 1;
            }
            if (s.lookahead === 0) {
                break;
            }
        }
        hash_head = 0;
        if (s.lookahead >= 3) {
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= 3) {
            bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            if (s.match_length <= s.max_lazy_match && s.lookahead >= 3) {
                s.match_length--;
                do {
                    s.strstart++;
                    s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                }while (--s.match_length !== 0)
                s.strstart++;
            } else {
                s.strstart += s.match_length;
                s.match_length = 0;
                s.ins_h = s.window[s.strstart];
                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
            }
        } else {
            bflush = _tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
        }
        if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return 1;
            }
        }
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
            return 3;
        }
        return 4;
    }
    if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
            return 1;
        }
    }
    return 2;
};
const deflate_slow = (s, flush)=>{
    let hash_head;
    let bflush;
    let max_insert;
    for(;;){
        if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
                return 1;
            }
            if (s.lookahead === 0) break;
        }
        hash_head = 0;
        if (s.lookahead >= 3) {
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
            if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === 3 && s.strstart - s.match_start > 4096)) {
                s.match_length = MIN_MATCH - 1;
            }
        }
        if (s.prev_length >= 3 && s.match_length <= s.prev_length) {
            max_insert = s.strstart + s.lookahead - MIN_MATCH;
            bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
            s.lookahead -= s.prev_length - 1;
            s.prev_length -= 2;
            do {
                if (++s.strstart <= max_insert) {
                    s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                }
            }while (--s.prev_length !== 0)
            s.match_available = 0;
            s.match_length = MIN_MATCH - 1;
            s.strstart++;
            if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return 1;
                }
            }
        } else if (s.match_available) {
            bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
            if (bflush) {
                flush_block_only(s, false);
            }
            s.strstart++;
            s.lookahead--;
            if (s.strm.avail_out === 0) {
                return 1;
            }
        } else {
            s.match_available = 1;
            s.strstart++;
            s.lookahead--;
        }
    }
    if (s.match_available) {
        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
            return 3;
        }
        return 4;
    }
    if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
            return 1;
        }
    }
    return 2;
};
const deflate_rle = (s, flush)=>{
    let bflush;
    let prev;
    let scan, strend;
    const _win = s.window;
    for(;;){
        if (s.lookahead <= 258) {
            fill_window(s);
            if (s.lookahead <= 258 && flush === Z_NO_FLUSH$2) {
                return 1;
            }
            if (s.lookahead === 0) break;
        }
        s.match_length = 0;
        if (s.lookahead >= 3 && s.strstart > 0) {
            scan = s.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                strend = s.strstart + MAX_MATCH;
                do {}while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend)
                s.match_length = MAX_MATCH - (strend - scan);
                if (s.match_length > s.lookahead) {
                    s.match_length = s.lookahead;
                }
            }
        }
        if (s.match_length >= 3) {
            bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            s.strstart += s.match_length;
            s.match_length = 0;
        } else {
            bflush = _tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
        }
        if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return 1;
            }
        }
    }
    s.insert = 0;
    if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
            return 3;
        }
        return 4;
    }
    if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
            return 1;
        }
    }
    return 2;
};
const deflate_huff = (s, flush)=>{
    let bflush;
    for(;;){
        if (s.lookahead === 0) {
            fill_window(s);
            if (s.lookahead === 0) {
                if (flush === Z_NO_FLUSH$2) {
                    return 1;
                }
                break;
            }
        }
        s.match_length = 0;
        bflush = _tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return 1;
            }
        }
    }
    s.insert = 0;
    if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
            return 3;
        }
        return 4;
    }
    if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
            return 1;
        }
    }
    return 2;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
}
const configuration_table = [
    new Config(0, 0, 0, 0, deflate_stored),
    new Config(4, 4, 8, 4, deflate_fast),
    new Config(4, 5, 16, 8, deflate_fast),
    new Config(4, 6, 32, 32, deflate_fast),
    new Config(4, 4, 16, 16, deflate_slow),
    new Config(8, 16, 32, 32, deflate_slow),
    new Config(8, 16, 128, 128, deflate_slow),
    new Config(8, 32, 128, 256, deflate_slow),
    new Config(32, 128, 258, 1024, deflate_slow),
    new Config(32, 258, 258, 4096, deflate_slow)
];
const lm_init = (s)=>{
    s.window_size = 2 * s.w_size;
    zero(s.head);
    s.max_lazy_match = configuration_table[s.level].max_lazy;
    s.good_match = configuration_table[s.level].good_length;
    s.nice_match = configuration_table[s.level].nice_length;
    s.max_chain_length = configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
};
function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED$2;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(MAX_BITS + 1);
    this.heap = new Uint16Array(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
}
const deflateResetKeep = (strm)=>{
    if (!strm || !strm.state) {
        return err1(strm, Z_STREAM_ERROR$2);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    const s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
        s.wrap = -s.wrap;
    }
    s.status = s.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = Z_NO_FLUSH$2;
    _tr_init(s);
    return Z_OK$3;
};
const deflateReset = (strm)=>{
    const ret = deflateResetKeep(strm);
    if (ret === Z_OK$3) {
        lm_init(strm.state);
    }
    return ret;
};
const deflateSetHeader = (strm, head)=>{
    if (!strm || !strm.state) return Z_STREAM_ERROR$2;
    if (strm.state.wrap !== 2) return Z_STREAM_ERROR$2;
    strm.state.gzhead = head;
    return Z_OK$3;
};
const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy)=>{
    if (!strm) {
        return Z_STREAM_ERROR$2;
    }
    let wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION$1) {
        level = 6;
    }
    if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
    } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > 9 || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err1(strm, Z_STREAM_ERROR$2);
    }
    if (windowBits === 8) {
        windowBits = 9;
    }
    const s = new DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return deflateReset(strm);
};
const deflateInit = (strm, level)=>{
    return deflateInit2(strm, level, Z_DEFLATED$2, 15, 8, Z_DEFAULT_STRATEGY$1);
};
const deflate$2 = (strm, flush)=>{
    let beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK$1 || flush < 0) {
        return strm ? err1(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
    }
    const s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === 666 && flush !== Z_FINISH$3) {
        return err1(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
    }
    s.strm = strm;
    const old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === 42) {
        if (s.wrap === 2) {
            strm.adler = 0;
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (!s.gzhead) {
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                put_byte(s, 0x03);
                s.status = BUSY_STATE;
            } else {
                put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
                put_byte(s, s.gzhead.time & 0xff);
                put_byte(s, s.gzhead.time >> 8 & 0xff);
                put_byte(s, s.gzhead.time >> 16 & 0xff);
                put_byte(s, s.gzhead.time >> 24 & 0xff);
                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                put_byte(s, s.gzhead.os & 0xff);
                if (s.gzhead.extra && s.gzhead.extra.length) {
                    put_byte(s, s.gzhead.extra.length & 0xff);
                    put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
                }
                if (s.gzhead.hcrc) {
                    strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
                }
                s.gzindex = 0;
                s.status = EXTRA_STATE;
            }
        } else {
            let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
            let level_flags = -1;
            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                level_flags = 0;
            } else if (s.level < 6) {
                level_flags = 1;
            } else if (s.level === 6) {
                level_flags = 2;
            } else {
                level_flags = 3;
            }
            header |= level_flags << 6;
            if (s.strstart !== 0) header |= PRESET_DICT;
            header += 31 - header % 31;
            s.status = BUSY_STATE;
            putShortMSB(s, header);
            if (s.strstart !== 0) {
                putShortMSB(s, strm.adler >>> 16);
                putShortMSB(s, strm.adler & 0xffff);
            }
            strm.adler = 1;
        }
    }
    if (s.status === 69) {
        if (s.gzhead.extra) {
            beg = s.pending;
            while(s.gzindex < (s.gzhead.extra.length & 0xffff)){
                if (s.pending === s.pending_buf_size) {
                    if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    flush_pending(strm);
                    beg = s.pending;
                    if (s.pending === s.pending_buf_size) {
                        break;
                    }
                }
                put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
                s.gzindex++;
            }
            if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (s.gzindex === s.gzhead.extra.length) {
                s.gzindex = 0;
                s.status = NAME_STATE;
            }
        } else {
            s.status = NAME_STATE;
        }
    }
    if (s.status === 73) {
        if (s.gzhead.name) {
            beg = s.pending;
            do {
                if (s.pending === s.pending_buf_size) {
                    if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    flush_pending(strm);
                    beg = s.pending;
                    if (s.pending === s.pending_buf_size) {
                        val = 1;
                        break;
                    }
                }
                if (s.gzindex < s.gzhead.name.length) {
                    val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
                } else {
                    val = 0;
                }
                put_byte(s, val);
            }while (val !== 0)
            if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (val === 0) {
                s.gzindex = 0;
                s.status = COMMENT_STATE;
            }
        } else {
            s.status = COMMENT_STATE;
        }
    }
    if (s.status === 91) {
        if (s.gzhead.comment) {
            beg = s.pending;
            do {
                if (s.pending === s.pending_buf_size) {
                    if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    flush_pending(strm);
                    beg = s.pending;
                    if (s.pending === s.pending_buf_size) {
                        val = 1;
                        break;
                    }
                }
                if (s.gzindex < s.gzhead.comment.length) {
                    val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
                } else {
                    val = 0;
                }
                put_byte(s, val);
            }while (val !== 0)
            if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (val === 0) {
                s.status = HCRC_STATE;
            }
        } else {
            s.status = HCRC_STATE;
        }
    }
    if (s.status === 103) {
        if (s.gzhead.hcrc) {
            if (s.pending + 2 > s.pending_buf_size) {
                flush_pending(strm);
            }
            if (s.pending + 2 <= s.pending_buf_size) {
                put_byte(s, strm.adler & 0xff);
                put_byte(s, strm.adler >> 8 & 0xff);
                strm.adler = 0;
                s.status = BUSY_STATE;
            }
        } else {
            s.status = BUSY_STATE;
        }
    }
    if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK$3;
        }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
        return err1(strm, Z_BUF_ERROR$1);
    }
    if (s.status === 666 && strm.avail_in !== 0) {
        return err1(strm, Z_BUF_ERROR$1);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== 666) {
        let bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === 3 || bstate === 4) {
            s.status = FINISH_STATE;
        }
        if (bstate === 1 || bstate === 3) {
            if (strm.avail_out === 0) {
                s.last_flush = -1;
            }
            return Z_OK$3;
        }
        if (bstate === 2) {
            if (flush === Z_PARTIAL_FLUSH) {
                _tr_align(s);
            } else if (flush !== Z_BLOCK$1) {
                _tr_stored_block(s, 0, 0, false);
                if (flush === Z_FULL_FLUSH$1) {
                    zero(s.head);
                    if (s.lookahead === 0) {
                        s.strstart = 0;
                        s.block_start = 0;
                        s.insert = 0;
                    }
                }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
                s.last_flush = -1;
                return Z_OK$3;
            }
        }
    }
    if (flush !== Z_FINISH$3) return Z_OK$3;
    if (s.wrap <= 0) return Z_STREAM_END$3;
    if (s.wrap === 2) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, strm.adler >> 8 & 0xff);
        put_byte(s, strm.adler >> 16 & 0xff);
        put_byte(s, strm.adler >> 24 & 0xff);
        put_byte(s, strm.total_in & 0xff);
        put_byte(s, strm.total_in >> 8 & 0xff);
        put_byte(s, strm.total_in >> 16 & 0xff);
        put_byte(s, strm.total_in >> 24 & 0xff);
    } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
    }
    flush_pending(strm);
    if (s.wrap > 0) s.wrap = -s.wrap;
    return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
const deflateEnd = (strm)=>{
    if (!strm || !strm.state) {
        return Z_STREAM_ERROR$2;
    }
    const status = strm.state.status;
    if (status !== 42 && status !== 69 && status !== 73 && status !== 91 && status !== 103 && status !== 113 && status !== 666) {
        return err1(strm, Z_STREAM_ERROR$2);
    }
    strm.state = null;
    return status === 113 ? err1(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
const deflateSetDictionary = (strm, dictionary)=>{
    let dictLength = dictionary.length;
    if (!strm || !strm.state) {
        return Z_STREAM_ERROR$2;
    }
    const s = strm.state;
    const wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== 42 || s.lookahead) {
        return Z_STREAM_ERROR$2;
    }
    if (wrap === 1) {
        strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
        if (wrap === 0) {
            zero(s.head);
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
        }
        let tmpDict = new Uint8Array(s.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s);
    while(s.lookahead >= 3){
        let str = s.strstart;
        let n = s.lookahead - (3 - 1);
        do {
            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
        }while (--n)
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
    deflateInit: deflateInit_1,
    deflateInit2: deflateInit2_1,
    deflateReset: deflateReset_1,
    deflateResetKeep: deflateResetKeep_1,
    deflateSetHeader: deflateSetHeader_1,
    deflate: deflate_2$1,
    deflateEnd: deflateEnd_1,
    deflateSetDictionary: deflateSetDictionary_1,
    deflateInfo: deflateInfo
};
const _has = (obj, key)=>{
    return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
    const sources = Array.prototype.slice.call(arguments, 1);
    while(sources.length){
        const source = sources.shift();
        if (!source) continue;
        if (typeof source !== "object") {
            throw new TypeError(source + "must be non-object");
        }
        for(const p in source){
            if (_has(source, p)) {
                obj[p] = source[p];
            }
        }
    }
    return obj;
};
var flattenChunks = (chunks)=>{
    let len = 0;
    for(let i = 0, l = chunks.length; i < l; i++){
        len += chunks[i].length;
    }
    const result = new Uint8Array(len);
    for(let i = 0, pos = 0, l = chunks.length; i < l; i++){
        let chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
    }
    return result;
};
var common1 = {
    assign: assign,
    flattenChunks: flattenChunks
};
let STR_APPLY_UIA_OK = true;
try {
    String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
    STR_APPLY_UIA_OK = false;
}
const _utf8len = new Uint8Array(256);
for(let q = 0; q < 256; q++){
    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str)=>{
    if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
        return new TextEncoder().encode(str);
    }
    let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
    for(m_pos = 0; m_pos < str_len; m_pos++){
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for(i = 0, m_pos = 0; i < buf_len; m_pos++){
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        if (c < 0x80) {
            buf[i++] = c;
        } else if (c < 0x800) {
            buf[i++] = 0xC0 | c >>> 6;
            buf[i++] = 0x80 | c & 0x3f;
        } else if (c < 0x10000) {
            buf[i++] = 0xE0 | c >>> 12;
            buf[i++] = 0x80 | c >>> 6 & 0x3f;
            buf[i++] = 0x80 | c & 0x3f;
        } else {
            buf[i++] = 0xf0 | c >>> 18;
            buf[i++] = 0x80 | c >>> 12 & 0x3f;
            buf[i++] = 0x80 | c >>> 6 & 0x3f;
            buf[i++] = 0x80 | c & 0x3f;
        }
    }
    return buf;
};
const buf2binstring = (buf, len)=>{
    if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK) {
            return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
        }
    }
    let result = "";
    for(let i = 0; i < len; i++){
        result += String.fromCharCode(buf[i]);
    }
    return result;
};
var buf2string = (buf, max)=>{
    const len = max || buf.length;
    if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
        return new TextDecoder().decode(buf.subarray(0, max));
    }
    let i, out;
    const utf16buf = new Array(len * 2);
    for(out = 0, i = 0; i < len;){
        let c = buf[i++];
        if (c < 0x80) {
            utf16buf[out++] = c;
            continue;
        }
        let c_len = _utf8len[c];
        if (c_len > 4) {
            utf16buf[out++] = 0xfffd;
            i += c_len - 1;
            continue;
        }
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        while(c_len > 1 && i < len){
            c = c << 6 | buf[i++] & 0x3f;
            c_len--;
        }
        if (c_len > 1) {
            utf16buf[out++] = 0xfffd;
            continue;
        }
        if (c < 0x10000) {
            utf16buf[out++] = c;
        } else {
            c -= 0x10000;
            utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
            utf16buf[out++] = 0xdc00 | c & 0x3ff;
        }
    }
    return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max)=>{
    max = max || buf.length;
    if (max > buf.length) max = buf.length;
    let pos = max - 1;
    while(pos >= 0 && (buf[pos] & 0xC0) === 0x80)pos--;
    if (pos < 0) return max;
    if (pos === 0) return max;
    return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
    string2buf: string2buf,
    buf2string: buf2string,
    utf8border: utf8border
};
function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
}
var zstream = ZStream;
const toString$1 = Object.prototype.toString;
const { Z_NO_FLUSH: Z_NO_FLUSH$1 , Z_SYNC_FLUSH , Z_FULL_FLUSH , Z_FINISH: Z_FINISH$2 , Z_OK: Z_OK$2 , Z_STREAM_END: Z_STREAM_END$2 , Z_DEFAULT_COMPRESSION , Z_DEFAULT_STRATEGY , Z_DEFLATED: Z_DEFLATED$1  } = constants$2;
function Deflate$1(options) {
    this.options = common1.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED$1,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY
    }, options || {});
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zstream();
    this.strm.avail_out = 0;
    let status = deflate_1$2.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== Z_OK$2) {
        throw new Error(messages[status]);
    }
    if (opt.header) {
        deflate_1$2.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
        let dict;
        if (typeof opt.dictionary === "string") {
            dict = strings.string2buf(opt.dictionary);
        } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
            dict = new Uint8Array(opt.dictionary);
        } else {
            dict = opt.dictionary;
        }
        status = deflate_1$2.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK$2) {
            throw new Error(messages[status]);
        }
        this._dict_set = true;
    }
}
Deflate$1.prototype.push = function(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status, _flush_mode;
    if (this.ended) return false;
    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
    else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
    if (typeof data === "string") {
        strm.input = strings.string2buf(data);
    } else if (toString$1.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
    } else {
        strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for(;;){
        if (strm.avail_out === 0) {
            strm.output = new Uint8Array(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
        }
        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
            this.onData(strm.output.subarray(0, strm.next_out));
            strm.avail_out = 0;
            continue;
        }
        status = deflate_1$2.deflate(strm, _flush_mode);
        if (status === Z_STREAM_END$2) {
            if (strm.next_out > 0) {
                this.onData(strm.output.subarray(0, strm.next_out));
            }
            status = deflate_1$2.deflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === Z_OK$2;
        }
        if (strm.avail_out === 0) {
            this.onData(strm.output);
            continue;
        }
        if (_flush_mode > 0 && strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
            strm.avail_out = 0;
            continue;
        }
        if (strm.avail_in === 0) break;
    }
    return true;
};
Deflate$1.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
    if (status === Z_OK$2) {
        this.result = common1.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
};
function deflate$1(input, options) {
    const deflator = new Deflate$1(options);
    deflator.push(input, true);
    if (deflator.err) throw deflator.msg || messages[deflator.err];
    return deflator.result;
}
function deflateRaw$1(input, options) {
    options = options || {};
    options.raw = true;
    return deflate$1(input, options);
}
function gzip$1(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
    Deflate: Deflate_1$1,
    deflate: deflate_2,
    deflateRaw: deflateRaw_1$1,
    gzip: gzip_1$1,
    constants: constants$1
};
const BAD$1 = 30;
const TYPE$1 = 12;
var inffast = function inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let dmax;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input, output;
    const state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top: do {
        if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
        }
        here = lcode[hold & lmask];
        dolen: for(;;){
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 0xff;
            if (op === 0) {
                output[_out++] = here & 0xffff;
            } else if (op & 16) {
                len = here & 0xffff;
                op &= 15;
                if (op) {
                    if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                    }
                    len += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                }
                if (bits < 15) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    hold += input[_in++] << bits;
                    bits += 8;
                }
                here = dcode[hold & dmask];
                dodist: for(;;){
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 0xff;
                    if (op & 16) {
                        dist = here & 0xffff;
                        op &= 15;
                        if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                            if (bits < op) {
                                hold += input[_in++] << bits;
                                bits += 8;
                            }
                        }
                        dist += hold & (1 << op) - 1;
                        if (dist > dmax) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD$1;
                            break top;
                        }
                        hold >>>= op;
                        bits -= op;
                        op = _out - beg;
                        if (dist > op) {
                            op = dist - op;
                            if (op > whave) {
                                if (state.sane) {
                                    strm.msg = "invalid distance too far back";
                                    state.mode = BAD$1;
                                    break top;
                                }
                            }
                            from = 0;
                            from_source = s_window;
                            if (wnext === 0) {
                                from += wsize - op;
                                if (op < len) {
                                    len -= op;
                                    do {
                                        output[_out++] = s_window[from++];
                                    }while (--op)
                                    from = _out - dist;
                                    from_source = output;
                                }
                            } else if (wnext < op) {
                                from += wsize + wnext - op;
                                op -= wnext;
                                if (op < len) {
                                    len -= op;
                                    do {
                                        output[_out++] = s_window[from++];
                                    }while (--op)
                                    from = 0;
                                    if (wnext < len) {
                                        op = wnext;
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++];
                                        }while (--op)
                                        from = _out - dist;
                                        from_source = output;
                                    }
                                }
                            } else {
                                from += wnext - op;
                                if (op < len) {
                                    len -= op;
                                    do {
                                        output[_out++] = s_window[from++];
                                    }while (--op)
                                    from = _out - dist;
                                    from_source = output;
                                }
                            }
                            while(len > 2){
                                output[_out++] = from_source[from++];
                                output[_out++] = from_source[from++];
                                output[_out++] = from_source[from++];
                                len -= 3;
                            }
                            if (len) {
                                output[_out++] = from_source[from++];
                                if (len > 1) {
                                    output[_out++] = from_source[from++];
                                }
                            }
                        } else {
                            from = _out - dist;
                            do {
                                output[_out++] = output[from++];
                                output[_out++] = output[from++];
                                output[_out++] = output[from++];
                                len -= 3;
                            }while (len > 2)
                            if (len) {
                                output[_out++] = output[from++];
                                if (len > 1) {
                                    output[_out++] = output[from++];
                                }
                            }
                        }
                    } else if ((op & 64) === 0) {
                        here = dcode[(here & 0xffff) + (hold & (1 << op) - 1)];
                        continue dodist;
                    } else {
                        strm.msg = "invalid distance code";
                        state.mode = BAD$1;
                        break top;
                    }
                    break;
                }
            } else if ((op & 64) === 0) {
                here = lcode[(here & 0xffff) + (hold & (1 << op) - 1)];
                continue dolen;
            } else if (op & 32) {
                state.mode = TYPE$1;
                break top;
            } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD$1;
                break top;
            }
            break;
        }
    }while (_in < last && _out < end)
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
};
const MAXBITS = 15;
const lbase = new Uint16Array([
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
]);
const lext = new Uint8Array([
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
]);
const dbase = new Uint16Array([
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
]);
const dext = new Uint8Array([
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
]);
const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts)=>{
    const bits = opts.bits;
    let len = 0;
    let sym = 0;
    let min = 0, max = 0;
    let root = 0;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base = null;
    let base_index = 0;
    let end;
    const count = new Uint16Array(15 + 1);
    const offs = new Uint16Array(15 + 1);
    let extra = null;
    let extra_index = 0;
    let here_bits, here_op, here_val;
    for(len = 0; len <= 15; len++){
        count[len] = 0;
    }
    for(sym = 0; sym < codes; sym++){
        count[lens[lens_index + sym]]++;
    }
    root = bits;
    for(max = MAXBITS; max >= 1; max--){
        if (count[max] !== 0) break;
    }
    if (root > max) {
        root = max;
    }
    if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
    }
    for(min = 1; min < max; min++){
        if (count[min] !== 0) break;
    }
    if (root < min) {
        root = min;
    }
    left = 1;
    for(len = 1; len <= 15; len++){
        left <<= 1;
        left -= count[len];
        if (left < 0) {
            return -1;
        }
    }
    if (left > 0 && (type === 0 || max !== 1)) {
        return -1;
    }
    offs[1] = 0;
    for(len = 1; len < 15; len++){
        offs[len + 1] = offs[len] + count[len];
    }
    for(sym = 0; sym < codes; sym++){
        if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym;
        }
    }
    if (type === 0) {
        base = extra = work;
        end = 19;
    } else if (type === 1) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
    } else {
        base = dbase;
        extra = dext;
        end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === 1 && used > 852 || type === 2 && used > 592) {
        return 1;
    }
    for(;;){
        here_bits = len - drop;
        if (work[sym] < end) {
            here_op = 0;
            here_val = work[sym];
        } else if (work[sym] > end) {
            here_op = extra[extra_index + work[sym]];
            here_val = base[base_index + work[sym]];
        } else {
            here_op = 32 + 64;
            here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
            fill -= incr;
            table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        }while (fill !== 0)
        incr = 1 << len - 1;
        while(huff & incr){
            incr >>= 1;
        }
        if (incr !== 0) {
            huff &= incr - 1;
            huff += incr;
        } else {
            huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
            if (len === max) break;
            len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
            if (drop === 0) {
                drop = root;
            }
            next += min;
            curr = len - drop;
            left = 1 << curr;
            while(curr + drop < max){
                left -= count[curr + drop];
                if (left <= 0) break;
                curr++;
                left <<= 1;
            }
            used += 1 << curr;
            if (type === 1 && used > 852 || type === 2 && used > 592) {
                return 1;
            }
            low = huff & mask;
            table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
    }
    if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
};
var inftrees = inflate_table;
const CODES = 0;
const LENS = 1;
const DISTS = 2;
const { Z_FINISH: Z_FINISH$1 , Z_BLOCK , Z_TREES , Z_OK: Z_OK$1 , Z_STREAM_END: Z_STREAM_END$1 , Z_NEED_DICT: Z_NEED_DICT$1 , Z_STREAM_ERROR: Z_STREAM_ERROR$1 , Z_DATA_ERROR: Z_DATA_ERROR$1 , Z_MEM_ERROR: Z_MEM_ERROR$1 , Z_BUF_ERROR , Z_DEFLATED  } = constants$2;
const HEAD = 1;
const FLAGS = 2;
const TIME = 3;
const OS = 4;
const EXLEN = 5;
const EXTRA = 6;
const NAME = 7;
const COMMENT = 8;
const HCRC = 9;
const DICTID = 10;
const DICT = 11;
const TYPE = 12;
const TYPEDO = 13;
const STORED = 14;
const COPY_ = 15;
const COPY = 16;
const TABLE = 17;
const LENLENS = 18;
const CODELENS = 19;
const LEN_ = 20;
const LEN = 21;
const LENEXT = 22;
const DIST = 23;
const DISTEXT = 24;
const MATCH = 25;
const LIT = 26;
const CHECK = 27;
const LENGTH = 28;
const DONE = 29;
const BAD = 30;
const MEM = 31;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
const zswap32 = (q)=>{
    return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
};
function InflateState() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
}
const inflateResetKeep = (strm)=>{
    if (!strm || !strm.state) return Z_STREAM_ERROR$1;
    const state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
        strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK$1;
};
const inflateReset = (strm)=>{
    if (!strm || !strm.state) return Z_STREAM_ERROR$1;
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
};
const inflateReset2 = (strm, windowBits)=>{
    let wrap;
    if (!strm || !strm.state) return Z_STREAM_ERROR$1;
    const state = strm.state;
    if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
    } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
            windowBits &= 15;
        }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR$1;
    }
    if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
};
const inflateInit2 = (strm, windowBits)=>{
    if (!strm) return Z_STREAM_ERROR$1;
    const state = new InflateState();
    strm.state = state;
    state.window = null;
    const ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK$1) {
        strm.state = null;
    }
    return ret;
};
const inflateInit = (strm)=>{
    return inflateInit2(strm, 15);
};
let virgin = true;
let lenfix, distfix;
const fixedtables = (state)=>{
    if (virgin) {
        lenfix = new Int32Array(512);
        distfix = new Int32Array(32);
        let sym = 0;
        while(sym < 144)state.lens[sym++] = 8;
        while(sym < 256)state.lens[sym++] = 9;
        while(sym < 280)state.lens[sym++] = 7;
        while(sym < 288)state.lens[sym++] = 8;
        inftrees(1, state.lens, 0, 288, lenfix, 0, state.work, {
            bits: 9
        });
        sym = 0;
        while(sym < 32)state.lens[sym++] = 5;
        inftrees(2, state.lens, 0, 32, distfix, 0, state.work, {
            bits: 5
        });
        virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
};
const updatewindow = (strm, src, end, copy)=>{
    let dist;
    const state = strm.state;
    if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new Uint8Array(state.wsize);
    }
    if (copy >= state.wsize) {
        state.window.set(src.subarray(end - state.wsize, end), 0);
        state.wnext = 0;
        state.whave = state.wsize;
    } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
            dist = copy;
        }
        state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
        copy -= dist;
        if (copy) {
            state.window.set(src.subarray(end - copy, end), 0);
            state.wnext = copy;
            state.whave = state.wsize;
        } else {
            state.wnext += dist;
            if (state.wnext === state.wsize) state.wnext = 0;
            if (state.whave < state.wsize) state.whave += dist;
        }
    }
    return 0;
};
const inflate$2 = (strm, flush)=>{
    let state;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in, _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits, here_op, here_val;
    let last_bits, last_op, last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n;
    const order = new Uint8Array([
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
    ]);
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR$1;
    }
    state = strm.state;
    if (state.mode === 12) state.mode = TYPEDO;
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK$1;
    inf_leave: for(;;){
        switch(state.mode){
            case 1:
                if (state.wrap === 0) {
                    state.mode = TYPEDO;
                    break;
                }
                while(bits < 16){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (state.wrap & 2 && hold === 0x8b1f) {
                    state.check = 0;
                    hbuf[0] = hold & 0xff;
                    hbuf[1] = hold >>> 8 & 0xff;
                    state.check = crc32_1(state.check, hbuf, 2, 0);
                    hold = 0;
                    bits = 0;
                    state.mode = FLAGS;
                    break;
                }
                state.flags = 0;
                if (state.head) {
                    state.head.done = false;
                }
                if (!(state.wrap & 1) || (((hold & 0xff) << 8) + (hold >> 8)) % 31) {
                    strm.msg = "incorrect header check";
                    state.mode = BAD;
                    break;
                }
                if ((hold & 0x0f) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                }
                hold >>>= 4;
                bits -= 4;
                len = (hold & 0x0f) + 8;
                if (state.wbits === 0) {
                    state.wbits = len;
                } else if (len > state.wbits) {
                    strm.msg = "invalid window size";
                    state.mode = BAD;
                    break;
                }
                state.dmax = 1 << state.wbits;
                strm.adler = state.check = 1;
                state.mode = hold & 0x200 ? DICTID : TYPE;
                hold = 0;
                bits = 0;
                break;
            case 2:
                while(bits < 16){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                state.flags = hold;
                if ((state.flags & 0xff) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                }
                if (state.flags & 0xe000) {
                    strm.msg = "unknown header flags set";
                    state.mode = BAD;
                    break;
                }
                if (state.head) {
                    state.head.text = hold >> 8 & 1;
                }
                if (state.flags & 0x0200) {
                    hbuf[0] = hold & 0xff;
                    hbuf[1] = hold >>> 8 & 0xff;
                    state.check = crc32_1(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = TIME;
            case 3:
                while(bits < 32){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (state.head) {
                    state.head.time = hold;
                }
                if (state.flags & 0x0200) {
                    hbuf[0] = hold & 0xff;
                    hbuf[1] = hold >>> 8 & 0xff;
                    hbuf[2] = hold >>> 16 & 0xff;
                    hbuf[3] = hold >>> 24 & 0xff;
                    state.check = crc32_1(state.check, hbuf, 4, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = OS;
            case 4:
                while(bits < 16){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (state.head) {
                    state.head.xflags = hold & 0xff;
                    state.head.os = hold >> 8;
                }
                if (state.flags & 0x0200) {
                    hbuf[0] = hold & 0xff;
                    hbuf[1] = hold >>> 8 & 0xff;
                    state.check = crc32_1(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = EXLEN;
            case 5:
                if (state.flags & 0x0400) {
                    while(bits < 16){
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.length = hold;
                    if (state.head) {
                        state.head.extra_len = hold;
                    }
                    if (state.flags & 0x0200) {
                        hbuf[0] = hold & 0xff;
                        hbuf[1] = hold >>> 8 & 0xff;
                        state.check = crc32_1(state.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                } else if (state.head) {
                    state.head.extra = null;
                }
                state.mode = EXTRA;
            case 6:
                if (state.flags & 0x0400) {
                    copy = state.length;
                    if (copy > have) copy = have;
                    if (copy) {
                        if (state.head) {
                            len = state.head.extra_len - state.length;
                            if (!state.head.extra) {
                                state.head.extra = new Uint8Array(state.head.extra_len);
                            }
                            state.head.extra.set(input.subarray(next, next + copy), len);
                        }
                        if (state.flags & 0x0200) {
                            state.check = crc32_1(state.check, input, copy, next);
                        }
                        have -= copy;
                        next += copy;
                        state.length -= copy;
                    }
                    if (state.length) break inf_leave;
                }
                state.length = 0;
                state.mode = NAME;
            case 7:
                if (state.flags & 0x0800) {
                    if (have === 0) break inf_leave;
                    copy = 0;
                    do {
                        len = input[next + copy++];
                        if (state.head && len && state.length < 65536) {
                            state.head.name += String.fromCharCode(len);
                        }
                    }while (len && copy < have)
                    if (state.flags & 0x0200) {
                        state.check = crc32_1(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) break inf_leave;
                } else if (state.head) {
                    state.head.name = null;
                }
                state.length = 0;
                state.mode = COMMENT;
            case 8:
                if (state.flags & 0x1000) {
                    if (have === 0) break inf_leave;
                    copy = 0;
                    do {
                        len = input[next + copy++];
                        if (state.head && len && state.length < 65536) {
                            state.head.comment += String.fromCharCode(len);
                        }
                    }while (len && copy < have)
                    if (state.flags & 0x0200) {
                        state.check = crc32_1(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) break inf_leave;
                } else if (state.head) {
                    state.head.comment = null;
                }
                state.mode = HCRC;
            case 9:
                if (state.flags & 0x0200) {
                    while(bits < 16){
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (hold !== (state.check & 0xffff)) {
                        strm.msg = "header crc mismatch";
                        state.mode = BAD;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                if (state.head) {
                    state.head.hcrc = state.flags >> 9 & 1;
                    state.head.done = true;
                }
                strm.adler = state.check = 0;
                state.mode = TYPE;
                break;
            case 10:
                while(bits < 32){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                strm.adler = state.check = zswap32(hold);
                hold = 0;
                bits = 0;
                state.mode = DICT;
            case 11:
                if (state.havedict === 0) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    return Z_NEED_DICT$1;
                }
                strm.adler = state.check = 1;
                state.mode = TYPE;
            case 12:
                if (flush === Z_BLOCK || flush === Z_TREES) break inf_leave;
            case 13:
                if (state.last) {
                    hold >>>= bits & 7;
                    bits -= bits & 7;
                    state.mode = CHECK;
                    break;
                }
                while(bits < 3){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                state.last = hold & 0x01;
                hold >>>= 1;
                bits -= 1;
                switch(hold & 0x03){
                    case 0:
                        state.mode = STORED;
                        break;
                    case 1:
                        fixedtables(state);
                        state.mode = LEN_;
                        if (flush === Z_TREES) {
                            hold >>>= 2;
                            bits -= 2;
                            break inf_leave;
                        }
                        break;
                    case 2:
                        state.mode = TABLE;
                        break;
                    case 3:
                        strm.msg = "invalid block type";
                        state.mode = BAD;
                }
                hold >>>= 2;
                bits -= 2;
                break;
            case 14:
                hold >>>= bits & 7;
                bits -= bits & 7;
                while(bits < 32){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
                    strm.msg = "invalid stored block lengths";
                    state.mode = BAD;
                    break;
                }
                state.length = hold & 0xffff;
                hold = 0;
                bits = 0;
                state.mode = COPY_;
                if (flush === Z_TREES) break inf_leave;
            case 15:
                state.mode = COPY;
            case 16:
                copy = state.length;
                if (copy) {
                    if (copy > have) copy = have;
                    if (copy > left) copy = left;
                    if (copy === 0) break inf_leave;
                    output.set(input.subarray(next, next + copy), put);
                    have -= copy;
                    next += copy;
                    left -= copy;
                    put += copy;
                    state.length -= copy;
                    break;
                }
                state.mode = TYPE;
                break;
            case 17:
                while(bits < 14){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                state.nlen = (hold & 0x1f) + 257;
                hold >>>= 5;
                bits -= 5;
                state.ndist = (hold & 0x1f) + 1;
                hold >>>= 5;
                bits -= 5;
                state.ncode = (hold & 0x0f) + 4;
                hold >>>= 4;
                bits -= 4;
                if (state.nlen > 286 || state.ndist > 30) {
                    strm.msg = "too many length or distance symbols";
                    state.mode = BAD;
                    break;
                }
                state.have = 0;
                state.mode = LENLENS;
            case 18:
                while(state.have < state.ncode){
                    while(bits < 3){
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.lens[order[state.have++]] = hold & 0x07;
                    hold >>>= 3;
                    bits -= 3;
                }
                while(state.have < 19){
                    state.lens[order[state.have++]] = 0;
                }
                state.lencode = state.lendyn;
                state.lenbits = 7;
                opts = {
                    bits: state.lenbits
                };
                ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                    strm.msg = "invalid code lengths set";
                    state.mode = BAD;
                    break;
                }
                state.have = 0;
                state.mode = CODELENS;
            case 19:
                while(state.have < state.nlen + state.ndist){
                    for(;;){
                        here = state.lencode[hold & (1 << state.lenbits) - 1];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 0xff;
                        here_val = here & 0xffff;
                        if (here_bits <= bits) break;
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (here_val < 16) {
                        hold >>>= here_bits;
                        bits -= here_bits;
                        state.lens[state.have++] = here_val;
                    } else {
                        if (here_val === 16) {
                            n = here_bits + 2;
                            while(bits < n){
                                if (have === 0) break inf_leave;
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            if (state.have === 0) {
                                strm.msg = "invalid bit length repeat";
                                state.mode = BAD;
                                break;
                            }
                            len = state.lens[state.have - 1];
                            copy = 3 + (hold & 0x03);
                            hold >>>= 2;
                            bits -= 2;
                        } else if (here_val === 17) {
                            n = here_bits + 3;
                            while(bits < n){
                                if (have === 0) break inf_leave;
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            len = 0;
                            copy = 3 + (hold & 0x07);
                            hold >>>= 3;
                            bits -= 3;
                        } else {
                            n = here_bits + 7;
                            while(bits < n){
                                if (have === 0) break inf_leave;
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            len = 0;
                            copy = 11 + (hold & 0x7f);
                            hold >>>= 7;
                            bits -= 7;
                        }
                        if (state.have + copy > state.nlen + state.ndist) {
                            strm.msg = "invalid bit length repeat";
                            state.mode = BAD;
                            break;
                        }
                        while(copy--){
                            state.lens[state.have++] = len;
                        }
                    }
                }
                if (state.mode === 30) break;
                if (state.lens[256] === 0) {
                    strm.msg = "invalid code -- missing end-of-block";
                    state.mode = BAD;
                    break;
                }
                state.lenbits = 9;
                opts = {
                    bits: state.lenbits
                };
                ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                    strm.msg = "invalid literal/lengths set";
                    state.mode = BAD;
                    break;
                }
                state.distbits = 6;
                state.distcode = state.distdyn;
                opts = {
                    bits: state.distbits
                };
                ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                state.distbits = opts.bits;
                if (ret) {
                    strm.msg = "invalid distances set";
                    state.mode = BAD;
                    break;
                }
                state.mode = LEN_;
                if (flush === Z_TREES) break inf_leave;
            case 20:
                state.mode = LEN;
            case 21:
                if (have >= 6 && left >= 258) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    inffast(strm, _out);
                    put = strm.next_out;
                    output = strm.output;
                    left = strm.avail_out;
                    next = strm.next_in;
                    input = strm.input;
                    have = strm.avail_in;
                    hold = state.hold;
                    bits = state.bits;
                    if (state.mode === 12) {
                        state.back = -1;
                    }
                    break;
                }
                state.back = 0;
                for(;;){
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 0xff;
                    here_val = here & 0xffff;
                    if (here_bits <= bits) break;
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (here_op && (here_op & 0xf0) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for(;;){
                        here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 0xff;
                        here_val = here & 0xffff;
                        if (last_bits + here_bits <= bits) break;
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                state.length = here_val;
                if (here_op === 0) {
                    state.mode = LIT;
                    break;
                }
                if (here_op & 32) {
                    state.back = -1;
                    state.mode = TYPE;
                    break;
                }
                if (here_op & 64) {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD;
                    break;
                }
                state.extra = here_op & 15;
                state.mode = LENEXT;
            case 22:
                if (state.extra) {
                    n = state.extra;
                    while(bits < n){
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.length += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                }
                state.was = state.length;
                state.mode = DIST;
            case 23:
                for(;;){
                    here = state.distcode[hold & (1 << state.distbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 0xff;
                    here_val = here & 0xffff;
                    if (here_bits <= bits) break;
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if ((here_op & 0xf0) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for(;;){
                        here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 0xff;
                        here_val = here & 0xffff;
                        if (last_bits + here_bits <= bits) break;
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                if (here_op & 64) {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break;
                }
                state.offset = here_val;
                state.extra = here_op & 15;
                state.mode = DISTEXT;
            case 24:
                if (state.extra) {
                    n = state.extra;
                    while(bits < n){
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.offset += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                }
                if (state.offset > state.dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                }
                state.mode = MATCH;
            case 25:
                if (left === 0) break inf_leave;
                copy = _out - left;
                if (state.offset > copy) {
                    copy = state.offset - copy;
                    if (copy > state.whave) {
                        if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break;
                        }
                    }
                    if (copy > state.wnext) {
                        copy -= state.wnext;
                        from = state.wsize - copy;
                    } else {
                        from = state.wnext - copy;
                    }
                    if (copy > state.length) copy = state.length;
                    from_source = state.window;
                } else {
                    from_source = output;
                    from = put - state.offset;
                    copy = state.length;
                }
                if (copy > left) copy = left;
                left -= copy;
                state.length -= copy;
                do {
                    output[put++] = from_source[from++];
                }while (--copy)
                if (state.length === 0) state.mode = LEN;
                break;
            case 26:
                if (left === 0) break inf_leave;
                output[put++] = state.length;
                left--;
                state.mode = LEN;
                break;
            case 27:
                if (state.wrap) {
                    while(bits < 32){
                        if (have === 0) break inf_leave;
                        have--;
                        hold |= input[next++] << bits;
                        bits += 8;
                    }
                    _out -= left;
                    strm.total_out += _out;
                    state.total += _out;
                    if (_out) {
                        strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
                    }
                    _out = left;
                    if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                        strm.msg = "incorrect data check";
                        state.mode = BAD;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                state.mode = LENGTH;
            case 28:
                if (state.wrap && state.flags) {
                    while(bits < 32){
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (hold !== (state.total & 0xffffffff)) {
                        strm.msg = "incorrect length check";
                        state.mode = BAD;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                state.mode = DONE;
            case 29:
                ret = Z_STREAM_END$1;
                break inf_leave;
            case 30:
                ret = Z_DATA_ERROR$1;
                break inf_leave;
            case 31:
                return Z_MEM_ERROR$1;
            case 32:
            default:
                return Z_STREAM_ERROR$1;
        }
    }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < 30 && (state.mode < 27 || flush !== Z_FINISH$1)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
        strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
        ret = Z_BUF_ERROR;
    }
    return ret;
};
const inflateEnd = (strm)=>{
    if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
    }
    let state = strm.state;
    if (state.window) {
        state.window = null;
    }
    strm.state = null;
    return Z_OK$1;
};
const inflateGetHeader = (strm, head)=>{
    if (!strm || !strm.state) return Z_STREAM_ERROR$1;
    const state = strm.state;
    if ((state.wrap & 2) === 0) return Z_STREAM_ERROR$1;
    state.head = head;
    head.done = false;
    return Z_OK$1;
};
const inflateSetDictionary = (strm, dictionary)=>{
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== 11) {
        return Z_STREAM_ERROR$1;
    }
    if (state.mode === 11) {
        dictid = 1;
        dictid = adler32_1(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
            return Z_DATA_ERROR$1;
        }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR$1;
    }
    state.havedict = 1;
    return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
    inflateReset: inflateReset_1,
    inflateReset2: inflateReset2_1,
    inflateResetKeep: inflateResetKeep_1,
    inflateInit: inflateInit_1,
    inflateInit2: inflateInit2_1,
    inflate: inflate_2$1,
    inflateEnd: inflateEnd_1,
    inflateGetHeader: inflateGetHeader_1,
    inflateSetDictionary: inflateSetDictionary_1,
    inflateInfo: inflateInfo
};
function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
}
var gzheader = GZheader;
const toString = Object.prototype.toString;
const { Z_NO_FLUSH , Z_FINISH , Z_OK , Z_STREAM_END , Z_NEED_DICT , Z_STREAM_ERROR , Z_DATA_ERROR , Z_MEM_ERROR  } = constants$2;
function Inflate$1(options) {
    this.options = common1.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: ""
    }, options || {});
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) opt.windowBits = -15;
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
            opt.windowBits |= 15;
        }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zstream();
    this.strm.avail_out = 0;
    let status = inflate_1$2.inflateInit2(this.strm, opt.windowBits);
    if (status !== Z_OK) {
        throw new Error(messages[status]);
    }
    this.header = new gzheader();
    inflate_1$2.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
            opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
            status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
            if (status !== Z_OK) {
                throw new Error(messages[status]);
            }
        }
    }
}
Inflate$1.prototype.push = function(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status, _flush_mode, last_avail_out;
    if (this.ended) return false;
    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
    else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
    } else {
        strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for(;;){
        if (strm.avail_out === 0) {
            strm.output = new Uint8Array(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
        }
        status = inflate_1$2.inflate(strm, _flush_mode);
        if (status === Z_NEED_DICT && dictionary) {
            status = inflate_1$2.inflateSetDictionary(strm, dictionary);
            if (status === Z_OK) {
                status = inflate_1$2.inflate(strm, _flush_mode);
            } else if (status === Z_DATA_ERROR) {
                status = Z_NEED_DICT;
            }
        }
        while(strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0){
            inflate_1$2.inflateReset(strm);
            status = inflate_1$2.inflate(strm, _flush_mode);
        }
        switch(status){
            case Z_STREAM_ERROR:
            case Z_DATA_ERROR:
            case Z_NEED_DICT:
            case Z_MEM_ERROR:
                this.onEnd(status);
                this.ended = true;
                return false;
        }
        last_avail_out = strm.avail_out;
        if (strm.next_out) {
            if (strm.avail_out === 0 || status === Z_STREAM_END) {
                if (this.options.to === "string") {
                    let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                    let tail = strm.next_out - next_out_utf8;
                    let utf8str = strings.buf2string(strm.output, next_out_utf8);
                    strm.next_out = tail;
                    strm.avail_out = chunkSize - tail;
                    if (tail) {
                        strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
                    }
                    this.onData(utf8str);
                } else {
                    this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
                }
            }
        }
        if (status === Z_OK && last_avail_out === 0) continue;
        if (status === Z_STREAM_END) {
            status = inflate_1$2.inflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return true;
        }
        if (strm.avail_in === 0) break;
    }
    return true;
};
Inflate$1.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
    if (status === Z_OK) {
        if (this.options.to === "string") {
            this.result = this.chunks.join("");
        } else {
            this.result = common1.flattenChunks(this.chunks);
        }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
};
function inflate$1(input, options) {
    const inflator = new Inflate$1(options);
    inflator.push(input);
    if (inflator.err) throw inflator.msg || messages[inflator.err];
    return inflator.result;
}
function inflateRaw$1(input, options) {
    options = options || {};
    options.raw = true;
    return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants9 = constants$2;
var inflate_1$1 = {
    Inflate: Inflate_1$1,
    inflate: inflate_2,
    inflateRaw: inflateRaw_1$1,
    ungzip: ungzip$1,
    constants: constants9
};
const { Deflate , deflate , deflateRaw , gzip  } = deflate_1$1;
const { Inflate , inflate , inflateRaw , ungzip  } = inflate_1$1;
var constants_1 = constants$2;
const Z_NO_FLUSH1 = constants_1.Z_NO_FLUSH;
const Z_PARTIAL_FLUSH1 = constants_1.Z_PARTIAL_FLUSH;
const Z_SYNC_FLUSH1 = constants_1.Z_SYNC_FLUSH;
const Z_FULL_FLUSH1 = constants_1.Z_FULL_FLUSH;
const Z_FINISH1 = constants_1.Z_FINISH;
const Z_BLOCK1 = constants_1.Z_BLOCK;
constants_1.Z_TREES;
const Z_OK1 = constants_1.Z_OK;
const Z_STREAM_END1 = constants_1.Z_STREAM_END;
const Z_NEED_DICT1 = constants_1.Z_NEED_DICT;
const Z_ERRNO = constants_1.Z_ERRNO;
const Z_STREAM_ERROR1 = constants_1.Z_STREAM_ERROR;
const Z_DATA_ERROR1 = constants_1.Z_DATA_ERROR;
const Z_MEM_ERROR1 = constants_1.Z_MEM_ERROR;
const Z_BUF_ERROR1 = constants_1.Z_BUF_ERROR;
const Z_VERSION_ERROR = constants_1.Z_VERSION_ERROR;
constants_1.Z_NO_COMPRESSION;
constants_1.Z_BEST_SPEED;
constants_1.Z_BEST_COMPRESSION;
constants_1.Z_DEFAULT_COMPRESSION;
const Z_FILTERED1 = constants_1.Z_FILTERED;
const Z_HUFFMAN_ONLY1 = constants_1.Z_HUFFMAN_ONLYZ_FILTERED;
const Z_RLE1 = constants_1.Z_RLE;
const Z_FIXED1 = constants_1.Z_FIXED;
const Z_DEFAULT_STRATEGY1 = constants_1.Z_DEFAULT_STRATEGY;
constants_1.Z_BINARY;
constants_1.Z_TEXT;
constants_1.Z_UNKNOWN;
const Z_DEFLATED1 = constants_1.Z_DEFLATED;
const NONE = 0;
const DEFLATE = 1;
const INFLATE = 2;
const GZIP = 3;
const GUNZIP = 4;
const DEFLATERAW = 5;
const INFLATERAW = 6;
const UNZIP = 7;
var GZIP_HEADER_ID1 = 0x1f;
var GZIP_HEADER_ID2 = 0x8b;
function Zlib(mode) {
    if (typeof mode !== "number" || mode < 1 || mode > 7) {
        throw new TypeError("Bad argument");
    }
    this.dictionary = null;
    this.err = 0;
    this.flush = 0;
    this.init_done = false;
    this.level = 0;
    this.memLevel = 0;
    this.mode = mode;
    this.strategy = 0;
    this.windowBits = 0;
    this.write_in_progress = false;
    this.pending_close = false;
    this.gzip_id_bytes_read = 0;
}
Zlib.prototype.close = function() {
    if (this.write_in_progress) {
        this.pending_close = true;
        return;
    }
    this.pending_close = false;
    __default22(this.init_done, "close before init");
    __default22(this.mode <= UNZIP);
    if (this.mode === DEFLATE || this.mode === GZIP || this.mode === DEFLATERAW) {
        deflate_1$2.deflateEnd(this.strm);
    } else if (this.mode === INFLATE || this.mode === GUNZIP || this.mode === INFLATERAW || this.mode === UNZIP) {
        inflate_1$2.inflateEnd(this.strm);
    }
    this.mode = NONE;
    this.dictionary = null;
};
Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
};
Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
};
Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
    __default22.equal(arguments.length, 8);
    __default22(this.init_done, "write before init");
    __default22(this.mode !== NONE, "already finalized");
    __default22.equal(false, this.write_in_progress, "write already in progress");
    __default22.equal(false, this.pending_close, "close is pending");
    this.write_in_progress = true;
    __default22.equal(false, flush === undefined, "must provide flush value");
    this.write_in_progress = true;
    if (flush !== Z_NO_FLUSH1 && flush !== Z_PARTIAL_FLUSH1 && flush !== Z_SYNC_FLUSH1 && flush !== Z_FULL_FLUSH1 && flush !== Z_FINISH1 && flush !== Z_BLOCK1) {
        throw new Error("Invalid flush value");
    }
    if (input == null) {
        input = Buffer.alloc(0);
        in_len = 0;
        in_off = 0;
    }
    this.strm.avail_in = in_len;
    this.strm.input = input;
    this.strm.next_in = in_off;
    this.strm.avail_out = out_len;
    this.strm.output = out;
    this.strm.next_out = out_off;
    this.flush = flush;
    if (!async) {
        this._process();
        if (this._checkError()) {
            return this._afterSync();
        }
        return;
    }
    var self = this;
    nextTick1(function() {
        self._process();
        self._after();
    });
    return this;
};
Zlib.prototype._afterSync = function() {
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    return [
        avail_in,
        avail_out
    ];
};
Zlib.prototype._process = function() {
    var next_expected_header_byte = null;
    switch(this.mode){
        case DEFLATE:
        case GZIP:
        case DEFLATERAW:
            this.err = deflate_1$2.deflate(this.strm, this.flush);
            break;
        case UNZIP:
            if (this.strm.avail_in > 0) {
                next_expected_header_byte = this.strm.next_in;
            }
            switch(this.gzip_id_bytes_read){
                case 0:
                    if (next_expected_header_byte === null) {
                        break;
                    }
                    if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
                        this.gzip_id_bytes_read = 1;
                        next_expected_header_byte++;
                        if (this.strm.avail_in === 1) {
                            break;
                        }
                    } else {
                        this.mode = INFLATE;
                        break;
                    }
                case 1:
                    if (next_expected_header_byte === null) {
                        break;
                    }
                    if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
                        this.gzip_id_bytes_read = 2;
                        this.mode = GUNZIP;
                    } else {
                        this.mode = INFLATE;
                    }
                    break;
                default:
                    throw new Error("invalid number of gzip magic number bytes read");
            }
        case INFLATE:
        case GUNZIP:
        case INFLATERAW:
            this.err = inflate_1$2.inflate(this.strm, this.flush);
            if (this.err === Z_NEED_DICT1 && this.dictionary) {
                this.err = inflate_1$2.inflateSetDictionary(this.strm, this.dictionary);
                if (this.err === Z_OK1) {
                    this.err = inflate_1$2.inflate(this.strm, this.flush);
                } else if (this.err === Z_DATA_ERROR1) {
                    this.err = Z_NEED_DICT1;
                }
            }
            while(this.strm.avail_in > 0 && this.mode === GUNZIP && this.err === Z_STREAM_END1 && this.strm.next_in[0] !== 0x00){
                this.reset();
                this.err = inflate_1$2.inflate(this.strm, this.flush);
            }
            break;
        default:
            throw new Error("Unknown mode " + this.mode);
    }
};
Zlib.prototype._checkError = function() {
    switch(this.err){
        case Z_OK1:
        case Z_BUF_ERROR1:
            if (this.strm.avail_out !== 0 && this.flush === Z_FINISH1) {
                this._error("unexpected end of file");
                return false;
            }
            break;
        case Z_STREAM_END1:
            break;
        case Z_NEED_DICT1:
            if (this.dictionary == null) {
                this._error("Missing dictionary");
            } else {
                this._error("Bad dictionary");
            }
            return false;
        default:
            this._error("Zlib error");
            return false;
    }
    return true;
};
Zlib.prototype._after = function() {
    if (!this._checkError()) {
        return;
    }
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    this.callback(avail_in, avail_out);
    if (this.pending_close) {
        this.close();
    }
};
Zlib.prototype._error = function(message) {
    if (this.strm.msg) {
        message = this.strm.msg;
    }
    this.onerror(message, this.err);
    this.write_in_progress = false;
    if (this.pending_close) {
        this.close();
    }
};
Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
    __default22(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
    __default22(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
    __default22(level >= -1 && level <= 9, "invalid compression level");
    __default22(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
    __default22(strategy === Z_FILTERED1 || strategy === Z_HUFFMAN_ONLY1 || strategy === Z_RLE1 || strategy === Z_FIXED1 || strategy === Z_DEFAULT_STRATEGY1, "invalid strategy");
    this._init(level, windowBits, memLevel, strategy, dictionary);
    this._setDictionary();
};
Zlib.prototype.params = function() {
    throw new Error("deflateParams Not supported");
};
Zlib.prototype.reset = function() {
    this._reset();
    this._setDictionary();
};
Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
    this.level = level;
    this.windowBits = windowBits;
    this.memLevel = memLevel;
    this.strategy = strategy;
    this.flush = Z_NO_FLUSH1;
    this.err = Z_OK1;
    if (this.mode === GZIP || this.mode === GUNZIP) {
        this.windowBits += 16;
    }
    if (this.mode === UNZIP) {
        this.windowBits += 32;
    }
    if (this.mode === DEFLATERAW || this.mode === INFLATERAW) {
        this.windowBits = -1 * this.windowBits;
    }
    this.strm = new ZStream();
    switch(this.mode){
        case DEFLATE:
        case GZIP:
        case DEFLATERAW:
            this.err = deflate_1$2.deflateInit2(this.strm, this.level, Z_DEFLATED1, this.windowBits, this.memLevel, this.strategy);
            break;
        case INFLATE:
        case GUNZIP:
        case INFLATERAW:
        case UNZIP:
            this.err = inflate_1$2.inflateInit2(this.strm, this.windowBits);
            break;
        default:
            throw new Error("Unknown mode " + this.mode);
    }
    if (this.err !== Z_OK1) {
        this._error("Init error");
    }
    this.dictionary = dictionary;
    this.write_in_progress = false;
    this.init_done = true;
};
Zlib.prototype._setDictionary = function() {
    if (this.dictionary == null) {
        return;
    }
    this.err = Z_OK1;
    switch(this.mode){
        case DEFLATE:
        case DEFLATERAW:
            this.err = deflate_1$2.deflateSetDictionary(this.strm, this.dictionary);
            break;
        default:
            break;
    }
    if (this.err !== Z_OK1) {
        this._error("Failed to set dictionary");
    }
};
Zlib.prototype._reset = function() {
    this.err = Z_OK1;
    switch(this.mode){
        case DEFLATE:
        case DEFLATERAW:
        case GZIP:
            this.err = deflate_1$2.deflateReset(this.strm);
            break;
        case INFLATE:
        case INFLATERAW:
        case GUNZIP:
            this.err = inflate_1$2.inflateReset(this.strm);
            break;
        default:
            break;
    }
    if (this.err !== Z_OK1) {
        this._error("Failed to reset stream");
    }
};
var kRangeErrorMessage = "Cannot create final Buffer. It would be larger " + "than 0x" + 2147483647..toString(16) + " bytes";
const codes1 = Object.freeze({
    Z_OK: Z_OK1,
    Z_STREAM_END: Z_STREAM_END1,
    Z_NEED_DICT: Z_NEED_DICT1,
    Z_ERRNO: Z_ERRNO,
    Z_STREAM_ERROR: Z_STREAM_ERROR1,
    Z_DATA_ERROR: Z_DATA_ERROR1,
    Z_MEM_ERROR: Z_MEM_ERROR1,
    Z_BUF_ERROR: Z_BUF_ERROR1,
    Z_VERSION_ERROR: Z_VERSION_ERROR,
    [Z_OK1]: "Z_OK",
    [Z_STREAM_END1]: "Z_STREAM_END",
    [Z_NEED_DICT1]: "Z_NEED_DICT",
    [Z_ERRNO]: "Z_ERRNO",
    [Z_STREAM_ERROR1]: "Z_STREAM_ERROR",
    [Z_DATA_ERROR1]: "Z_DATA_ERROR",
    [Z_MEM_ERROR1]: "Z_MEM_ERROR",
    [Z_BUF_ERROR1]: "Z_BUF_ERROR",
    [Z_VERSION_ERROR]: "Z_VERSION_ERROR"
});
const createDeflate = function(o) {
    return new Deflate1(o);
};
const createInflate = function(o) {
    return new Inflate1(o);
};
const createDeflateRaw = function(o) {
    return new DeflateRaw(o);
};
const createInflateRaw = function(o) {
    return new InflateRaw(o);
};
const createGzip = function(o) {
    return new Gzip(o);
};
const createGunzip = function(o) {
    return new Gunzip(o);
};
const createUnzip = function(o) {
    return new Unzip(o);
};
const deflate1 = function(buffer, opts, callback) {
    if (typeof opts === "function") {
        callback = opts;
        opts = {};
    }
    return zlibBuffer(new Deflate1(opts), buffer, callback);
};
const deflateSync = function(buffer, opts) {
    return zlibBufferSync(new Deflate1(opts), buffer);
};
const gzip1 = function(buffer, opts, callback) {
    if (typeof opts === "function") {
        callback = opts;
        opts = {};
    }
    return zlibBuffer(new Gzip(opts), buffer, callback);
};
const gzipSync = function(buffer, opts) {
    return zlibBufferSync(new Gzip(opts), buffer);
};
const deflateRaw1 = function(buffer, opts, callback) {
    if (typeof opts === "function") {
        callback = opts;
        opts = {};
    }
    return zlibBuffer(new DeflateRaw(opts), buffer, callback);
};
const deflateRawSync = function(buffer, opts) {
    return zlibBufferSync(new DeflateRaw(opts), buffer);
};
const unzip = function(buffer, opts, callback) {
    if (typeof opts === "function") {
        callback = opts;
        opts = {};
    }
    return zlibBuffer(new Unzip(opts), buffer, callback);
};
const unzipSync = function(buffer, opts) {
    return zlibBufferSync(new Unzip(opts), buffer);
};
const inflate1 = function(buffer, opts, callback) {
    if (typeof opts === "function") {
        callback = opts;
        opts = {};
    }
    return zlibBuffer(new Inflate1(opts), buffer, callback);
};
const inflateSync = function(buffer, opts) {
    return zlibBufferSync(new Inflate1(opts), buffer);
};
const gunzip = function(buffer, opts, callback) {
    if (typeof opts === "function") {
        callback = opts;
        opts = {};
    }
    return zlibBuffer(new Gunzip(opts), buffer, callback);
};
const gunzipSync = function(buffer, opts) {
    return zlibBufferSync(new Gunzip(opts), buffer);
};
const inflateRaw1 = function(buffer, opts, callback) {
    if (typeof opts === "function") {
        callback = opts;
        opts = {};
    }
    return zlibBuffer(new InflateRaw(opts), buffer, callback);
};
const inflateRawSync = function(buffer, opts) {
    return zlibBufferSync(new InflateRaw(opts), buffer);
};
function zlibBuffer(engine, buffer, callback) {
    var buffers = [];
    var nread = 0;
    engine.on("error", onError);
    engine.on("end", onEnd);
    engine.end(buffer);
    flow();
    function flow() {
        var chunk;
        while(null !== (chunk = engine.read())){
            buffers.push(chunk);
            nread += chunk.length;
        }
        engine.once("readable", flow);
    }
    function onError(err) {
        engine.removeListener("end", onEnd);
        engine.removeListener("readable", flow);
        callback(err);
    }
    function onEnd() {
        var buf;
        var err = null;
        if (nread >= 2147483647) {
            err = new RangeError(kRangeErrorMessage);
        } else {
            buf = Buffer1.concat(buffers, nread);
        }
        buffers = [];
        engine.close();
        callback(err, buf);
    }
}
function zlibBufferSync(engine, buffer) {
    if (typeof buffer === "string") buffer = Buffer1.from(buffer);
    if (!Buffer1.isBuffer(buffer)) throw new TypeError("Not a string or buffer");
    var flushFlag = engine._finishFlushFlag;
    return engine._processChunk(buffer, flushFlag);
}
function Deflate1(opts) {
    if (!(this instanceof Deflate1)) return new Deflate1(opts);
    Zlib1.call(this, opts, 1);
}
function Inflate1(opts) {
    if (!(this instanceof Inflate1)) return new Inflate1(opts);
    Zlib1.call(this, opts, 2);
}
function Gzip(opts) {
    if (!(this instanceof Gzip)) return new Gzip(opts);
    Zlib1.call(this, opts, 3);
}
function Gunzip(opts) {
    if (!(this instanceof Gunzip)) return new Gunzip(opts);
    Zlib1.call(this, opts, 4);
}
function DeflateRaw(opts) {
    if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
    Zlib1.call(this, opts, 5);
}
function InflateRaw(opts) {
    if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
    Zlib1.call(this, opts, 6);
}
function Unzip(opts) {
    if (!(this instanceof Unzip)) return new Unzip(opts);
    Zlib1.call(this, opts, 7);
}
function isValidFlushFlag(flag) {
    return flag === Z_NO_FLUSH1 || flag === Z_PARTIAL_FLUSH1 || flag === Z_SYNC_FLUSH1 || flag === Z_FULL_FLUSH1 || flag === Z_FINISH1 || flag === Z_BLOCK1;
}
function Zlib1(opts, mode) {
    var _this = this;
    this._opts = opts = opts || {};
    this._chunkSize = opts.chunkSize || zlib.Z_DEFAULT_CHUNK;
    Iu.call(this, opts);
    if (opts.flush && !isValidFlushFlag(opts.flush)) {
        throw new Error("Invalid flush flag: " + opts.flush);
    }
    if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
        throw new Error("Invalid flush flag: " + opts.finishFlush);
    }
    this._flushFlag = opts.flush || Z_NO_FLUSH1;
    this._finishFlushFlag = typeof opts.finishFlush !== "undefined" ? opts.finishFlush : Z_FINISH1;
    if (opts.chunkSize) {
        if (opts.chunkSize < zlib.Z_MIN_CHUNK || opts.chunkSize > zlib.Z_MAX_CHUNK) {
            throw new Error("Invalid chunk size: " + opts.chunkSize);
        }
    }
    if (opts.windowBits) {
        if (opts.windowBits < zlib.Z_MIN_WINDOWBITS || opts.windowBits > zlib.Z_MAX_WINDOWBITS) {
            throw new Error("Invalid windowBits: " + opts.windowBits);
        }
    }
    if (opts.level) {
        if (opts.level < zlib.Z_MIN_LEVEL || opts.level > zlib.Z_MAX_LEVEL) {
            throw new Error("Invalid compression level: " + opts.level);
        }
    }
    if (opts.memLevel) {
        if (opts.memLevel < zlib.Z_MIN_MEMLEVEL || opts.memLevel > zlib.Z_MAX_MEMLEVEL) {
            throw new Error("Invalid memLevel: " + opts.memLevel);
        }
    }
    if (opts.strategy) {
        if (opts.strategy != zlib.Z_FILTERED && opts.strategy != zlib.Z_HUFFMAN_ONLY && opts.strategy != zlib.Z_RLE && opts.strategy != zlib.Z_FIXED && opts.strategy != zlib.Z_DEFAULT_STRATEGY) {
            throw new Error("Invalid strategy: " + opts.strategy);
        }
    }
    if (opts.dictionary) {
        if (!Buffer1.isBuffer(opts.dictionary)) {
            throw new Error("Invalid dictionary: it should be a Buffer instance");
        }
    }
    this._handle = new Zlib(mode);
    var self = this;
    this._hadError = false;
    this._handle.onerror = function(message, errno) {
        _close(self);
        self._hadError = true;
        var error = new Error(message);
        error.errno = errno;
        error.code = codes1[errno];
        self.emit("error", error);
    };
    var level = zlib.Z_DEFAULT_COMPRESSION;
    if (typeof opts.level === "number") level = opts.level;
    var strategy = zlib.Z_DEFAULT_STRATEGY;
    if (typeof opts.strategy === "number") strategy = opts.strategy;
    this._handle.init(opts.windowBits || zlib.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || zlib.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
    this._buffer = Buffer1.allocUnsafe(this._chunkSize);
    this._offset = 0;
    this._level = level;
    this._strategy = strategy;
    this.once("end", this.close);
    Object.defineProperty(this, "_closed", {
        get: function() {
            return !_this._handle;
        },
        configurable: true,
        enumerable: true
    });
}
__default19.inherits(Zlib1, Iu);
Zlib1.prototype.params = function(level, strategy, callback) {
    if (level < zlib.Z_MIN_LEVEL || level > zlib.Z_MAX_LEVEL) {
        throw new RangeError("Invalid compression level: " + level);
    }
    if (strategy != zlib.Z_FILTERED && strategy != zlib.Z_HUFFMAN_ONLY && strategy != zlib.Z_RLE && strategy != zlib.Z_FIXED && strategy != zlib.Z_DEFAULT_STRATEGY) {
        throw new TypeError("Invalid strategy: " + strategy);
    }
    if (this._level !== level || this._strategy !== strategy) {
        var self = this;
        this.flush(Z_SYNC_FLUSH1, function() {
            ok(self._handle, "zlib binding closed");
            self._handle.params(level, strategy);
            if (!self._hadError) {
                self._level = level;
                self._strategy = strategy;
                if (callback) callback();
            }
        });
    } else {
        nextTick1(callback);
    }
};
Zlib1.prototype.reset = function() {
    ok(this._handle, "zlib binding closed");
    return this._handle.reset();
};
Zlib1.prototype._flush = function(callback) {
    this._transform(Buffer1.alloc(0), "", callback);
};
Zlib1.prototype.flush = function(kind, callback) {
    var _this2 = this;
    var ws = this._writableState;
    if (typeof kind === "function" || kind === undefined && !callback) {
        callback = kind;
        kind = Z_FULL_FLUSH1;
    }
    if (ws.ended) {
        if (callback) nextTick1(callback);
    } else if (ws.ending) {
        if (callback) this.once("end", callback);
    } else if (ws.needDrain) {
        if (callback) {
            this.once("drain", function() {
                return _this2.flush(kind, callback);
            });
        }
    } else {
        this._flushFlag = kind;
        this.write(Buffer1.alloc(0), "", callback);
    }
};
Zlib1.prototype.close = function(callback) {
    _close(this, callback);
    nextTick1(emitCloseNT1, this);
};
function _close(engine, callback) {
    if (callback) nextTick1(callback);
    if (!engine._handle) return;
    engine._handle.close();
    engine._handle = null;
}
function emitCloseNT1(self) {
    self.emit("close");
}
Zlib1.prototype._transform = function(chunk, encoding, cb) {
    var flushFlag;
    var ws = this._writableState;
    var ending = ws.ending || ws.ended;
    var last = ending && (!chunk || ws.length === chunk.length);
    if (chunk !== null && !Buffer1.isBuffer(chunk)) {
        return cb(new Error("invalid input"));
    }
    if (!this._handle) return cb(new Error("zlib binding closed"));
    if (last) flushFlag = this._finishFlushFlag;
    else {
        flushFlag = this._flushFlag;
        if (chunk.length >= ws.length) {
            this._flushFlag = this._opts.flush || Z_NO_FLUSH1;
        }
    }
    this._processChunk(chunk, flushFlag, cb);
};
Zlib1.prototype._processChunk = function(chunk, flushFlag, cb) {
    var availInBefore = chunk && chunk.length;
    var availOutBefore = this._chunkSize - this._offset;
    var inOff = 0;
    var self = this;
    var async = typeof cb === "function";
    if (!async) {
        var buffers = [];
        var nread = 0;
        var error;
        this.on("error", function(er) {
            error = er;
        });
        ok(this._handle, "zlib binding closed");
        do {
            var res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
        }while (!this._hadError && callback(res[0], res[1]))
        if (this._hadError) {
            throw error;
        }
        if (nread >= kMaxLength) {
            _close(this);
            throw new RangeError(kRangeErrorMessage);
        }
        var buf = Buffer1.concat(buffers, nread);
        _close(this);
        return buf;
    }
    ok(this._handle, "zlib binding closed");
    var req = this._handle.write(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
    req.buffer = chunk;
    req.callback = callback;
    function callback(availInAfter, availOutAfter) {
        if (this) {
            this.buffer = null;
            this.callback = null;
        }
        if (self._hadError) return;
        var have = availOutBefore - availOutAfter;
        ok(have >= 0, "have should not go down");
        if (have > 0) {
            var out = self._buffer.slice(self._offset, self._offset + have);
            self._offset += have;
            if (async) {
                self.push(out);
            } else {
                buffers.push(out);
                nread += out.length;
            }
        }
        if (availOutAfter === 0 || self._offset >= self._chunkSize) {
            availOutBefore = self._chunkSize;
            self._offset = 0;
            self._buffer = Buffer1.allocUnsafe(self._chunkSize);
        }
        if (availOutAfter === 0) {
            inOff += availInBefore - availInAfter;
            availInBefore = availInAfter;
            if (!async) return true;
            var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);
            newReq.callback = callback;
            newReq.buffer = chunk;
            return;
        }
        if (!async) return false;
        cb();
    }
};
__default19.inherits(Deflate1, Zlib1);
__default19.inherits(Inflate1, Zlib1);
__default19.inherits(Gzip, Zlib1);
__default19.inherits(Gunzip, Zlib1);
__default19.inherits(DeflateRaw, Zlib1);
__default19.inherits(InflateRaw, Zlib1);
__default19.inherits(Unzip, Zlib1);
class Options {
    constructor(){
        notImplemented("Options.prototype.constructor");
    }
}
class BrotliOptions {
    constructor(){
        notImplemented("BrotliOptions.prototype.constructor");
    }
}
class BrotliCompress {
    constructor(){
        notImplemented("BrotliCompress.prototype.constructor");
    }
}
class BrotliDecompress {
    constructor(){
        notImplemented("BrotliDecompress.prototype.constructor");
    }
}
class ZlibBase {
    constructor(){
        notImplemented("ZlibBase.prototype.constructor");
    }
}
function createBrotliCompress() {
    notImplemented("createBrotliCompress");
}
function createBrotliDecompress() {
    notImplemented("createBrotliDecompress");
}
function brotliCompress() {
    notImplemented("brotliCompress");
}
function brotliCompressSync() {
    notImplemented("brotliCompressSync");
}
function brotliDecompress() {
    notImplemented("brotliDecompress");
}
function brotliDecompressSync() {
    notImplemented("brotliDecompressSync");
}
const __default79 = {
    Options,
    BrotliOptions,
    BrotliCompress,
    BrotliDecompress,
    Deflate: Deflate1,
    DeflateRaw,
    Gunzip,
    Gzip,
    Inflate: Inflate1,
    InflateRaw,
    Unzip,
    ZlibBase,
    constants: zlib,
    codes: codes1,
    createBrotliCompress,
    createBrotliDecompress,
    createDeflate,
    createDeflateRaw,
    createGunzip,
    createGzip,
    createInflate,
    createInflateRaw,
    createUnzip,
    brotliCompress,
    brotliCompressSync,
    brotliDecompress,
    brotliDecompressSync,
    deflate: deflate1,
    deflateSync,
    deflateRaw: deflateRaw1,
    deflateRawSync,
    gunzip,
    gunzipSync,
    gzip: gzip1,
    gzipSync,
    inflate: inflate1,
    inflateSync,
    inflateRaw: inflateRaw1,
    inflateRawSync,
    unzip,
    unzipSync
};
const __default80 = {
    _http_agent: __default16,
    _http_outgoing: __default21,
    _stream_duplex: Tu,
    _stream_passthrough: Mu,
    _stream_readable: Au,
    _stream_transform: Iu,
    _stream_writable: mu,
    assert: __default22,
    "assert/strict": strict,
    async_hooks: __default15,
    buffer: __default6,
    crypto: __default51,
    console: __default32,
    constants: __default35,
    child_process: __default30,
    cluster: __default31,
    dgram: __default53,
    diagnostics_channel: __default13,
    dns: __default12,
    "dns/promises": promises,
    domain: __default54,
    events: EventEmitter,
    fs: __default33,
    "fs/promises": promises1,
    http: __default55,
    http2: __default56,
    https: __default57,
    inspector: __default58,
    "internal/child_process": __default29,
    "internal/crypto/certificate": Certificate,
    "internal/crypto/cipher": __default48,
    "internal/crypto/diffiehellman": __default44,
    "internal/crypto/hash": __default38,
    "internal/crypto/hkdf": __default42,
    "internal/crypto/keygen": __default43,
    "internal/crypto/keys": __default37,
    "internal/crypto/pbkdf2": __default39,
    "internal/crypto/random": __default36,
    "internal/crypto/scrypt": __default40,
    "internal/crypto/sig": __default49,
    "internal/crypto/util": __default41,
    "internal/crypto/x509": __default50,
    "internal/dgram": __default52,
    "internal/dns/promises": __default11,
    "internal/errors": __default2,
    "internal/event_target": __default59,
    "internal/fs/utils": __default28,
    "internal/http": __default20,
    "internal/readline/utils": __default7,
    "internal/streams/add-abort-signal": __default60,
    "internal/streams/buffer_list": BufferList,
    "internal/streams/lazy_transform": LazyTransform,
    "internal/streams/state": __default17,
    "internal/test/binding": __default61,
    "internal/timers": __default9,
    "internal/util/inspect": __default1,
    "internal/util": __default5,
    net: __default14,
    os: __default34,
    "path/posix": __default24,
    "path/win32": __default23,
    path: __default25,
    perf_hooks: __default62,
    process: process2,
    get punycode () {
        process2.emitWarning("The `punycode` module is deprecated. Please use a userland " + "alternative instead.", "DeprecationWarning", "DEP0040");
        return __default63;
    },
    querystring: __default26,
    readline: __default65,
    "readline/promises": __default64,
    repl: __default66,
    stream: Lu,
    "stream/consumers": __default67,
    "stream/promises": __default68,
    "stream/web": __default69,
    string_decoder: __default8,
    sys: __default19,
    timers: __default10,
    "timers/promises": __default70,
    tls: __default73,
    tty: __default74,
    url: __default27,
    util: __default19,
    "util/types": __default18,
    v8: __default75,
    vm: __default76,
    wasi: __default78,
    worker_threads: __default77,
    zlib: __default79
};
const callerPath = `const callerCallsite = require("caller-callsite");
const re = /^file:/;

module.exports = () => {
  const fileUrl = callerCallsite().getFileName();
  return fileUrl.replace(re, "");
};
`;
const getCallerFile = `
const re = /^file:\\/\\//;

module.exports = function getCallerFile(position = 2) {
  if (position >= Error.stackTraceLimit) {
    throw new TypeError('getCallerFile(position) requires position be less then Error.stackTraceLimit but position was: "' + position + '" and Error.stackTraceLimit was: "' + Error.stackTraceLimit + '"');
  }

  const oldPrepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = (_, stack)  => stack;
  const stack = new Error().stack;
  Error.prepareStackTrace = oldPrepareStackTrace;


  if (stack !== null && typeof stack === 'object') {
    // stack[0] holds this file
    // stack[1] holds where this function was called
    // stack[2] holds the file we're interested in
    return stack[position] ? stack[position].getFileName().replace(re, "") : undefined;
  }
};
`;
const __default81 = {
    "caller-path": callerPath,
    "get-caller-file": getCallerFile
};
const { hasOwn: hasOwn1  } = Object;
const encodedSepRegEx = /%2F|%2C/i;
function throwInvalidSubpath(subpath, packageJSONUrl, internal, base) {
    const reason = `request is not a valid subpath for the "${internal ? "imports" : "exports"}" resolution of ${fileURLToPath(packageJSONUrl)}`;
    throw new ERR_INVALID_MODULE_SPECIFIER(subpath, reason, base && fileURLToPath(base));
}
function throwInvalidPackageTarget(subpath, target, packageJSONUrl, internal, base) {
    if (typeof target === "object" && target !== null) {
        target = JSON.stringify(target, null, "");
    } else {
        target = `${target}`;
    }
    throw new ERR_INVALID_PACKAGE_TARGET(fileURLToPath(new URL(".", packageJSONUrl)), subpath, target, internal, base && fileURLToPath(base));
}
function throwImportNotDefined(specifier, packageJSONUrl, base) {
    throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier, packageJSONUrl && fileURLToPath(new URL(".", packageJSONUrl)), fileURLToPath(base));
}
function throwExportsNotFound(subpath, packageJSONUrl, base) {
    throw new ERR_PACKAGE_PATH_NOT_EXPORTED(subpath, fileURLToPath(new URL(".", packageJSONUrl)), base && fileURLToPath(base));
}
function patternKeyCompare(a, b) {
    const aPatternIndex = a.indexOf("*");
    const bPatternIndex = b.indexOf("*");
    const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
    const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
    if (baseLenA > baseLenB) return -1;
    if (baseLenB > baseLenA) return 1;
    if (aPatternIndex === -1) return 1;
    if (bPatternIndex === -1) return -1;
    if (a.length > b.length) return -1;
    if (b.length > a.length) return 1;
    return 0;
}
function fileExists(url) {
    try {
        const info = Deno.statSync(url);
        return info.isFile;
    } catch  {
        return false;
    }
}
function tryStatSync(path) {
    try {
        const info = Deno.statSync(path);
        return {
            isDirectory: info.isDirectory
        };
    } catch  {
        return {
            isDirectory: false
        };
    }
}
function legacyMainResolve(packageJSONUrl, packageConfig, base) {
    let guess;
    if (packageConfig.main !== undefined) {
        if (fileExists(guess = new URL(`./${packageConfig.main}`, packageJSONUrl))) {
            return guess;
        } else if (fileExists(guess = new URL(`./${packageConfig.main}.js`, packageJSONUrl))) {} else if (fileExists(guess = new URL(`./${packageConfig.main}.json`, packageJSONUrl))) {} else if (fileExists(guess = new URL(`./${packageConfig.main}.node`, packageJSONUrl))) {} else if (fileExists(guess = new URL(`./${packageConfig.main}/index.js`, packageJSONUrl))) {} else if (fileExists(guess = new URL(`./${packageConfig.main}/index.json`, packageJSONUrl))) {} else if (fileExists(guess = new URL(`./${packageConfig.main}/index.node`, packageJSONUrl))) {} else guess = undefined;
        if (guess) {
            return guess;
        }
    }
    if (fileExists(guess = new URL("./index.js", packageJSONUrl))) {} else if (fileExists(guess = new URL("./index.json", packageJSONUrl))) {} else if (fileExists(guess = new URL("./index.node", packageJSONUrl))) {} else guess = undefined;
    if (guess) {
        return guess;
    }
    throw new ERR_MODULE_NOT_FOUND(fileURLToPath(new URL(".", packageJSONUrl)), fileURLToPath(base));
}
function parsePackageName(specifier, base) {
    let separatorIndex = specifier.indexOf("/");
    let validPackageName = true;
    let isScoped = false;
    if (specifier[0] === "@") {
        isScoped = true;
        if (separatorIndex === -1 || specifier.length === 0) {
            validPackageName = false;
        } else {
            separatorIndex = specifier.indexOf("/", separatorIndex + 1);
        }
    }
    const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
    for(let i = 0; i < packageName.length; i++){
        if (packageName[i] === "%" || packageName[i] === "\\") {
            validPackageName = false;
            break;
        }
    }
    if (!validPackageName) {
        throw new ERR_INVALID_MODULE_SPECIFIER(specifier, "is not a valid package name", fileURLToPath(base));
    }
    const packageSubpath = "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex));
    return {
        packageName,
        packageSubpath,
        isScoped
    };
}
function packageResolve(specifier, base, conditions) {
    const { packageName , packageSubpath , isScoped  } = parsePackageName(specifier, base);
    const packageConfig = getPackageScopeConfig(base);
    if (packageConfig.exists) {
        const packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);
        if (packageConfig.name === packageName && packageConfig.exports !== undefined && packageConfig.exports !== null) {
            return packageExportsResolve(packageJSONUrl.toString(), packageSubpath, packageConfig, base, conditions);
        }
    }
    let packageJSONUrl = new URL("./node_modules/" + packageName + "/package.json", base);
    let packageJSONPath = fileURLToPath(packageJSONUrl);
    let lastPath;
    do {
        const stat = tryStatSync(packageJSONPath.slice(0, packageJSONPath.length - 13));
        if (!stat.isDirectory) {
            lastPath = packageJSONPath;
            packageJSONUrl = new URL((isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json", packageJSONUrl);
            packageJSONPath = fileURLToPath(packageJSONUrl);
            continue;
        }
        const packageConfig = getPackageConfig(packageJSONPath, specifier, base);
        if (packageConfig.exports !== undefined && packageConfig.exports !== null) {
            return packageExportsResolve(packageJSONUrl.toString(), packageSubpath, packageConfig, base, conditions);
        }
        if (packageSubpath === ".") {
            return legacyMainResolve(packageJSONUrl, packageConfig, base);
        }
        return new URL(packageSubpath, packageJSONUrl);
    }while (packageJSONPath.length !== lastPath.length)
    throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base));
}
const invalidSegmentRegEx = /(^|\\|\/)(\.\.?|node_modules)(\\|\/|$)/;
const patternRegEx = /\*/g;
function resolvePackageTargetString(target, subpath, match, packageJSONUrl, base, pattern, internal, conditions) {
    if (subpath !== "" && !pattern && target[target.length - 1] !== "/") {
        throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
    }
    if (!target.startsWith("./")) {
        if (internal && !target.startsWith("../") && !target.startsWith("/")) {
            let isURL = false;
            try {
                new URL(target);
                isURL = true;
            } catch  {}
            if (!isURL) {
                const exportTarget = pattern ? target.replace(patternRegEx, ()=>subpath) : target + subpath;
                return packageResolve(exportTarget, packageJSONUrl, conditions);
            }
        }
        throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
    }
    if (invalidSegmentRegEx.test(target.slice(2))) {
        throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
    }
    const resolved = new URL(target, packageJSONUrl);
    const resolvedPath = resolved.pathname;
    const packagePath = new URL(".", packageJSONUrl).pathname;
    if (!resolvedPath.startsWith(packagePath)) {
        throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
    }
    if (subpath === "") return resolved;
    if (invalidSegmentRegEx.test(subpath)) {
        const request = pattern ? match.replace("*", ()=>subpath) : match + subpath;
        throwInvalidSubpath(request, packageJSONUrl, internal, base);
    }
    if (pattern) {
        return new URL(resolved.href.replace(patternRegEx, ()=>subpath));
    }
    return new URL(subpath, resolved);
}
function isArrayIndex1(key) {
    const keyNum = +key;
    if (`${keyNum}` !== key) return false;
    return keyNum >= 0 && keyNum < 0xFFFF_FFFF;
}
function resolvePackageTarget(packageJSONUrl, target, subpath, packageSubpath, base, pattern, internal, conditions) {
    if (typeof target === "string") {
        return resolvePackageTargetString(target, subpath, packageSubpath, packageJSONUrl, base, pattern, internal, conditions);
    } else if (Array.isArray(target)) {
        if (target.length === 0) {
            return undefined;
        }
        let lastException;
        for(let i = 0; i < target.length; i++){
            const targetItem = target[i];
            let resolved;
            try {
                resolved = resolvePackageTarget(packageJSONUrl, targetItem, subpath, packageSubpath, base, pattern, internal, conditions);
            } catch (e) {
                lastException = e;
                if (e instanceof NodeError && e.code === "ERR_INVALID_PACKAGE_TARGET") {
                    continue;
                }
                throw e;
            }
            if (resolved === undefined) {
                continue;
            }
            if (resolved === null) {
                lastException = null;
                continue;
            }
            return resolved;
        }
        if (lastException === undefined || lastException === null) {
            return undefined;
        }
        throw lastException;
    } else if (typeof target === "object" && target !== null) {
        const keys = Object.getOwnPropertyNames(target);
        for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            if (isArrayIndex1(key)) {
                throw new ERR_INVALID_PACKAGE_CONFIG(fileURLToPath(packageJSONUrl), base, '"exports" cannot contain numeric property keys.');
            }
        }
        for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            if (key === "default" || conditions.has(key)) {
                const conditionalTarget = target[key];
                const resolved = resolvePackageTarget(packageJSONUrl, conditionalTarget, subpath, packageSubpath, base, pattern, internal, conditions);
                if (resolved === undefined) {
                    continue;
                }
                return resolved;
            }
        }
        return undefined;
    } else if (target === null) {
        return undefined;
    }
    throwInvalidPackageTarget(packageSubpath, target, packageJSONUrl, internal, base);
}
function packageExportsResolve(packageJSONUrl, packageSubpath, packageConfig, base, conditions) {
    let exports = packageConfig.exports;
    if (isConditionalExportsMainSugar(exports, packageJSONUrl, base)) {
        exports = {
            ".": exports
        };
    }
    if (hasOwn1(exports, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
        const target = exports[packageSubpath];
        const resolved = resolvePackageTarget(packageJSONUrl, target, "", packageSubpath, base, false, false, conditions);
        if (resolved === null || resolved === undefined) {
            throwExportsNotFound(packageSubpath, packageJSONUrl, base);
        }
        return resolved;
    }
    let bestMatch = "";
    let bestMatchSubpath = "";
    const keys = Object.getOwnPropertyNames(exports);
    for(let i = 0; i < keys.length; i++){
        const key = keys[i];
        const patternIndex = key.indexOf("*");
        if (patternIndex !== -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
            if (packageSubpath.endsWith("/")) {}
            const patternTrailer = key.slice(patternIndex + 1);
            if (packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
                bestMatch = key;
                bestMatchSubpath = packageSubpath.slice(patternIndex, packageSubpath.length - patternTrailer.length);
            }
        }
    }
    if (bestMatch) {
        const target = exports[bestMatch];
        const resolved = resolvePackageTarget(packageJSONUrl, target, bestMatchSubpath, bestMatch, base, true, false, conditions);
        if (resolved === null || resolved === undefined) {
            throwExportsNotFound(packageSubpath, packageJSONUrl, base);
        }
        return resolved;
    }
    throwExportsNotFound(packageSubpath, packageJSONUrl, base);
}
const packageJSONCache = new Map();
function getPackageConfig(path, specifier, base) {
    const existing = packageJSONCache.get(path);
    if (existing !== undefined) {
        return existing;
    }
    let source;
    try {
        source = new TextDecoder().decode(Deno.readFileSync(path));
    } catch  {}
    if (source === undefined) {
        const packageConfig = {
            pjsonPath: path,
            exists: false,
            main: undefined,
            name: undefined,
            type: "none",
            exports: undefined,
            imports: undefined
        };
        packageJSONCache.set(path, packageConfig);
        return packageConfig;
    }
    let packageJSON;
    try {
        packageJSON = JSON.parse(source);
    } catch (error) {
        throw new ERR_INVALID_PACKAGE_CONFIG(path, (base ? `"${specifier}" from ` : "") + fileURLToPath(base || specifier), error.message);
    }
    let { imports , main , name , type  } = packageJSON;
    const { exports  } = packageJSON;
    if (typeof imports !== "object" || imports === null) imports = undefined;
    if (typeof main !== "string") main = undefined;
    if (typeof name !== "string") name = undefined;
    if (type !== "module" && type !== "commonjs") type = "none";
    const packageConfig = {
        pjsonPath: path,
        exists: true,
        main,
        name,
        type,
        exports,
        imports
    };
    packageJSONCache.set(path, packageConfig);
    return packageConfig;
}
function getPackageScopeConfig(resolved) {
    let packageJSONUrl = new URL("./package.json", resolved);
    while(true){
        const packageJSONPath = packageJSONUrl.pathname;
        if (packageJSONPath.endsWith("node_modules/package.json")) {
            break;
        }
        const packageConfig = getPackageConfig(fileURLToPath(packageJSONUrl), resolved);
        if (packageConfig.exists) return packageConfig;
        const lastPackageJSONUrl = packageJSONUrl;
        packageJSONUrl = new URL("../package.json", packageJSONUrl);
        if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) break;
    }
    const packageJSONPath = fileURLToPath(packageJSONUrl);
    const packageConfig = {
        pjsonPath: packageJSONPath,
        exists: false,
        main: undefined,
        name: undefined,
        type: "none",
        exports: undefined,
        imports: undefined
    };
    packageJSONCache.set(packageJSONPath, packageConfig);
    return packageConfig;
}
function packageImportsResolve(name, base, conditions) {
    if (name === "#" || name.startsWith("#/") || name.startsWith("/")) {
        const reason = "is not a valid internal imports specifier name";
        throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, fileURLToPath(base));
    }
    let packageJSONUrl;
    const packageConfig = getPackageScopeConfig(base);
    if (packageConfig.exists) {
        packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);
        const imports = packageConfig.imports;
        if (imports) {
            if (hasOwn1(imports, name) && !name.includes("*")) {
                const resolved = resolvePackageTarget(packageJSONUrl.toString(), imports[name], "", name, base, false, true, conditions);
                if (resolved !== null && resolved !== undefined) {
                    return resolved;
                }
            } else {
                let bestMatch = "";
                let bestMatchSubpath = "";
                const keys = Object.getOwnPropertyNames(imports);
                for(let i = 0; i < keys.length; i++){
                    const key = keys[i];
                    const patternIndex = key.indexOf("*");
                    if (patternIndex !== -1 && name.startsWith(key.slice(0, patternIndex))) {
                        const patternTrailer = key.slice(patternIndex + 1);
                        if (name.length >= key.length && name.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
                            bestMatch = key;
                            bestMatchSubpath = name.slice(patternIndex, name.length - patternTrailer.length);
                        }
                    }
                }
                if (bestMatch) {
                    const target = imports[bestMatch];
                    const resolved = resolvePackageTarget(packageJSONUrl.toString(), target, bestMatchSubpath, bestMatch, base, true, true, conditions);
                    if (resolved !== null && resolved !== undefined) {
                        return resolved;
                    }
                }
            }
        }
    }
    throwImportNotDefined(name, packageJSONUrl, base);
}
function isConditionalExportsMainSugar(exports, packageJSONUrl, base) {
    if (typeof exports === "string" || Array.isArray(exports)) return true;
    if (typeof exports !== "object" || exports === null) return false;
    const keys = Object.getOwnPropertyNames(exports);
    let isConditionalSugar = false;
    let i = 0;
    for(let j = 0; j < keys.length; j++){
        const key = keys[j];
        const curIsConditionalSugar = key === "" || key[0] !== ".";
        if (i++ === 0) {
            isConditionalSugar = curIsConditionalSugar;
        } else if (isConditionalSugar !== curIsConditionalSugar) {
            const message = "\"exports\" cannot contain some keys starting with '.' and some not." + " The exports object must either be an object of package subpath keys" + " or an object of main entry condition name keys only.";
            throw new ERR_INVALID_PACKAGE_CONFIG(fileURLToPath(packageJSONUrl), base, message);
        }
    }
    return isConditionalSugar;
}
const { hasOwn: hasOwn2  } = Object;
const CHAR_FORWARD_SLASH2 = "/".charCodeAt(0);
const CHAR_BACKWARD_SLASH = "\\".charCodeAt(0);
const CHAR_COLON = ":".charCodeAt(0);
const relativeResolveCache = Object.create(null);
let requireDepth = 0;
let statCache = null;
function stat1(filename) {
    filename = toNamespacedPath2(filename);
    if (statCache !== null) {
        const result = statCache.get(filename);
        if (result !== undefined) return result;
    }
    try {
        const info = Deno.statSync(filename);
        const result = info.isFile ? 0 : 1;
        if (statCache !== null) statCache.set(filename, result);
        return result;
    } catch (e) {
        if (e instanceof Deno.errors.PermissionDenied) {
            throw new Error("CJS loader requires --allow-read.");
        }
        return -1;
    }
}
function updateChildren(parent, child, scan) {
    const children = parent && parent.children;
    if (children && !(scan && children.includes(child))) {
        children.push(child);
    }
}
function finalizeEsmResolution(resolved, parentPath, pkgPath) {
    if (encodedSepRegEx.test(resolved)) {
        throw new ERR_INVALID_MODULE_SPECIFIER(resolved, 'must not include encoded "/" or "\\" characters', parentPath);
    }
    const filename = fileURLToPath(resolved);
    const actual = tryFile(filename, false);
    if (actual) {
        return actual;
    }
    throw new ERR_MODULE_NOT_FOUND(filename, resolve2(pkgPath, "package.json"));
}
function createEsmNotFoundErr(request, path) {
    const err = new Error(`Cannot find module '${request}'`);
    err.code = "MODULE_NOT_FOUND";
    if (path) {
        err.path = path;
    }
    return err;
}
function trySelfParentPath(parent) {
    if (!parent) return undefined;
    if (parent.filename) {
        return parent.filename;
    } else if (parent.id === "<repl>" || parent.id === "internal/preload") {
        try {
            return process.cwd() + sep2;
        } catch  {
            return undefined;
        }
    }
    return undefined;
}
function trySelf(parentPath, request) {
    if (!parentPath) return false;
    const { data: pkg , path: pkgPath  } = readPackageScope(parentPath) || {
        data: {},
        path: ""
    };
    if (!pkg || pkg.exports === undefined) return false;
    if (typeof pkg.name !== "string") return false;
    let expansion;
    if (request === pkg.name) {
        expansion = ".";
    } else if (request.startsWith(`${pkg.name}/`)) {
        expansion = "." + request.slice(pkg.name.length);
    } else {
        return false;
    }
    try {
        return finalizeEsmResolution(packageExportsResolve(pathToFileURL(pkgPath + "/package.json").toString(), expansion, pkg, pathToFileURL(parentPath).toString(), cjsConditions).toString(), parentPath, pkgPath);
    } catch (e) {
        if (e instanceof NodeError && e.code === "ERR_MODULE_NOT_FOUND") {
            throw createEsmNotFoundErr(request, pkgPath + "/package.json");
        }
        throw e;
    }
}
class Module {
    id;
    exports;
    parent;
    filename;
    loaded;
    children;
    paths;
    path;
    constructor(id = "", parent){
        this.id = id;
        this.exports = {};
        this.parent = parent || null;
        updateChildren(parent || null, this, false);
        this.filename = null;
        this.loaded = false;
        this.children = [];
        this.paths = [];
        this.path = dirname2(id);
    }
    static builtinModules = [];
    static _extensions = Object.create(null);
    static _cache = Object.create(null);
    static _pathCache = Object.create(null);
    static globalPaths = [];
    static wrapper = [
        "(function (exports, require, module, __filename, __dirname, setTimeout, clearTimeout, setInterval, clearInterval) { (function (exports, require, module, __filename, __dirname) {",
        "\n}).call(this, exports, require, module, __filename, __dirname); })"
    ];
    require(id) {
        if (id === "") {
            throw new Error(`id '${id}' must be a non-empty string`);
        }
        requireDepth++;
        try {
            return Module._load(id, this, false);
        } finally{
            requireDepth--;
        }
    }
    load(filename) {
        assert(!this.loaded);
        this.filename = filename;
        this.paths = Module._nodeModulePaths(dirname2(filename));
        const extension = findLongestRegisteredExtension(filename);
        Module._extensions[extension](this, filename);
        this.loaded = true;
    }
    _compile(content, filename) {
        const compiledWrapper = wrapSafe(filename, content, this);
        const dirname = dirname2(filename);
        const require1 = makeRequireFunction(this);
        const exports = this.exports;
        const thisValue = exports;
        if (requireDepth === 0) {
            statCache = new Map();
        }
        const result = compiledWrapper.call(thisValue, exports, require1, this, filename, dirname, setTimeout1, clearTimeout1, setInterval, clearInterval);
        if (requireDepth === 0) {
            statCache = null;
        }
        return result;
    }
    static _resolveLookupPaths(request, parent) {
        if (request.charAt(0) !== "." || request.length > 1 && request.charAt(1) !== "." && request.charAt(1) !== "/" && (!isWindows || request.charAt(1) !== "\\")) {
            let paths = modulePaths;
            if (parent !== null && parent.paths && parent.paths.length) {
                paths = parent.paths.concat(paths);
            }
            return paths.length > 0 ? paths : null;
        }
        if (!parent || !parent.id || !parent.filename) {
            return [
                "."
            ].concat(Module._nodeModulePaths("."), modulePaths);
        }
        return [
            dirname2(parent.filename)
        ];
    }
    static _resolveFilename(request, parent, isMain, options) {
        if (request.startsWith("node:") || nativeModuleCanBeRequiredByUsers(request)) {
            return request;
        }
        let paths;
        if (typeof options === "object" && options !== null) {
            if (Array.isArray(options.paths)) {
                const isRelative = request.startsWith("./") || request.startsWith("../") || isWindows && request.startsWith(".\\") || request.startsWith("..\\");
                if (isRelative) {
                    paths = options.paths;
                } else {
                    const fakeParent = new Module("", null);
                    paths = [];
                    for(let i = 0; i < options.paths.length; i++){
                        const path = options.paths[i];
                        fakeParent.paths = Module._nodeModulePaths(path);
                        const lookupPaths = Module._resolveLookupPaths(request, fakeParent);
                        for(let j = 0; j < lookupPaths.length; j++){
                            if (!paths.includes(lookupPaths[j])) {
                                paths.push(lookupPaths[j]);
                            }
                        }
                    }
                }
            } else if (options.paths === undefined) {
                paths = Module._resolveLookupPaths(request, parent);
            } else {
                throw new Error("options.paths is invalid");
            }
        } else {
            paths = Module._resolveLookupPaths(request, parent);
        }
        if (parent?.filename) {
            if (request[0] === "#") {
                const pkg = readPackageScope(parent.filename) || {
                    path: "",
                    data: {}
                };
                if (pkg.data?.imports != null) {
                    try {
                        return finalizeEsmResolution(packageImportsResolve(request, pathToFileURL(parent.filename).toString(), cjsConditions).toString(), parent.filename, pkg.path);
                    } catch (e) {
                        if (e instanceof NodeError && e.code === "ERR_MODULE_NOT_FOUND") {
                            throw createEsmNotFoundErr(request);
                        }
                        throw e;
                    }
                }
            }
        }
        const parentPath = trySelfParentPath(parent);
        const selfResolved = trySelf(parentPath, request);
        if (selfResolved) {
            const cacheKey = request + "\x00" + (paths.length === 1 ? paths[0] : paths.join("\x00"));
            Module._pathCache[cacheKey] = selfResolved;
            return selfResolved;
        }
        const filename = Module._findPath(request, paths, isMain);
        if (!filename) {
            const requireStack = [];
            for(let cursor = parent; cursor; cursor = cursor.parent){
                requireStack.push(cursor.filename || cursor.id);
            }
            let message = `Cannot find module '${request}'`;
            if (requireStack.length > 0) {
                message = message + "\nRequire stack:\n- " + requireStack.join("\n- ");
            }
            const err = new Error(message);
            err.code = "MODULE_NOT_FOUND";
            err.requireStack = requireStack;
            throw err;
        }
        return filename;
    }
    static _findPath(request, paths, isMain) {
        const absoluteRequest = isAbsolute2(request);
        if (absoluteRequest) {
            paths = [
                ""
            ];
        } else if (!paths || paths.length === 0) {
            return false;
        }
        const cacheKey = request + "\x00" + (paths.length === 1 ? paths[0] : paths.join("\x00"));
        const entry = Module._pathCache[cacheKey];
        if (entry) {
            return entry;
        }
        let exts;
        let trailingSlash = request.length > 0 && request.charCodeAt(request.length - 1) === CHAR_FORWARD_SLASH2;
        if (!trailingSlash) {
            trailingSlash = /(?:^|\/)\.?\.$/.test(request);
        }
        for(let i = 0; i < paths.length; i++){
            const curPath = paths[i];
            if (curPath && stat1(curPath) < 1) continue;
            const basePath = resolveExports(curPath, request, absoluteRequest);
            let filename;
            const rc = stat1(basePath);
            if (!trailingSlash) {
                if (rc === 0) {
                    filename = toRealPath(basePath);
                }
                if (!filename) {
                    if (exts === undefined) exts = Object.keys(Module._extensions);
                    filename = tryExtensions(basePath, exts, isMain);
                }
            }
            if (!filename && rc === 1) {
                if (exts === undefined) exts = Object.keys(Module._extensions);
                filename = tryPackage(basePath, exts, isMain, request);
            }
            if (filename) {
                Module._pathCache[cacheKey] = filename;
                return filename;
            }
        }
        return false;
    }
    static _load(request, parent, isMain) {
        let relResolveCacheIdentifier;
        if (parent) {
            relResolveCacheIdentifier = `${parent.path}\x00${request}`;
            const filename = relativeResolveCache[relResolveCacheIdentifier];
            if (filename !== undefined) {
                const cachedModule = Module._cache[filename];
                if (cachedModule !== undefined) {
                    updateChildren(parent, cachedModule, true);
                    if (!cachedModule.loaded) {
                        return getExportsForCircularRequire(cachedModule);
                    }
                    return cachedModule.exports;
                }
                delete relativeResolveCache[relResolveCacheIdentifier];
            }
        }
        const upstreamMod = loadUpstreamModule(request, parent, request);
        if (upstreamMod) return upstreamMod.exports;
        const filename = Module._resolveFilename(request, parent, isMain);
        if (filename.startsWith("node:")) {
            const id = filename.slice(5);
            const module = loadNativeModule(id, id);
            return module?.exports;
        }
        const cachedModule = Module._cache[filename];
        if (cachedModule !== undefined) {
            updateChildren(parent, cachedModule, true);
            if (!cachedModule.loaded) {
                return getExportsForCircularRequire(cachedModule);
            }
            return cachedModule.exports;
        }
        const mod = loadNativeModule(filename, request);
        if (mod) return mod.exports;
        const module = new Module(filename, parent);
        if (isMain) {
            process.mainModule = module;
            module.id = ".";
        }
        Module._cache[filename] = module;
        if (parent !== undefined) {
            relativeResolveCache[relResolveCacheIdentifier] = filename;
        }
        let threw = true;
        try {
            module.load(filename);
            threw = false;
        } finally{
            if (threw) {
                delete Module._cache[filename];
                if (parent !== undefined) {
                    delete relativeResolveCache[relResolveCacheIdentifier];
                }
            } else if (module.exports && Object.getPrototypeOf(module.exports) === CircularRequirePrototypeWarningProxy) {
                Object.setPrototypeOf(module.exports, PublicObjectPrototype);
            }
        }
        return module.exports;
    }
    static wrap(script) {
        script = script.replace(/^#!.*?\n/, "");
        return `${Module.wrapper[0]}${script}${Module.wrapper[1]}`;
    }
    static _nodeModulePaths(from) {
        if (isWindows) {
            from = resolve2(from);
            if (from.charCodeAt(from.length - 1) === CHAR_BACKWARD_SLASH && from.charCodeAt(from.length - 2) === CHAR_COLON) {
                return [
                    from + "node_modules"
                ];
            }
            const paths = [];
            for(let i = from.length - 1, p = 0, last = from.length; i >= 0; --i){
                const code = from.charCodeAt(i);
                if (code === CHAR_BACKWARD_SLASH || code === CHAR_FORWARD_SLASH2 || code === CHAR_COLON) {
                    if (p !== nmLen) paths.push(from.slice(0, last) + "\\node_modules");
                    last = i;
                    p = 0;
                } else if (p !== -1) {
                    if (nmChars[p] === code) {
                        ++p;
                    } else {
                        p = -1;
                    }
                }
            }
            return paths;
        } else {
            from = resolve2(from);
            if (from === "/") return [
                "/node_modules"
            ];
            const paths = [];
            for(let i = from.length - 1, p = 0, last = from.length; i >= 0; --i){
                const code = from.charCodeAt(i);
                if (code === CHAR_FORWARD_SLASH2) {
                    if (p !== nmLen) paths.push(from.slice(0, last) + "/node_modules");
                    last = i;
                    p = 0;
                } else if (p !== -1) {
                    if (nmChars[p] === code) {
                        ++p;
                    } else {
                        p = -1;
                    }
                }
            }
            paths.push("/node_modules");
            return paths;
        }
    }
    static createRequire(filename) {
        let filepath;
        if (filename instanceof URL || typeof filename === "string" && !isAbsolute2(filename)) {
            try {
                filepath = fileURLToPath(filename);
            } catch (err) {
                if (err.code === "ERR_INVALID_URL_SCHEME") {
                    throw new Error(`${createRequire.name} only supports 'file://' URLs for the 'filename' parameter. Received '${filename}'`);
                } else {
                    throw err;
                }
            }
        } else if (typeof filename !== "string") {
            throw new Error("filename should be a string");
        } else {
            filepath = filename;
        }
        return createRequireFromPath(filepath);
    }
    static _initPaths() {
        const homeDir = Deno.env.get("HOME");
        const nodePath = Deno.env.get("NODE_PATH");
        let paths = [];
        if (homeDir) {
            paths.unshift(resolve2(homeDir, ".node_libraries"));
            paths.unshift(resolve2(homeDir, ".node_modules"));
        }
        if (nodePath) {
            paths = nodePath.split(delimiter2).filter(function pathsFilterCB(path) {
                return !!path;
            }).concat(paths);
        }
        modulePaths = paths;
        Module.globalPaths = modulePaths.slice(0);
    }
    static _preloadModules(requests) {
        if (!Array.isArray(requests)) {
            return;
        }
        const parent = new Module("internal/preload", null);
        try {
            parent.paths = Module._nodeModulePaths(Deno.cwd());
        } catch (e) {
            if (!(e instanceof Error) || e.code !== "ENOENT") {
                throw e;
            }
        }
        for(let n = 0; n < requests.length; n++){
            parent.require(requests[n]);
        }
    }
}
const nativeModulePolyfill = new Map();
function createNativeModule(id, exports) {
    const mod = new Module(id);
    mod.exports = exports;
    mod.loaded = true;
    return mod;
}
const m1 = {
    _cache: Module._cache,
    _extensions: Module._extensions,
    _findPath: Module._findPath,
    _initPaths: Module._initPaths,
    _load: Module._load,
    _nodeModulePaths: Module._nodeModulePaths,
    _pathCache: Module._pathCache,
    _preloadModules: Module._preloadModules,
    _resolveFilename: Module._resolveFilename,
    _resolveLookupPaths: Module._resolveLookupPaths,
    builtinModules: Module.builtinModules,
    createRequire: Module.createRequire,
    globalPaths: Module.globalPaths,
    Module,
    wrap: Module.wrap
};
Object.setPrototypeOf(m1, Module);
__default80.module = m1;
function loadNativeModule(_filename, request) {
    if (nativeModulePolyfill.has(request)) {
        return nativeModulePolyfill.get(request);
    }
    const mod = __default80[request];
    if (mod) {
        const nodeMod = createNativeModule(request, mod);
        nativeModulePolyfill.set(request, nodeMod);
        return nodeMod;
    }
    return undefined;
}
function nativeModuleCanBeRequiredByUsers(request) {
    return hasOwn2(__default80, request);
}
Module.builtinModules.push(...Object.keys(__default80));
const upstreamModules = new Map();
function loadUpstreamModule(filename, parent, request) {
    if (typeof __default81[request] !== "undefined") {
        if (!upstreamModules.has(filename)) {
            upstreamModules.set(filename, createUpstreamModule(filename, parent, __default81[request]));
        }
        return upstreamModules.get(filename);
    }
}
function createUpstreamModule(filename, parent, content) {
    const mod = new Module(filename, parent);
    mod.filename = filename;
    mod.paths = Module._nodeModulePaths(dirname2(filename));
    mod._compile(content, filename);
    mod.loaded = true;
    return mod;
}
let modulePaths = [];
const packageJsonCache = new Map();
function readPackage(requestPath) {
    const jsonPath = resolve2(requestPath, "package.json");
    const existing = packageJsonCache.get(jsonPath);
    if (existing !== undefined) {
        return existing;
    }
    let json;
    try {
        json = new TextDecoder().decode(Deno.readFileSync(toNamespacedPath2(jsonPath)));
    } catch  {}
    if (json === undefined) {
        packageJsonCache.set(jsonPath, null);
        return null;
    }
    try {
        const parsed = JSON.parse(json);
        const filtered = {
            name: parsed.name,
            main: parsed.main,
            path: jsonPath,
            exports: parsed.exports,
            imports: parsed.imports,
            type: parsed.type
        };
        packageJsonCache.set(jsonPath, filtered);
        return filtered;
    } catch (e) {
        const err = e instanceof Error ? e : new Error("[non-error thrown]");
        err.path = jsonPath;
        err.message = "Error parsing " + jsonPath + ": " + err.message;
        throw e;
    }
}
function readPackageScope(checkPath) {
    const rootSeparatorIndex = checkPath.indexOf(sep2);
    let separatorIndex;
    while((separatorIndex = checkPath.lastIndexOf(sep2)) > rootSeparatorIndex){
        checkPath = checkPath.slice(0, separatorIndex);
        if (checkPath.endsWith(sep2 + "node_modules")) return false;
        const pjson = readPackage(checkPath);
        if (pjson) {
            return {
                path: checkPath,
                data: pjson
            };
        }
    }
    return false;
}
function readPackageMain(requestPath) {
    const pkg = readPackage(requestPath);
    return pkg ? pkg.main : undefined;
}
function readPackageExports(requestPath) {
    const pkg = readPackage(requestPath);
    return pkg ? pkg.exports : undefined;
}
function tryPackage(requestPath, exts, isMain, _originalPath) {
    const pkg = readPackageMain(requestPath);
    if (!pkg) {
        return tryExtensions(resolve2(requestPath, "index"), exts, isMain);
    }
    const filename = resolve2(requestPath, pkg);
    let actual = tryFile(filename, isMain) || tryExtensions(filename, exts, isMain) || tryExtensions(resolve2(filename, "index"), exts, isMain);
    if (actual === false) {
        actual = tryExtensions(resolve2(requestPath, "index"), exts, isMain);
        if (!actual) {
            const err = new Error(`Cannot find module '${filename}'. ` + 'Please verify that the package.json has a valid "main" entry');
            err.code = "MODULE_NOT_FOUND";
            throw err;
        }
    }
    return actual;
}
function tryFile(requestPath, _isMain) {
    const rc = stat1(requestPath);
    return rc === 0 && toRealPath(requestPath);
}
function toRealPath(requestPath) {
    return Deno.realPathSync(requestPath);
}
function tryExtensions(p, exts, isMain) {
    for(let i = 0; i < exts.length; i++){
        const filename = tryFile(p + exts[i], isMain);
        if (filename) {
            return filename;
        }
    }
    return false;
}
function findLongestRegisteredExtension(filename) {
    const name = basename2(filename);
    let currentExtension;
    let index;
    let startIndex = 0;
    while((index = name.indexOf(".", startIndex)) !== -1){
        startIndex = index + 1;
        if (index === 0) continue;
        currentExtension = name.slice(index);
        if (Module._extensions[currentExtension]) return currentExtension;
    }
    return ".js";
}
function isConditionalDotExportSugar(exports, _basePath) {
    if (typeof exports === "string") return true;
    if (Array.isArray(exports)) return true;
    if (typeof exports !== "object") return false;
    let isConditional = false;
    let firstCheck = true;
    for (const key of Object.keys(exports)){
        const curIsConditional = key[0] !== ".";
        if (firstCheck) {
            firstCheck = false;
            isConditional = curIsConditional;
        } else if (isConditional !== curIsConditional) {
            throw new Error('"exports" cannot ' + "contain some keys starting with '.' and some not. The exports " + "object must either be an object of package subpath keys or an " + "object of main entry condition name keys only.");
        }
    }
    return isConditional;
}
function applyExports(basePath, expansion) {
    const mappingKey = `.${expansion}`;
    let pkgExports = readPackageExports(basePath);
    if (pkgExports === undefined || pkgExports === null) {
        return resolve2(basePath, mappingKey);
    }
    if (isConditionalDotExportSugar(pkgExports, basePath)) {
        pkgExports = {
            ".": pkgExports
        };
    }
    if (typeof pkgExports === "object") {
        if (hasOwn2(pkgExports, mappingKey)) {
            const mapping = pkgExports[mappingKey];
            return resolveExportsTarget(pathToFileURL(basePath + "/"), mapping, "", basePath, mappingKey);
        }
        if (mappingKey === ".") return basePath;
        let dirMatch = "";
        for (const candidateKey of Object.keys(pkgExports)){
            if (candidateKey[candidateKey.length - 1] !== "/") continue;
            if (candidateKey.length > dirMatch.length && mappingKey.startsWith(candidateKey)) {
                dirMatch = candidateKey;
            }
        }
        if (dirMatch !== "") {
            const mapping = pkgExports[dirMatch];
            const subpath = mappingKey.slice(dirMatch.length);
            return resolveExportsTarget(pathToFileURL(basePath + "/"), mapping, subpath, basePath, mappingKey);
        }
    }
    if (mappingKey === ".") return basePath;
    const e = new Error(`Package exports for '${basePath}' do not define ` + `a '${mappingKey}' subpath`);
    e.code = "MODULE_NOT_FOUND";
    throw e;
}
const EXPORTS_PATTERN = /^((?:@[^/\\%]+\/)?[^./\\%][^/\\%]*)(\/.*)?$/;
function resolveExports(nmPath, request, absoluteRequest) {
    if (!absoluteRequest) {
        const [, name, expansion = ""] = request.match(EXPORTS_PATTERN) || [];
        if (!name) {
            return resolve2(nmPath, request);
        }
        const basePath = resolve2(nmPath, name);
        return applyExports(basePath, expansion);
    }
    return resolve2(nmPath, request);
}
const cjsConditions = new Set([
    "deno",
    "require",
    "node"
]);
function resolveExportsTarget(pkgPath, target, subpath, basePath, mappingKey) {
    if (typeof target === "string") {
        if (target.startsWith("./") && (subpath.length === 0 || target.endsWith("/"))) {
            const resolvedTarget = new URL(target, pkgPath);
            const pkgPathPath = pkgPath.pathname;
            const resolvedTargetPath = resolvedTarget.pathname;
            if (resolvedTargetPath.startsWith(pkgPathPath) && resolvedTargetPath.indexOf("/node_modules/", pkgPathPath.length - 1) === -1) {
                const resolved = new URL(subpath, resolvedTarget);
                const resolvedPath = resolved.pathname;
                if (resolvedPath.startsWith(resolvedTargetPath) && resolvedPath.indexOf("/node_modules/", pkgPathPath.length - 1) === -1) {
                    return fileURLToPath(resolved);
                }
            }
        }
    } else if (Array.isArray(target)) {
        for (const targetValue of target){
            if (Array.isArray(targetValue)) continue;
            try {
                return resolveExportsTarget(pkgPath, targetValue, subpath, basePath, mappingKey);
            } catch (e) {
                if (!(e instanceof Error) || e.code !== "MODULE_NOT_FOUND") {
                    throw e;
                }
            }
        }
    } else if (typeof target === "object" && target !== null) {
        for (const key of Object.keys(target)){
            if (key !== "default" && !cjsConditions.has(key)) {
                continue;
            }
            if (hasOwn2(target, key)) {
                try {
                    return resolveExportsTarget(pkgPath, target[key], subpath, basePath, mappingKey);
                } catch (e) {
                    if (!(e instanceof Error) || e.code !== "MODULE_NOT_FOUND") {
                        throw e;
                    }
                }
            }
        }
    }
    let e;
    if (mappingKey !== ".") {
        e = new Error(`Package exports for '${basePath}' do not define a ` + `valid '${mappingKey}' target${subpath ? " for " + subpath : ""}`);
    } else {
        e = new Error(`No valid exports main found for '${basePath}'`);
    }
    e.code = "MODULE_NOT_FOUND";
    throw e;
}
const nmChars = [
    115,
    101,
    108,
    117,
    100,
    111,
    109,
    95,
    101,
    100,
    111,
    110
];
const nmLen = nmChars.length;
function emitCircularRequireWarning(prop) {
    console.error(`Accessing non-existent property '${String(prop)}' of module exports inside circular dependency`);
}
const CircularRequirePrototypeWarningProxy = new Proxy({}, {
    get (target, prop) {
        if (prop in target) return target[prop];
        emitCircularRequireWarning(prop);
        return undefined;
    },
    getOwnPropertyDescriptor (target, prop) {
        if (hasOwn2(target, prop)) {
            return Object.getOwnPropertyDescriptor(target, prop);
        }
        emitCircularRequireWarning(prop);
        return undefined;
    }
});
const PublicObjectPrototype = globalThis.Object.prototype;
function getExportsForCircularRequire(module) {
    if (module.exports && Object.getPrototypeOf(module.exports) === PublicObjectPrototype && !module.exports.__esModule) {
        Object.setPrototypeOf(module.exports, CircularRequirePrototypeWarningProxy);
    }
    return module.exports;
}
function enrichCJSError(error) {
    if (error instanceof SyntaxError) {
        if (error.message.includes("Cannot use import statement outside a module") || error.message.includes("Unexpected token 'export'")) {
            console.error('To load an ES module, set "type": "module" in the package.json or use ' + "the .mjs extension.");
        }
    }
}
function wrapSafe(filename, content, cjsModuleInstance) {
    const wrapper = Module.wrap(content);
    const [f, err] = core.evalContext(wrapper, filename);
    if (err) {
        if (process.mainModule === cjsModuleInstance) {
            enrichCJSError(err.thrown);
        }
        throw err.thrown;
    }
    return f;
}
Module._extensions[".js"] = (module, filename)=>{
    if (filename.endsWith(".js")) {
        const pkg = readPackageScope(filename);
        if (pkg !== false && pkg.data && pkg.data.type === "module") {
            throw new Error(`Importing ESM module: ${filename}.`);
        }
    }
    const content = new TextDecoder().decode(Deno.readFileSync(filename));
    module._compile(content, filename);
};
Module._extensions[".mjs"] = (_module, filename)=>{
    throw new Error(`Importing ESM module: ${filename}.`);
};
Module._extensions[".json"] = (module, filename)=>{
    const content = new TextDecoder().decode(Deno.readFileSync(filename));
    try {
        module.exports = JSON.parse(stripBOM(content));
    } catch (err) {
        const e = err instanceof Error ? err : new Error("[non-error thrown]");
        e.message = `${filename}: ${e.message}`;
        throw e;
    }
};
Module._extensions[".node"] = (module, filename)=>{
    module.exports = core.ops.op_napi_open(filename);
};
function createRequireFromPath(filename) {
    const trailingSlash = filename.endsWith("/") || isWindows && filename.endsWith("\\");
    const proxyPath = trailingSlash ? join4(filename, "noop.js") : filename;
    const m = new Module(proxyPath);
    m.filename = proxyPath;
    m.paths = Module._nodeModulePaths(m.path);
    return makeRequireFunction(m);
}
function makeRequireFunction(mod) {
    const require1 = function require1(path) {
        return mod.require(path);
    };
    function resolve(request, options) {
        return Module._resolveFilename(request, mod, false, options);
    }
    require1.resolve = resolve;
    function paths(request) {
        return Module._resolveLookupPaths(request, mod);
    }
    resolve.paths = paths;
    require1.main = process.mainModule;
    require1.extensions = Module._extensions;
    require1.cache = Module._cache;
    return require1;
}
function stripBOM(content) {
    if (content.charCodeAt(0) === 0xfeff) {
        content = content.slice(1);
    }
    return content;
}
Module.builtinModules;
const createRequire = Module.createRequire;
const WASM_BIN = new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    166,
    1,
    21,
    96,
    3,
    127,
    127,
    127,
    0,
    96,
    1,
    127,
    0,
    96,
    2,
    127,
    127,
    0,
    96,
    2,
    127,
    127,
    1,
    127,
    96,
    2,
    127,
    127,
    1,
    126,
    96,
    1,
    127,
    1,
    126,
    96,
    6,
    127,
    127,
    127,
    127,
    127,
    126,
    1,
    126,
    96,
    5,
    127,
    127,
    127,
    127,
    127,
    0,
    96,
    4,
    127,
    127,
    127,
    127,
    0,
    96,
    2,
    127,
    126,
    0,
    96,
    6,
    127,
    127,
    127,
    127,
    127,
    127,
    0,
    96,
    13,
    127,
    127,
    127,
    127,
    127,
    127,
    127,
    127,
    127,
    127,
    127,
    127,
    127,
    0,
    96,
    9,
    127,
    127,
    127,
    127,
    127,
    127,
    127,
    127,
    127,
    0,
    96,
    7,
    127,
    127,
    127,
    127,
    127,
    127,
    127,
    0,
    96,
    1,
    127,
    1,
    127,
    96,
    4,
    127,
    127,
    127,
    127,
    1,
    127,
    96,
    3,
    127,
    127,
    127,
    1,
    127,
    96,
    8,
    127,
    127,
    127,
    127,
    127,
    127,
    127,
    127,
    0,
    96,
    8,
    127,
    127,
    127,
    127,
    127,
    127,
    127,
    127,
    1,
    127,
    96,
    6,
    127,
    127,
    127,
    127,
    127,
    127,
    1,
    127,
    96,
    0,
    0,
    3,
    95,
    94,
    3,
    4,
    5,
    3,
    3,
    2,
    0,
    2,
    2,
    6,
    6,
    7,
    7,
    7,
    2,
    0,
    0,
    1,
    2,
    8,
    8,
    0,
    0,
    1,
    2,
    2,
    9,
    10,
    0,
    1,
    0,
    2,
    11,
    2,
    8,
    1,
    1,
    12,
    0,
    8,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    2,
    8,
    13,
    0,
    14,
    2,
    8,
    1,
    1,
    2,
    2,
    0,
    7,
    8,
    14,
    3,
    2,
    0,
    15,
    7,
    15,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    16,
    0,
    0,
    0,
    2,
    2,
    17,
    10,
    18,
    10,
    19,
    2,
    14,
    14,
    1,
    20,
    4,
    5,
    1,
    112,
    1,
    5,
    5,
    5,
    3,
    1,
    0,
    2,
    6,
    8,
    1,
    127,
    1,
    65,
    240,
    166,
    4,
    11,
    7,
    161,
    5,
    34,
    6,
    109,
    101,
    109,
    111,
    114,
    121,
    2,
    0,
    15,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    118,
    101,
    114,
    105,
    102,
    121,
    49,
    54,
    0,
    0,
    15,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    118,
    101,
    114,
    105,
    102,
    121,
    51,
    50,
    0,
    3,
    15,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    118,
    101,
    114,
    105,
    102,
    121,
    54,
    52,
    0,
    4,
    11,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    119,
    105,
    112,
    101,
    0,
    5,
    16,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    104,
    99,
    104,
    97,
    99,
    104,
    97,
    50,
    48,
    0,
    6,
    15,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    99,
    104,
    97,
    99,
    104,
    97,
    50,
    48,
    0,
    11,
    20,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    105,
    101,
    116,
    102,
    95,
    99,
    104,
    97,
    99,
    104,
    97,
    50,
    48,
    0,
    12,
    16,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    120,
    99,
    104,
    97,
    99,
    104,
    97,
    50,
    48,
    0,
    13,
    15,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    112,
    111,
    108,
    121,
    49,
    51,
    48,
    53,
    0,
    19,
    22,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    98,
    108,
    97,
    107,
    101,
    50,
    98,
    95,
    103,
    101,
    110,
    101,
    114,
    97,
    108,
    0,
    27,
    14,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    98,
    108,
    97,
    107,
    101,
    50,
    98,
    0,
    28,
    22,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    97,
    114,
    103,
    111,
    110,
    50,
    105,
    95,
    103,
    101,
    110,
    101,
    114,
    97,
    108,
    0,
    32,
    14,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    97,
    114,
    103,
    111,
    110,
    50,
    105,
    0,
    37,
    13,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    120,
    50,
    53,
    53,
    49,
    57,
    0,
    38,
    24,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    120,
    50,
    53,
    53,
    49,
    57,
    95,
    112,
    117,
    98,
    108,
    105,
    99,
    95,
    107,
    101,
    121,
    0,
    46,
    22,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    115,
    105,
    103,
    110,
    95,
    112,
    117,
    98,
    108,
    105,
    99,
    95,
    107,
    101,
    121,
    0,
    54,
    11,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    115,
    105,
    103,
    110,
    0,
    61,
    12,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    99,
    104,
    101,
    99,
    107,
    0,
    69,
    25,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    102,
    114,
    111,
    109,
    95,
    101,
    100,
    100,
    115,
    97,
    95,
    112,
    114,
    105,
    118,
    97,
    116,
    101,
    0,
    70,
    24,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    102,
    114,
    111,
    109,
    95,
    101,
    100,
    100,
    115,
    97,
    95,
    112,
    117,
    98,
    108,
    105,
    99,
    0,
    71,
    25,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    120,
    50,
    53,
    53,
    49,
    57,
    95,
    100,
    105,
    114,
    116,
    121,
    95,
    115,
    109,
    97,
    108,
    108,
    0,
    73,
    24,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    120,
    50,
    53,
    53,
    49,
    57,
    95,
    100,
    105,
    114,
    116,
    121,
    95,
    102,
    97,
    115,
    116,
    0,
    75,
    22,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    104,
    105,
    100,
    100,
    101,
    110,
    95,
    116,
    111,
    95,
    99,
    117,
    114,
    118,
    101,
    0,
    76,
    22,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    99,
    117,
    114,
    118,
    101,
    95,
    116,
    111,
    95,
    104,
    105,
    100,
    100,
    101,
    110,
    0,
    78,
    22,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    104,
    105,
    100,
    100,
    101,
    110,
    95,
    107,
    101,
    121,
    95,
    112,
    97,
    105,
    114,
    0,
    79,
    19,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    107,
    101,
    121,
    95,
    101,
    120,
    99,
    104,
    97,
    110,
    103,
    101,
    0,
    80,
    21,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    120,
    50,
    53,
    53,
    49,
    57,
    95,
    105,
    110,
    118,
    101,
    114,
    115,
    101,
    0,
    81,
    16,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    108,
    111,
    99,
    107,
    95,
    97,
    101,
    97,
    100,
    0,
    84,
    18,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    117,
    110,
    108,
    111,
    99,
    107,
    95,
    97,
    101,
    97,
    100,
    0,
    86,
    11,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    108,
    111,
    99,
    107,
    0,
    87,
    13,
    99,
    114,
    121,
    112,
    116,
    111,
    95,
    117,
    110,
    108,
    111,
    99,
    107,
    0,
    88,
    6,
    109,
    97,
    108,
    108,
    111,
    99,
    0,
    90,
    4,
    102,
    114,
    101,
    101,
    0,
    92,
    9,
    10,
    1,
    0,
    65,
    1,
    11,
    4,
    28,
    29,
    30,
    31,
    10,
    252,
    167,
    2,
    94,
    42,
    1,
    1,
    126,
    32,
    0,
    32,
    1,
    16,
    129,
    128,
    128,
    128,
    0,
    34,
    2,
    66,
    32,
    136,
    32,
    2,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    132,
    66,
    127,
    124,
    66,
    32,
    136,
    167,
    65,
    1,
    113,
    65,
    127,
    106,
    11,
    53,
    1,
    2,
    126,
    32,
    0,
    16,
    130,
    128,
    128,
    128,
    0,
    33,
    2,
    32,
    1,
    16,
    130,
    128,
    128,
    128,
    0,
    33,
    3,
    32,
    0,
    65,
    8,
    106,
    16,
    130,
    128,
    128,
    128,
    0,
    32,
    1,
    65,
    8,
    106,
    16,
    130,
    128,
    128,
    128,
    0,
    133,
    32,
    3,
    32,
    2,
    133,
    132,
    11,
    7,
    0,
    32,
    0,
    41,
    0,
    0,
    11,
    59,
    1,
    1,
    126,
    32,
    0,
    32,
    1,
    16,
    129,
    128,
    128,
    128,
    0,
    32,
    0,
    65,
    16,
    106,
    32,
    1,
    65,
    16,
    106,
    16,
    129,
    128,
    128,
    128,
    0,
    132,
    34,
    2,
    66,
    32,
    136,
    32,
    2,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    132,
    66,
    127,
    124,
    66,
    32,
    136,
    167,
    65,
    1,
    113,
    65,
    127,
    106,
    11,
    93,
    1,
    1,
    126,
    32,
    0,
    32,
    1,
    16,
    129,
    128,
    128,
    128,
    0,
    32,
    0,
    65,
    16,
    106,
    32,
    1,
    65,
    16,
    106,
    16,
    129,
    128,
    128,
    128,
    0,
    132,
    32,
    0,
    65,
    32,
    106,
    32,
    1,
    65,
    32,
    106,
    16,
    129,
    128,
    128,
    128,
    0,
    132,
    32,
    0,
    65,
    48,
    106,
    32,
    1,
    65,
    48,
    106,
    16,
    129,
    128,
    128,
    128,
    0,
    132,
    34,
    2,
    66,
    32,
    136,
    32,
    2,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    132,
    66,
    127,
    124,
    66,
    32,
    136,
    167,
    65,
    1,
    113,
    65,
    127,
    106,
    11,
    36,
    0,
    2,
    64,
    32,
    1,
    69,
    13,
    0,
    3,
    64,
    32,
    0,
    65,
    0,
    58,
    0,
    0,
    32,
    0,
    65,
    1,
    106,
    33,
    0,
    32,
    1,
    65,
    127,
    106,
    34,
    1,
    13,
    0,
    11,
    11,
    11,
    206,
    1,
    1,
    2,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    192,
    0,
    107,
    34,
    3,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    3,
    32,
    1,
    16,
    135,
    128,
    128,
    128,
    0,
    32,
    3,
    65,
    48,
    106,
    33,
    4,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    4,
    32,
    1,
    106,
    32,
    2,
    32,
    1,
    106,
    40,
    0,
    0,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    16,
    71,
    13,
    0,
    11,
    32,
    3,
    32,
    3,
    16,
    136,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    0,
    32,
    1,
    106,
    32,
    3,
    32,
    1,
    106,
    40,
    2,
    0,
    54,
    0,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    16,
    71,
    13,
    0,
    11,
    32,
    3,
    65,
    48,
    106,
    33,
    2,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    0,
    32,
    1,
    106,
    65,
    16,
    106,
    32,
    2,
    32,
    1,
    106,
    40,
    2,
    0,
    54,
    0,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    16,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    3,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    32,
    3,
    65,
    192,
    0,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    77,
    1,
    1,
    127,
    32,
    0,
    66,
    178,
    218,
    136,
    203,
    199,
    174,
    153,
    144,
    235,
    0,
    55,
    2,
    8,
    32,
    0,
    66,
    229,
    240,
    193,
    139,
    230,
    141,
    153,
    144,
    51,
    55,
    2,
    0,
    32,
    0,
    65,
    16,
    106,
    33,
    2,
    65,
    0,
    33,
    0,
    3,
    64,
    32,
    2,
    32,
    0,
    106,
    32,
    1,
    32,
    0,
    106,
    40,
    0,
    0,
    54,
    2,
    0,
    32,
    0,
    65,
    4,
    106,
    34,
    0,
    65,
    32,
    71,
    13,
    0,
    11,
    11,
    156,
    5,
    1,
    19,
    127,
    32,
    1,
    40,
    2,
    60,
    33,
    2,
    32,
    1,
    40,
    2,
    56,
    33,
    3,
    32,
    1,
    40,
    2,
    52,
    33,
    4,
    32,
    1,
    40,
    2,
    48,
    33,
    5,
    32,
    1,
    40,
    2,
    44,
    33,
    6,
    32,
    1,
    40,
    2,
    40,
    33,
    7,
    32,
    1,
    40,
    2,
    36,
    33,
    8,
    32,
    1,
    40,
    2,
    32,
    33,
    9,
    32,
    1,
    40,
    2,
    28,
    33,
    10,
    32,
    1,
    40,
    2,
    24,
    33,
    11,
    32,
    1,
    40,
    2,
    20,
    33,
    12,
    32,
    1,
    40,
    2,
    16,
    33,
    13,
    32,
    1,
    40,
    2,
    12,
    33,
    14,
    32,
    1,
    40,
    2,
    8,
    33,
    15,
    32,
    1,
    40,
    2,
    4,
    33,
    16,
    32,
    1,
    40,
    2,
    0,
    33,
    1,
    65,
    10,
    33,
    17,
    3,
    64,
    32,
    5,
    32,
    13,
    32,
    1,
    106,
    34,
    1,
    115,
    65,
    16,
    119,
    34,
    5,
    32,
    9,
    106,
    34,
    9,
    32,
    13,
    115,
    65,
    12,
    119,
    34,
    13,
    32,
    1,
    106,
    34,
    1,
    32,
    5,
    115,
    65,
    8,
    119,
    34,
    5,
    32,
    9,
    106,
    34,
    9,
    32,
    13,
    115,
    65,
    7,
    119,
    34,
    13,
    32,
    2,
    32,
    10,
    32,
    14,
    106,
    34,
    14,
    115,
    65,
    16,
    119,
    34,
    2,
    32,
    6,
    106,
    34,
    6,
    32,
    10,
    115,
    65,
    12,
    119,
    34,
    10,
    32,
    14,
    106,
    34,
    18,
    106,
    34,
    14,
    32,
    3,
    32,
    11,
    32,
    15,
    106,
    34,
    15,
    115,
    65,
    16,
    119,
    34,
    3,
    32,
    7,
    106,
    34,
    7,
    32,
    11,
    115,
    65,
    12,
    119,
    34,
    11,
    32,
    15,
    106,
    34,
    15,
    32,
    3,
    115,
    65,
    8,
    119,
    34,
    19,
    115,
    65,
    16,
    119,
    34,
    3,
    32,
    4,
    32,
    12,
    32,
    16,
    106,
    34,
    16,
    115,
    65,
    16,
    119,
    34,
    4,
    32,
    8,
    106,
    34,
    8,
    32,
    12,
    115,
    65,
    12,
    119,
    34,
    12,
    32,
    16,
    106,
    34,
    16,
    32,
    4,
    115,
    65,
    8,
    119,
    34,
    4,
    32,
    8,
    106,
    34,
    20,
    106,
    34,
    8,
    32,
    13,
    115,
    65,
    12,
    119,
    34,
    13,
    32,
    14,
    106,
    34,
    14,
    32,
    3,
    115,
    65,
    8,
    119,
    34,
    3,
    32,
    8,
    106,
    34,
    8,
    32,
    13,
    115,
    65,
    7,
    119,
    33,
    13,
    32,
    18,
    32,
    2,
    115,
    65,
    8,
    119,
    34,
    2,
    32,
    6,
    106,
    34,
    6,
    32,
    10,
    115,
    65,
    7,
    119,
    34,
    10,
    32,
    15,
    106,
    34,
    15,
    32,
    4,
    115,
    65,
    16,
    119,
    34,
    4,
    32,
    9,
    106,
    34,
    9,
    32,
    10,
    115,
    65,
    12,
    119,
    34,
    10,
    32,
    15,
    106,
    34,
    15,
    32,
    4,
    115,
    65,
    8,
    119,
    34,
    4,
    32,
    9,
    106,
    34,
    9,
    32,
    10,
    115,
    65,
    7,
    119,
    33,
    10,
    32,
    19,
    32,
    7,
    106,
    34,
    7,
    32,
    11,
    115,
    65,
    7,
    119,
    34,
    11,
    32,
    16,
    106,
    34,
    16,
    32,
    5,
    115,
    65,
    16,
    119,
    34,
    5,
    32,
    6,
    106,
    34,
    6,
    32,
    11,
    115,
    65,
    12,
    119,
    34,
    11,
    32,
    16,
    106,
    34,
    16,
    32,
    5,
    115,
    65,
    8,
    119,
    34,
    5,
    32,
    6,
    106,
    34,
    6,
    32,
    11,
    115,
    65,
    7,
    119,
    33,
    11,
    32,
    20,
    32,
    12,
    115,
    65,
    7,
    119,
    34,
    12,
    32,
    1,
    106,
    34,
    1,
    32,
    2,
    115,
    65,
    16,
    119,
    34,
    2,
    32,
    7,
    106,
    34,
    7,
    32,
    12,
    115,
    65,
    12,
    119,
    34,
    12,
    32,
    1,
    106,
    34,
    1,
    32,
    2,
    115,
    65,
    8,
    119,
    34,
    2,
    32,
    7,
    106,
    34,
    7,
    32,
    12,
    115,
    65,
    7,
    119,
    33,
    12,
    32,
    17,
    65,
    127,
    106,
    34,
    17,
    13,
    0,
    11,
    32,
    0,
    32,
    2,
    54,
    2,
    60,
    32,
    0,
    32,
    3,
    54,
    2,
    56,
    32,
    0,
    32,
    4,
    54,
    2,
    52,
    32,
    0,
    32,
    5,
    54,
    2,
    48,
    32,
    0,
    32,
    6,
    54,
    2,
    44,
    32,
    0,
    32,
    7,
    54,
    2,
    40,
    32,
    0,
    32,
    8,
    54,
    2,
    36,
    32,
    0,
    32,
    9,
    54,
    2,
    32,
    32,
    0,
    32,
    10,
    54,
    2,
    28,
    32,
    0,
    32,
    11,
    54,
    2,
    24,
    32,
    0,
    32,
    12,
    54,
    2,
    20,
    32,
    0,
    32,
    13,
    54,
    2,
    16,
    32,
    0,
    32,
    14,
    54,
    2,
    12,
    32,
    0,
    32,
    15,
    54,
    2,
    8,
    32,
    0,
    32,
    16,
    54,
    2,
    4,
    32,
    0,
    32,
    1,
    54,
    2,
    0,
    11,
    128,
    5,
    1,
    3,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    192,
    1,
    107,
    34,
    6,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    6,
    65,
    128,
    1,
    106,
    32,
    3,
    16,
    135,
    128,
    128,
    128,
    0,
    32,
    6,
    65,
    184,
    1,
    106,
    33,
    7,
    32,
    6,
    32,
    5,
    55,
    3,
    176,
    1,
    32,
    5,
    167,
    33,
    8,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    7,
    32,
    3,
    106,
    32,
    4,
    32,
    3,
    106,
    40,
    0,
    0,
    54,
    2,
    0,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    8,
    71,
    13,
    0,
    11,
    2,
    64,
    32,
    2,
    65,
    192,
    0,
    73,
    13,
    0,
    32,
    2,
    65,
    6,
    118,
    33,
    7,
    65,
    0,
    33,
    4,
    3,
    64,
    32,
    6,
    65,
    192,
    0,
    106,
    32,
    6,
    65,
    128,
    1,
    106,
    16,
    136,
    128,
    128,
    128,
    0,
    2,
    64,
    2,
    64,
    32,
    1,
    69,
    13,
    0,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    0,
    32,
    3,
    106,
    32,
    1,
    32,
    3,
    106,
    40,
    0,
    0,
    32,
    6,
    65,
    128,
    1,
    106,
    32,
    3,
    106,
    40,
    2,
    0,
    32,
    6,
    65,
    192,
    0,
    106,
    32,
    3,
    106,
    40,
    2,
    0,
    106,
    115,
    54,
    0,
    0,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    32,
    1,
    32,
    3,
    106,
    33,
    1,
    32,
    0,
    32,
    3,
    106,
    33,
    0,
    12,
    1,
    11,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    0,
    32,
    3,
    106,
    32,
    6,
    65,
    128,
    1,
    106,
    32,
    3,
    106,
    40,
    2,
    0,
    32,
    6,
    65,
    192,
    0,
    106,
    32,
    3,
    106,
    40,
    2,
    0,
    106,
    54,
    0,
    0,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    32,
    0,
    32,
    3,
    106,
    33,
    0,
    65,
    0,
    33,
    1,
    11,
    32,
    6,
    32,
    6,
    40,
    2,
    176,
    1,
    34,
    3,
    65,
    1,
    106,
    34,
    8,
    54,
    2,
    176,
    1,
    2,
    64,
    32,
    8,
    32,
    3,
    79,
    13,
    0,
    32,
    6,
    32,
    6,
    40,
    2,
    180,
    1,
    65,
    1,
    106,
    54,
    2,
    180,
    1,
    11,
    32,
    4,
    65,
    1,
    106,
    34,
    4,
    32,
    7,
    71,
    13,
    0,
    11,
    11,
    2,
    64,
    32,
    2,
    65,
    63,
    113,
    34,
    4,
    69,
    13,
    0,
    32,
    6,
    65,
    192,
    0,
    106,
    32,
    6,
    65,
    128,
    1,
    106,
    16,
    136,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    6,
    32,
    3,
    106,
    32,
    6,
    65,
    128,
    1,
    106,
    32,
    3,
    106,
    40,
    2,
    0,
    32,
    6,
    65,
    192,
    0,
    106,
    32,
    3,
    106,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    32,
    1,
    65,
    128,
    136,
    128,
    128,
    0,
    32,
    1,
    27,
    33,
    3,
    32,
    6,
    33,
    1,
    32,
    4,
    33,
    8,
    3,
    64,
    32,
    0,
    32,
    3,
    45,
    0,
    0,
    32,
    1,
    45,
    0,
    0,
    115,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    33,
    1,
    32,
    3,
    65,
    1,
    106,
    33,
    3,
    32,
    0,
    65,
    1,
    106,
    33,
    0,
    32,
    8,
    65,
    127,
    106,
    34,
    8,
    13,
    0,
    11,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    6,
    32,
    3,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    3,
    65,
    1,
    106,
    34,
    3,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    32,
    6,
    40,
    2,
    176,
    1,
    33,
    8,
    11,
    32,
    6,
    53,
    2,
    180,
    1,
    33,
    5,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    6,
    65,
    192,
    0,
    106,
    32,
    3,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    3,
    65,
    1,
    106,
    34,
    3,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    6,
    65,
    128,
    1,
    106,
    32,
    3,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    3,
    65,
    1,
    106,
    34,
    3,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    32,
    6,
    65,
    192,
    1,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    5,
    66,
    32,
    134,
    32,
    8,
    173,
    132,
    32,
    4,
    65,
    0,
    71,
    173,
    124,
    11,
    98,
    1,
    1,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    32,
    107,
    34,
    6,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    6,
    32,
    3,
    32,
    4,
    16,
    134,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    1,
    32,
    2,
    32,
    6,
    32,
    4,
    65,
    16,
    106,
    32,
    5,
    16,
    137,
    128,
    128,
    128,
    0,
    33,
    5,
    65,
    0,
    33,
    4,
    3,
    64,
    32,
    6,
    32,
    4,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    4,
    65,
    1,
    106,
    34,
    4,
    65,
    32,
    71,
    13,
    0,
    11,
    32,
    6,
    65,
    32,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    5,
    11,
    21,
    0,
    32,
    0,
    32,
    1,
    32,
    2,
    32,
    3,
    32,
    4,
    66,
    0,
    16,
    137,
    128,
    128,
    128,
    0,
    26,
    11,
    57,
    0,
    32,
    0,
    32,
    1,
    32,
    2,
    32,
    3,
    32,
    4,
    65,
    4,
    106,
    32,
    4,
    49,
    0,
    1,
    66,
    40,
    134,
    32,
    4,
    49,
    0,
    0,
    66,
    32,
    134,
    132,
    32,
    4,
    49,
    0,
    2,
    66,
    48,
    134,
    132,
    32,
    4,
    49,
    0,
    3,
    66,
    56,
    134,
    132,
    16,
    137,
    128,
    128,
    128,
    0,
    26,
    11,
    21,
    0,
    32,
    0,
    32,
    1,
    32,
    2,
    32,
    3,
    32,
    4,
    66,
    0,
    16,
    138,
    128,
    128,
    128,
    0,
    26,
    11,
    209,
    1,
    1,
    2,
    127,
    65,
    0,
    33,
    2,
    32,
    0,
    65,
    0,
    54,
    2,
    72,
    32,
    0,
    65,
    32,
    106,
    65,
    0,
    54,
    2,
    0,
    32,
    0,
    65,
    24,
    106,
    66,
    0,
    55,
    2,
    0,
    32,
    0,
    65,
    16,
    106,
    66,
    0,
    55,
    2,
    0,
    32,
    0,
    65,
    52,
    106,
    65,
    1,
    54,
    2,
    0,
    32,
    0,
    65,
    36,
    106,
    66,
    0,
    55,
    2,
    0,
    32,
    0,
    65,
    44,
    106,
    66,
    0,
    55,
    2,
    0,
    3,
    64,
    32,
    0,
    32,
    2,
    106,
    32,
    1,
    32,
    2,
    106,
    40,
    0,
    0,
    54,
    2,
    0,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    16,
    71,
    13,
    0,
    11,
    32,
    0,
    65,
    56,
    106,
    33,
    3,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    3,
    32,
    2,
    106,
    32,
    1,
    32,
    2,
    106,
    65,
    16,
    106,
    40,
    0,
    0,
    54,
    2,
    0,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    16,
    71,
    13,
    0,
    11,
    32,
    0,
    32,
    0,
    40,
    2,
    0,
    65,
    255,
    255,
    255,
    255,
    0,
    113,
    54,
    2,
    0,
    65,
    4,
    33,
    2,
    3,
    64,
    32,
    0,
    32,
    2,
    106,
    34,
    1,
    32,
    1,
    40,
    2,
    0,
    65,
    252,
    255,
    255,
    255,
    0,
    113,
    54,
    2,
    0,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    16,
    71,
    13,
    0,
    11,
    11,
    195,
    1,
    1,
    3,
    127,
    2,
    64,
    32,
    2,
    69,
    13,
    0,
    65,
    0,
    33,
    3,
    32,
    0,
    32,
    1,
    32,
    2,
    65,
    0,
    32,
    0,
    40,
    2,
    72,
    107,
    65,
    15,
    113,
    34,
    4,
    32,
    4,
    32,
    2,
    75,
    27,
    34,
    4,
    16,
    144,
    128,
    128,
    128,
    0,
    32,
    1,
    32,
    4,
    106,
    33,
    1,
    2,
    64,
    32,
    2,
    32,
    4,
    107,
    34,
    5,
    65,
    16,
    73,
    13,
    0,
    32,
    5,
    65,
    4,
    118,
    33,
    4,
    3,
    64,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    0,
    32,
    2,
    106,
    65,
    36,
    106,
    32,
    1,
    32,
    2,
    106,
    40,
    0,
    0,
    54,
    2,
    0,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    16,
    71,
    13,
    0,
    11,
    32,
    0,
    16,
    145,
    128,
    128,
    128,
    0,
    32,
    1,
    65,
    16,
    106,
    33,
    1,
    32,
    3,
    65,
    1,
    106,
    34,
    3,
    32,
    4,
    71,
    13,
    0,
    11,
    32,
    5,
    65,
    16,
    73,
    13,
    0,
    32,
    0,
    65,
    0,
    54,
    2,
    72,
    32,
    0,
    65,
    44,
    106,
    66,
    0,
    55,
    2,
    0,
    32,
    0,
    65,
    36,
    106,
    66,
    0,
    55,
    2,
    0,
    11,
    32,
    0,
    32,
    1,
    32,
    5,
    65,
    15,
    113,
    16,
    144,
    128,
    128,
    128,
    0,
    11,
    11,
    146,
    1,
    1,
    6,
    127,
    2,
    64,
    32,
    2,
    69,
    13,
    0,
    32,
    0,
    40,
    2,
    72,
    33,
    3,
    32,
    0,
    65,
    36,
    106,
    34,
    4,
    65,
    8,
    106,
    33,
    5,
    3,
    64,
    32,
    1,
    45,
    0,
    0,
    33,
    6,
    32,
    0,
    32,
    3,
    65,
    1,
    106,
    34,
    7,
    54,
    2,
    72,
    32,
    0,
    32,
    3,
    65,
    124,
    113,
    106,
    65,
    36,
    106,
    34,
    8,
    32,
    6,
    32,
    3,
    65,
    3,
    116,
    116,
    32,
    8,
    40,
    2,
    0,
    114,
    54,
    2,
    0,
    2,
    64,
    32,
    7,
    65,
    16,
    71,
    13,
    0,
    32,
    0,
    16,
    145,
    128,
    128,
    128,
    0,
    32,
    5,
    66,
    0,
    55,
    2,
    0,
    32,
    4,
    66,
    0,
    55,
    2,
    0,
    65,
    0,
    33,
    7,
    32,
    0,
    65,
    0,
    54,
    2,
    72,
    11,
    32,
    1,
    65,
    1,
    106,
    33,
    1,
    32,
    7,
    33,
    3,
    32,
    2,
    65,
    127,
    106,
    34,
    2,
    13,
    0,
    11,
    11,
    11,
    188,
    3,
    13,
    1,
    126,
    1,
    127,
    1,
    126,
    3,
    127,
    1,
    126,
    3,
    127,
    1,
    126,
    2,
    127,
    1,
    126,
    1,
    127,
    1,
    126,
    2,
    127,
    6,
    126,
    32,
    0,
    32,
    0,
    53,
    2,
    36,
    32,
    0,
    53,
    2,
    16,
    124,
    34,
    1,
    32,
    0,
    40,
    2,
    0,
    34,
    2,
    173,
    34,
    3,
    126,
    32,
    0,
    65,
    52,
    106,
    40,
    2,
    0,
    32,
    0,
    65,
    32,
    106,
    34,
    4,
    40,
    2,
    0,
    106,
    34,
    5,
    32,
    2,
    65,
    2,
    118,
    108,
    65,
    5,
    108,
    173,
    124,
    32,
    0,
    65,
    48,
    106,
    53,
    2,
    0,
    32,
    0,
    65,
    28,
    106,
    34,
    6,
    53,
    2,
    0,
    124,
    34,
    7,
    32,
    0,
    40,
    2,
    4,
    34,
    8,
    65,
    2,
    118,
    32,
    8,
    106,
    34,
    9,
    173,
    126,
    124,
    32,
    0,
    65,
    44,
    106,
    53,
    2,
    0,
    32,
    0,
    65,
    24,
    106,
    34,
    10,
    53,
    2,
    0,
    124,
    34,
    11,
    32,
    0,
    40,
    2,
    8,
    34,
    12,
    65,
    2,
    118,
    32,
    12,
    106,
    34,
    13,
    173,
    34,
    14,
    126,
    124,
    32,
    0,
    65,
    40,
    106,
    53,
    2,
    0,
    32,
    0,
    65,
    20,
    106,
    34,
    15,
    53,
    2,
    0,
    124,
    34,
    16,
    32,
    0,
    40,
    2,
    12,
    34,
    17,
    65,
    2,
    118,
    32,
    17,
    106,
    34,
    18,
    173,
    34,
    19,
    126,
    124,
    34,
    20,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    2,
    65,
    3,
    113,
    32,
    5,
    108,
    32,
    11,
    32,
    8,
    173,
    34,
    21,
    126,
    32,
    7,
    32,
    3,
    126,
    124,
    32,
    16,
    32,
    12,
    173,
    34,
    22,
    126,
    124,
    32,
    1,
    32,
    17,
    173,
    126,
    124,
    32,
    18,
    32,
    5,
    108,
    173,
    124,
    34,
    23,
    66,
    32,
    136,
    167,
    106,
    34,
    2,
    65,
    2,
    118,
    65,
    5,
    108,
    173,
    124,
    34,
    24,
    62,
    2,
    16,
    32,
    15,
    32,
    20,
    66,
    32,
    136,
    32,
    1,
    32,
    21,
    126,
    32,
    16,
    32,
    3,
    126,
    124,
    32,
    9,
    32,
    5,
    108,
    173,
    124,
    32,
    7,
    32,
    14,
    126,
    124,
    32,
    11,
    32,
    19,
    126,
    124,
    34,
    14,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    124,
    32,
    24,
    66,
    32,
    136,
    124,
    34,
    20,
    62,
    2,
    0,
    32,
    10,
    32,
    14,
    66,
    32,
    136,
    32,
    16,
    32,
    21,
    126,
    32,
    11,
    32,
    3,
    126,
    124,
    32,
    1,
    32,
    22,
    126,
    124,
    32,
    13,
    32,
    5,
    108,
    173,
    124,
    32,
    7,
    32,
    19,
    126,
    124,
    34,
    1,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    124,
    32,
    20,
    66,
    32,
    136,
    124,
    34,
    3,
    62,
    2,
    0,
    32,
    6,
    32,
    1,
    66,
    32,
    136,
    32,
    23,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    124,
    32,
    3,
    66,
    32,
    136,
    124,
    34,
    1,
    62,
    2,
    0,
    32,
    4,
    32,
    2,
    65,
    3,
    113,
    32,
    1,
    66,
    32,
    136,
    167,
    106,
    54,
    2,
    0,
    11,
    233,
    1,
    2,
    2,
    127,
    1,
    126,
    2,
    64,
    32,
    0,
    40,
    2,
    72,
    34,
    2,
    69,
    13,
    0,
    32,
    0,
    65,
    52,
    106,
    65,
    0,
    54,
    2,
    0,
    32,
    0,
    32,
    2,
    65,
    1,
    106,
    54,
    2,
    72,
    32,
    0,
    32,
    2,
    65,
    124,
    113,
    106,
    65,
    36,
    106,
    34,
    3,
    32,
    3,
    40,
    2,
    0,
    65,
    1,
    32,
    2,
    65,
    3,
    116,
    116,
    114,
    54,
    2,
    0,
    32,
    0,
    16,
    145,
    128,
    128,
    128,
    0,
    11,
    32,
    0,
    65,
    16,
    106,
    33,
    3,
    66,
    5,
    33,
    4,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    32,
    3,
    32,
    2,
    106,
    53,
    2,
    0,
    124,
    66,
    32,
    136,
    33,
    4,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    16,
    71,
    13,
    0,
    11,
    32,
    4,
    32,
    0,
    65,
    32,
    106,
    53,
    2,
    0,
    124,
    66,
    2,
    136,
    66,
    5,
    126,
    33,
    4,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    1,
    32,
    2,
    106,
    32,
    4,
    32,
    0,
    32,
    2,
    106,
    34,
    3,
    65,
    16,
    106,
    53,
    2,
    0,
    124,
    32,
    3,
    65,
    56,
    106,
    53,
    2,
    0,
    124,
    34,
    4,
    62,
    0,
    0,
    32,
    4,
    66,
    32,
    136,
    33,
    4,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    16,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    0,
    32,
    2,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    2,
    65,
    1,
    106,
    34,
    2,
    65,
    204,
    0,
    71,
    13,
    0,
    11,
    11,
    66,
    1,
    1,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    208,
    0,
    107,
    34,
    4,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    4,
    32,
    3,
    16,
    142,
    128,
    128,
    128,
    0,
    32,
    4,
    32,
    1,
    32,
    2,
    16,
    143,
    128,
    128,
    128,
    0,
    32,
    4,
    32,
    0,
    16,
    146,
    128,
    128,
    128,
    0,
    32,
    4,
    65,
    208,
    0,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    208,
    1,
    1,
    2,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    128,
    1,
    107,
    34,
    4,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    0,
    65,
    128,
    137,
    128,
    128,
    0,
    65,
    192,
    0,
    252,
    10,
    0,
    0,
    32,
    0,
    66,
    0,
    55,
    3,
    64,
    32,
    0,
    65,
    200,
    0,
    106,
    66,
    0,
    55,
    3,
    0,
    32,
    0,
    32,
    1,
    54,
    2,
    212,
    1,
    65,
    0,
    33,
    5,
    32,
    0,
    65,
    0,
    54,
    2,
    208,
    1,
    32,
    0,
    32,
    3,
    65,
    8,
    116,
    32,
    1,
    115,
    173,
    66,
    136,
    146,
    247,
    149,
    255,
    204,
    249,
    132,
    234,
    0,
    133,
    55,
    3,
    0,
    2,
    64,
    32,
    3,
    69,
    13,
    0,
    32,
    4,
    32,
    3,
    106,
    65,
    0,
    65,
    0,
    65,
    128,
    1,
    32,
    3,
    107,
    32,
    3,
    65,
    255,
    0,
    75,
    27,
    252,
    11,
    0,
    32,
    4,
    32,
    2,
    32,
    3,
    252,
    10,
    0,
    0,
    32,
    0,
    65,
    208,
    0,
    106,
    33,
    3,
    3,
    64,
    32,
    3,
    32,
    5,
    106,
    32,
    4,
    32,
    5,
    106,
    16,
    130,
    128,
    128,
    128,
    0,
    55,
    3,
    0,
    32,
    5,
    65,
    8,
    106,
    34,
    5,
    65,
    128,
    1,
    71,
    13,
    0,
    11,
    32,
    0,
    65,
    128,
    1,
    54,
    2,
    208,
    1,
    11,
    32,
    4,
    65,
    128,
    1,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    184,
    1,
    1,
    4,
    127,
    2,
    64,
    32,
    2,
    69,
    13,
    0,
    65,
    0,
    33,
    3,
    32,
    0,
    32,
    1,
    32,
    2,
    65,
    0,
    32,
    0,
    40,
    2,
    208,
    1,
    107,
    65,
    255,
    0,
    113,
    34,
    4,
    32,
    4,
    32,
    2,
    75,
    27,
    34,
    4,
    16,
    150,
    128,
    128,
    128,
    0,
    32,
    1,
    32,
    4,
    106,
    33,
    1,
    2,
    64,
    32,
    2,
    32,
    4,
    107,
    34,
    5,
    65,
    128,
    1,
    73,
    13,
    0,
    32,
    0,
    65,
    208,
    0,
    106,
    33,
    4,
    32,
    5,
    65,
    7,
    118,
    33,
    6,
    3,
    64,
    32,
    0,
    16,
    151,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    32,
    2,
    106,
    32,
    1,
    32,
    2,
    106,
    16,
    130,
    128,
    128,
    128,
    0,
    55,
    3,
    0,
    32,
    2,
    65,
    8,
    106,
    34,
    2,
    65,
    128,
    1,
    71,
    13,
    0,
    11,
    32,
    0,
    65,
    128,
    1,
    54,
    2,
    208,
    1,
    32,
    1,
    65,
    128,
    1,
    106,
    33,
    1,
    32,
    3,
    65,
    1,
    106,
    34,
    3,
    32,
    6,
    71,
    13,
    0,
    11,
    11,
    32,
    0,
    32,
    1,
    32,
    5,
    65,
    255,
    0,
    113,
    16,
    150,
    128,
    128,
    128,
    0,
    11,
    11,
    127,
    3,
    1,
    127,
    1,
    126,
    2,
    127,
    2,
    64,
    32,
    2,
    69,
    13,
    0,
    32,
    0,
    65,
    208,
    0,
    106,
    33,
    3,
    3,
    64,
    32,
    0,
    16,
    151,
    128,
    128,
    128,
    0,
    32,
    1,
    49,
    0,
    0,
    33,
    4,
    2,
    64,
    32,
    0,
    40,
    2,
    208,
    1,
    34,
    5,
    13,
    0,
    32,
    3,
    65,
    0,
    65,
    128,
    1,
    252,
    11,
    0,
    11,
    32,
    0,
    32,
    5,
    65,
    1,
    106,
    54,
    2,
    208,
    1,
    32,
    0,
    32,
    5,
    65,
    120,
    113,
    106,
    65,
    208,
    0,
    106,
    34,
    6,
    32,
    6,
    41,
    3,
    0,
    32,
    4,
    32,
    5,
    65,
    3,
    116,
    65,
    56,
    113,
    173,
    134,
    132,
    55,
    3,
    0,
    32,
    1,
    65,
    1,
    106,
    33,
    1,
    32,
    2,
    65,
    127,
    106,
    34,
    2,
    13,
    0,
    11,
    11,
    11,
    85,
    2,
    1,
    126,
    1,
    127,
    2,
    64,
    32,
    0,
    40,
    2,
    208,
    1,
    65,
    128,
    1,
    71,
    13,
    0,
    32,
    0,
    32,
    0,
    41,
    3,
    64,
    34,
    1,
    66,
    128,
    1,
    124,
    55,
    3,
    64,
    2,
    64,
    32,
    1,
    66,
    128,
    127,
    84,
    13,
    0,
    32,
    0,
    65,
    200,
    0,
    106,
    34,
    2,
    32,
    2,
    41,
    3,
    0,
    66,
    1,
    124,
    55,
    3,
    0,
    11,
    32,
    0,
    65,
    0,
    16,
    152,
    128,
    128,
    128,
    0,
    32,
    0,
    65,
    0,
    54,
    2,
    208,
    1,
    11,
    11,
    181,
    46,
    1,
    43,
    126,
    32,
    0,
    32,
    0,
    41,
    3,
    32,
    34,
    2,
    32,
    0,
    41,
    3,
    0,
    34,
    3,
    124,
    32,
    0,
    41,
    3,
    80,
    34,
    4,
    124,
    34,
    5,
    32,
    0,
    65,
    216,
    0,
    106,
    41,
    3,
    0,
    34,
    6,
    124,
    32,
    0,
    41,
    3,
    64,
    32,
    5,
    133,
    66,
    209,
    133,
    154,
    239,
    250,
    207,
    148,
    135,
    209,
    0,
    133,
    66,
    32,
    137,
    34,
    7,
    66,
    136,
    146,
    243,
    157,
    255,
    204,
    249,
    132,
    234,
    0,
    124,
    34,
    8,
    32,
    2,
    133,
    66,
    40,
    137,
    34,
    9,
    124,
    34,
    10,
    32,
    0,
    65,
    144,
    1,
    106,
    41,
    3,
    0,
    34,
    5,
    124,
    32,
    0,
    41,
    3,
    40,
    34,
    11,
    32,
    0,
    41,
    3,
    8,
    34,
    12,
    124,
    32,
    0,
    65,
    224,
    0,
    106,
    41,
    3,
    0,
    34,
    13,
    124,
    34,
    14,
    32,
    0,
    65,
    232,
    0,
    106,
    41,
    3,
    0,
    34,
    15,
    124,
    32,
    0,
    65,
    200,
    0,
    106,
    41,
    3,
    0,
    32,
    14,
    133,
    66,
    159,
    216,
    249,
    217,
    194,
    145,
    218,
    130,
    155,
    127,
    133,
    66,
    32,
    137,
    34,
    14,
    66,
    187,
    206,
    170,
    166,
    216,
    208,
    235,
    179,
    187,
    127,
    124,
    34,
    16,
    32,
    11,
    133,
    66,
    40,
    137,
    34,
    17,
    124,
    34,
    18,
    32,
    14,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    16,
    124,
    34,
    20,
    32,
    17,
    133,
    66,
    1,
    137,
    34,
    21,
    124,
    34,
    22,
    32,
    0,
    65,
    152,
    1,
    106,
    41,
    3,
    0,
    34,
    14,
    124,
    32,
    22,
    32,
    0,
    41,
    3,
    56,
    34,
    23,
    32,
    0,
    41,
    3,
    24,
    34,
    24,
    124,
    32,
    0,
    65,
    128,
    1,
    106,
    41,
    3,
    0,
    34,
    16,
    124,
    34,
    25,
    32,
    0,
    65,
    136,
    1,
    106,
    41,
    3,
    0,
    34,
    17,
    124,
    32,
    25,
    66,
    249,
    194,
    248,
    155,
    145,
    163,
    179,
    240,
    219,
    0,
    133,
    66,
    32,
    137,
    34,
    25,
    66,
    241,
    237,
    244,
    248,
    165,
    167,
    253,
    167,
    165,
    127,
    124,
    34,
    26,
    32,
    23,
    133,
    66,
    40,
    137,
    34,
    27,
    124,
    34,
    28,
    32,
    25,
    133,
    66,
    48,
    137,
    34,
    29,
    133,
    66,
    32,
    137,
    34,
    30,
    32,
    0,
    41,
    3,
    48,
    34,
    31,
    32,
    0,
    41,
    3,
    16,
    34,
    32,
    124,
    32,
    0,
    65,
    240,
    0,
    106,
    41,
    3,
    0,
    34,
    22,
    124,
    34,
    33,
    32,
    0,
    65,
    248,
    0,
    106,
    41,
    3,
    0,
    34,
    25,
    124,
    32,
    33,
    65,
    0,
    32,
    1,
    107,
    172,
    133,
    66,
    235,
    250,
    134,
    218,
    191,
    181,
    246,
    193,
    31,
    133,
    66,
    32,
    137,
    34,
    33,
    66,
    171,
    240,
    211,
    244,
    175,
    238,
    188,
    183,
    60,
    124,
    34,
    34,
    32,
    31,
    133,
    66,
    40,
    137,
    34,
    35,
    124,
    34,
    36,
    32,
    33,
    133,
    66,
    48,
    137,
    34,
    33,
    32,
    34,
    124,
    34,
    34,
    124,
    34,
    37,
    32,
    21,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    39,
    32,
    0,
    65,
    192,
    1,
    106,
    41,
    3,
    0,
    34,
    21,
    124,
    32,
    10,
    32,
    7,
    133,
    66,
    48,
    137,
    34,
    40,
    32,
    8,
    124,
    34,
    41,
    32,
    9,
    133,
    66,
    1,
    137,
    34,
    8,
    32,
    21,
    124,
    32,
    28,
    124,
    34,
    9,
    32,
    0,
    65,
    200,
    1,
    106,
    41,
    3,
    0,
    34,
    7,
    124,
    32,
    9,
    32,
    33,
    133,
    66,
    32,
    137,
    34,
    9,
    32,
    20,
    124,
    34,
    10,
    32,
    8,
    133,
    66,
    40,
    137,
    34,
    8,
    124,
    34,
    20,
    32,
    9,
    133,
    66,
    48,
    137,
    34,
    28,
    32,
    10,
    124,
    34,
    33,
    32,
    8,
    133,
    66,
    1,
    137,
    34,
    42,
    124,
    34,
    43,
    32,
    0,
    65,
    160,
    1,
    106,
    41,
    3,
    0,
    34,
    8,
    124,
    32,
    36,
    32,
    0,
    65,
    176,
    1,
    106,
    41,
    3,
    0,
    34,
    9,
    124,
    32,
    29,
    32,
    26,
    124,
    34,
    26,
    32,
    27,
    133,
    66,
    1,
    137,
    34,
    27,
    124,
    34,
    29,
    32,
    0,
    65,
    184,
    1,
    106,
    41,
    3,
    0,
    34,
    10,
    124,
    32,
    29,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    41,
    124,
    34,
    29,
    32,
    27,
    133,
    66,
    40,
    137,
    34,
    27,
    124,
    34,
    36,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    29,
    124,
    34,
    29,
    32,
    43,
    32,
    18,
    32,
    8,
    124,
    32,
    34,
    32,
    35,
    133,
    66,
    1,
    137,
    34,
    34,
    124,
    34,
    35,
    32,
    0,
    65,
    168,
    1,
    106,
    41,
    3,
    0,
    34,
    18,
    124,
    32,
    35,
    32,
    40,
    133,
    66,
    32,
    137,
    34,
    35,
    32,
    26,
    124,
    34,
    26,
    32,
    34,
    133,
    66,
    40,
    137,
    34,
    34,
    124,
    34,
    40,
    32,
    35,
    133,
    66,
    48,
    137,
    34,
    35,
    133,
    66,
    32,
    137,
    34,
    41,
    124,
    34,
    43,
    32,
    42,
    133,
    66,
    40,
    137,
    34,
    42,
    124,
    34,
    44,
    32,
    6,
    124,
    32,
    40,
    32,
    22,
    124,
    32,
    39,
    32,
    30,
    133,
    66,
    48,
    137,
    34,
    30,
    32,
    37,
    124,
    34,
    37,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    38,
    124,
    34,
    39,
    32,
    5,
    124,
    32,
    39,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    33,
    124,
    34,
    33,
    32,
    38,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    39,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    33,
    124,
    34,
    33,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    38,
    124,
    34,
    40,
    32,
    9,
    124,
    32,
    40,
    32,
    20,
    32,
    10,
    124,
    32,
    29,
    32,
    27,
    133,
    66,
    1,
    137,
    34,
    20,
    124,
    34,
    27,
    32,
    16,
    124,
    32,
    27,
    32,
    30,
    133,
    66,
    32,
    137,
    34,
    27,
    32,
    35,
    32,
    26,
    124,
    34,
    26,
    124,
    34,
    29,
    32,
    20,
    133,
    66,
    40,
    137,
    34,
    20,
    124,
    34,
    30,
    32,
    27,
    133,
    66,
    48,
    137,
    34,
    27,
    133,
    66,
    32,
    137,
    34,
    35,
    32,
    36,
    32,
    14,
    124,
    32,
    26,
    32,
    34,
    133,
    66,
    1,
    137,
    34,
    26,
    124,
    34,
    34,
    32,
    7,
    124,
    32,
    34,
    32,
    28,
    133,
    66,
    32,
    137,
    34,
    28,
    32,
    37,
    124,
    34,
    34,
    32,
    26,
    133,
    66,
    40,
    137,
    34,
    26,
    124,
    34,
    36,
    32,
    28,
    133,
    66,
    48,
    137,
    34,
    28,
    32,
    34,
    124,
    34,
    34,
    124,
    34,
    37,
    32,
    38,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    40,
    32,
    18,
    124,
    32,
    44,
    32,
    41,
    133,
    66,
    48,
    137,
    34,
    41,
    32,
    43,
    124,
    34,
    43,
    32,
    42,
    133,
    66,
    1,
    137,
    34,
    42,
    32,
    25,
    124,
    32,
    30,
    124,
    34,
    30,
    32,
    15,
    124,
    32,
    30,
    32,
    28,
    133,
    66,
    32,
    137,
    34,
    28,
    32,
    33,
    124,
    34,
    30,
    32,
    42,
    133,
    66,
    40,
    137,
    34,
    33,
    124,
    34,
    42,
    32,
    28,
    133,
    66,
    48,
    137,
    34,
    28,
    32,
    30,
    124,
    34,
    30,
    32,
    33,
    133,
    66,
    1,
    137,
    34,
    33,
    124,
    34,
    44,
    32,
    5,
    124,
    32,
    36,
    32,
    18,
    124,
    32,
    27,
    32,
    29,
    124,
    34,
    27,
    32,
    20,
    133,
    66,
    1,
    137,
    34,
    20,
    124,
    34,
    29,
    32,
    17,
    124,
    32,
    29,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    43,
    124,
    34,
    29,
    32,
    20,
    133,
    66,
    40,
    137,
    34,
    20,
    124,
    34,
    36,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    29,
    124,
    34,
    29,
    32,
    44,
    32,
    39,
    32,
    4,
    124,
    32,
    34,
    32,
    26,
    133,
    66,
    1,
    137,
    34,
    26,
    124,
    34,
    34,
    32,
    13,
    124,
    32,
    34,
    32,
    41,
    133,
    66,
    32,
    137,
    34,
    34,
    32,
    27,
    124,
    34,
    27,
    32,
    26,
    133,
    66,
    40,
    137,
    34,
    26,
    124,
    34,
    39,
    32,
    34,
    133,
    66,
    48,
    137,
    34,
    34,
    133,
    66,
    32,
    137,
    34,
    41,
    124,
    34,
    43,
    32,
    33,
    133,
    66,
    40,
    137,
    34,
    33,
    124,
    34,
    44,
    32,
    8,
    124,
    32,
    39,
    32,
    9,
    124,
    32,
    40,
    32,
    35,
    133,
    66,
    48,
    137,
    34,
    35,
    32,
    37,
    124,
    34,
    37,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    38,
    124,
    34,
    39,
    32,
    4,
    124,
    32,
    39,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    30,
    124,
    34,
    30,
    32,
    38,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    39,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    30,
    124,
    34,
    30,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    38,
    124,
    34,
    40,
    32,
    21,
    124,
    32,
    40,
    32,
    42,
    32,
    7,
    124,
    32,
    29,
    32,
    20,
    133,
    66,
    1,
    137,
    34,
    20,
    124,
    34,
    29,
    32,
    10,
    124,
    32,
    29,
    32,
    35,
    133,
    66,
    32,
    137,
    34,
    29,
    32,
    34,
    32,
    27,
    124,
    34,
    27,
    124,
    34,
    34,
    32,
    20,
    133,
    66,
    40,
    137,
    34,
    20,
    124,
    34,
    35,
    32,
    29,
    133,
    66,
    48,
    137,
    34,
    29,
    133,
    66,
    32,
    137,
    34,
    40,
    32,
    36,
    32,
    25,
    124,
    32,
    27,
    32,
    26,
    133,
    66,
    1,
    137,
    34,
    26,
    124,
    34,
    27,
    32,
    13,
    124,
    32,
    27,
    32,
    28,
    133,
    66,
    32,
    137,
    34,
    27,
    32,
    37,
    124,
    34,
    28,
    32,
    26,
    133,
    66,
    40,
    137,
    34,
    26,
    124,
    34,
    36,
    32,
    27,
    133,
    66,
    48,
    137,
    34,
    27,
    32,
    28,
    124,
    34,
    28,
    124,
    34,
    37,
    32,
    38,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    42,
    32,
    17,
    124,
    32,
    44,
    32,
    41,
    133,
    66,
    48,
    137,
    34,
    41,
    32,
    43,
    124,
    34,
    43,
    32,
    33,
    133,
    66,
    1,
    137,
    34,
    33,
    32,
    14,
    124,
    32,
    35,
    124,
    34,
    35,
    32,
    22,
    124,
    32,
    35,
    32,
    27,
    133,
    66,
    32,
    137,
    34,
    27,
    32,
    30,
    124,
    34,
    30,
    32,
    33,
    133,
    66,
    40,
    137,
    34,
    33,
    124,
    34,
    35,
    32,
    27,
    133,
    66,
    48,
    137,
    34,
    27,
    32,
    30,
    124,
    34,
    30,
    32,
    33,
    133,
    66,
    1,
    137,
    34,
    33,
    124,
    34,
    44,
    32,
    14,
    124,
    32,
    36,
    32,
    17,
    124,
    32,
    29,
    32,
    34,
    124,
    34,
    29,
    32,
    20,
    133,
    66,
    1,
    137,
    34,
    20,
    124,
    34,
    34,
    32,
    6,
    124,
    32,
    34,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    43,
    124,
    34,
    34,
    32,
    20,
    133,
    66,
    40,
    137,
    34,
    20,
    124,
    34,
    36,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    34,
    124,
    34,
    34,
    32,
    44,
    32,
    39,
    32,
    15,
    124,
    32,
    28,
    32,
    26,
    133,
    66,
    1,
    137,
    34,
    26,
    124,
    34,
    28,
    32,
    16,
    124,
    32,
    28,
    32,
    41,
    133,
    66,
    32,
    137,
    34,
    28,
    32,
    29,
    124,
    34,
    29,
    32,
    26,
    133,
    66,
    40,
    137,
    34,
    26,
    124,
    34,
    39,
    32,
    28,
    133,
    66,
    48,
    137,
    34,
    28,
    133,
    66,
    32,
    137,
    34,
    41,
    124,
    34,
    43,
    32,
    33,
    133,
    66,
    40,
    137,
    34,
    33,
    124,
    34,
    44,
    32,
    13,
    124,
    32,
    39,
    32,
    15,
    124,
    32,
    42,
    32,
    40,
    133,
    66,
    48,
    137,
    34,
    39,
    32,
    37,
    124,
    34,
    37,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    38,
    124,
    34,
    40,
    32,
    6,
    124,
    32,
    40,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    30,
    124,
    34,
    30,
    32,
    38,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    40,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    30,
    124,
    34,
    30,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    38,
    124,
    34,
    42,
    32,
    16,
    124,
    32,
    42,
    32,
    35,
    32,
    18,
    124,
    32,
    34,
    32,
    20,
    133,
    66,
    1,
    137,
    34,
    20,
    124,
    34,
    34,
    32,
    21,
    124,
    32,
    34,
    32,
    39,
    133,
    66,
    32,
    137,
    34,
    34,
    32,
    28,
    32,
    29,
    124,
    34,
    28,
    124,
    34,
    29,
    32,
    20,
    133,
    66,
    40,
    137,
    34,
    20,
    124,
    34,
    35,
    32,
    34,
    133,
    66,
    48,
    137,
    34,
    34,
    133,
    66,
    32,
    137,
    34,
    39,
    32,
    36,
    32,
    10,
    124,
    32,
    28,
    32,
    26,
    133,
    66,
    1,
    137,
    34,
    26,
    124,
    34,
    28,
    32,
    9,
    124,
    32,
    28,
    32,
    27,
    133,
    66,
    32,
    137,
    34,
    27,
    32,
    37,
    124,
    34,
    28,
    32,
    26,
    133,
    66,
    40,
    137,
    34,
    26,
    124,
    34,
    36,
    32,
    27,
    133,
    66,
    48,
    137,
    34,
    27,
    32,
    28,
    124,
    34,
    28,
    124,
    34,
    37,
    32,
    38,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    42,
    32,
    14,
    124,
    32,
    44,
    32,
    41,
    133,
    66,
    48,
    137,
    34,
    41,
    32,
    43,
    124,
    34,
    43,
    32,
    33,
    133,
    66,
    1,
    137,
    34,
    33,
    32,
    7,
    124,
    32,
    35,
    124,
    34,
    35,
    32,
    5,
    124,
    32,
    35,
    32,
    27,
    133,
    66,
    32,
    137,
    34,
    27,
    32,
    30,
    124,
    34,
    30,
    32,
    33,
    133,
    66,
    40,
    137,
    34,
    33,
    124,
    34,
    35,
    32,
    27,
    133,
    66,
    48,
    137,
    34,
    27,
    32,
    30,
    124,
    34,
    30,
    32,
    33,
    133,
    66,
    1,
    137,
    34,
    33,
    124,
    34,
    44,
    32,
    4,
    124,
    32,
    36,
    32,
    22,
    124,
    32,
    34,
    32,
    29,
    124,
    34,
    29,
    32,
    20,
    133,
    66,
    1,
    137,
    34,
    20,
    124,
    34,
    34,
    32,
    4,
    124,
    32,
    34,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    43,
    124,
    34,
    34,
    32,
    20,
    133,
    66,
    40,
    137,
    34,
    20,
    124,
    34,
    36,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    34,
    124,
    34,
    34,
    32,
    44,
    32,
    40,
    32,
    25,
    124,
    32,
    28,
    32,
    26,
    133,
    66,
    1,
    137,
    34,
    26,
    124,
    34,
    28,
    32,
    8,
    124,
    32,
    28,
    32,
    41,
    133,
    66,
    32,
    137,
    34,
    28,
    32,
    29,
    124,
    34,
    29,
    32,
    26,
    133,
    66,
    40,
    137,
    34,
    26,
    124,
    34,
    40,
    32,
    28,
    133,
    66,
    48,
    137,
    34,
    28,
    133,
    66,
    32,
    137,
    34,
    41,
    124,
    34,
    43,
    32,
    33,
    133,
    66,
    40,
    137,
    34,
    33,
    124,
    34,
    44,
    32,
    21,
    124,
    32,
    40,
    32,
    25,
    124,
    32,
    42,
    32,
    39,
    133,
    66,
    48,
    137,
    34,
    39,
    32,
    37,
    124,
    34,
    37,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    38,
    124,
    34,
    40,
    32,
    17,
    124,
    32,
    40,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    30,
    124,
    34,
    30,
    32,
    38,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    40,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    30,
    124,
    34,
    30,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    38,
    124,
    34,
    42,
    32,
    6,
    124,
    32,
    42,
    32,
    35,
    32,
    8,
    124,
    32,
    34,
    32,
    20,
    133,
    66,
    1,
    137,
    34,
    20,
    124,
    34,
    34,
    32,
    7,
    124,
    32,
    34,
    32,
    39,
    133,
    66,
    32,
    137,
    34,
    34,
    32,
    28,
    32,
    29,
    124,
    34,
    28,
    124,
    34,
    29,
    32,
    20,
    133,
    66,
    40,
    137,
    34,
    20,
    124,
    34,
    35,
    32,
    34,
    133,
    66,
    48,
    137,
    34,
    34,
    133,
    66,
    32,
    137,
    34,
    39,
    32,
    36,
    32,
    13,
    124,
    32,
    28,
    32,
    26,
    133,
    66,
    1,
    137,
    34,
    26,
    124,
    34,
    28,
    32,
    22,
    124,
    32,
    28,
    32,
    27,
    133,
    66,
    32,
    137,
    34,
    27,
    32,
    37,
    124,
    34,
    28,
    32,
    26,
    133,
    66,
    40,
    137,
    34,
    26,
    124,
    34,
    36,
    32,
    27,
    133,
    66,
    48,
    137,
    34,
    27,
    32,
    28,
    124,
    34,
    28,
    124,
    34,
    37,
    32,
    38,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    42,
    32,
    13,
    124,
    32,
    44,
    32,
    41,
    133,
    66,
    48,
    137,
    34,
    41,
    32,
    43,
    124,
    34,
    43,
    32,
    33,
    133,
    66,
    1,
    137,
    34,
    33,
    32,
    15,
    124,
    32,
    35,
    124,
    34,
    35,
    32,
    10,
    124,
    32,
    35,
    32,
    27,
    133,
    66,
    32,
    137,
    34,
    27,
    32,
    30,
    124,
    34,
    30,
    32,
    33,
    133,
    66,
    40,
    137,
    34,
    33,
    124,
    34,
    35,
    32,
    27,
    133,
    66,
    48,
    137,
    34,
    27,
    32,
    30,
    124,
    34,
    30,
    32,
    33,
    133,
    66,
    1,
    137,
    34,
    33,
    124,
    34,
    44,
    32,
    9,
    124,
    32,
    36,
    32,
    16,
    124,
    32,
    34,
    32,
    29,
    124,
    34,
    29,
    32,
    20,
    133,
    66,
    1,
    137,
    34,
    20,
    124,
    34,
    34,
    32,
    5,
    124,
    32,
    34,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    43,
    124,
    34,
    34,
    32,
    20,
    133,
    66,
    40,
    137,
    34,
    20,
    124,
    34,
    36,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    34,
    124,
    34,
    34,
    32,
    44,
    32,
    40,
    32,
    18,
    124,
    32,
    28,
    32,
    26,
    133,
    66,
    1,
    137,
    34,
    26,
    124,
    34,
    28,
    32,
    9,
    124,
    32,
    28,
    32,
    41,
    133,
    66,
    32,
    137,
    34,
    28,
    32,
    29,
    124,
    34,
    29,
    32,
    26,
    133,
    66,
    40,
    137,
    34,
    26,
    124,
    34,
    40,
    32,
    28,
    133,
    66,
    48,
    137,
    34,
    28,
    133,
    66,
    32,
    137,
    34,
    41,
    124,
    34,
    43,
    32,
    33,
    133,
    66,
    40,
    137,
    34,
    33,
    124,
    34,
    44,
    32,
    22,
    124,
    32,
    40,
    32,
    16,
    124,
    32,
    42,
    32,
    39,
    133,
    66,
    48,
    137,
    34,
    39,
    32,
    37,
    124,
    34,
    37,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    38,
    124,
    34,
    40,
    32,
    8,
    124,
    32,
    40,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    30,
    124,
    34,
    30,
    32,
    38,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    40,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    30,
    124,
    34,
    30,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    38,
    124,
    34,
    42,
    32,
    10,
    124,
    32,
    42,
    32,
    35,
    32,
    5,
    124,
    32,
    34,
    32,
    20,
    133,
    66,
    1,
    137,
    34,
    20,
    124,
    34,
    34,
    32,
    15,
    124,
    32,
    34,
    32,
    39,
    133,
    66,
    32,
    137,
    34,
    34,
    32,
    28,
    32,
    29,
    124,
    34,
    28,
    124,
    34,
    29,
    32,
    20,
    133,
    66,
    40,
    137,
    34,
    20,
    124,
    34,
    35,
    32,
    34,
    133,
    66,
    48,
    137,
    34,
    34,
    133,
    66,
    32,
    137,
    34,
    39,
    32,
    36,
    32,
    4,
    124,
    32,
    28,
    32,
    26,
    133,
    66,
    1,
    137,
    34,
    26,
    124,
    34,
    28,
    32,
    18,
    124,
    32,
    28,
    32,
    27,
    133,
    66,
    32,
    137,
    34,
    27,
    32,
    37,
    124,
    34,
    28,
    32,
    26,
    133,
    66,
    40,
    137,
    34,
    26,
    124,
    34,
    36,
    32,
    27,
    133,
    66,
    48,
    137,
    34,
    27,
    32,
    28,
    124,
    34,
    28,
    124,
    34,
    37,
    32,
    38,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    42,
    32,
    9,
    124,
    32,
    44,
    32,
    41,
    133,
    66,
    48,
    137,
    34,
    41,
    32,
    43,
    124,
    34,
    43,
    32,
    33,
    133,
    66,
    1,
    137,
    34,
    33,
    32,
    6,
    124,
    32,
    35,
    124,
    34,
    35,
    32,
    14,
    124,
    32,
    35,
    32,
    27,
    133,
    66,
    32,
    137,
    34,
    27,
    32,
    30,
    124,
    34,
    30,
    32,
    33,
    133,
    66,
    40,
    137,
    34,
    33,
    124,
    34,
    35,
    32,
    27,
    133,
    66,
    48,
    137,
    34,
    27,
    32,
    30,
    124,
    34,
    30,
    32,
    33,
    133,
    66,
    1,
    137,
    34,
    33,
    124,
    34,
    44,
    32,
    25,
    124,
    32,
    36,
    32,
    7,
    124,
    32,
    34,
    32,
    29,
    124,
    34,
    29,
    32,
    20,
    133,
    66,
    1,
    137,
    34,
    20,
    124,
    34,
    34,
    32,
    21,
    124,
    32,
    34,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    43,
    124,
    34,
    34,
    32,
    20,
    133,
    66,
    40,
    137,
    34,
    20,
    124,
    34,
    36,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    34,
    124,
    34,
    34,
    32,
    44,
    32,
    40,
    32,
    17,
    124,
    32,
    28,
    32,
    26,
    133,
    66,
    1,
    137,
    34,
    26,
    124,
    34,
    28,
    32,
    25,
    124,
    32,
    28,
    32,
    41,
    133,
    66,
    32,
    137,
    34,
    28,
    32,
    29,
    124,
    34,
    29,
    32,
    26,
    133,
    66,
    40,
    137,
    34,
    26,
    124,
    34,
    40,
    32,
    28,
    133,
    66,
    48,
    137,
    34,
    28,
    133,
    66,
    32,
    137,
    34,
    41,
    124,
    34,
    43,
    32,
    33,
    133,
    66,
    40,
    137,
    34,
    33,
    124,
    34,
    44,
    32,
    4,
    124,
    32,
    40,
    32,
    6,
    124,
    32,
    42,
    32,
    39,
    133,
    66,
    48,
    137,
    34,
    39,
    32,
    37,
    124,
    34,
    37,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    38,
    124,
    34,
    40,
    32,
    7,
    124,
    32,
    40,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    30,
    124,
    34,
    30,
    32,
    38,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    40,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    30,
    124,
    34,
    30,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    38,
    124,
    34,
    42,
    32,
    17,
    124,
    32,
    42,
    32,
    35,
    32,
    22,
    124,
    32,
    34,
    32,
    20,
    133,
    66,
    1,
    137,
    34,
    20,
    124,
    34,
    34,
    32,
    8,
    124,
    32,
    34,
    32,
    39,
    133,
    66,
    32,
    137,
    34,
    34,
    32,
    28,
    32,
    29,
    124,
    34,
    28,
    124,
    34,
    29,
    32,
    20,
    133,
    66,
    40,
    137,
    34,
    20,
    124,
    34,
    35,
    32,
    34,
    133,
    66,
    48,
    137,
    34,
    34,
    133,
    66,
    32,
    137,
    34,
    39,
    32,
    36,
    32,
    21,
    124,
    32,
    28,
    32,
    26,
    133,
    66,
    1,
    137,
    34,
    26,
    124,
    34,
    28,
    32,
    10,
    124,
    32,
    28,
    32,
    27,
    133,
    66,
    32,
    137,
    34,
    27,
    32,
    37,
    124,
    34,
    28,
    32,
    26,
    133,
    66,
    40,
    137,
    34,
    26,
    124,
    34,
    36,
    32,
    27,
    133,
    66,
    48,
    137,
    34,
    27,
    32,
    28,
    124,
    34,
    28,
    124,
    34,
    37,
    32,
    38,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    42,
    32,
    10,
    124,
    32,
    44,
    32,
    41,
    133,
    66,
    48,
    137,
    34,
    41,
    32,
    43,
    124,
    34,
    43,
    32,
    33,
    133,
    66,
    1,
    137,
    34,
    33,
    32,
    5,
    124,
    32,
    35,
    124,
    34,
    35,
    32,
    18,
    124,
    32,
    35,
    32,
    27,
    133,
    66,
    32,
    137,
    34,
    27,
    32,
    30,
    124,
    34,
    30,
    32,
    33,
    133,
    66,
    40,
    137,
    34,
    33,
    124,
    34,
    35,
    32,
    27,
    133,
    66,
    48,
    137,
    34,
    27,
    32,
    30,
    124,
    34,
    30,
    32,
    33,
    133,
    66,
    1,
    137,
    34,
    33,
    124,
    34,
    44,
    32,
    18,
    124,
    32,
    36,
    32,
    14,
    124,
    32,
    34,
    32,
    29,
    124,
    34,
    29,
    32,
    20,
    133,
    66,
    1,
    137,
    34,
    20,
    124,
    34,
    34,
    32,
    13,
    124,
    32,
    34,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    43,
    124,
    34,
    34,
    32,
    20,
    133,
    66,
    40,
    137,
    34,
    20,
    124,
    34,
    36,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    34,
    124,
    34,
    34,
    32,
    44,
    32,
    40,
    32,
    16,
    124,
    32,
    28,
    32,
    26,
    133,
    66,
    1,
    137,
    34,
    26,
    124,
    34,
    28,
    32,
    15,
    124,
    32,
    28,
    32,
    41,
    133,
    66,
    32,
    137,
    34,
    28,
    32,
    29,
    124,
    34,
    29,
    32,
    26,
    133,
    66,
    40,
    137,
    34,
    26,
    124,
    34,
    40,
    32,
    28,
    133,
    66,
    48,
    137,
    34,
    28,
    133,
    66,
    32,
    137,
    34,
    41,
    124,
    34,
    43,
    32,
    33,
    133,
    66,
    40,
    137,
    34,
    33,
    124,
    34,
    44,
    32,
    25,
    124,
    32,
    40,
    32,
    17,
    124,
    32,
    42,
    32,
    39,
    133,
    66,
    48,
    137,
    34,
    39,
    32,
    37,
    124,
    34,
    37,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    38,
    124,
    34,
    40,
    32,
    21,
    124,
    32,
    40,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    30,
    124,
    34,
    30,
    32,
    38,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    40,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    30,
    124,
    34,
    30,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    38,
    124,
    34,
    42,
    32,
    4,
    124,
    32,
    42,
    32,
    35,
    32,
    15,
    124,
    32,
    34,
    32,
    20,
    133,
    66,
    1,
    137,
    34,
    20,
    124,
    34,
    34,
    32,
    14,
    124,
    32,
    34,
    32,
    39,
    133,
    66,
    32,
    137,
    34,
    34,
    32,
    28,
    32,
    29,
    124,
    34,
    28,
    124,
    34,
    29,
    32,
    20,
    133,
    66,
    40,
    137,
    34,
    20,
    124,
    34,
    35,
    32,
    34,
    133,
    66,
    48,
    137,
    34,
    34,
    133,
    66,
    32,
    137,
    34,
    39,
    32,
    36,
    32,
    9,
    124,
    32,
    28,
    32,
    26,
    133,
    66,
    1,
    137,
    34,
    26,
    124,
    34,
    28,
    32,
    6,
    124,
    32,
    28,
    32,
    27,
    133,
    66,
    32,
    137,
    34,
    27,
    32,
    37,
    124,
    34,
    28,
    32,
    26,
    133,
    66,
    40,
    137,
    34,
    26,
    124,
    34,
    36,
    32,
    27,
    133,
    66,
    48,
    137,
    34,
    27,
    32,
    28,
    124,
    34,
    28,
    124,
    34,
    37,
    32,
    38,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    42,
    32,
    16,
    124,
    32,
    44,
    32,
    41,
    133,
    66,
    48,
    137,
    34,
    41,
    32,
    43,
    124,
    34,
    43,
    32,
    33,
    133,
    66,
    1,
    137,
    34,
    33,
    32,
    13,
    124,
    32,
    35,
    124,
    34,
    35,
    32,
    8,
    124,
    32,
    35,
    32,
    27,
    133,
    66,
    32,
    137,
    34,
    27,
    32,
    30,
    124,
    34,
    30,
    32,
    33,
    133,
    66,
    40,
    137,
    34,
    33,
    124,
    34,
    35,
    32,
    27,
    133,
    66,
    48,
    137,
    34,
    27,
    32,
    30,
    124,
    34,
    30,
    32,
    33,
    133,
    66,
    1,
    137,
    34,
    33,
    124,
    34,
    44,
    32,
    7,
    124,
    32,
    36,
    32,
    5,
    124,
    32,
    34,
    32,
    29,
    124,
    34,
    29,
    32,
    20,
    133,
    66,
    1,
    137,
    34,
    20,
    124,
    34,
    34,
    32,
    16,
    124,
    32,
    34,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    43,
    124,
    34,
    34,
    32,
    20,
    133,
    66,
    40,
    137,
    34,
    20,
    124,
    34,
    36,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    34,
    124,
    34,
    34,
    32,
    44,
    32,
    40,
    32,
    7,
    124,
    32,
    28,
    32,
    26,
    133,
    66,
    1,
    137,
    34,
    26,
    124,
    34,
    28,
    32,
    22,
    124,
    32,
    28,
    32,
    41,
    133,
    66,
    32,
    137,
    34,
    28,
    32,
    29,
    124,
    34,
    29,
    32,
    26,
    133,
    66,
    40,
    137,
    34,
    26,
    124,
    34,
    40,
    32,
    28,
    133,
    66,
    48,
    137,
    34,
    28,
    133,
    66,
    32,
    137,
    34,
    41,
    124,
    34,
    43,
    32,
    33,
    133,
    66,
    40,
    137,
    34,
    33,
    124,
    34,
    44,
    32,
    9,
    124,
    32,
    40,
    32,
    21,
    124,
    32,
    42,
    32,
    39,
    133,
    66,
    48,
    137,
    34,
    39,
    32,
    37,
    124,
    34,
    37,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    38,
    124,
    34,
    40,
    32,
    14,
    124,
    32,
    40,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    30,
    124,
    34,
    30,
    32,
    38,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    40,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    30,
    124,
    34,
    30,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    38,
    124,
    34,
    42,
    32,
    13,
    124,
    32,
    42,
    32,
    35,
    32,
    4,
    124,
    32,
    34,
    32,
    20,
    133,
    66,
    1,
    137,
    34,
    20,
    124,
    34,
    34,
    32,
    5,
    124,
    32,
    34,
    32,
    39,
    133,
    66,
    32,
    137,
    34,
    34,
    32,
    28,
    32,
    29,
    124,
    34,
    28,
    124,
    34,
    29,
    32,
    20,
    133,
    66,
    40,
    137,
    34,
    20,
    124,
    34,
    35,
    32,
    34,
    133,
    66,
    48,
    137,
    34,
    34,
    133,
    66,
    32,
    137,
    34,
    39,
    32,
    36,
    32,
    18,
    124,
    32,
    28,
    32,
    26,
    133,
    66,
    1,
    137,
    34,
    26,
    124,
    34,
    28,
    32,
    15,
    124,
    32,
    28,
    32,
    27,
    133,
    66,
    32,
    137,
    34,
    27,
    32,
    37,
    124,
    34,
    28,
    32,
    26,
    133,
    66,
    40,
    137,
    34,
    26,
    124,
    34,
    36,
    32,
    27,
    133,
    66,
    48,
    137,
    34,
    27,
    32,
    28,
    124,
    34,
    28,
    124,
    34,
    37,
    32,
    38,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    42,
    32,
    8,
    124,
    32,
    44,
    32,
    41,
    133,
    66,
    48,
    137,
    34,
    41,
    32,
    43,
    124,
    34,
    43,
    32,
    33,
    133,
    66,
    1,
    137,
    34,
    33,
    32,
    8,
    124,
    32,
    35,
    124,
    34,
    35,
    32,
    25,
    124,
    32,
    35,
    32,
    27,
    133,
    66,
    32,
    137,
    34,
    27,
    32,
    30,
    124,
    34,
    30,
    32,
    33,
    133,
    66,
    40,
    137,
    34,
    33,
    124,
    34,
    35,
    32,
    27,
    133,
    66,
    48,
    137,
    34,
    27,
    32,
    30,
    124,
    34,
    30,
    32,
    33,
    133,
    66,
    1,
    137,
    34,
    33,
    124,
    34,
    44,
    32,
    13,
    124,
    32,
    36,
    32,
    6,
    124,
    32,
    34,
    32,
    29,
    124,
    34,
    29,
    32,
    20,
    133,
    66,
    1,
    137,
    34,
    20,
    124,
    34,
    34,
    32,
    22,
    124,
    32,
    34,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    43,
    124,
    34,
    34,
    32,
    20,
    133,
    66,
    40,
    137,
    34,
    20,
    124,
    34,
    36,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    34,
    124,
    34,
    34,
    32,
    44,
    32,
    40,
    32,
    10,
    124,
    32,
    28,
    32,
    26,
    133,
    66,
    1,
    137,
    34,
    26,
    124,
    34,
    28,
    32,
    17,
    124,
    32,
    28,
    32,
    41,
    133,
    66,
    32,
    137,
    34,
    28,
    32,
    29,
    124,
    34,
    29,
    32,
    26,
    133,
    66,
    40,
    137,
    34,
    26,
    124,
    34,
    40,
    32,
    28,
    133,
    66,
    48,
    137,
    34,
    28,
    133,
    66,
    32,
    137,
    34,
    41,
    124,
    34,
    43,
    32,
    33,
    133,
    66,
    40,
    137,
    34,
    33,
    124,
    34,
    44,
    32,
    7,
    124,
    32,
    40,
    32,
    5,
    124,
    32,
    42,
    32,
    39,
    133,
    66,
    48,
    137,
    34,
    39,
    32,
    37,
    124,
    34,
    37,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    38,
    124,
    34,
    40,
    32,
    22,
    124,
    32,
    40,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    30,
    124,
    34,
    30,
    32,
    38,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    40,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    30,
    124,
    34,
    30,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    38,
    124,
    34,
    42,
    32,
    18,
    124,
    32,
    42,
    32,
    35,
    32,
    6,
    124,
    32,
    34,
    32,
    20,
    133,
    66,
    1,
    137,
    34,
    20,
    124,
    34,
    34,
    32,
    25,
    124,
    32,
    34,
    32,
    39,
    133,
    66,
    32,
    137,
    34,
    34,
    32,
    28,
    32,
    29,
    124,
    34,
    28,
    124,
    34,
    29,
    32,
    20,
    133,
    66,
    40,
    137,
    34,
    20,
    124,
    34,
    35,
    32,
    34,
    133,
    66,
    48,
    137,
    34,
    34,
    133,
    66,
    32,
    137,
    34,
    39,
    32,
    36,
    32,
    17,
    124,
    32,
    28,
    32,
    26,
    133,
    66,
    1,
    137,
    34,
    26,
    124,
    34,
    28,
    32,
    16,
    124,
    32,
    28,
    32,
    27,
    133,
    66,
    32,
    137,
    34,
    27,
    32,
    37,
    124,
    34,
    28,
    32,
    26,
    133,
    66,
    40,
    137,
    34,
    26,
    124,
    34,
    36,
    32,
    27,
    133,
    66,
    48,
    137,
    34,
    27,
    32,
    28,
    124,
    34,
    28,
    124,
    34,
    37,
    32,
    38,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    42,
    32,
    4,
    124,
    32,
    44,
    32,
    41,
    133,
    66,
    48,
    137,
    34,
    41,
    32,
    43,
    124,
    34,
    43,
    32,
    33,
    133,
    66,
    1,
    137,
    34,
    33,
    32,
    10,
    124,
    32,
    35,
    124,
    34,
    35,
    32,
    4,
    124,
    32,
    35,
    32,
    27,
    133,
    66,
    32,
    137,
    34,
    27,
    32,
    30,
    124,
    34,
    30,
    32,
    33,
    133,
    66,
    40,
    137,
    34,
    33,
    124,
    34,
    35,
    32,
    27,
    133,
    66,
    48,
    137,
    34,
    27,
    32,
    30,
    124,
    34,
    30,
    32,
    33,
    133,
    66,
    1,
    137,
    34,
    33,
    124,
    34,
    44,
    32,
    6,
    124,
    32,
    36,
    32,
    15,
    124,
    32,
    34,
    32,
    29,
    124,
    34,
    29,
    32,
    20,
    133,
    66,
    1,
    137,
    34,
    20,
    124,
    34,
    34,
    32,
    9,
    124,
    32,
    34,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    43,
    124,
    34,
    34,
    32,
    20,
    133,
    66,
    40,
    137,
    34,
    20,
    124,
    34,
    36,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    34,
    124,
    34,
    34,
    32,
    44,
    32,
    40,
    32,
    14,
    124,
    32,
    28,
    32,
    26,
    133,
    66,
    1,
    137,
    34,
    26,
    124,
    34,
    28,
    32,
    21,
    124,
    32,
    28,
    32,
    41,
    133,
    66,
    32,
    137,
    34,
    28,
    32,
    29,
    124,
    34,
    29,
    32,
    26,
    133,
    66,
    40,
    137,
    34,
    26,
    124,
    34,
    40,
    32,
    28,
    133,
    66,
    48,
    137,
    34,
    28,
    133,
    66,
    32,
    137,
    34,
    41,
    124,
    34,
    43,
    32,
    33,
    133,
    66,
    40,
    137,
    34,
    33,
    124,
    34,
    44,
    32,
    5,
    124,
    32,
    40,
    32,
    13,
    124,
    32,
    42,
    32,
    39,
    133,
    66,
    48,
    137,
    34,
    39,
    32,
    37,
    124,
    34,
    37,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    38,
    124,
    34,
    40,
    32,
    15,
    124,
    32,
    40,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    30,
    124,
    34,
    30,
    32,
    38,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    40,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    30,
    124,
    34,
    30,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    38,
    124,
    34,
    42,
    32,
    14,
    124,
    32,
    42,
    32,
    35,
    32,
    16,
    124,
    32,
    34,
    32,
    20,
    133,
    66,
    1,
    137,
    34,
    20,
    124,
    34,
    34,
    32,
    17,
    124,
    32,
    34,
    32,
    39,
    133,
    66,
    32,
    137,
    34,
    34,
    32,
    28,
    32,
    29,
    124,
    34,
    28,
    124,
    34,
    29,
    32,
    20,
    133,
    66,
    40,
    137,
    34,
    20,
    124,
    34,
    35,
    32,
    34,
    133,
    66,
    48,
    137,
    34,
    34,
    133,
    66,
    32,
    137,
    34,
    39,
    32,
    36,
    32,
    22,
    124,
    32,
    28,
    32,
    26,
    133,
    66,
    1,
    137,
    34,
    26,
    124,
    34,
    28,
    32,
    25,
    124,
    32,
    28,
    32,
    27,
    133,
    66,
    32,
    137,
    34,
    27,
    32,
    37,
    124,
    34,
    28,
    32,
    26,
    133,
    66,
    40,
    137,
    34,
    26,
    124,
    34,
    36,
    32,
    27,
    133,
    66,
    48,
    137,
    34,
    27,
    32,
    28,
    124,
    34,
    28,
    124,
    34,
    37,
    32,
    38,
    133,
    66,
    40,
    137,
    34,
    38,
    124,
    34,
    42,
    32,
    21,
    124,
    32,
    44,
    32,
    41,
    133,
    66,
    48,
    137,
    34,
    41,
    32,
    43,
    124,
    34,
    43,
    32,
    33,
    133,
    66,
    1,
    137,
    34,
    33,
    32,
    21,
    124,
    32,
    35,
    124,
    34,
    21,
    32,
    7,
    124,
    32,
    21,
    32,
    27,
    133,
    66,
    32,
    137,
    34,
    21,
    32,
    30,
    124,
    34,
    27,
    32,
    33,
    133,
    66,
    40,
    137,
    34,
    30,
    124,
    34,
    33,
    32,
    21,
    133,
    66,
    48,
    137,
    34,
    21,
    32,
    27,
    124,
    34,
    27,
    32,
    30,
    133,
    66,
    1,
    137,
    34,
    30,
    124,
    34,
    35,
    32,
    8,
    124,
    32,
    36,
    32,
    9,
    124,
    32,
    34,
    32,
    29,
    124,
    34,
    29,
    32,
    20,
    133,
    66,
    1,
    137,
    34,
    20,
    124,
    34,
    34,
    32,
    10,
    124,
    32,
    34,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    19,
    32,
    43,
    124,
    34,
    34,
    32,
    20,
    133,
    66,
    40,
    137,
    34,
    20,
    124,
    34,
    36,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    19,
    32,
    34,
    124,
    34,
    34,
    32,
    35,
    32,
    40,
    32,
    8,
    124,
    32,
    28,
    32,
    26,
    133,
    66,
    1,
    137,
    34,
    8,
    124,
    34,
    26,
    32,
    18,
    124,
    32,
    26,
    32,
    41,
    133,
    66,
    32,
    137,
    34,
    26,
    32,
    29,
    124,
    34,
    28,
    32,
    8,
    133,
    66,
    40,
    137,
    34,
    8,
    124,
    34,
    29,
    32,
    26,
    133,
    66,
    48,
    137,
    34,
    26,
    133,
    66,
    32,
    137,
    34,
    35,
    124,
    34,
    40,
    32,
    30,
    133,
    66,
    40,
    137,
    34,
    30,
    124,
    34,
    41,
    32,
    6,
    124,
    32,
    29,
    32,
    22,
    124,
    32,
    42,
    32,
    39,
    133,
    66,
    48,
    137,
    34,
    6,
    32,
    37,
    124,
    34,
    22,
    32,
    38,
    133,
    66,
    1,
    137,
    34,
    29,
    124,
    34,
    37,
    32,
    5,
    124,
    32,
    37,
    32,
    19,
    133,
    66,
    32,
    137,
    34,
    5,
    32,
    27,
    124,
    34,
    19,
    32,
    29,
    133,
    66,
    40,
    137,
    34,
    27,
    124,
    34,
    29,
    32,
    5,
    133,
    66,
    48,
    137,
    34,
    5,
    32,
    19,
    124,
    34,
    19,
    32,
    27,
    133,
    66,
    1,
    137,
    34,
    27,
    124,
    34,
    37,
    32,
    9,
    124,
    32,
    37,
    32,
    33,
    32,
    10,
    124,
    32,
    34,
    32,
    20,
    133,
    66,
    1,
    137,
    34,
    9,
    124,
    34,
    10,
    32,
    16,
    124,
    32,
    10,
    32,
    6,
    133,
    66,
    32,
    137,
    34,
    6,
    32,
    26,
    32,
    28,
    124,
    34,
    16,
    124,
    34,
    10,
    32,
    9,
    133,
    66,
    40,
    137,
    34,
    9,
    124,
    34,
    20,
    32,
    6,
    133,
    66,
    48,
    137,
    34,
    6,
    133,
    66,
    32,
    137,
    34,
    26,
    32,
    36,
    32,
    14,
    124,
    32,
    16,
    32,
    8,
    133,
    66,
    1,
    137,
    34,
    14,
    124,
    34,
    16,
    32,
    7,
    124,
    32,
    16,
    32,
    21,
    133,
    66,
    32,
    137,
    34,
    16,
    32,
    22,
    124,
    34,
    22,
    32,
    14,
    133,
    66,
    40,
    137,
    34,
    14,
    124,
    34,
    21,
    32,
    16,
    133,
    66,
    48,
    137,
    34,
    16,
    32,
    22,
    124,
    34,
    22,
    124,
    34,
    7,
    32,
    27,
    133,
    66,
    40,
    137,
    34,
    8,
    124,
    34,
    27,
    32,
    3,
    133,
    32,
    21,
    32,
    18,
    124,
    32,
    6,
    32,
    10,
    124,
    34,
    6,
    32,
    9,
    133,
    66,
    1,
    137,
    34,
    21,
    124,
    34,
    9,
    32,
    17,
    124,
    32,
    9,
    32,
    5,
    133,
    66,
    32,
    137,
    34,
    5,
    32,
    41,
    32,
    35,
    133,
    66,
    48,
    137,
    34,
    17,
    32,
    40,
    124,
    34,
    9,
    124,
    34,
    10,
    32,
    21,
    133,
    66,
    40,
    137,
    34,
    21,
    124,
    34,
    18,
    32,
    5,
    133,
    66,
    48,
    137,
    34,
    5,
    32,
    10,
    124,
    34,
    10,
    133,
    55,
    3,
    0,
    32,
    0,
    32,
    32,
    32,
    27,
    32,
    26,
    133,
    66,
    48,
    137,
    34,
    3,
    32,
    7,
    124,
    34,
    7,
    133,
    32,
    18,
    133,
    55,
    3,
    16,
    32,
    0,
    32,
    3,
    32,
    23,
    133,
    32,
    10,
    32,
    21,
    133,
    66,
    1,
    137,
    133,
    55,
    3,
    56,
    32,
    0,
    32,
    11,
    32,
    7,
    32,
    8,
    133,
    66,
    1,
    137,
    133,
    32,
    5,
    133,
    55,
    3,
    40,
    32,
    0,
    32,
    24,
    32,
    15,
    32,
    25,
    32,
    9,
    32,
    30,
    133,
    66,
    1,
    137,
    34,
    5,
    124,
    32,
    20,
    124,
    34,
    25,
    124,
    32,
    25,
    32,
    16,
    133,
    66,
    32,
    137,
    34,
    15,
    32,
    19,
    124,
    34,
    16,
    32,
    5,
    133,
    66,
    40,
    137,
    34,
    5,
    124,
    34,
    25,
    133,
    32,
    13,
    32,
    29,
    32,
    4,
    124,
    32,
    22,
    32,
    14,
    133,
    66,
    1,
    137,
    34,
    4,
    124,
    34,
    14,
    124,
    32,
    14,
    32,
    17,
    133,
    66,
    32,
    137,
    34,
    13,
    32,
    6,
    124,
    34,
    6,
    32,
    4,
    133,
    66,
    40,
    137,
    34,
    4,
    124,
    34,
    14,
    32,
    13,
    133,
    66,
    48,
    137,
    34,
    13,
    32,
    6,
    124,
    34,
    6,
    133,
    55,
    3,
    24,
    32,
    0,
    32,
    31,
    32,
    25,
    32,
    15,
    133,
    66,
    48,
    137,
    34,
    15,
    133,
    32,
    6,
    32,
    4,
    133,
    66,
    1,
    137,
    133,
    55,
    3,
    48,
    32,
    0,
    32,
    12,
    32,
    15,
    32,
    16,
    124,
    34,
    4,
    133,
    32,
    14,
    133,
    55,
    3,
    8,
    32,
    0,
    32,
    2,
    32,
    4,
    32,
    5,
    133,
    66,
    1,
    137,
    133,
    32,
    13,
    133,
    55,
    3,
    32,
    11,
    188,
    2,
    3,
    3,
    127,
    2,
    126,
    1,
    127,
    2,
    64,
    32,
    0,
    40,
    2,
    208,
    1,
    34,
    2,
    65,
    255,
    0,
    75,
    13,
    0,
    32,
    0,
    65,
    208,
    0,
    106,
    33,
    3,
    32,
    2,
    33,
    4,
    3,
    64,
    2,
    64,
    32,
    4,
    13,
    0,
    32,
    3,
    65,
    0,
    65,
    128,
    1,
    252,
    11,
    0,
    11,
    32,
    4,
    65,
    1,
    106,
    34,
    4,
    65,
    128,
    1,
    71,
    13,
    0,
    11,
    11,
    32,
    0,
    32,
    0,
    41,
    3,
    64,
    34,
    5,
    32,
    2,
    173,
    124,
    34,
    6,
    55,
    3,
    64,
    2,
    64,
    32,
    6,
    32,
    5,
    90,
    13,
    0,
    32,
    0,
    65,
    200,
    0,
    106,
    34,
    4,
    32,
    4,
    41,
    3,
    0,
    66,
    1,
    124,
    55,
    3,
    0,
    11,
    32,
    0,
    65,
    1,
    16,
    152,
    128,
    128,
    128,
    0,
    32,
    0,
    40,
    2,
    212,
    1,
    34,
    7,
    33,
    3,
    2,
    64,
    32,
    7,
    65,
    8,
    73,
    13,
    0,
    32,
    7,
    65,
    3,
    118,
    33,
    2,
    32,
    1,
    33,
    4,
    32,
    0,
    33,
    3,
    3,
    64,
    32,
    4,
    32,
    3,
    41,
    3,
    0,
    16,
    154,
    128,
    128,
    128,
    0,
    32,
    4,
    65,
    8,
    106,
    33,
    4,
    32,
    3,
    65,
    8,
    106,
    33,
    3,
    32,
    2,
    65,
    127,
    106,
    34,
    2,
    13,
    0,
    11,
    32,
    0,
    40,
    2,
    212,
    1,
    33,
    3,
    11,
    2,
    64,
    32,
    7,
    65,
    120,
    113,
    34,
    4,
    32,
    3,
    79,
    13,
    0,
    32,
    7,
    65,
    3,
    116,
    65,
    64,
    113,
    33,
    3,
    3,
    64,
    32,
    1,
    32,
    4,
    106,
    32,
    0,
    32,
    4,
    65,
    120,
    113,
    106,
    41,
    3,
    0,
    32,
    3,
    65,
    56,
    113,
    173,
    136,
    60,
    0,
    0,
    32,
    3,
    65,
    8,
    106,
    33,
    3,
    32,
    4,
    65,
    1,
    106,
    34,
    4,
    32,
    0,
    40,
    2,
    212,
    1,
    73,
    13,
    0,
    11,
    11,
    65,
    0,
    33,
    4,
    3,
    64,
    32,
    0,
    32,
    4,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    4,
    65,
    1,
    106,
    34,
    4,
    65,
    216,
    1,
    71,
    13,
    0,
    11,
    11,
    9,
    0,
    32,
    0,
    32,
    1,
    55,
    0,
    0,
    11,
    79,
    1,
    1,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    224,
    1,
    107,
    34,
    6,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    6,
    65,
    8,
    106,
    32,
    1,
    32,
    2,
    32,
    3,
    16,
    148,
    128,
    128,
    128,
    0,
    32,
    6,
    65,
    8,
    106,
    32,
    4,
    32,
    5,
    16,
    149,
    128,
    128,
    128,
    0,
    32,
    6,
    65,
    8,
    106,
    32,
    0,
    16,
    153,
    128,
    128,
    128,
    0,
    32,
    6,
    65,
    224,
    1,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    21,
    0,
    32,
    0,
    65,
    192,
    0,
    65,
    0,
    65,
    0,
    32,
    1,
    32,
    2,
    16,
    155,
    128,
    128,
    128,
    0,
    11,
    70,
    0,
    32,
    0,
    65,
    136,
    1,
    106,
    65,
    128,
    137,
    128,
    128,
    0,
    65,
    192,
    0,
    252,
    10,
    0,
    0,
    32,
    0,
    66,
    0,
    55,
    3,
    200,
    1,
    32,
    0,
    66,
    200,
    146,
    247,
    149,
    255,
    204,
    249,
    132,
    234,
    0,
    55,
    3,
    136,
    1,
    32,
    0,
    65,
    208,
    1,
    106,
    66,
    0,
    55,
    3,
    0,
    32,
    0,
    66,
    128,
    128,
    128,
    128,
    128,
    8,
    55,
    3,
    216,
    2,
    11,
    18,
    0,
    32,
    0,
    65,
    136,
    1,
    106,
    32,
    1,
    32,
    2,
    16,
    149,
    128,
    128,
    128,
    0,
    11,
    16,
    0,
    32,
    0,
    65,
    136,
    1,
    106,
    32,
    1,
    16,
    153,
    128,
    128,
    128,
    0,
    11,
    164,
    12,
    3,
    11,
    127,
    2,
    126,
    1,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    240,
    24,
    107,
    34,
    13,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    13,
    65,
    128,
    137,
    128,
    128,
    0,
    65,
    192,
    0,
    252,
    10,
    0,
    0,
    32,
    13,
    65,
    200,
    0,
    106,
    66,
    0,
    55,
    3,
    0,
    32,
    13,
    66,
    0,
    55,
    3,
    64,
    32,
    13,
    66,
    200,
    146,
    247,
    149,
    255,
    204,
    249,
    132,
    234,
    0,
    55,
    3,
    0,
    32,
    13,
    66,
    128,
    128,
    128,
    128,
    128,
    8,
    55,
    3,
    208,
    1,
    32,
    13,
    65,
    1,
    16,
    161,
    128,
    128,
    128,
    0,
    32,
    13,
    32,
    1,
    16,
    161,
    128,
    128,
    128,
    0,
    32,
    13,
    32,
    3,
    16,
    161,
    128,
    128,
    128,
    0,
    32,
    13,
    32,
    4,
    16,
    161,
    128,
    128,
    128,
    0,
    32,
    13,
    65,
    19,
    16,
    161,
    128,
    128,
    128,
    0,
    32,
    13,
    65,
    1,
    16,
    161,
    128,
    128,
    128,
    0,
    32,
    13,
    32,
    6,
    16,
    161,
    128,
    128,
    128,
    0,
    32,
    13,
    32,
    5,
    32,
    6,
    16,
    149,
    128,
    128,
    128,
    0,
    32,
    13,
    32,
    8,
    16,
    161,
    128,
    128,
    128,
    0,
    32,
    13,
    32,
    7,
    32,
    8,
    16,
    149,
    128,
    128,
    128,
    0,
    32,
    13,
    32,
    10,
    16,
    161,
    128,
    128,
    128,
    0,
    32,
    13,
    32,
    9,
    32,
    10,
    16,
    149,
    128,
    128,
    128,
    0,
    32,
    13,
    32,
    12,
    16,
    161,
    128,
    128,
    128,
    0,
    32,
    13,
    32,
    11,
    32,
    12,
    16,
    149,
    128,
    128,
    128,
    0,
    32,
    13,
    32,
    13,
    65,
    160,
    24,
    106,
    16,
    153,
    128,
    128,
    128,
    0,
    32,
    13,
    66,
    0,
    55,
    3,
    224,
    24,
    32,
    13,
    65,
    160,
    16,
    106,
    65,
    128,
    8,
    32,
    13,
    65,
    160,
    24,
    106,
    65,
    200,
    0,
    16,
    162,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    12,
    3,
    64,
    32,
    13,
    65,
    136,
    8,
    106,
    32,
    12,
    106,
    32,
    13,
    65,
    160,
    16,
    106,
    32,
    12,
    106,
    16,
    130,
    128,
    128,
    128,
    0,
    55,
    3,
    0,
    32,
    12,
    65,
    8,
    106,
    34,
    12,
    65,
    128,
    8,
    71,
    13,
    0,
    11,
    32,
    2,
    32,
    13,
    65,
    136,
    8,
    106,
    65,
    128,
    8,
    252,
    10,
    0,
    0,
    32,
    13,
    65,
    1,
    54,
    2,
    224,
    24,
    32,
    13,
    65,
    160,
    16,
    106,
    65,
    128,
    8,
    32,
    13,
    65,
    160,
    24,
    106,
    65,
    200,
    0,
    16,
    162,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    12,
    3,
    64,
    32,
    13,
    65,
    136,
    8,
    106,
    32,
    12,
    106,
    32,
    13,
    65,
    160,
    16,
    106,
    32,
    12,
    106,
    16,
    130,
    128,
    128,
    128,
    0,
    55,
    3,
    0,
    32,
    12,
    65,
    8,
    106,
    34,
    12,
    65,
    128,
    8,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    128,
    8,
    106,
    32,
    13,
    65,
    136,
    8,
    106,
    65,
    128,
    8,
    252,
    10,
    0,
    0,
    65,
    0,
    33,
    12,
    3,
    64,
    32,
    13,
    65,
    160,
    24,
    106,
    32,
    12,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    12,
    65,
    1,
    106,
    34,
    12,
    65,
    200,
    0,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    12,
    3,
    64,
    32,
    13,
    65,
    160,
    16,
    106,
    32,
    12,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    12,
    65,
    1,
    106,
    34,
    12,
    65,
    128,
    8,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    12,
    3,
    64,
    32,
    13,
    65,
    136,
    8,
    106,
    32,
    12,
    106,
    66,
    0,
    55,
    3,
    0,
    32,
    12,
    65,
    8,
    106,
    34,
    12,
    65,
    128,
    8,
    71,
    13,
    0,
    11,
    32,
    3,
    65,
    124,
    113,
    33,
    14,
    2,
    64,
    32,
    4,
    69,
    13,
    0,
    32,
    2,
    65,
    128,
    112,
    106,
    33,
    15,
    32,
    3,
    65,
    2,
    118,
    34,
    16,
    65,
    10,
    116,
    33,
    17,
    32,
    2,
    65,
    128,
    120,
    106,
    33,
    18,
    65,
    0,
    33,
    19,
    3,
    64,
    32,
    2,
    33,
    20,
    65,
    0,
    33,
    21,
    3,
    64,
    32,
    13,
    65,
    0,
    54,
    2,
    152,
    16,
    32,
    13,
    32,
    4,
    54,
    2,
    148,
    16,
    32,
    13,
    32,
    14,
    54,
    2,
    144,
    16,
    32,
    13,
    32,
    19,
    54,
    2,
    136,
    16,
    32,
    13,
    32,
    21,
    54,
    2,
    140,
    16,
    2,
    64,
    2,
    64,
    32,
    21,
    32,
    19,
    114,
    34,
    12,
    69,
    13,
    0,
    32,
    13,
    65,
    0,
    54,
    2,
    156,
    16,
    12,
    1,
    11,
    32,
    13,
    66,
    129,
    128,
    128,
    128,
    32,
    55,
    3,
    152,
    16,
    32,
    13,
    65,
    136,
    8,
    106,
    16,
    163,
    128,
    128,
    128,
    0,
    11,
    2,
    64,
    32,
    12,
    69,
    65,
    1,
    116,
    34,
    12,
    32,
    21,
    32,
    16,
    108,
    106,
    34,
    22,
    32,
    21,
    65,
    1,
    106,
    34,
    21,
    32,
    16,
    108,
    79,
    13,
    0,
    32,
    16,
    32,
    12,
    107,
    33,
    23,
    32,
    20,
    32,
    12,
    65,
    10,
    116,
    106,
    33,
    10,
    65,
    0,
    33,
    7,
    32,
    22,
    33,
    11,
    3,
    64,
    2,
    64,
    32,
    13,
    40,
    2,
    156,
    16,
    34,
    12,
    65,
    255,
    0,
    113,
    34,
    8,
    13,
    0,
    32,
    13,
    32,
    13,
    40,
    2,
    152,
    16,
    65,
    1,
    106,
    54,
    2,
    152,
    16,
    32,
    13,
    65,
    136,
    8,
    106,
    16,
    163,
    128,
    128,
    128,
    0,
    32,
    13,
    40,
    2,
    156,
    16,
    34,
    12,
    65,
    255,
    0,
    113,
    33,
    8,
    11,
    32,
    13,
    32,
    12,
    65,
    1,
    106,
    54,
    2,
    156,
    16,
    32,
    13,
    65,
    136,
    8,
    106,
    32,
    8,
    65,
    3,
    116,
    106,
    53,
    2,
    0,
    33,
    24,
    32,
    13,
    40,
    2,
    144,
    16,
    33,
    8,
    32,
    13,
    40,
    2,
    136,
    16,
    33,
    6,
    32,
    13,
    40,
    2,
    140,
    16,
    33,
    9,
    32,
    13,
    65,
    160,
    16,
    106,
    32,
    18,
    32,
    11,
    32,
    14,
    32,
    11,
    27,
    65,
    10,
    116,
    106,
    65,
    128,
    8,
    252,
    10,
    0,
    0,
    66,
    0,
    32,
    8,
    173,
    34,
    25,
    65,
    3,
    32,
    9,
    32,
    6,
    27,
    32,
    8,
    65,
    2,
    118,
    34,
    8,
    108,
    34,
    26,
    32,
    12,
    106,
    34,
    5,
    65,
    126,
    106,
    173,
    32,
    24,
    32,
    24,
    126,
    66,
    32,
    136,
    32,
    5,
    65,
    127,
    106,
    173,
    126,
    66,
    32,
    136,
    34,
    24,
    125,
    32,
    9,
    65,
    1,
    106,
    65,
    3,
    113,
    32,
    8,
    108,
    65,
    0,
    32,
    6,
    27,
    34,
    8,
    173,
    124,
    32,
    25,
    84,
    27,
    33,
    25,
    2,
    64,
    2,
    64,
    32,
    19,
    69,
    13,
    0,
    32,
    15,
    32,
    8,
    32,
    12,
    106,
    32,
    26,
    106,
    65,
    10,
    116,
    32,
    25,
    167,
    32,
    24,
    167,
    106,
    65,
    10,
    116,
    107,
    106,
    33,
    6,
    65,
    0,
    33,
    12,
    3,
    64,
    32,
    13,
    65,
    160,
    16,
    106,
    32,
    12,
    106,
    34,
    8,
    32,
    8,
    41,
    3,
    0,
    32,
    6,
    32,
    12,
    106,
    41,
    3,
    0,
    133,
    55,
    3,
    0,
    32,
    12,
    65,
    8,
    106,
    34,
    12,
    65,
    128,
    8,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    12,
    3,
    64,
    32,
    10,
    32,
    12,
    106,
    34,
    8,
    32,
    8,
    41,
    3,
    0,
    32,
    13,
    65,
    160,
    16,
    106,
    32,
    12,
    106,
    41,
    3,
    0,
    133,
    55,
    3,
    0,
    32,
    12,
    65,
    8,
    106,
    34,
    12,
    65,
    128,
    8,
    71,
    13,
    0,
    11,
    32,
    13,
    65,
    160,
    16,
    106,
    16,
    164,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    12,
    3,
    64,
    32,
    10,
    32,
    12,
    106,
    34,
    8,
    32,
    8,
    41,
    3,
    0,
    32,
    13,
    65,
    160,
    16,
    106,
    32,
    12,
    106,
    41,
    3,
    0,
    133,
    55,
    3,
    0,
    32,
    12,
    65,
    8,
    106,
    34,
    12,
    65,
    128,
    8,
    71,
    13,
    0,
    12,
    2,
    11,
    11,
    32,
    2,
    32,
    22,
    32,
    7,
    106,
    65,
    10,
    116,
    106,
    33,
    9,
    32,
    15,
    32,
    8,
    32,
    12,
    106,
    32,
    26,
    106,
    65,
    10,
    116,
    32,
    25,
    167,
    32,
    24,
    167,
    106,
    65,
    10,
    116,
    107,
    106,
    33,
    6,
    65,
    0,
    33,
    12,
    3,
    64,
    32,
    13,
    65,
    160,
    16,
    106,
    32,
    12,
    106,
    34,
    8,
    32,
    8,
    41,
    3,
    0,
    32,
    6,
    32,
    12,
    106,
    41,
    3,
    0,
    133,
    55,
    3,
    0,
    32,
    12,
    65,
    8,
    106,
    34,
    12,
    65,
    128,
    8,
    71,
    13,
    0,
    11,
    32,
    9,
    32,
    13,
    65,
    160,
    16,
    106,
    65,
    128,
    8,
    252,
    10,
    0,
    0,
    32,
    13,
    65,
    160,
    16,
    106,
    16,
    164,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    12,
    3,
    64,
    32,
    10,
    32,
    12,
    106,
    34,
    8,
    32,
    8,
    41,
    3,
    0,
    32,
    13,
    65,
    160,
    16,
    106,
    32,
    12,
    106,
    41,
    3,
    0,
    133,
    55,
    3,
    0,
    32,
    12,
    65,
    8,
    106,
    34,
    12,
    65,
    128,
    8,
    71,
    13,
    0,
    11,
    11,
    32,
    10,
    65,
    128,
    8,
    106,
    33,
    10,
    32,
    11,
    65,
    1,
    106,
    33,
    11,
    32,
    7,
    65,
    1,
    106,
    34,
    7,
    32,
    23,
    71,
    13,
    0,
    11,
    11,
    32,
    20,
    32,
    17,
    106,
    33,
    20,
    32,
    21,
    65,
    4,
    71,
    13,
    0,
    11,
    32,
    19,
    65,
    1,
    106,
    34,
    19,
    32,
    4,
    71,
    13,
    0,
    11,
    11,
    65,
    0,
    33,
    12,
    3,
    64,
    32,
    13,
    65,
    160,
    16,
    106,
    32,
    12,
    106,
    66,
    0,
    55,
    3,
    0,
    32,
    12,
    65,
    8,
    106,
    34,
    12,
    65,
    128,
    8,
    71,
    13,
    0,
    11,
    32,
    3,
    65,
    10,
    116,
    65,
    128,
    96,
    113,
    32,
    2,
    106,
    65,
    128,
    120,
    106,
    33,
    10,
    65,
    0,
    33,
    12,
    3,
    64,
    32,
    13,
    32,
    12,
    106,
    32,
    10,
    32,
    12,
    106,
    41,
    3,
    0,
    16,
    154,
    128,
    128,
    128,
    0,
    32,
    12,
    65,
    8,
    106,
    34,
    12,
    65,
    128,
    8,
    71,
    13,
    0,
    11,
    2,
    64,
    32,
    14,
    65,
    7,
    116,
    34,
    12,
    69,
    13,
    0,
    3,
    64,
    32,
    2,
    66,
    0,
    55,
    3,
    0,
    32,
    2,
    65,
    8,
    106,
    33,
    2,
    32,
    12,
    65,
    127,
    106,
    34,
    12,
    13,
    0,
    11,
    11,
    32,
    0,
    32,
    1,
    32,
    13,
    65,
    128,
    8,
    16,
    162,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    12,
    3,
    64,
    32,
    13,
    32,
    12,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    12,
    65,
    1,
    106,
    34,
    12,
    65,
    128,
    8,
    71,
    13,
    0,
    11,
    32,
    13,
    65,
    240,
    24,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    86,
    1,
    1,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    16,
    107,
    34,
    2,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    2,
    32,
    1,
    54,
    0,
    12,
    32,
    0,
    32,
    2,
    65,
    12,
    106,
    65,
    4,
    16,
    149,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    0,
    3,
    64,
    32,
    2,
    65,
    12,
    106,
    32,
    0,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    0,
    65,
    1,
    106,
    34,
    0,
    65,
    4,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    16,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    171,
    2,
    1,
    3,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    224,
    1,
    107,
    34,
    4,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    4,
    65,
    8,
    106,
    65,
    128,
    137,
    128,
    128,
    0,
    65,
    192,
    0,
    252,
    10,
    0,
    0,
    32,
    4,
    65,
    208,
    0,
    106,
    66,
    0,
    55,
    3,
    0,
    32,
    4,
    66,
    0,
    55,
    3,
    72,
    65,
    0,
    33,
    5,
    32,
    4,
    65,
    0,
    54,
    2,
    216,
    1,
    32,
    4,
    32,
    1,
    65,
    192,
    0,
    32,
    1,
    65,
    192,
    0,
    73,
    27,
    34,
    6,
    54,
    2,
    220,
    1,
    32,
    4,
    32,
    6,
    173,
    66,
    136,
    146,
    247,
    149,
    255,
    204,
    249,
    132,
    234,
    0,
    133,
    55,
    3,
    8,
    32,
    4,
    65,
    8,
    106,
    32,
    1,
    16,
    161,
    128,
    128,
    128,
    0,
    32,
    4,
    65,
    8,
    106,
    32,
    2,
    32,
    3,
    16,
    149,
    128,
    128,
    128,
    0,
    32,
    4,
    65,
    8,
    106,
    32,
    0,
    16,
    153,
    128,
    128,
    128,
    0,
    2,
    64,
    32,
    1,
    65,
    193,
    0,
    73,
    13,
    0,
    65,
    32,
    33,
    2,
    2,
    64,
    32,
    1,
    173,
    66,
    31,
    124,
    66,
    5,
    136,
    167,
    34,
    3,
    65,
    126,
    106,
    34,
    6,
    65,
    2,
    73,
    13,
    0,
    32,
    3,
    65,
    125,
    106,
    33,
    2,
    65,
    0,
    33,
    5,
    3,
    64,
    32,
    0,
    32,
    5,
    106,
    34,
    3,
    65,
    32,
    106,
    65,
    192,
    0,
    65,
    0,
    65,
    0,
    32,
    3,
    65,
    192,
    0,
    16,
    155,
    128,
    128,
    128,
    0,
    32,
    5,
    65,
    32,
    106,
    33,
    5,
    32,
    2,
    65,
    127,
    106,
    34,
    2,
    13,
    0,
    11,
    32,
    5,
    65,
    32,
    106,
    33,
    2,
    11,
    32,
    0,
    32,
    2,
    106,
    32,
    1,
    32,
    6,
    65,
    5,
    116,
    107,
    65,
    0,
    65,
    0,
    32,
    0,
    32,
    5,
    106,
    65,
    192,
    0,
    16,
    155,
    128,
    128,
    128,
    0,
    11,
    32,
    4,
    65,
    224,
    1,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    166,
    1,
    1,
    2,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    128,
    8,
    107,
    34,
    1,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    0,
    66,
    0,
    55,
    3,
    8,
    32,
    0,
    66,
    1,
    55,
    3,
    40,
    32,
    0,
    32,
    0,
    53,
    2,
    128,
    8,
    55,
    3,
    0,
    32,
    0,
    32,
    0,
    53,
    2,
    132,
    8,
    55,
    3,
    16,
    32,
    0,
    32,
    0,
    53,
    2,
    136,
    8,
    55,
    3,
    24,
    32,
    0,
    32,
    0,
    53,
    2,
    140,
    8,
    55,
    3,
    32,
    32,
    0,
    32,
    0,
    53,
    2,
    144,
    8,
    55,
    3,
    48,
    65,
    0,
    33,
    2,
    32,
    0,
    65,
    56,
    106,
    65,
    0,
    65,
    200,
    7,
    252,
    11,
    0,
    32,
    0,
    32,
    1,
    16,
    217,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    1,
    16,
    217,
    128,
    128,
    128,
    0,
    3,
    64,
    32,
    1,
    32,
    2,
    106,
    66,
    0,
    55,
    3,
    0,
    32,
    2,
    65,
    8,
    106,
    34,
    2,
    65,
    128,
    8,
    71,
    13,
    0,
    11,
    32,
    1,
    65,
    128,
    8,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    140,
    23,
    30,
    3,
    127,
    1,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    2,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    3,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    2,
    126,
    65,
    112,
    33,
    1,
    32,
    0,
    33,
    2,
    3,
    64,
    32,
    2,
    32,
    2,
    65,
    24,
    106,
    34,
    3,
    41,
    3,
    0,
    34,
    4,
    32,
    2,
    65,
    56,
    106,
    34,
    5,
    41,
    3,
    0,
    34,
    6,
    124,
    32,
    4,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    32,
    6,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    126,
    124,
    34,
    4,
    32,
    2,
    65,
    248,
    0,
    106,
    34,
    7,
    41,
    3,
    0,
    133,
    66,
    32,
    137,
    34,
    8,
    32,
    2,
    65,
    216,
    0,
    106,
    34,
    9,
    41,
    3,
    0,
    34,
    10,
    124,
    32,
    8,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    10,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    10,
    32,
    6,
    133,
    66,
    40,
    137,
    34,
    6,
    32,
    4,
    124,
    32,
    6,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    4,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    4,
    32,
    8,
    133,
    66,
    48,
    137,
    34,
    8,
    32,
    2,
    65,
    8,
    106,
    34,
    11,
    41,
    3,
    0,
    34,
    12,
    32,
    2,
    65,
    40,
    106,
    34,
    13,
    41,
    3,
    0,
    34,
    14,
    124,
    32,
    12,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    32,
    14,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    126,
    124,
    34,
    12,
    32,
    2,
    65,
    232,
    0,
    106,
    34,
    15,
    41,
    3,
    0,
    133,
    66,
    32,
    137,
    34,
    16,
    32,
    2,
    65,
    200,
    0,
    106,
    34,
    17,
    41,
    3,
    0,
    34,
    18,
    124,
    32,
    16,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    18,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    18,
    32,
    14,
    133,
    66,
    40,
    137,
    34,
    14,
    32,
    12,
    124,
    32,
    14,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    12,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    12,
    32,
    16,
    133,
    66,
    48,
    137,
    34,
    16,
    32,
    18,
    124,
    32,
    16,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    18,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    18,
    32,
    14,
    133,
    66,
    1,
    137,
    34,
    14,
    32,
    2,
    41,
    3,
    0,
    34,
    19,
    32,
    2,
    65,
    32,
    106,
    34,
    20,
    41,
    3,
    0,
    34,
    21,
    124,
    32,
    19,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    32,
    21,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    126,
    124,
    34,
    19,
    32,
    2,
    65,
    224,
    0,
    106,
    34,
    22,
    41,
    3,
    0,
    133,
    66,
    32,
    137,
    34,
    23,
    32,
    2,
    65,
    192,
    0,
    106,
    34,
    24,
    41,
    3,
    0,
    34,
    25,
    124,
    32,
    23,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    25,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    25,
    32,
    21,
    133,
    66,
    40,
    137,
    34,
    21,
    32,
    19,
    124,
    32,
    21,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    19,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    19,
    124,
    32,
    14,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    19,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    26,
    133,
    66,
    32,
    137,
    34,
    27,
    32,
    2,
    65,
    16,
    106,
    34,
    28,
    41,
    3,
    0,
    34,
    29,
    32,
    2,
    65,
    48,
    106,
    34,
    30,
    41,
    3,
    0,
    34,
    31,
    124,
    32,
    29,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    32,
    31,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    126,
    124,
    34,
    29,
    32,
    2,
    65,
    240,
    0,
    106,
    34,
    32,
    41,
    3,
    0,
    133,
    66,
    32,
    137,
    34,
    33,
    32,
    2,
    65,
    208,
    0,
    106,
    34,
    34,
    41,
    3,
    0,
    34,
    35,
    124,
    32,
    33,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    35,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    35,
    32,
    31,
    133,
    66,
    40,
    137,
    34,
    31,
    32,
    29,
    124,
    32,
    31,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    29,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    29,
    32,
    33,
    133,
    66,
    48,
    137,
    34,
    33,
    32,
    35,
    124,
    32,
    33,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    35,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    35,
    124,
    32,
    27,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    35,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    36,
    32,
    14,
    133,
    66,
    40,
    137,
    34,
    14,
    32,
    26,
    124,
    32,
    14,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    26,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    26,
    55,
    3,
    0,
    32,
    7,
    32,
    26,
    32,
    27,
    133,
    66,
    48,
    137,
    34,
    26,
    55,
    3,
    0,
    32,
    34,
    32,
    26,
    32,
    36,
    124,
    32,
    26,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    36,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    26,
    55,
    3,
    0,
    32,
    13,
    32,
    26,
    32,
    14,
    133,
    66,
    1,
    137,
    55,
    3,
    0,
    32,
    22,
    32,
    8,
    32,
    10,
    124,
    32,
    8,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    10,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    8,
    32,
    35,
    32,
    31,
    133,
    66,
    1,
    137,
    34,
    10,
    32,
    12,
    124,
    32,
    10,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    12,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    14,
    32,
    19,
    32,
    23,
    133,
    66,
    48,
    137,
    34,
    12,
    133,
    66,
    32,
    137,
    34,
    19,
    124,
    32,
    8,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    32,
    19,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    126,
    124,
    34,
    23,
    32,
    10,
    133,
    66,
    40,
    137,
    34,
    10,
    32,
    14,
    124,
    32,
    10,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    14,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    26,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    14,
    55,
    3,
    0,
    32,
    11,
    32,
    26,
    55,
    3,
    0,
    32,
    9,
    32,
    14,
    32,
    23,
    124,
    32,
    14,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    23,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    14,
    55,
    3,
    0,
    32,
    30,
    32,
    14,
    32,
    10,
    133,
    66,
    1,
    137,
    55,
    3,
    0,
    32,
    15,
    32,
    8,
    32,
    6,
    133,
    66,
    1,
    137,
    34,
    6,
    32,
    29,
    124,
    32,
    6,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    29,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    8,
    32,
    16,
    133,
    66,
    32,
    137,
    34,
    10,
    32,
    12,
    32,
    25,
    124,
    32,
    12,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    25,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    14,
    124,
    32,
    10,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    14,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    12,
    32,
    6,
    133,
    66,
    40,
    137,
    34,
    6,
    32,
    8,
    124,
    32,
    6,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    8,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    16,
    32,
    10,
    133,
    66,
    48,
    137,
    34,
    8,
    55,
    3,
    0,
    32,
    28,
    32,
    16,
    55,
    3,
    0,
    32,
    24,
    32,
    8,
    32,
    12,
    124,
    32,
    8,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    12,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    8,
    55,
    3,
    0,
    32,
    5,
    32,
    8,
    32,
    6,
    133,
    66,
    1,
    137,
    55,
    3,
    0,
    32,
    32,
    32,
    4,
    32,
    14,
    32,
    21,
    133,
    66,
    1,
    137,
    34,
    6,
    124,
    32,
    4,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    32,
    6,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    126,
    124,
    34,
    4,
    32,
    33,
    133,
    66,
    32,
    137,
    34,
    8,
    32,
    18,
    124,
    32,
    8,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    18,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    10,
    32,
    6,
    133,
    66,
    40,
    137,
    34,
    6,
    32,
    4,
    124,
    32,
    6,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    4,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    14,
    32,
    8,
    133,
    66,
    48,
    137,
    34,
    4,
    55,
    3,
    0,
    32,
    3,
    32,
    14,
    55,
    3,
    0,
    32,
    17,
    32,
    4,
    32,
    10,
    124,
    32,
    4,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    10,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    4,
    55,
    3,
    0,
    32,
    20,
    32,
    4,
    32,
    6,
    133,
    66,
    1,
    137,
    55,
    3,
    0,
    32,
    2,
    65,
    128,
    1,
    106,
    33,
    2,
    32,
    1,
    65,
    16,
    106,
    34,
    1,
    65,
    240,
    0,
    73,
    13,
    0,
    11,
    32,
    0,
    65,
    136,
    7,
    106,
    33,
    2,
    65,
    126,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    248,
    120,
    106,
    34,
    3,
    32,
    2,
    65,
    128,
    122,
    106,
    34,
    5,
    41,
    3,
    0,
    34,
    4,
    32,
    2,
    65,
    128,
    124,
    106,
    34,
    7,
    41,
    3,
    0,
    34,
    6,
    124,
    32,
    4,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    32,
    6,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    126,
    124,
    34,
    4,
    32,
    2,
    41,
    3,
    0,
    133,
    66,
    32,
    137,
    34,
    8,
    32,
    2,
    65,
    128,
    126,
    106,
    34,
    9,
    41,
    3,
    0,
    34,
    10,
    124,
    32,
    8,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    10,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    10,
    32,
    6,
    133,
    66,
    40,
    137,
    34,
    6,
    32,
    4,
    124,
    32,
    6,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    4,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    4,
    32,
    8,
    133,
    66,
    48,
    137,
    34,
    8,
    32,
    2,
    65,
    128,
    121,
    106,
    34,
    11,
    41,
    3,
    0,
    34,
    12,
    32,
    2,
    65,
    128,
    123,
    106,
    34,
    13,
    41,
    3,
    0,
    34,
    14,
    124,
    32,
    12,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    32,
    14,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    126,
    124,
    34,
    12,
    32,
    2,
    65,
    128,
    127,
    106,
    34,
    15,
    41,
    3,
    0,
    133,
    66,
    32,
    137,
    34,
    16,
    32,
    2,
    65,
    128,
    125,
    106,
    34,
    17,
    41,
    3,
    0,
    34,
    18,
    124,
    32,
    16,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    18,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    18,
    32,
    14,
    133,
    66,
    40,
    137,
    34,
    14,
    32,
    12,
    124,
    32,
    14,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    12,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    12,
    32,
    16,
    133,
    66,
    48,
    137,
    34,
    16,
    32,
    18,
    124,
    32,
    16,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    18,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    18,
    32,
    14,
    133,
    66,
    1,
    137,
    34,
    14,
    32,
    3,
    41,
    3,
    0,
    34,
    19,
    32,
    2,
    65,
    248,
    122,
    106,
    34,
    3,
    41,
    3,
    0,
    34,
    21,
    124,
    32,
    19,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    32,
    21,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    126,
    124,
    34,
    19,
    32,
    2,
    65,
    248,
    126,
    106,
    34,
    20,
    41,
    3,
    0,
    133,
    66,
    32,
    137,
    34,
    23,
    32,
    2,
    65,
    248,
    124,
    106,
    34,
    22,
    41,
    3,
    0,
    34,
    25,
    124,
    32,
    23,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    25,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    25,
    32,
    21,
    133,
    66,
    40,
    137,
    34,
    21,
    32,
    19,
    124,
    32,
    21,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    19,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    19,
    124,
    32,
    14,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    19,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    26,
    133,
    66,
    32,
    137,
    34,
    27,
    32,
    2,
    65,
    248,
    121,
    106,
    34,
    24,
    41,
    3,
    0,
    34,
    29,
    32,
    2,
    65,
    248,
    123,
    106,
    34,
    28,
    41,
    3,
    0,
    34,
    31,
    124,
    32,
    29,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    32,
    31,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    126,
    124,
    34,
    29,
    32,
    2,
    65,
    120,
    106,
    34,
    30,
    41,
    3,
    0,
    133,
    66,
    32,
    137,
    34,
    33,
    32,
    2,
    65,
    248,
    125,
    106,
    34,
    32,
    41,
    3,
    0,
    34,
    35,
    124,
    32,
    33,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    35,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    35,
    32,
    31,
    133,
    66,
    40,
    137,
    34,
    31,
    32,
    29,
    124,
    32,
    31,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    29,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    29,
    32,
    33,
    133,
    66,
    48,
    137,
    34,
    33,
    32,
    35,
    124,
    32,
    33,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    35,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    35,
    124,
    32,
    27,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    35,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    36,
    32,
    14,
    133,
    66,
    40,
    137,
    34,
    14,
    32,
    26,
    124,
    32,
    14,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    26,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    26,
    55,
    3,
    0,
    32,
    2,
    32,
    26,
    32,
    27,
    133,
    66,
    48,
    137,
    34,
    26,
    55,
    3,
    0,
    32,
    32,
    32,
    26,
    32,
    36,
    124,
    32,
    26,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    36,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    26,
    55,
    3,
    0,
    32,
    13,
    32,
    26,
    32,
    14,
    133,
    66,
    1,
    137,
    55,
    3,
    0,
    32,
    20,
    32,
    8,
    32,
    10,
    124,
    32,
    8,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    10,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    8,
    32,
    35,
    32,
    31,
    133,
    66,
    1,
    137,
    34,
    10,
    32,
    12,
    124,
    32,
    10,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    12,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    14,
    32,
    19,
    32,
    23,
    133,
    66,
    48,
    137,
    34,
    12,
    133,
    66,
    32,
    137,
    34,
    19,
    124,
    32,
    8,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    32,
    19,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    126,
    124,
    34,
    23,
    32,
    10,
    133,
    66,
    40,
    137,
    34,
    10,
    32,
    14,
    124,
    32,
    10,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    14,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    26,
    32,
    19,
    133,
    66,
    48,
    137,
    34,
    14,
    55,
    3,
    0,
    32,
    11,
    32,
    26,
    55,
    3,
    0,
    32,
    9,
    32,
    14,
    32,
    23,
    124,
    32,
    14,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    23,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    14,
    55,
    3,
    0,
    32,
    28,
    32,
    14,
    32,
    10,
    133,
    66,
    1,
    137,
    55,
    3,
    0,
    32,
    15,
    32,
    8,
    32,
    6,
    133,
    66,
    1,
    137,
    34,
    6,
    32,
    29,
    124,
    32,
    6,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    29,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    8,
    32,
    16,
    133,
    66,
    32,
    137,
    34,
    10,
    32,
    12,
    32,
    25,
    124,
    32,
    12,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    25,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    14,
    124,
    32,
    10,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    14,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    12,
    32,
    6,
    133,
    66,
    40,
    137,
    34,
    6,
    32,
    8,
    124,
    32,
    6,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    8,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    16,
    32,
    10,
    133,
    66,
    48,
    137,
    34,
    8,
    55,
    3,
    0,
    32,
    24,
    32,
    16,
    55,
    3,
    0,
    32,
    22,
    32,
    8,
    32,
    12,
    124,
    32,
    8,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    12,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    8,
    55,
    3,
    0,
    32,
    7,
    32,
    8,
    32,
    6,
    133,
    66,
    1,
    137,
    55,
    3,
    0,
    32,
    30,
    32,
    4,
    32,
    14,
    32,
    21,
    133,
    66,
    1,
    137,
    34,
    6,
    124,
    32,
    4,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    32,
    6,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    126,
    124,
    34,
    4,
    32,
    33,
    133,
    66,
    32,
    137,
    34,
    8,
    32,
    18,
    124,
    32,
    8,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    18,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    10,
    32,
    6,
    133,
    66,
    40,
    137,
    34,
    6,
    32,
    4,
    124,
    32,
    6,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    4,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    14,
    32,
    8,
    133,
    66,
    48,
    137,
    34,
    4,
    55,
    3,
    0,
    32,
    5,
    32,
    14,
    55,
    3,
    0,
    32,
    17,
    32,
    4,
    32,
    10,
    124,
    32,
    4,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    32,
    10,
    66,
    1,
    134,
    66,
    254,
    255,
    255,
    255,
    31,
    131,
    126,
    124,
    34,
    4,
    55,
    3,
    0,
    32,
    3,
    32,
    4,
    32,
    6,
    133,
    66,
    1,
    137,
    55,
    3,
    0,
    32,
    2,
    65,
    16,
    106,
    33,
    2,
    32,
    1,
    65,
    2,
    106,
    34,
    1,
    65,
    14,
    73,
    13,
    0,
    11,
    11,
    34,
    0,
    32,
    0,
    32,
    1,
    32,
    2,
    32,
    3,
    32,
    4,
    32,
    5,
    32,
    6,
    32,
    7,
    32,
    8,
    65,
    0,
    65,
    0,
    65,
    0,
    65,
    0,
    16,
    160,
    128,
    128,
    128,
    0,
    11,
    164,
    1,
    2,
    1,
    127,
    1,
    126,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    32,
    107,
    34,
    3,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    3,
    65,
    24,
    106,
    32,
    1,
    65,
    24,
    106,
    41,
    0,
    0,
    55,
    3,
    0,
    32,
    3,
    65,
    16,
    106,
    32,
    1,
    65,
    16,
    106,
    41,
    0,
    0,
    55,
    3,
    0,
    32,
    3,
    32,
    1,
    41,
    0,
    0,
    34,
    4,
    55,
    3,
    0,
    32,
    3,
    32,
    1,
    65,
    8,
    106,
    41,
    0,
    0,
    55,
    3,
    8,
    32,
    3,
    32,
    4,
    167,
    65,
    248,
    1,
    113,
    58,
    0,
    0,
    32,
    3,
    32,
    3,
    45,
    0,
    31,
    65,
    63,
    113,
    65,
    192,
    0,
    114,
    58,
    0,
    31,
    32,
    0,
    32,
    3,
    32,
    2,
    65,
    255,
    1,
    16,
    167,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    3,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    32,
    71,
    13,
    0,
    11,
    32,
    3,
    65,
    32,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    241,
    10,
    1,
    9,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    208,
    2,
    107,
    34,
    4,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    4,
    65,
    160,
    2,
    106,
    32,
    2,
    16,
    168,
    128,
    128,
    128,
    0,
    32,
    4,
    65,
    1,
    54,
    2,
    240,
    1,
    65,
    0,
    33,
    5,
    32,
    4,
    65,
    240,
    1,
    106,
    65,
    4,
    114,
    65,
    0,
    65,
    36,
    252,
    11,
    0,
    32,
    4,
    65,
    192,
    1,
    106,
    65,
    0,
    65,
    40,
    252,
    11,
    0,
    32,
    4,
    65,
    144,
    1,
    106,
    32,
    4,
    65,
    160,
    2,
    106,
    65,
    40,
    252,
    10,
    0,
    0,
    32,
    4,
    65,
    1,
    54,
    2,
    96,
    32,
    4,
    65,
    224,
    0,
    106,
    65,
    4,
    114,
    65,
    0,
    65,
    36,
    252,
    11,
    0,
    65,
    0,
    33,
    6,
    2,
    64,
    32,
    3,
    65,
    1,
    72,
    13,
    0,
    65,
    0,
    33,
    2,
    3,
    64,
    65,
    0,
    32,
    1,
    32,
    3,
    65,
    127,
    106,
    34,
    7,
    65,
    3,
    118,
    106,
    45,
    0,
    0,
    32,
    7,
    65,
    7,
    113,
    118,
    65,
    1,
    113,
    34,
    6,
    32,
    2,
    115,
    107,
    33,
    8,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    65,
    240,
    1,
    106,
    32,
    2,
    106,
    34,
    9,
    32,
    4,
    65,
    144,
    1,
    106,
    32,
    2,
    106,
    34,
    10,
    40,
    2,
    0,
    34,
    11,
    32,
    9,
    40,
    2,
    0,
    34,
    9,
    115,
    32,
    8,
    113,
    34,
    12,
    32,
    9,
    115,
    54,
    2,
    0,
    32,
    10,
    32,
    12,
    32,
    11,
    115,
    54,
    2,
    0,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    65,
    192,
    1,
    106,
    32,
    2,
    106,
    34,
    9,
    32,
    4,
    65,
    224,
    0,
    106,
    32,
    2,
    106,
    34,
    10,
    40,
    2,
    0,
    34,
    11,
    32,
    9,
    40,
    2,
    0,
    34,
    9,
    115,
    32,
    8,
    113,
    34,
    12,
    32,
    9,
    115,
    54,
    2,
    0,
    32,
    10,
    32,
    12,
    32,
    11,
    115,
    54,
    2,
    0,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    65,
    48,
    106,
    32,
    2,
    106,
    32,
    4,
    65,
    144,
    1,
    106,
    32,
    2,
    106,
    40,
    2,
    0,
    32,
    4,
    65,
    224,
    0,
    106,
    32,
    2,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    32,
    2,
    106,
    32,
    4,
    65,
    240,
    1,
    106,
    32,
    2,
    106,
    40,
    2,
    0,
    32,
    4,
    65,
    192,
    1,
    106,
    32,
    2,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    65,
    240,
    1,
    106,
    32,
    2,
    106,
    34,
    8,
    32,
    4,
    65,
    192,
    1,
    106,
    32,
    2,
    106,
    40,
    2,
    0,
    32,
    8,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    65,
    192,
    1,
    106,
    32,
    2,
    106,
    32,
    4,
    65,
    224,
    0,
    106,
    32,
    2,
    106,
    40,
    2,
    0,
    32,
    4,
    65,
    144,
    1,
    106,
    32,
    2,
    106,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    4,
    65,
    224,
    0,
    106,
    32,
    4,
    65,
    48,
    106,
    32,
    4,
    65,
    240,
    1,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    4,
    65,
    192,
    1,
    106,
    32,
    4,
    65,
    192,
    1,
    106,
    32,
    4,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    4,
    65,
    48,
    106,
    32,
    4,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    4,
    32,
    4,
    65,
    240,
    1,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    65,
    144,
    1,
    106,
    32,
    2,
    106,
    32,
    4,
    65,
    192,
    1,
    106,
    32,
    2,
    106,
    40,
    2,
    0,
    32,
    4,
    65,
    224,
    0,
    106,
    32,
    2,
    106,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    65,
    192,
    1,
    106,
    32,
    2,
    106,
    34,
    8,
    32,
    4,
    65,
    224,
    0,
    106,
    32,
    2,
    106,
    40,
    2,
    0,
    32,
    8,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    4,
    65,
    240,
    1,
    106,
    32,
    4,
    32,
    4,
    65,
    48,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    32,
    2,
    106,
    34,
    8,
    32,
    8,
    40,
    2,
    0,
    32,
    4,
    65,
    48,
    106,
    32,
    2,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    4,
    65,
    192,
    1,
    106,
    32,
    4,
    65,
    192,
    1,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    4,
    65,
    224,
    0,
    106,
    32,
    4,
    65,
    194,
    182,
    7,
    16,
    171,
    128,
    128,
    128,
    0,
    32,
    4,
    65,
    144,
    1,
    106,
    32,
    4,
    65,
    144,
    1,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    65,
    48,
    106,
    32,
    2,
    106,
    34,
    8,
    32,
    4,
    65,
    224,
    0,
    106,
    32,
    2,
    106,
    40,
    2,
    0,
    32,
    8,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    3,
    65,
    1,
    74,
    33,
    8,
    32,
    4,
    65,
    224,
    0,
    106,
    32,
    4,
    65,
    160,
    2,
    106,
    32,
    4,
    65,
    192,
    1,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    4,
    65,
    192,
    1,
    106,
    32,
    4,
    32,
    4,
    65,
    48,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    7,
    33,
    3,
    32,
    6,
    33,
    2,
    32,
    8,
    13,
    0,
    11,
    11,
    65,
    0,
    32,
    6,
    107,
    33,
    8,
    3,
    64,
    32,
    4,
    65,
    240,
    1,
    106,
    32,
    5,
    106,
    34,
    2,
    32,
    4,
    65,
    144,
    1,
    106,
    32,
    5,
    106,
    34,
    9,
    40,
    2,
    0,
    34,
    10,
    32,
    2,
    40,
    2,
    0,
    34,
    2,
    115,
    32,
    8,
    113,
    34,
    11,
    32,
    2,
    115,
    54,
    2,
    0,
    32,
    9,
    32,
    11,
    32,
    10,
    115,
    54,
    2,
    0,
    32,
    5,
    65,
    4,
    106,
    34,
    5,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    65,
    192,
    1,
    106,
    32,
    2,
    106,
    34,
    9,
    32,
    4,
    65,
    224,
    0,
    106,
    32,
    2,
    106,
    34,
    10,
    40,
    2,
    0,
    34,
    11,
    32,
    9,
    40,
    2,
    0,
    34,
    9,
    115,
    32,
    8,
    113,
    34,
    12,
    32,
    9,
    115,
    54,
    2,
    0,
    32,
    10,
    32,
    12,
    32,
    11,
    115,
    54,
    2,
    0,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    4,
    65,
    192,
    1,
    106,
    32,
    4,
    65,
    192,
    1,
    106,
    16,
    172,
    128,
    128,
    128,
    0,
    32,
    4,
    65,
    240,
    1,
    106,
    32,
    4,
    65,
    240,
    1,
    106,
    32,
    4,
    65,
    192,
    1,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    4,
    65,
    240,
    1,
    106,
    16,
    173,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    65,
    160,
    2,
    106,
    32,
    2,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    2,
    65,
    1,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    65,
    240,
    1,
    106,
    32,
    2,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    2,
    65,
    1,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    65,
    192,
    1,
    106,
    32,
    2,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    2,
    65,
    1,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    65,
    48,
    106,
    32,
    2,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    2,
    65,
    1,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    65,
    144,
    1,
    106,
    32,
    2,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    2,
    65,
    1,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    65,
    224,
    0,
    106,
    32,
    2,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    2,
    65,
    1,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    32,
    2,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    2,
    65,
    1,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    4,
    65,
    208,
    2,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    156,
    5,
    1,
    24,
    126,
    32,
    1,
    49,
    0,
    31,
    33,
    2,
    32,
    1,
    49,
    0,
    30,
    33,
    3,
    32,
    1,
    49,
    0,
    29,
    33,
    4,
    32,
    1,
    49,
    0,
    28,
    33,
    5,
    32,
    1,
    49,
    0,
    27,
    33,
    6,
    32,
    1,
    49,
    0,
    26,
    33,
    7,
    32,
    1,
    49,
    0,
    25,
    33,
    8,
    32,
    1,
    49,
    0,
    24,
    33,
    9,
    32,
    1,
    49,
    0,
    23,
    33,
    10,
    32,
    1,
    49,
    0,
    12,
    33,
    11,
    32,
    1,
    49,
    0,
    11,
    33,
    12,
    32,
    1,
    49,
    0,
    10,
    33,
    13,
    32,
    1,
    53,
    0,
    16,
    33,
    14,
    32,
    1,
    49,
    0,
    15,
    33,
    15,
    32,
    1,
    49,
    0,
    14,
    33,
    16,
    32,
    1,
    49,
    0,
    13,
    33,
    17,
    32,
    1,
    49,
    0,
    22,
    33,
    18,
    32,
    1,
    49,
    0,
    21,
    33,
    19,
    32,
    1,
    49,
    0,
    20,
    33,
    20,
    32,
    0,
    32,
    1,
    49,
    0,
    5,
    66,
    14,
    134,
    32,
    1,
    49,
    0,
    4,
    66,
    6,
    134,
    132,
    32,
    1,
    49,
    0,
    6,
    66,
    22,
    134,
    132,
    32,
    1,
    53,
    0,
    0,
    34,
    21,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    22,
    66,
    26,
    136,
    124,
    34,
    23,
    66,
    128,
    128,
    128,
    8,
    124,
    34,
    24,
    66,
    25,
    136,
    32,
    1,
    49,
    0,
    8,
    66,
    13,
    134,
    32,
    1,
    49,
    0,
    7,
    66,
    5,
    134,
    132,
    32,
    1,
    49,
    0,
    9,
    66,
    21,
    134,
    132,
    124,
    34,
    25,
    32,
    25,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    25,
    66,
    128,
    128,
    128,
    224,
    15,
    131,
    125,
    62,
    2,
    8,
    32,
    0,
    32,
    14,
    32,
    16,
    66,
    10,
    134,
    32,
    17,
    66,
    2,
    134,
    132,
    32,
    15,
    66,
    18,
    134,
    132,
    34,
    15,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    16,
    66,
    26,
    136,
    124,
    34,
    14,
    66,
    128,
    128,
    128,
    8,
    124,
    34,
    17,
    66,
    25,
    136,
    32,
    19,
    66,
    15,
    134,
    32,
    20,
    66,
    7,
    134,
    132,
    32,
    18,
    66,
    23,
    134,
    132,
    124,
    34,
    18,
    32,
    18,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    18,
    66,
    128,
    128,
    128,
    224,
    15,
    131,
    125,
    62,
    2,
    24,
    32,
    0,
    32,
    25,
    66,
    26,
    136,
    32,
    12,
    66,
    11,
    134,
    32,
    13,
    66,
    3,
    134,
    132,
    32,
    11,
    66,
    19,
    134,
    132,
    124,
    34,
    11,
    32,
    11,
    66,
    128,
    128,
    128,
    8,
    124,
    34,
    11,
    66,
    128,
    128,
    128,
    240,
    15,
    131,
    125,
    62,
    2,
    12,
    32,
    0,
    32,
    18,
    66,
    26,
    136,
    32,
    9,
    66,
    13,
    134,
    32,
    10,
    66,
    5,
    134,
    132,
    32,
    8,
    66,
    21,
    134,
    132,
    124,
    34,
    8,
    32,
    8,
    66,
    128,
    128,
    128,
    8,
    124,
    34,
    8,
    66,
    128,
    128,
    128,
    240,
    15,
    131,
    125,
    62,
    2,
    28,
    32,
    0,
    32,
    15,
    32,
    16,
    66,
    128,
    128,
    128,
    32,
    131,
    125,
    32,
    11,
    66,
    25,
    136,
    124,
    34,
    9,
    32,
    9,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    9,
    66,
    128,
    128,
    128,
    224,
    15,
    131,
    125,
    62,
    2,
    16,
    32,
    0,
    32,
    9,
    66,
    26,
    136,
    32,
    14,
    124,
    32,
    17,
    66,
    128,
    128,
    128,
    240,
    15,
    131,
    125,
    62,
    2,
    20,
    32,
    0,
    32,
    8,
    66,
    25,
    136,
    32,
    6,
    66,
    12,
    134,
    32,
    7,
    66,
    4,
    134,
    132,
    32,
    5,
    66,
    20,
    134,
    132,
    124,
    34,
    5,
    32,
    5,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    5,
    66,
    128,
    128,
    128,
    224,
    15,
    131,
    125,
    62,
    2,
    32,
    32,
    0,
    32,
    3,
    66,
    10,
    134,
    32,
    4,
    66,
    2,
    134,
    132,
    32,
    2,
    66,
    18,
    134,
    66,
    128,
    128,
    240,
    15,
    131,
    132,
    32,
    5,
    66,
    26,
    136,
    124,
    34,
    2,
    32,
    2,
    66,
    128,
    128,
    128,
    8,
    124,
    34,
    2,
    66,
    128,
    128,
    128,
    240,
    15,
    131,
    125,
    62,
    2,
    36,
    32,
    0,
    32,
    23,
    32,
    24,
    66,
    128,
    128,
    128,
    240,
    15,
    131,
    125,
    32,
    2,
    66,
    25,
    136,
    66,
    19,
    126,
    32,
    21,
    32,
    22,
    66,
    128,
    128,
    128,
    224,
    31,
    131,
    125,
    124,
    34,
    2,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    3,
    66,
    26,
    136,
    124,
    62,
    2,
    4,
    32,
    0,
    32,
    2,
    32,
    3,
    66,
    128,
    128,
    128,
    224,
    15,
    131,
    125,
    62,
    2,
    0,
    11,
    201,
    9,
    24,
    1,
    127,
    1,
    126,
    1,
    127,
    3,
    126,
    1,
    127,
    2,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    2,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    2,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    23,
    126,
    32,
    0,
    32,
    2,
    40,
    2,
    4,
    34,
    3,
    172,
    34,
    4,
    32,
    1,
    40,
    2,
    20,
    34,
    5,
    65,
    1,
    116,
    172,
    34,
    6,
    126,
    32,
    2,
    52,
    2,
    0,
    34,
    7,
    32,
    1,
    52,
    2,
    24,
    34,
    8,
    126,
    124,
    32,
    2,
    40,
    2,
    8,
    34,
    9,
    172,
    34,
    10,
    32,
    1,
    52,
    2,
    16,
    34,
    11,
    126,
    124,
    32,
    2,
    40,
    2,
    12,
    34,
    12,
    172,
    34,
    13,
    32,
    1,
    40,
    2,
    12,
    34,
    14,
    65,
    1,
    116,
    172,
    34,
    15,
    126,
    124,
    32,
    2,
    40,
    2,
    16,
    34,
    16,
    172,
    34,
    17,
    32,
    1,
    52,
    2,
    8,
    34,
    18,
    126,
    124,
    32,
    2,
    40,
    2,
    20,
    34,
    19,
    172,
    34,
    20,
    32,
    1,
    40,
    2,
    4,
    34,
    21,
    65,
    1,
    116,
    172,
    34,
    22,
    126,
    124,
    32,
    2,
    40,
    2,
    24,
    34,
    23,
    172,
    34,
    24,
    32,
    1,
    52,
    2,
    0,
    34,
    25,
    126,
    124,
    32,
    2,
    40,
    2,
    28,
    34,
    26,
    65,
    19,
    108,
    172,
    34,
    27,
    32,
    1,
    40,
    2,
    36,
    34,
    28,
    65,
    1,
    116,
    172,
    34,
    29,
    126,
    124,
    32,
    2,
    40,
    2,
    32,
    34,
    30,
    65,
    19,
    108,
    172,
    34,
    31,
    32,
    1,
    52,
    2,
    32,
    34,
    32,
    126,
    124,
    32,
    2,
    40,
    2,
    36,
    34,
    2,
    65,
    19,
    108,
    172,
    34,
    33,
    32,
    1,
    40,
    2,
    28,
    34,
    1,
    65,
    1,
    116,
    172,
    34,
    34,
    126,
    124,
    32,
    4,
    32,
    11,
    126,
    32,
    7,
    32,
    5,
    172,
    34,
    35,
    126,
    124,
    32,
    10,
    32,
    14,
    172,
    34,
    36,
    126,
    124,
    32,
    13,
    32,
    18,
    126,
    124,
    32,
    17,
    32,
    21,
    172,
    34,
    37,
    126,
    124,
    32,
    20,
    32,
    25,
    126,
    124,
    32,
    23,
    65,
    19,
    108,
    172,
    34,
    38,
    32,
    28,
    172,
    34,
    39,
    126,
    124,
    32,
    27,
    32,
    32,
    126,
    124,
    32,
    31,
    32,
    1,
    172,
    34,
    40,
    126,
    124,
    32,
    33,
    32,
    8,
    126,
    124,
    32,
    4,
    32,
    15,
    126,
    32,
    7,
    32,
    11,
    126,
    124,
    32,
    10,
    32,
    18,
    126,
    124,
    32,
    13,
    32,
    22,
    126,
    124,
    32,
    17,
    32,
    25,
    126,
    124,
    32,
    19,
    65,
    19,
    108,
    172,
    34,
    41,
    32,
    29,
    126,
    124,
    32,
    38,
    32,
    32,
    126,
    124,
    32,
    27,
    32,
    34,
    126,
    124,
    32,
    31,
    32,
    8,
    126,
    124,
    32,
    33,
    32,
    6,
    126,
    124,
    34,
    42,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    43,
    66,
    26,
    135,
    124,
    34,
    44,
    66,
    128,
    128,
    128,
    8,
    124,
    34,
    45,
    66,
    25,
    135,
    124,
    34,
    46,
    32,
    46,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    47,
    66,
    128,
    128,
    128,
    224,
    15,
    131,
    125,
    62,
    2,
    24,
    32,
    0,
    32,
    4,
    32,
    22,
    126,
    32,
    7,
    32,
    18,
    126,
    124,
    32,
    10,
    32,
    25,
    126,
    124,
    32,
    12,
    65,
    19,
    108,
    172,
    34,
    48,
    32,
    29,
    126,
    124,
    32,
    32,
    32,
    16,
    65,
    19,
    108,
    172,
    34,
    46,
    126,
    124,
    32,
    41,
    32,
    34,
    126,
    124,
    32,
    38,
    32,
    8,
    126,
    124,
    32,
    27,
    32,
    6,
    126,
    124,
    32,
    31,
    32,
    11,
    126,
    124,
    32,
    33,
    32,
    15,
    126,
    124,
    32,
    4,
    32,
    25,
    126,
    32,
    7,
    32,
    37,
    126,
    124,
    32,
    9,
    65,
    19,
    108,
    172,
    34,
    49,
    32,
    39,
    126,
    124,
    32,
    48,
    32,
    32,
    126,
    124,
    32,
    46,
    32,
    40,
    126,
    124,
    32,
    41,
    32,
    8,
    126,
    124,
    32,
    38,
    32,
    35,
    126,
    124,
    32,
    27,
    32,
    11,
    126,
    124,
    32,
    31,
    32,
    36,
    126,
    124,
    32,
    33,
    32,
    18,
    126,
    124,
    32,
    3,
    65,
    19,
    108,
    172,
    32,
    29,
    126,
    32,
    7,
    32,
    25,
    126,
    124,
    32,
    49,
    32,
    32,
    126,
    124,
    32,
    48,
    32,
    34,
    126,
    124,
    32,
    46,
    32,
    8,
    126,
    124,
    32,
    41,
    32,
    6,
    126,
    124,
    32,
    38,
    32,
    11,
    126,
    124,
    32,
    27,
    32,
    15,
    126,
    124,
    32,
    31,
    32,
    18,
    126,
    124,
    32,
    33,
    32,
    22,
    126,
    124,
    34,
    49,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    50,
    66,
    26,
    135,
    124,
    34,
    51,
    66,
    128,
    128,
    128,
    8,
    124,
    34,
    52,
    66,
    25,
    135,
    124,
    34,
    48,
    32,
    48,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    53,
    66,
    128,
    128,
    128,
    224,
    15,
    131,
    125,
    62,
    2,
    8,
    32,
    0,
    32,
    4,
    32,
    8,
    126,
    32,
    7,
    32,
    40,
    126,
    124,
    32,
    10,
    32,
    35,
    126,
    124,
    32,
    13,
    32,
    11,
    126,
    124,
    32,
    17,
    32,
    36,
    126,
    124,
    32,
    20,
    32,
    18,
    126,
    124,
    32,
    24,
    32,
    37,
    126,
    124,
    32,
    25,
    32,
    26,
    172,
    34,
    48,
    126,
    124,
    32,
    31,
    32,
    39,
    126,
    124,
    32,
    33,
    32,
    32,
    126,
    124,
    32,
    47,
    66,
    26,
    135,
    124,
    34,
    47,
    32,
    47,
    66,
    128,
    128,
    128,
    8,
    124,
    34,
    47,
    66,
    128,
    128,
    128,
    240,
    15,
    131,
    125,
    62,
    2,
    28,
    32,
    0,
    32,
    4,
    32,
    18,
    126,
    32,
    7,
    32,
    36,
    126,
    124,
    32,
    10,
    32,
    37,
    126,
    124,
    32,
    13,
    32,
    25,
    126,
    124,
    32,
    46,
    32,
    39,
    126,
    124,
    32,
    41,
    32,
    32,
    126,
    124,
    32,
    38,
    32,
    40,
    126,
    124,
    32,
    27,
    32,
    8,
    126,
    124,
    32,
    31,
    32,
    35,
    126,
    124,
    32,
    33,
    32,
    11,
    126,
    124,
    32,
    53,
    66,
    26,
    135,
    124,
    34,
    31,
    32,
    31,
    66,
    128,
    128,
    128,
    8,
    124,
    34,
    31,
    66,
    128,
    128,
    128,
    240,
    15,
    131,
    125,
    62,
    2,
    12,
    32,
    0,
    32,
    4,
    32,
    34,
    126,
    32,
    7,
    32,
    32,
    126,
    124,
    32,
    10,
    32,
    8,
    126,
    124,
    32,
    13,
    32,
    6,
    126,
    124,
    32,
    17,
    32,
    11,
    126,
    124,
    32,
    20,
    32,
    15,
    126,
    124,
    32,
    24,
    32,
    18,
    126,
    124,
    32,
    48,
    32,
    22,
    126,
    124,
    32,
    25,
    32,
    30,
    172,
    34,
    27,
    126,
    124,
    32,
    33,
    32,
    29,
    126,
    124,
    32,
    47,
    66,
    25,
    135,
    124,
    34,
    33,
    32,
    33,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    33,
    66,
    128,
    128,
    128,
    224,
    15,
    131,
    125,
    62,
    2,
    32,
    32,
    0,
    32,
    44,
    32,
    45,
    66,
    128,
    128,
    128,
    240,
    15,
    131,
    125,
    32,
    31,
    66,
    25,
    135,
    32,
    42,
    32,
    43,
    66,
    128,
    128,
    128,
    96,
    131,
    125,
    124,
    34,
    31,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    38,
    66,
    26,
    136,
    124,
    62,
    2,
    20,
    32,
    0,
    32,
    31,
    32,
    38,
    66,
    128,
    128,
    128,
    224,
    15,
    131,
    125,
    62,
    2,
    16,
    32,
    0,
    32,
    4,
    32,
    32,
    126,
    32,
    7,
    32,
    39,
    126,
    124,
    32,
    10,
    32,
    40,
    126,
    124,
    32,
    13,
    32,
    8,
    126,
    124,
    32,
    17,
    32,
    35,
    126,
    124,
    32,
    20,
    32,
    11,
    126,
    124,
    32,
    24,
    32,
    36,
    126,
    124,
    32,
    48,
    32,
    18,
    126,
    124,
    32,
    27,
    32,
    37,
    126,
    124,
    32,
    25,
    32,
    2,
    172,
    126,
    124,
    32,
    33,
    66,
    26,
    135,
    124,
    34,
    7,
    32,
    7,
    66,
    128,
    128,
    128,
    8,
    124,
    34,
    7,
    66,
    128,
    128,
    128,
    240,
    15,
    131,
    125,
    62,
    2,
    36,
    32,
    0,
    32,
    51,
    32,
    52,
    66,
    128,
    128,
    128,
    240,
    15,
    131,
    125,
    32,
    7,
    66,
    25,
    135,
    66,
    19,
    126,
    32,
    49,
    32,
    50,
    66,
    128,
    128,
    128,
    96,
    131,
    125,
    124,
    34,
    7,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    8,
    66,
    26,
    136,
    124,
    62,
    2,
    4,
    32,
    0,
    32,
    7,
    32,
    8,
    66,
    128,
    128,
    128,
    224,
    15,
    131,
    125,
    62,
    2,
    0,
    11,
    227,
    6,
    14,
    1,
    127,
    2,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    2,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    18,
    126,
    32,
    0,
    32,
    1,
    40,
    2,
    12,
    34,
    2,
    65,
    1,
    116,
    172,
    34,
    3,
    32,
    2,
    172,
    34,
    4,
    126,
    32,
    1,
    40,
    2,
    16,
    34,
    5,
    172,
    34,
    6,
    32,
    1,
    40,
    2,
    8,
    34,
    7,
    65,
    1,
    116,
    172,
    34,
    8,
    126,
    124,
    32,
    1,
    40,
    2,
    20,
    34,
    2,
    65,
    1,
    116,
    172,
    34,
    9,
    32,
    1,
    40,
    2,
    4,
    34,
    10,
    65,
    1,
    116,
    172,
    34,
    11,
    126,
    124,
    32,
    1,
    40,
    2,
    24,
    34,
    12,
    172,
    34,
    13,
    32,
    1,
    40,
    2,
    0,
    34,
    14,
    65,
    1,
    116,
    172,
    34,
    15,
    126,
    124,
    32,
    1,
    40,
    2,
    32,
    34,
    16,
    65,
    19,
    108,
    172,
    34,
    17,
    32,
    16,
    172,
    34,
    18,
    126,
    124,
    32,
    1,
    40,
    2,
    36,
    34,
    16,
    65,
    38,
    108,
    172,
    34,
    19,
    32,
    1,
    40,
    2,
    28,
    34,
    1,
    65,
    1,
    116,
    172,
    34,
    20,
    126,
    124,
    32,
    6,
    32,
    11,
    126,
    32,
    8,
    32,
    4,
    126,
    124,
    32,
    2,
    172,
    34,
    21,
    32,
    15,
    126,
    124,
    32,
    17,
    32,
    20,
    126,
    124,
    32,
    19,
    32,
    13,
    126,
    124,
    32,
    3,
    32,
    11,
    126,
    32,
    7,
    172,
    34,
    22,
    32,
    22,
    126,
    124,
    32,
    6,
    32,
    15,
    126,
    124,
    32,
    1,
    65,
    38,
    108,
    172,
    34,
    23,
    32,
    1,
    172,
    34,
    24,
    126,
    124,
    32,
    17,
    32,
    12,
    65,
    1,
    116,
    172,
    126,
    124,
    32,
    19,
    32,
    9,
    126,
    124,
    34,
    25,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    26,
    66,
    26,
    135,
    124,
    34,
    27,
    66,
    128,
    128,
    128,
    8,
    124,
    34,
    28,
    66,
    25,
    135,
    124,
    34,
    29,
    32,
    29,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    30,
    66,
    128,
    128,
    128,
    224,
    15,
    131,
    125,
    62,
    2,
    24,
    32,
    0,
    32,
    22,
    32,
    15,
    126,
    32,
    11,
    32,
    10,
    172,
    34,
    31,
    126,
    124,
    32,
    12,
    65,
    19,
    108,
    172,
    34,
    29,
    32,
    13,
    126,
    124,
    32,
    23,
    32,
    9,
    126,
    124,
    32,
    17,
    32,
    5,
    65,
    1,
    116,
    172,
    34,
    32,
    126,
    124,
    32,
    19,
    32,
    3,
    126,
    124,
    32,
    29,
    32,
    9,
    126,
    32,
    15,
    32,
    31,
    126,
    124,
    32,
    23,
    32,
    6,
    126,
    124,
    32,
    17,
    32,
    3,
    126,
    124,
    32,
    19,
    32,
    22,
    126,
    124,
    32,
    2,
    65,
    38,
    108,
    172,
    32,
    21,
    126,
    32,
    14,
    172,
    34,
    31,
    32,
    31,
    126,
    124,
    32,
    29,
    32,
    32,
    126,
    124,
    32,
    23,
    32,
    3,
    126,
    124,
    32,
    17,
    32,
    8,
    126,
    124,
    32,
    19,
    32,
    11,
    126,
    124,
    34,
    29,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    31,
    66,
    26,
    135,
    124,
    34,
    32,
    66,
    128,
    128,
    128,
    8,
    124,
    34,
    33,
    66,
    25,
    135,
    124,
    34,
    34,
    32,
    34,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    34,
    66,
    128,
    128,
    128,
    224,
    15,
    131,
    125,
    62,
    2,
    8,
    32,
    0,
    32,
    21,
    32,
    8,
    126,
    32,
    3,
    32,
    6,
    126,
    124,
    32,
    13,
    32,
    11,
    126,
    124,
    32,
    24,
    32,
    15,
    126,
    124,
    32,
    19,
    32,
    18,
    126,
    124,
    32,
    30,
    66,
    26,
    135,
    124,
    34,
    21,
    32,
    21,
    66,
    128,
    128,
    128,
    8,
    124,
    34,
    21,
    66,
    128,
    128,
    128,
    240,
    15,
    131,
    125,
    62,
    2,
    28,
    32,
    0,
    32,
    4,
    32,
    15,
    126,
    32,
    11,
    32,
    22,
    126,
    124,
    32,
    23,
    32,
    13,
    126,
    124,
    32,
    17,
    32,
    9,
    126,
    124,
    32,
    19,
    32,
    6,
    126,
    124,
    32,
    34,
    66,
    26,
    135,
    124,
    34,
    17,
    32,
    17,
    66,
    128,
    128,
    128,
    8,
    124,
    34,
    17,
    66,
    128,
    128,
    128,
    240,
    15,
    131,
    125,
    62,
    2,
    12,
    32,
    0,
    32,
    13,
    32,
    8,
    126,
    32,
    6,
    32,
    6,
    126,
    124,
    32,
    9,
    32,
    3,
    126,
    124,
    32,
    20,
    32,
    11,
    126,
    124,
    32,
    18,
    32,
    15,
    126,
    124,
    32,
    19,
    32,
    16,
    172,
    34,
    22,
    126,
    124,
    32,
    21,
    66,
    25,
    135,
    124,
    34,
    19,
    32,
    19,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    19,
    66,
    128,
    128,
    128,
    224,
    15,
    131,
    125,
    62,
    2,
    32,
    32,
    0,
    32,
    27,
    32,
    28,
    66,
    128,
    128,
    128,
    240,
    15,
    131,
    125,
    32,
    17,
    66,
    25,
    135,
    32,
    25,
    32,
    26,
    66,
    128,
    128,
    128,
    96,
    131,
    125,
    124,
    34,
    17,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    23,
    66,
    26,
    136,
    124,
    62,
    2,
    20,
    32,
    0,
    32,
    17,
    32,
    23,
    66,
    128,
    128,
    128,
    224,
    15,
    131,
    125,
    62,
    2,
    16,
    32,
    0,
    32,
    9,
    32,
    6,
    126,
    32,
    13,
    32,
    3,
    126,
    124,
    32,
    24,
    32,
    8,
    126,
    124,
    32,
    18,
    32,
    11,
    126,
    124,
    32,
    22,
    32,
    15,
    126,
    124,
    32,
    19,
    66,
    26,
    135,
    124,
    34,
    6,
    32,
    6,
    66,
    128,
    128,
    128,
    8,
    124,
    34,
    6,
    66,
    128,
    128,
    128,
    240,
    15,
    131,
    125,
    62,
    2,
    36,
    32,
    0,
    32,
    32,
    32,
    33,
    66,
    128,
    128,
    128,
    240,
    15,
    131,
    125,
    32,
    6,
    66,
    25,
    135,
    66,
    19,
    126,
    32,
    29,
    32,
    31,
    66,
    128,
    128,
    128,
    96,
    131,
    125,
    124,
    34,
    6,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    11,
    66,
    26,
    136,
    124,
    62,
    2,
    4,
    32,
    0,
    32,
    6,
    32,
    11,
    66,
    128,
    128,
    128,
    224,
    15,
    131,
    125,
    62,
    2,
    0,
    11,
    222,
    3,
    1,
    15,
    126,
    32,
    1,
    52,
    2,
    36,
    33,
    3,
    32,
    1,
    52,
    2,
    32,
    33,
    4,
    32,
    1,
    52,
    2,
    12,
    33,
    5,
    32,
    1,
    52,
    2,
    28,
    33,
    6,
    32,
    1,
    52,
    2,
    8,
    33,
    7,
    32,
    1,
    52,
    2,
    0,
    33,
    8,
    32,
    1,
    52,
    2,
    4,
    33,
    9,
    32,
    0,
    32,
    1,
    52,
    2,
    16,
    32,
    2,
    172,
    34,
    10,
    126,
    34,
    11,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    12,
    66,
    26,
    135,
    32,
    1,
    52,
    2,
    20,
    32,
    10,
    126,
    124,
    34,
    13,
    66,
    128,
    128,
    128,
    8,
    124,
    34,
    14,
    66,
    25,
    135,
    32,
    1,
    52,
    2,
    24,
    32,
    10,
    126,
    124,
    34,
    15,
    32,
    15,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    15,
    66,
    128,
    128,
    128,
    224,
    15,
    131,
    125,
    62,
    2,
    24,
    32,
    0,
    32,
    8,
    32,
    10,
    126,
    34,
    8,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    16,
    66,
    26,
    135,
    32,
    9,
    32,
    10,
    126,
    124,
    34,
    9,
    66,
    128,
    128,
    128,
    8,
    124,
    34,
    17,
    66,
    25,
    135,
    32,
    7,
    32,
    10,
    126,
    124,
    34,
    7,
    32,
    7,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    7,
    66,
    128,
    128,
    128,
    224,
    15,
    131,
    125,
    62,
    2,
    8,
    32,
    0,
    32,
    15,
    66,
    26,
    135,
    32,
    6,
    32,
    10,
    126,
    124,
    34,
    6,
    32,
    6,
    66,
    128,
    128,
    128,
    8,
    124,
    34,
    6,
    66,
    128,
    128,
    128,
    240,
    15,
    131,
    125,
    62,
    2,
    28,
    32,
    0,
    32,
    7,
    66,
    26,
    135,
    32,
    5,
    32,
    10,
    126,
    124,
    34,
    5,
    32,
    5,
    66,
    128,
    128,
    128,
    8,
    124,
    34,
    5,
    66,
    128,
    128,
    128,
    240,
    15,
    131,
    125,
    62,
    2,
    12,
    32,
    0,
    32,
    6,
    66,
    25,
    135,
    32,
    4,
    32,
    10,
    126,
    124,
    34,
    4,
    32,
    4,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    4,
    66,
    128,
    128,
    128,
    224,
    15,
    131,
    125,
    62,
    2,
    32,
    32,
    0,
    32,
    13,
    32,
    14,
    66,
    128,
    128,
    128,
    240,
    15,
    131,
    125,
    32,
    5,
    66,
    25,
    135,
    32,
    11,
    32,
    12,
    66,
    128,
    128,
    128,
    96,
    131,
    125,
    124,
    34,
    5,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    6,
    66,
    26,
    136,
    124,
    62,
    2,
    20,
    32,
    0,
    32,
    5,
    32,
    6,
    66,
    128,
    128,
    128,
    224,
    15,
    131,
    125,
    62,
    2,
    16,
    32,
    0,
    32,
    4,
    66,
    26,
    135,
    32,
    3,
    32,
    10,
    126,
    124,
    34,
    10,
    32,
    10,
    66,
    128,
    128,
    128,
    8,
    124,
    34,
    10,
    66,
    128,
    128,
    128,
    240,
    15,
    131,
    125,
    62,
    2,
    36,
    32,
    0,
    32,
    9,
    32,
    17,
    66,
    128,
    128,
    128,
    240,
    15,
    131,
    125,
    32,
    10,
    66,
    25,
    135,
    66,
    19,
    126,
    32,
    8,
    32,
    16,
    66,
    128,
    128,
    128,
    96,
    131,
    125,
    124,
    34,
    10,
    66,
    128,
    128,
    128,
    16,
    124,
    34,
    3,
    66,
    26,
    136,
    124,
    62,
    2,
    4,
    32,
    0,
    32,
    10,
    32,
    3,
    66,
    128,
    128,
    128,
    224,
    15,
    131,
    125,
    62,
    2,
    0,
    11,
    125,
    1,
    1,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    48,
    107,
    34,
    2,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    2,
    32,
    1,
    16,
    200,
    128,
    128,
    128,
    0,
    32,
    2,
    32,
    2,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    2,
    32,
    2,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    2,
    32,
    2,
    32,
    1,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    2,
    32,
    2,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    2,
    32,
    1,
    16,
    169,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    48,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    128,
    5,
    1,
    7,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    48,
    107,
    34,
    2,
    32,
    1,
    65,
    40,
    252,
    10,
    0,
    0,
    32,
    2,
    40,
    2,
    36,
    65,
    19,
    108,
    65,
    128,
    128,
    128,
    8,
    106,
    65,
    25,
    117,
    33,
    3,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    32,
    1,
    106,
    34,
    4,
    40,
    2,
    0,
    32,
    3,
    106,
    65,
    26,
    117,
    32,
    4,
    65,
    4,
    106,
    40,
    2,
    0,
    106,
    65,
    25,
    117,
    33,
    3,
    32,
    1,
    65,
    8,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    3,
    65,
    19,
    108,
    33,
    4,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    32,
    1,
    106,
    34,
    3,
    32,
    3,
    40,
    2,
    0,
    32,
    4,
    106,
    34,
    4,
    65,
    255,
    255,
    255,
    31,
    113,
    54,
    2,
    0,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    32,
    3,
    40,
    2,
    0,
    32,
    4,
    65,
    26,
    117,
    106,
    34,
    3,
    65,
    255,
    255,
    255,
    15,
    113,
    54,
    2,
    0,
    32,
    3,
    65,
    25,
    117,
    33,
    4,
    32,
    1,
    65,
    8,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    0,
    32,
    2,
    40,
    2,
    0,
    34,
    1,
    58,
    0,
    0,
    32,
    0,
    32,
    1,
    65,
    16,
    118,
    58,
    0,
    2,
    32,
    0,
    32,
    1,
    65,
    8,
    118,
    58,
    0,
    1,
    32,
    0,
    32,
    2,
    40,
    2,
    4,
    34,
    3,
    65,
    14,
    118,
    58,
    0,
    5,
    32,
    0,
    32,
    3,
    65,
    6,
    118,
    34,
    5,
    58,
    0,
    4,
    32,
    0,
    32,
    2,
    40,
    2,
    12,
    34,
    4,
    65,
    11,
    118,
    58,
    0,
    11,
    32,
    0,
    32,
    2,
    40,
    2,
    8,
    34,
    6,
    65,
    13,
    118,
    34,
    7,
    58,
    0,
    8,
    32,
    0,
    32,
    2,
    40,
    2,
    16,
    34,
    8,
    65,
    18,
    118,
    58,
    0,
    15,
    32,
    0,
    32,
    8,
    65,
    10,
    118,
    58,
    0,
    14,
    32,
    0,
    32,
    8,
    65,
    6,
    116,
    32,
    4,
    65,
    19,
    118,
    114,
    34,
    8,
    58,
    0,
    12,
    32,
    0,
    32,
    1,
    32,
    3,
    65,
    26,
    116,
    114,
    65,
    24,
    118,
    58,
    0,
    3,
    32,
    0,
    32,
    6,
    65,
    19,
    116,
    32,
    5,
    114,
    34,
    1,
    65,
    24,
    118,
    58,
    0,
    7,
    32,
    0,
    32,
    1,
    65,
    16,
    118,
    58,
    0,
    6,
    32,
    0,
    32,
    4,
    65,
    13,
    116,
    32,
    7,
    114,
    34,
    1,
    65,
    16,
    118,
    58,
    0,
    10,
    32,
    0,
    32,
    1,
    65,
    8,
    118,
    58,
    0,
    9,
    32,
    0,
    32,
    8,
    65,
    8,
    118,
    58,
    0,
    13,
    32,
    0,
    32,
    2,
    40,
    2,
    20,
    34,
    1,
    58,
    0,
    16,
    32,
    0,
    32,
    1,
    65,
    8,
    118,
    58,
    0,
    17,
    32,
    0,
    32,
    1,
    65,
    16,
    118,
    58,
    0,
    18,
    32,
    0,
    32,
    2,
    40,
    2,
    24,
    34,
    3,
    65,
    7,
    118,
    34,
    5,
    58,
    0,
    20,
    32,
    0,
    32,
    3,
    65,
    15,
    118,
    58,
    0,
    21,
    32,
    0,
    32,
    2,
    40,
    2,
    28,
    34,
    6,
    65,
    13,
    118,
    34,
    7,
    58,
    0,
    24,
    32,
    0,
    32,
    2,
    40,
    2,
    32,
    34,
    4,
    65,
    12,
    118,
    58,
    0,
    27,
    32,
    0,
    32,
    2,
    40,
    2,
    36,
    34,
    8,
    65,
    18,
    118,
    58,
    0,
    31,
    32,
    0,
    32,
    8,
    65,
    10,
    118,
    58,
    0,
    30,
    32,
    0,
    32,
    8,
    65,
    6,
    116,
    32,
    4,
    65,
    20,
    118,
    114,
    34,
    8,
    58,
    0,
    28,
    32,
    0,
    32,
    1,
    32,
    3,
    65,
    25,
    116,
    114,
    65,
    24,
    118,
    58,
    0,
    19,
    32,
    0,
    32,
    6,
    65,
    19,
    116,
    32,
    5,
    114,
    34,
    1,
    65,
    24,
    118,
    58,
    0,
    23,
    32,
    0,
    32,
    1,
    65,
    16,
    118,
    58,
    0,
    22,
    32,
    0,
    32,
    4,
    65,
    12,
    116,
    32,
    7,
    114,
    34,
    1,
    65,
    16,
    118,
    58,
    0,
    26,
    32,
    0,
    32,
    1,
    65,
    8,
    118,
    58,
    0,
    25,
    32,
    0,
    32,
    8,
    65,
    8,
    118,
    58,
    0,
    29,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    11,
    18,
    0,
    32,
    0,
    32,
    1,
    65,
    224,
    137,
    128,
    128,
    0,
    16,
    166,
    128,
    128,
    128,
    0,
    11,
    179,
    1,
    1,
    1,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    224,
    1,
    107,
    34,
    3,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    3,
    65,
    160,
    1,
    106,
    32,
    1,
    65,
    32,
    32,
    2,
    40,
    2,
    0,
    17,
    128,
    128,
    128,
    128,
    0,
    0,
    32,
    3,
    32,
    3,
    45,
    0,
    160,
    1,
    65,
    248,
    1,
    113,
    58,
    0,
    160,
    1,
    32,
    3,
    32,
    3,
    45,
    0,
    191,
    1,
    65,
    63,
    113,
    65,
    192,
    0,
    114,
    58,
    0,
    191,
    1,
    32,
    3,
    32,
    3,
    65,
    160,
    1,
    106,
    16,
    176,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    3,
    16,
    177,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    0,
    3,
    64,
    32,
    3,
    65,
    160,
    1,
    106,
    32,
    0,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    0,
    65,
    1,
    106,
    34,
    0,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    0,
    3,
    64,
    32,
    3,
    32,
    0,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    0,
    65,
    1,
    106,
    34,
    0,
    65,
    160,
    1,
    71,
    13,
    0,
    11,
    32,
    3,
    65,
    224,
    1,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    140,
    4,
    1,
    2,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    160,
    3,
    107,
    34,
    2,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    128,
    3,
    106,
    32,
    1,
    65,
    208,
    140,
    128,
    128,
    0,
    65,
    240,
    140,
    128,
    128,
    0,
    16,
    178,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    1,
    54,
    2,
    168,
    1,
    32,
    2,
    65,
    168,
    1,
    106,
    65,
    4,
    114,
    65,
    0,
    65,
    36,
    252,
    11,
    0,
    32,
    2,
    65,
    1,
    54,
    2,
    208,
    1,
    32,
    2,
    65,
    168,
    1,
    106,
    65,
    44,
    106,
    65,
    0,
    65,
    204,
    0,
    252,
    11,
    0,
    32,
    0,
    65,
    0,
    65,
    40,
    252,
    11,
    0,
    32,
    0,
    65,
    1,
    54,
    2,
    40,
    32,
    0,
    65,
    44,
    106,
    65,
    0,
    65,
    36,
    252,
    11,
    0,
    32,
    0,
    65,
    1,
    54,
    2,
    80,
    32,
    0,
    65,
    212,
    0,
    106,
    65,
    0,
    65,
    204,
    0,
    252,
    11,
    0,
    32,
    0,
    32,
    2,
    65,
    168,
    1,
    106,
    32,
    2,
    65,
    208,
    2,
    106,
    32,
    2,
    65,
    160,
    2,
    106,
    65,
    144,
    141,
    128,
    128,
    0,
    32,
    2,
    65,
    128,
    3,
    106,
    65,
    31,
    16,
    179,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    2,
    65,
    168,
    1,
    106,
    32,
    2,
    65,
    208,
    2,
    106,
    32,
    2,
    65,
    160,
    2,
    106,
    65,
    208,
    148,
    128,
    128,
    0,
    32,
    2,
    65,
    128,
    3,
    106,
    65,
    159,
    1,
    16,
    179,
    128,
    128,
    128,
    0,
    65,
    30,
    33,
    3,
    3,
    64,
    32,
    0,
    32,
    0,
    32,
    2,
    65,
    8,
    106,
    16,
    180,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    2,
    65,
    168,
    1,
    106,
    32,
    2,
    65,
    208,
    2,
    106,
    32,
    2,
    65,
    160,
    2,
    106,
    65,
    144,
    141,
    128,
    128,
    0,
    32,
    2,
    65,
    128,
    3,
    106,
    32,
    3,
    34,
    1,
    16,
    179,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    2,
    65,
    168,
    1,
    106,
    32,
    2,
    65,
    208,
    2,
    106,
    32,
    2,
    65,
    160,
    2,
    106,
    65,
    208,
    148,
    128,
    128,
    0,
    32,
    2,
    65,
    128,
    3,
    106,
    32,
    1,
    65,
    128,
    1,
    106,
    16,
    179,
    128,
    128,
    128,
    0,
    32,
    1,
    65,
    127,
    106,
    33,
    3,
    32,
    1,
    13,
    0,
    11,
    65,
    0,
    33,
    0,
    3,
    64,
    32,
    2,
    65,
    208,
    2,
    106,
    32,
    0,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    0,
    65,
    1,
    106,
    34,
    0,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    0,
    3,
    64,
    32,
    2,
    65,
    8,
    106,
    32,
    0,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    0,
    65,
    1,
    106,
    34,
    0,
    65,
    160,
    1,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    0,
    3,
    64,
    32,
    2,
    65,
    160,
    2,
    106,
    32,
    0,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    0,
    65,
    1,
    106,
    34,
    0,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    0,
    3,
    64,
    32,
    2,
    65,
    168,
    1,
    106,
    32,
    0,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    0,
    65,
    1,
    106,
    34,
    0,
    65,
    248,
    0,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    0,
    3,
    64,
    32,
    2,
    65,
    128,
    3,
    106,
    32,
    0,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    0,
    65,
    1,
    106,
    34,
    0,
    65,
    32,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    160,
    3,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    219,
    1,
    1,
    1,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    144,
    1,
    107,
    34,
    2,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    1,
    65,
    208,
    0,
    106,
    16,
    172,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    48,
    106,
    32,
    1,
    32,
    2,
    65,
    224,
    0,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    2,
    32,
    1,
    65,
    40,
    106,
    32,
    2,
    65,
    224,
    0,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    2,
    16,
    173,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    2,
    65,
    48,
    106,
    16,
    181,
    128,
    128,
    128,
    0,
    65,
    7,
    116,
    32,
    0,
    45,
    0,
    31,
    115,
    58,
    0,
    31,
    65,
    0,
    33,
    0,
    3,
    64,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    0,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    0,
    65,
    1,
    106,
    34,
    0,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    0,
    3,
    64,
    32,
    2,
    65,
    48,
    106,
    32,
    0,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    0,
    65,
    1,
    106,
    34,
    0,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    0,
    3,
    64,
    32,
    2,
    32,
    0,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    0,
    65,
    1,
    106,
    34,
    0,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    144,
    1,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    182,
    2,
    1,
    2,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    128,
    1,
    107,
    34,
    4,
    36,
    128,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    5,
    3,
    64,
    32,
    4,
    65,
    224,
    0,
    106,
    32,
    5,
    106,
    32,
    1,
    32,
    5,
    106,
    40,
    0,
    0,
    54,
    2,
    0,
    32,
    5,
    65,
    4,
    106,
    34,
    5,
    65,
    32,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    5,
    3,
    64,
    32,
    4,
    65,
    192,
    0,
    106,
    32,
    5,
    106,
    32,
    2,
    32,
    5,
    106,
    40,
    0,
    0,
    54,
    2,
    0,
    32,
    5,
    65,
    4,
    106,
    34,
    5,
    65,
    32,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    5,
    3,
    64,
    32,
    4,
    32,
    5,
    106,
    32,
    3,
    32,
    5,
    106,
    40,
    0,
    0,
    54,
    2,
    0,
    32,
    5,
    65,
    4,
    106,
    34,
    5,
    65,
    32,
    71,
    13,
    0,
    11,
    32,
    4,
    65,
    56,
    106,
    66,
    0,
    55,
    3,
    0,
    32,
    4,
    65,
    48,
    106,
    66,
    0,
    55,
    3,
    0,
    32,
    4,
    65,
    40,
    106,
    66,
    0,
    55,
    3,
    0,
    32,
    4,
    66,
    0,
    55,
    3,
    32,
    32,
    4,
    32,
    4,
    65,
    224,
    0,
    106,
    32,
    4,
    65,
    192,
    0,
    106,
    16,
    188,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    4,
    16,
    186,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    5,
    3,
    64,
    32,
    4,
    32,
    5,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    5,
    65,
    1,
    106,
    34,
    5,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    5,
    3,
    64,
    32,
    4,
    65,
    224,
    0,
    106,
    32,
    5,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    5,
    65,
    1,
    106,
    34,
    5,
    65,
    32,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    5,
    3,
    64,
    32,
    4,
    65,
    192,
    0,
    106,
    32,
    5,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    5,
    65,
    1,
    106,
    34,
    5,
    65,
    32,
    71,
    13,
    0,
    11,
    32,
    4,
    65,
    128,
    1,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    222,
    4,
    1,
    4,
    127,
    65,
    0,
    33,
    7,
    2,
    64,
    2,
    64,
    2,
    64,
    2,
    64,
    2,
    64,
    2,
    64,
    2,
    64,
    32,
    6,
    65,
    0,
    72,
    13,
    0,
    32,
    5,
    32,
    6,
    65,
    3,
    118,
    106,
    45,
    0,
    0,
    32,
    6,
    65,
    7,
    113,
    118,
    65,
    1,
    113,
    33,
    7,
    12,
    1,
    11,
    32,
    6,
    65,
    96,
    73,
    13,
    1,
    11,
    32,
    5,
    32,
    6,
    65,
    32,
    106,
    65,
    3,
    118,
    106,
    45,
    0,
    0,
    32,
    6,
    65,
    7,
    113,
    118,
    65,
    1,
    116,
    65,
    2,
    113,
    32,
    7,
    114,
    33,
    7,
    12,
    1,
    11,
    65,
    0,
    33,
    7,
    32,
    6,
    65,
    64,
    73,
    13,
    1,
    11,
    32,
    7,
    32,
    5,
    32,
    6,
    65,
    192,
    0,
    106,
    65,
    3,
    118,
    106,
    45,
    0,
    0,
    32,
    6,
    65,
    7,
    113,
    118,
    65,
    2,
    116,
    65,
    4,
    113,
    114,
    33,
    7,
    12,
    1,
    11,
    65,
    0,
    33,
    7,
    65,
    0,
    33,
    8,
    32,
    6,
    65,
    160,
    127,
    73,
    13,
    1,
    11,
    32,
    5,
    32,
    6,
    65,
    224,
    0,
    106,
    65,
    3,
    118,
    106,
    45,
    0,
    0,
    32,
    6,
    65,
    7,
    113,
    118,
    65,
    1,
    113,
    33,
    8,
    11,
    32,
    8,
    65,
    127,
    106,
    65,
    7,
    113,
    32,
    7,
    115,
    33,
    9,
    65,
    0,
    33,
    10,
    3,
    64,
    65,
    0,
    32,
    9,
    32,
    10,
    115,
    65,
    127,
    106,
    65,
    8,
    118,
    65,
    1,
    113,
    107,
    33,
    5,
    65,
    0,
    33,
    6,
    3,
    64,
    32,
    1,
    32,
    6,
    106,
    34,
    7,
    32,
    4,
    32,
    6,
    106,
    40,
    2,
    0,
    32,
    7,
    40,
    2,
    0,
    34,
    7,
    115,
    32,
    5,
    113,
    32,
    7,
    115,
    54,
    2,
    0,
    32,
    6,
    65,
    4,
    106,
    34,
    6,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    40,
    33,
    6,
    3,
    64,
    32,
    1,
    32,
    6,
    106,
    34,
    7,
    32,
    4,
    32,
    6,
    106,
    40,
    2,
    0,
    32,
    7,
    40,
    2,
    0,
    34,
    7,
    115,
    32,
    5,
    113,
    32,
    7,
    115,
    54,
    2,
    0,
    32,
    6,
    65,
    4,
    106,
    34,
    6,
    65,
    208,
    0,
    71,
    13,
    0,
    11,
    65,
    208,
    0,
    33,
    6,
    3,
    64,
    32,
    1,
    32,
    6,
    106,
    34,
    7,
    32,
    4,
    32,
    6,
    106,
    40,
    2,
    0,
    32,
    7,
    40,
    2,
    0,
    34,
    7,
    115,
    32,
    5,
    113,
    32,
    7,
    115,
    54,
    2,
    0,
    32,
    6,
    65,
    4,
    106,
    34,
    6,
    65,
    248,
    0,
    71,
    13,
    0,
    11,
    32,
    4,
    65,
    248,
    0,
    106,
    33,
    4,
    32,
    10,
    65,
    1,
    106,
    34,
    10,
    65,
    8,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    6,
    3,
    64,
    32,
    2,
    32,
    6,
    106,
    65,
    0,
    32,
    1,
    32,
    6,
    106,
    65,
    208,
    0,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    6,
    65,
    4,
    106,
    34,
    6,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    8,
    65,
    127,
    106,
    33,
    5,
    65,
    0,
    33,
    6,
    3,
    64,
    32,
    1,
    32,
    6,
    106,
    65,
    208,
    0,
    106,
    34,
    7,
    32,
    2,
    32,
    6,
    106,
    34,
    4,
    40,
    2,
    0,
    32,
    7,
    40,
    2,
    0,
    34,
    7,
    115,
    32,
    5,
    113,
    34,
    10,
    32,
    7,
    115,
    54,
    2,
    0,
    32,
    4,
    32,
    4,
    40,
    2,
    0,
    32,
    10,
    115,
    54,
    2,
    0,
    32,
    6,
    65,
    4,
    106,
    34,
    6,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    6,
    3,
    64,
    32,
    1,
    32,
    6,
    106,
    34,
    4,
    65,
    40,
    106,
    34,
    7,
    32,
    7,
    40,
    2,
    0,
    34,
    7,
    32,
    4,
    40,
    2,
    0,
    34,
    10,
    115,
    32,
    5,
    113,
    34,
    9,
    32,
    7,
    115,
    54,
    2,
    0,
    32,
    4,
    32,
    9,
    32,
    10,
    115,
    54,
    2,
    0,
    32,
    6,
    65,
    4,
    106,
    34,
    6,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    0,
    32,
    0,
    32,
    1,
    32,
    2,
    32,
    3,
    16,
    196,
    128,
    128,
    128,
    0,
    11,
    135,
    3,
    1,
    6,
    127,
    32,
    2,
    32,
    1,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    40,
    106,
    34,
    3,
    32,
    1,
    65,
    40,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    208,
    0,
    106,
    34,
    4,
    32,
    1,
    65,
    208,
    0,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    4,
    32,
    4,
    65,
    2,
    16,
    171,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    248,
    0,
    106,
    33,
    5,
    65,
    0,
    33,
    6,
    3,
    64,
    32,
    5,
    32,
    6,
    106,
    32,
    1,
    32,
    6,
    106,
    34,
    7,
    65,
    40,
    106,
    40,
    2,
    0,
    32,
    7,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    6,
    65,
    4,
    106,
    34,
    6,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    0,
    65,
    248,
    0,
    106,
    34,
    8,
    32,
    2,
    65,
    248,
    0,
    106,
    34,
    5,
    16,
    170,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    6,
    3,
    64,
    32,
    2,
    32,
    6,
    106,
    34,
    7,
    65,
    248,
    0,
    106,
    32,
    7,
    40,
    2,
    0,
    32,
    7,
    65,
    40,
    106,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    6,
    65,
    4,
    106,
    34,
    6,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    6,
    3,
    64,
    32,
    2,
    32,
    6,
    106,
    34,
    7,
    65,
    40,
    106,
    34,
    1,
    32,
    1,
    40,
    2,
    0,
    32,
    7,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    6,
    65,
    4,
    106,
    34,
    6,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    0,
    65,
    248,
    0,
    106,
    33,
    1,
    65,
    0,
    33,
    6,
    3,
    64,
    32,
    2,
    32,
    6,
    106,
    34,
    7,
    32,
    1,
    32,
    6,
    106,
    40,
    2,
    0,
    32,
    7,
    65,
    248,
    0,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    6,
    65,
    4,
    106,
    34,
    6,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    6,
    3,
    64,
    32,
    2,
    32,
    6,
    106,
    34,
    7,
    65,
    208,
    0,
    106,
    34,
    1,
    32,
    1,
    40,
    2,
    0,
    32,
    7,
    65,
    40,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    6,
    65,
    4,
    106,
    34,
    6,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    0,
    32,
    2,
    32,
    4,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    0,
    65,
    40,
    106,
    32,
    5,
    32,
    3,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    0,
    65,
    208,
    0,
    106,
    32,
    3,
    32,
    4,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    8,
    32,
    2,
    32,
    5,
    16,
    169,
    128,
    128,
    128,
    0,
    11,
    83,
    1,
    2,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    32,
    107,
    34,
    1,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    1,
    32,
    0,
    16,
    173,
    128,
    128,
    128,
    0,
    32,
    1,
    45,
    0,
    0,
    33,
    2,
    65,
    0,
    33,
    0,
    3,
    64,
    32,
    1,
    32,
    0,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    0,
    65,
    1,
    106,
    34,
    0,
    65,
    32,
    71,
    13,
    0,
    11,
    32,
    1,
    65,
    32,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    1,
    113,
    11,
    18,
    0,
    32,
    0,
    32,
    1,
    65,
    192,
    137,
    128,
    128,
    0,
    16,
    175,
    128,
    128,
    128,
    0,
    11,
    182,
    1,
    0,
    32,
    0,
    32,
    3,
    54,
    2,
    0,
    32,
    0,
    65,
    4,
    106,
    32,
    1,
    65,
    32,
    32,
    3,
    40,
    2,
    0,
    17,
    128,
    128,
    128,
    128,
    0,
    0,
    32,
    0,
    32,
    0,
    45,
    0,
    4,
    65,
    248,
    1,
    113,
    58,
    0,
    4,
    32,
    0,
    65,
    35,
    106,
    34,
    3,
    32,
    3,
    45,
    0,
    0,
    65,
    63,
    113,
    65,
    192,
    0,
    114,
    58,
    0,
    0,
    2,
    64,
    2,
    64,
    32,
    2,
    69,
    13,
    0,
    32,
    0,
    65,
    228,
    0,
    106,
    33,
    1,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    1,
    32,
    3,
    106,
    32,
    2,
    32,
    3,
    106,
    45,
    0,
    0,
    58,
    0,
    0,
    32,
    3,
    65,
    1,
    106,
    34,
    3,
    65,
    32,
    71,
    13,
    0,
    12,
    2,
    11,
    11,
    32,
    0,
    65,
    228,
    0,
    106,
    32,
    1,
    32,
    0,
    40,
    2,
    0,
    16,
    175,
    128,
    128,
    128,
    0,
    11,
    32,
    0,
    32,
    0,
    40,
    2,
    0,
    40,
    2,
    4,
    17,
    129,
    128,
    128,
    128,
    0,
    0,
    32,
    0,
    32,
    0,
    65,
    36,
    106,
    65,
    32,
    32,
    0,
    40,
    2,
    0,
    40,
    2,
    8,
    17,
    128,
    128,
    128,
    128,
    0,
    0,
    11,
    185,
    1,
    1,
    3,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    160,
    1,
    107,
    34,
    1,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    0,
    65,
    36,
    106,
    34,
    2,
    32,
    0,
    40,
    2,
    0,
    40,
    2,
    12,
    17,
    130,
    128,
    128,
    128,
    0,
    0,
    32,
    2,
    16,
    185,
    128,
    128,
    128,
    0,
    32,
    1,
    32,
    2,
    16,
    176,
    128,
    128,
    128,
    0,
    32,
    0,
    65,
    196,
    0,
    106,
    34,
    3,
    32,
    1,
    16,
    177,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    1,
    32,
    2,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    2,
    65,
    1,
    106,
    34,
    2,
    65,
    160,
    1,
    71,
    13,
    0,
    11,
    32,
    0,
    32,
    0,
    40,
    2,
    0,
    40,
    2,
    4,
    17,
    129,
    128,
    128,
    128,
    0,
    0,
    32,
    0,
    32,
    3,
    65,
    32,
    32,
    0,
    40,
    2,
    0,
    40,
    2,
    8,
    17,
    128,
    128,
    128,
    128,
    0,
    0,
    32,
    0,
    32,
    0,
    65,
    228,
    0,
    106,
    65,
    32,
    32,
    0,
    40,
    2,
    0,
    40,
    2,
    8,
    17,
    128,
    128,
    128,
    128,
    0,
    0,
    32,
    1,
    65,
    160,
    1,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    110,
    1,
    2,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    192,
    0,
    107,
    34,
    1,
    36,
    128,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    1,
    32,
    2,
    106,
    32,
    0,
    32,
    2,
    106,
    40,
    0,
    0,
    54,
    2,
    0,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    32,
    0,
    32,
    1,
    16,
    186,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    1,
    32,
    2,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    2,
    65,
    1,
    106,
    34,
    2,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    32,
    1,
    65,
    192,
    0,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    217,
    3,
    3,
    4,
    127,
    2,
    126,
    3,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    240,
    0,
    107,
    34,
    2,
    36,
    128,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    3,
    32,
    2,
    65,
    0,
    65,
    228,
    0,
    252,
    11,
    0,
    32,
    2,
    33,
    4,
    3,
    64,
    32,
    3,
    65,
    2,
    116,
    34,
    5,
    65,
    176,
    165,
    128,
    128,
    0,
    106,
    53,
    2,
    0,
    33,
    6,
    66,
    0,
    33,
    7,
    65,
    0,
    33,
    8,
    3,
    64,
    32,
    4,
    32,
    8,
    106,
    34,
    9,
    32,
    7,
    32,
    9,
    53,
    2,
    0,
    124,
    32,
    1,
    32,
    8,
    106,
    53,
    2,
    0,
    32,
    6,
    126,
    124,
    34,
    7,
    62,
    2,
    0,
    32,
    7,
    66,
    32,
    136,
    33,
    7,
    32,
    8,
    65,
    4,
    106,
    34,
    8,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    32,
    5,
    32,
    2,
    106,
    65,
    192,
    0,
    106,
    32,
    7,
    62,
    2,
    0,
    32,
    4,
    65,
    4,
    106,
    33,
    4,
    32,
    3,
    65,
    1,
    106,
    34,
    3,
    65,
    9,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    24,
    106,
    66,
    0,
    55,
    3,
    0,
    32,
    2,
    65,
    16,
    106,
    66,
    0,
    55,
    3,
    0,
    32,
    2,
    66,
    0,
    55,
    3,
    8,
    32,
    2,
    66,
    0,
    55,
    3,
    0,
    65,
    0,
    33,
    10,
    65,
    32,
    33,
    4,
    32,
    2,
    33,
    3,
    3,
    64,
    32,
    10,
    65,
    2,
    116,
    32,
    2,
    106,
    65,
    192,
    0,
    106,
    33,
    5,
    65,
    0,
    33,
    8,
    66,
    0,
    33,
    7,
    3,
    64,
    32,
    3,
    32,
    8,
    106,
    34,
    9,
    32,
    7,
    32,
    9,
    53,
    2,
    0,
    124,
    32,
    8,
    65,
    192,
    156,
    128,
    128,
    0,
    106,
    53,
    2,
    0,
    32,
    5,
    53,
    2,
    0,
    126,
    124,
    34,
    7,
    62,
    2,
    0,
    32,
    7,
    66,
    32,
    136,
    33,
    7,
    32,
    4,
    32,
    8,
    65,
    4,
    106,
    34,
    8,
    71,
    13,
    0,
    11,
    32,
    3,
    65,
    4,
    106,
    33,
    3,
    32,
    4,
    65,
    124,
    106,
    33,
    4,
    32,
    10,
    65,
    1,
    106,
    34,
    10,
    65,
    8,
    71,
    13,
    0,
    11,
    66,
    1,
    33,
    7,
    65,
    0,
    33,
    8,
    3,
    64,
    32,
    2,
    32,
    8,
    106,
    34,
    9,
    32,
    7,
    32,
    1,
    32,
    8,
    106,
    53,
    2,
    0,
    124,
    32,
    9,
    53,
    2,
    0,
    66,
    255,
    255,
    255,
    255,
    15,
    133,
    124,
    34,
    7,
    62,
    2,
    0,
    32,
    7,
    66,
    32,
    136,
    33,
    7,
    32,
    8,
    65,
    4,
    106,
    34,
    8,
    65,
    32,
    71,
    13,
    0,
    11,
    32,
    2,
    32,
    2,
    16,
    211,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    8,
    3,
    64,
    32,
    0,
    32,
    8,
    106,
    32,
    2,
    32,
    8,
    106,
    40,
    2,
    0,
    54,
    0,
    0,
    32,
    8,
    65,
    4,
    106,
    34,
    8,
    65,
    32,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    8,
    3,
    64,
    32,
    2,
    32,
    8,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    8,
    65,
    1,
    106,
    34,
    8,
    65,
    228,
    0,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    240,
    0,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    199,
    1,
    1,
    3,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    192,
    0,
    107,
    34,
    2,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    2,
    32,
    0,
    40,
    2,
    0,
    40,
    2,
    12,
    17,
    130,
    128,
    128,
    128,
    0,
    0,
    32,
    0,
    65,
    196,
    0,
    106,
    33,
    3,
    32,
    2,
    16,
    185,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    4,
    3,
    64,
    32,
    1,
    32,
    4,
    106,
    32,
    3,
    32,
    4,
    106,
    45,
    0,
    0,
    58,
    0,
    0,
    32,
    4,
    65,
    1,
    106,
    34,
    4,
    65,
    32,
    71,
    13,
    0,
    11,
    32,
    1,
    65,
    32,
    106,
    32,
    2,
    32,
    0,
    65,
    4,
    106,
    32,
    0,
    65,
    36,
    106,
    16,
    178,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    4,
    3,
    64,
    32,
    2,
    32,
    4,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    4,
    65,
    1,
    106,
    34,
    4,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    2,
    64,
    32,
    0,
    40,
    2,
    0,
    40,
    2,
    16,
    34,
    4,
    69,
    13,
    0,
    3,
    64,
    32,
    0,
    65,
    0,
    58,
    0,
    0,
    32,
    0,
    65,
    1,
    106,
    33,
    0,
    32,
    4,
    65,
    127,
    106,
    34,
    4,
    13,
    0,
    11,
    11,
    32,
    2,
    65,
    192,
    0,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    128,
    1,
    3,
    4,
    127,
    1,
    126,
    2,
    127,
    65,
    0,
    33,
    3,
    32,
    0,
    33,
    4,
    3,
    64,
    32,
    1,
    32,
    3,
    65,
    2,
    116,
    34,
    5,
    106,
    33,
    6,
    66,
    0,
    33,
    7,
    65,
    0,
    33,
    8,
    3,
    64,
    32,
    4,
    32,
    8,
    106,
    34,
    9,
    32,
    7,
    32,
    9,
    53,
    2,
    0,
    124,
    32,
    2,
    32,
    8,
    106,
    53,
    2,
    0,
    32,
    6,
    53,
    2,
    0,
    126,
    124,
    34,
    7,
    62,
    2,
    0,
    32,
    7,
    66,
    32,
    136,
    33,
    7,
    32,
    8,
    65,
    4,
    106,
    34,
    8,
    65,
    32,
    71,
    13,
    0,
    11,
    32,
    5,
    32,
    0,
    106,
    65,
    32,
    106,
    32,
    7,
    62,
    2,
    0,
    32,
    4,
    65,
    4,
    106,
    33,
    4,
    32,
    3,
    65,
    1,
    106,
    34,
    3,
    65,
    8,
    71,
    13,
    0,
    11,
    11,
    112,
    1,
    1,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    224,
    2,
    107,
    34,
    5,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    5,
    32,
    1,
    32,
    2,
    65,
    192,
    137,
    128,
    128,
    0,
    16,
    183,
    128,
    128,
    128,
    0,
    32,
    5,
    32,
    3,
    32,
    4,
    32,
    5,
    40,
    2,
    0,
    40,
    2,
    8,
    17,
    128,
    128,
    128,
    128,
    0,
    0,
    32,
    5,
    16,
    184,
    128,
    128,
    128,
    0,
    32,
    5,
    32,
    3,
    32,
    4,
    32,
    5,
    40,
    2,
    0,
    40,
    2,
    8,
    17,
    128,
    128,
    128,
    128,
    0,
    0,
    32,
    5,
    32,
    0,
    16,
    187,
    128,
    128,
    128,
    0,
    32,
    5,
    65,
    224,
    2,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    153,
    1,
    1,
    2,
    127,
    32,
    0,
    32,
    3,
    54,
    2,
    0,
    32,
    0,
    65,
    4,
    106,
    33,
    4,
    65,
    0,
    33,
    5,
    3,
    64,
    32,
    4,
    32,
    5,
    106,
    32,
    1,
    32,
    5,
    106,
    45,
    0,
    0,
    58,
    0,
    0,
    32,
    5,
    65,
    1,
    106,
    34,
    5,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    32,
    0,
    65,
    228,
    0,
    106,
    33,
    4,
    65,
    0,
    33,
    5,
    3,
    64,
    32,
    4,
    32,
    5,
    106,
    32,
    2,
    32,
    5,
    106,
    45,
    0,
    0,
    58,
    0,
    0,
    32,
    5,
    65,
    1,
    106,
    34,
    5,
    65,
    32,
    71,
    13,
    0,
    11,
    32,
    0,
    32,
    3,
    40,
    2,
    4,
    17,
    129,
    128,
    128,
    128,
    0,
    0,
    32,
    0,
    32,
    1,
    65,
    32,
    32,
    0,
    40,
    2,
    0,
    40,
    2,
    8,
    17,
    128,
    128,
    128,
    128,
    0,
    0,
    32,
    0,
    32,
    2,
    65,
    32,
    32,
    0,
    40,
    2,
    0,
    40,
    2,
    8,
    17,
    128,
    128,
    128,
    128,
    0,
    0,
    11,
    244,
    14,
    3,
    10,
    127,
    2,
    126,
    4,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    192,
    7,
    107,
    34,
    1,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    1,
    32,
    0,
    40,
    2,
    0,
    40,
    2,
    12,
    17,
    130,
    128,
    128,
    128,
    0,
    0,
    32,
    0,
    65,
    36,
    106,
    33,
    2,
    32,
    1,
    16,
    185,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    1,
    65,
    192,
    0,
    106,
    32,
    3,
    106,
    32,
    0,
    32,
    3,
    106,
    65,
    36,
    106,
    40,
    0,
    0,
    54,
    2,
    0,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    32,
    71,
    13,
    0,
    11,
    32,
    1,
    65,
    224,
    0,
    106,
    65,
    40,
    106,
    34,
    4,
    32,
    0,
    65,
    228,
    0,
    106,
    34,
    5,
    16,
    168,
    128,
    128,
    128,
    0,
    32,
    1,
    65,
    1,
    54,
    2,
    176,
    1,
    65,
    0,
    33,
    3,
    32,
    1,
    65,
    180,
    1,
    106,
    34,
    6,
    65,
    0,
    65,
    36,
    252,
    11,
    0,
    32,
    1,
    65,
    224,
    0,
    106,
    65,
    248,
    0,
    106,
    34,
    7,
    32,
    4,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    7,
    65,
    144,
    156,
    128,
    128,
    0,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    1,
    65,
    224,
    0,
    106,
    65,
    208,
    0,
    106,
    33,
    8,
    3,
    64,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    3,
    106,
    34,
    9,
    65,
    248,
    0,
    106,
    34,
    10,
    32,
    10,
    40,
    2,
    0,
    32,
    9,
    65,
    208,
    0,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    3,
    106,
    34,
    9,
    32,
    9,
    65,
    208,
    0,
    106,
    40,
    2,
    0,
    32,
    9,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    7,
    32,
    1,
    65,
    224,
    0,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    2,
    64,
    2,
    64,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    1,
    65,
    224,
    0,
    106,
    16,
    192,
    128,
    128,
    128,
    0,
    69,
    13,
    0,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    7,
    32,
    1,
    65,
    224,
    0,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    2,
    64,
    32,
    1,
    65,
    224,
    0,
    106,
    16,
    181,
    128,
    128,
    128,
    0,
    32,
    0,
    65,
    131,
    1,
    106,
    45,
    0,
    0,
    65,
    7,
    118,
    70,
    13,
    0,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    3,
    106,
    34,
    9,
    65,
    0,
    32,
    9,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    40,
    71,
    13,
    0,
    11,
    11,
    32,
    7,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    4,
    16,
    169,
    128,
    128,
    128,
    0,
    66,
    1,
    33,
    11,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    11,
    32,
    1,
    65,
    192,
    0,
    106,
    32,
    3,
    106,
    53,
    2,
    0,
    124,
    32,
    3,
    65,
    192,
    156,
    128,
    128,
    0,
    106,
    53,
    2,
    0,
    66,
    255,
    255,
    255,
    255,
    15,
    133,
    124,
    34,
    12,
    66,
    32,
    136,
    33,
    11,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    32,
    71,
    13,
    0,
    11,
    32,
    12,
    66,
    255,
    255,
    255,
    255,
    15,
    86,
    13,
    0,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    3,
    106,
    34,
    9,
    65,
    0,
    32,
    9,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    248,
    0,
    33,
    3,
    3,
    64,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    3,
    106,
    34,
    9,
    65,
    0,
    32,
    9,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    160,
    1,
    71,
    13,
    0,
    11,
    32,
    1,
    65,
    160,
    6,
    106,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    1,
    65,
    192,
    2,
    106,
    16,
    180,
    128,
    128,
    128,
    0,
    32,
    1,
    65,
    224,
    3,
    106,
    32,
    1,
    65,
    224,
    0,
    106,
    16,
    193,
    128,
    128,
    128,
    0,
    32,
    1,
    65,
    192,
    2,
    106,
    32,
    1,
    65,
    160,
    6,
    106,
    32,
    1,
    65,
    224,
    3,
    106,
    16,
    194,
    128,
    128,
    128,
    0,
    32,
    1,
    65,
    128,
    5,
    106,
    32,
    1,
    65,
    192,
    2,
    106,
    16,
    193,
    128,
    128,
    128,
    0,
    65,
    252,
    1,
    33,
    3,
    2,
    64,
    3,
    64,
    32,
    1,
    32,
    3,
    65,
    3,
    118,
    106,
    45,
    0,
    0,
    32,
    3,
    65,
    7,
    113,
    118,
    65,
    1,
    113,
    13,
    1,
    32,
    3,
    65,
    1,
    75,
    33,
    9,
    32,
    3,
    65,
    127,
    106,
    33,
    3,
    32,
    9,
    13,
    0,
    11,
    65,
    0,
    33,
    3,
    11,
    32,
    1,
    65,
    255,
    1,
    58,
    0,
    186,
    2,
    32,
    1,
    65,
    255,
    255,
    3,
    59,
    1,
    184,
    2,
    32,
    1,
    32,
    3,
    65,
    1,
    106,
    34,
    13,
    58,
    0,
    187,
    2,
    65,
    252,
    1,
    33,
    3,
    2,
    64,
    3,
    64,
    32,
    2,
    32,
    3,
    65,
    3,
    118,
    106,
    45,
    0,
    0,
    32,
    3,
    65,
    7,
    113,
    118,
    65,
    1,
    113,
    13,
    1,
    32,
    3,
    65,
    1,
    75,
    33,
    9,
    32,
    3,
    65,
    127,
    106,
    33,
    3,
    32,
    9,
    13,
    0,
    11,
    65,
    0,
    33,
    3,
    11,
    32,
    1,
    65,
    255,
    255,
    3,
    59,
    1,
    176,
    2,
    32,
    1,
    32,
    3,
    65,
    1,
    106,
    34,
    3,
    58,
    0,
    179,
    2,
    32,
    1,
    65,
    255,
    1,
    58,
    0,
    178,
    2,
    32,
    1,
    65,
    224,
    0,
    106,
    65,
    0,
    65,
    40,
    252,
    11,
    0,
    32,
    1,
    65,
    224,
    0,
    106,
    65,
    40,
    106,
    34,
    10,
    65,
    1,
    54,
    2,
    0,
    32,
    1,
    65,
    140,
    1,
    106,
    65,
    0,
    65,
    36,
    252,
    11,
    0,
    32,
    1,
    65,
    224,
    0,
    106,
    65,
    208,
    0,
    106,
    34,
    14,
    65,
    1,
    54,
    2,
    0,
    32,
    6,
    65,
    0,
    65,
    204,
    0,
    252,
    11,
    0,
    32,
    3,
    65,
    255,
    1,
    113,
    34,
    3,
    32,
    13,
    65,
    255,
    1,
    113,
    34,
    9,
    32,
    9,
    32,
    3,
    73,
    27,
    33,
    3,
    32,
    1,
    65,
    160,
    6,
    106,
    65,
    208,
    0,
    106,
    33,
    15,
    32,
    1,
    65,
    160,
    6,
    106,
    65,
    40,
    106,
    33,
    16,
    3,
    64,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    1,
    65,
    192,
    2,
    106,
    16,
    180,
    128,
    128,
    128,
    0,
    32,
    1,
    65,
    184,
    2,
    106,
    65,
    3,
    32,
    3,
    34,
    6,
    32,
    1,
    16,
    195,
    128,
    128,
    128,
    0,
    33,
    3,
    32,
    1,
    65,
    176,
    2,
    106,
    65,
    5,
    32,
    6,
    32,
    2,
    16,
    195,
    128,
    128,
    128,
    0,
    33,
    13,
    2,
    64,
    2,
    64,
    32,
    3,
    65,
    1,
    72,
    13,
    0,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    1,
    65,
    224,
    3,
    106,
    32,
    3,
    65,
    1,
    118,
    65,
    160,
    1,
    108,
    106,
    16,
    194,
    128,
    128,
    128,
    0,
    12,
    1,
    11,
    32,
    3,
    65,
    127,
    74,
    13,
    0,
    32,
    16,
    32,
    1,
    65,
    224,
    3,
    106,
    65,
    0,
    32,
    3,
    107,
    65,
    1,
    118,
    65,
    160,
    1,
    108,
    106,
    34,
    9,
    65,
    40,
    252,
    10,
    0,
    0,
    32,
    1,
    65,
    160,
    6,
    106,
    32,
    9,
    65,
    40,
    106,
    65,
    40,
    252,
    10,
    0,
    0,
    32,
    15,
    32,
    9,
    65,
    208,
    0,
    106,
    65,
    40,
    252,
    10,
    0,
    0,
    65,
    248,
    0,
    33,
    3,
    3,
    64,
    32,
    1,
    65,
    160,
    6,
    106,
    32,
    3,
    106,
    65,
    0,
    32,
    9,
    32,
    3,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    160,
    1,
    71,
    13,
    0,
    11,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    1,
    65,
    160,
    6,
    106,
    16,
    194,
    128,
    128,
    128,
    0,
    11,
    2,
    64,
    2,
    64,
    32,
    13,
    65,
    1,
    72,
    13,
    0,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    13,
    65,
    1,
    118,
    65,
    248,
    0,
    108,
    65,
    224,
    156,
    128,
    128,
    0,
    106,
    32,
    1,
    65,
    160,
    6,
    106,
    32,
    1,
    65,
    128,
    2,
    106,
    16,
    196,
    128,
    128,
    128,
    0,
    12,
    1,
    11,
    32,
    13,
    65,
    127,
    74,
    13,
    0,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    1,
    65,
    160,
    6,
    106,
    32,
    3,
    106,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    3,
    106,
    34,
    9,
    40,
    2,
    0,
    32,
    9,
    65,
    40,
    106,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    1,
    65,
    128,
    2,
    106,
    32,
    3,
    106,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    3,
    106,
    34,
    9,
    65,
    40,
    106,
    40,
    2,
    0,
    32,
    9,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    3,
    32,
    1,
    65,
    160,
    6,
    106,
    32,
    1,
    65,
    160,
    6,
    106,
    65,
    0,
    32,
    13,
    107,
    65,
    1,
    118,
    65,
    248,
    0,
    108,
    34,
    13,
    65,
    136,
    157,
    128,
    128,
    0,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    1,
    65,
    128,
    2,
    106,
    32,
    1,
    65,
    128,
    2,
    106,
    32,
    13,
    65,
    224,
    156,
    128,
    128,
    0,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    3,
    64,
    32,
    10,
    32,
    3,
    106,
    32,
    1,
    65,
    128,
    2,
    106,
    32,
    3,
    106,
    40,
    2,
    0,
    32,
    1,
    65,
    160,
    6,
    106,
    32,
    3,
    106,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    3,
    106,
    32,
    1,
    65,
    160,
    6,
    106,
    32,
    3,
    106,
    40,
    2,
    0,
    32,
    1,
    65,
    128,
    2,
    106,
    32,
    3,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    14,
    32,
    3,
    106,
    34,
    9,
    32,
    9,
    40,
    2,
    0,
    65,
    1,
    116,
    54,
    2,
    0,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    7,
    32,
    7,
    32,
    13,
    65,
    176,
    157,
    128,
    128,
    0,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    1,
    65,
    160,
    6,
    106,
    32,
    3,
    106,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    3,
    106,
    34,
    9,
    65,
    208,
    0,
    106,
    40,
    2,
    0,
    32,
    9,
    65,
    248,
    0,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    1,
    65,
    128,
    2,
    106,
    32,
    3,
    106,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    3,
    106,
    34,
    9,
    65,
    248,
    0,
    106,
    40,
    2,
    0,
    32,
    9,
    65,
    208,
    0,
    106,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    7,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    4,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    1,
    65,
    224,
    0,
    106,
    32,
    1,
    65,
    128,
    2,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    4,
    32,
    4,
    32,
    1,
    65,
    160,
    6,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    8,
    32,
    1,
    65,
    160,
    6,
    106,
    32,
    1,
    65,
    128,
    2,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    11,
    32,
    6,
    65,
    127,
    106,
    33,
    3,
    32,
    6,
    65,
    0,
    74,
    13,
    0,
    11,
    32,
    5,
    32,
    1,
    65,
    224,
    0,
    106,
    16,
    177,
    128,
    128,
    128,
    0,
    32,
    0,
    65,
    4,
    106,
    32,
    5,
    16,
    131,
    128,
    128,
    128,
    0,
    33,
    3,
    12,
    1,
    11,
    65,
    127,
    33,
    3,
    11,
    32,
    1,
    65,
    192,
    7,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    3,
    11,
    137,
    3,
    1,
    5,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    224,
    0,
    107,
    34,
    2,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    48,
    106,
    32,
    1,
    65,
    40,
    252,
    10,
    0,
    0,
    32,
    0,
    32,
    2,
    65,
    48,
    106,
    16,
    200,
    128,
    128,
    128,
    0,
    32,
    2,
    32,
    0,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    2,
    32,
    2,
    32,
    2,
    65,
    48,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    1,
    54,
    2,
    48,
    32,
    2,
    65,
    48,
    106,
    65,
    4,
    114,
    65,
    0,
    65,
    36,
    252,
    11,
    0,
    32,
    2,
    32,
    2,
    65,
    48,
    106,
    16,
    205,
    128,
    128,
    128,
    0,
    33,
    3,
    32,
    2,
    65,
    127,
    54,
    2,
    48,
    65,
    4,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    48,
    106,
    32,
    1,
    106,
    34,
    4,
    65,
    0,
    32,
    4,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    2,
    32,
    2,
    65,
    48,
    106,
    16,
    205,
    128,
    128,
    128,
    0,
    33,
    5,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    48,
    106,
    32,
    1,
    106,
    65,
    0,
    32,
    1,
    65,
    160,
    138,
    128,
    128,
    0,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    2,
    32,
    2,
    65,
    48,
    106,
    16,
    205,
    128,
    128,
    128,
    0,
    33,
    4,
    32,
    2,
    65,
    48,
    106,
    32,
    0,
    65,
    160,
    138,
    128,
    128,
    0,
    16,
    169,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    1,
    65,
    0,
    32,
    4,
    32,
    5,
    114,
    107,
    33,
    6,
    3,
    64,
    32,
    0,
    32,
    1,
    106,
    34,
    4,
    32,
    2,
    65,
    48,
    106,
    32,
    1,
    106,
    40,
    2,
    0,
    32,
    4,
    40,
    2,
    0,
    34,
    4,
    115,
    32,
    6,
    113,
    32,
    4,
    115,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    48,
    106,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    224,
    0,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    5,
    32,
    3,
    114,
    11,
    178,
    1,
    1,
    3,
    127,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    0,
    32,
    2,
    106,
    32,
    1,
    32,
    2,
    106,
    34,
    3,
    40,
    2,
    0,
    32,
    3,
    65,
    40,
    106,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    0,
    65,
    40,
    106,
    33,
    4,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    32,
    2,
    106,
    32,
    1,
    32,
    2,
    106,
    34,
    3,
    65,
    40,
    106,
    40,
    2,
    0,
    32,
    3,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    1,
    65,
    208,
    0,
    106,
    33,
    3,
    32,
    0,
    65,
    208,
    0,
    106,
    33,
    4,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    4,
    32,
    2,
    106,
    32,
    3,
    32,
    2,
    106,
    40,
    2,
    0,
    54,
    2,
    0,
    32,
    2,
    65,
    4,
    106,
    34,
    2,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    0,
    65,
    248,
    0,
    106,
    32,
    1,
    65,
    248,
    0,
    106,
    65,
    176,
    139,
    128,
    128,
    0,
    16,
    169,
    128,
    128,
    128,
    0,
    11,
    147,
    4,
    1,
    5,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    224,
    0,
    107,
    34,
    3,
    36,
    128,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    4,
    3,
    64,
    32,
    3,
    65,
    48,
    106,
    32,
    4,
    106,
    32,
    1,
    32,
    4,
    106,
    34,
    5,
    40,
    2,
    0,
    32,
    5,
    65,
    40,
    106,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    4,
    65,
    4,
    106,
    34,
    4,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    4,
    3,
    64,
    32,
    3,
    32,
    4,
    106,
    32,
    1,
    32,
    4,
    106,
    34,
    5,
    65,
    40,
    106,
    40,
    2,
    0,
    32,
    5,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    4,
    65,
    4,
    106,
    34,
    4,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    3,
    65,
    48,
    106,
    32,
    3,
    65,
    48,
    106,
    32,
    2,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    3,
    32,
    3,
    32,
    2,
    65,
    40,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    0,
    65,
    40,
    106,
    33,
    5,
    65,
    0,
    33,
    4,
    3,
    64,
    32,
    5,
    32,
    4,
    106,
    32,
    3,
    32,
    4,
    106,
    40,
    2,
    0,
    32,
    3,
    65,
    48,
    106,
    32,
    4,
    106,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    4,
    65,
    4,
    106,
    34,
    4,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    0,
    65,
    40,
    106,
    33,
    6,
    65,
    0,
    33,
    4,
    3,
    64,
    32,
    0,
    32,
    4,
    106,
    32,
    3,
    65,
    48,
    106,
    32,
    4,
    106,
    40,
    2,
    0,
    32,
    3,
    32,
    4,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    4,
    65,
    4,
    106,
    34,
    4,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    1,
    65,
    208,
    0,
    106,
    33,
    5,
    32,
    0,
    65,
    208,
    0,
    106,
    33,
    7,
    65,
    0,
    33,
    4,
    3,
    64,
    32,
    7,
    32,
    4,
    106,
    32,
    5,
    32,
    4,
    106,
    40,
    2,
    0,
    65,
    1,
    116,
    54,
    2,
    0,
    32,
    4,
    65,
    4,
    106,
    34,
    4,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    0,
    65,
    208,
    0,
    106,
    34,
    5,
    32,
    5,
    32,
    2,
    65,
    208,
    0,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    0,
    65,
    248,
    0,
    106,
    34,
    7,
    32,
    1,
    65,
    248,
    0,
    106,
    32,
    2,
    65,
    248,
    0,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    4,
    3,
    64,
    32,
    3,
    65,
    48,
    106,
    32,
    4,
    106,
    32,
    0,
    32,
    4,
    106,
    34,
    1,
    65,
    248,
    0,
    106,
    40,
    2,
    0,
    32,
    1,
    65,
    208,
    0,
    106,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    4,
    65,
    4,
    106,
    34,
    4,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    4,
    3,
    64,
    32,
    3,
    32,
    4,
    106,
    32,
    0,
    32,
    4,
    106,
    34,
    1,
    65,
    208,
    0,
    106,
    40,
    2,
    0,
    32,
    1,
    65,
    248,
    0,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    4,
    65,
    4,
    106,
    34,
    4,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    7,
    32,
    0,
    32,
    6,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    0,
    32,
    3,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    6,
    32,
    6,
    32,
    3,
    65,
    48,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    5,
    32,
    3,
    65,
    48,
    106,
    32,
    3,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    3,
    65,
    224,
    0,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    143,
    3,
    1,
    8,
    127,
    2,
    64,
    32,
    0,
    45,
    0,
    3,
    34,
    4,
    32,
    2,
    71,
    13,
    0,
    65,
    0,
    33,
    5,
    2,
    64,
    2,
    64,
    2,
    64,
    32,
    2,
    65,
    0,
    72,
    13,
    0,
    32,
    3,
    32,
    2,
    65,
    3,
    118,
    106,
    45,
    0,
    0,
    32,
    2,
    65,
    7,
    113,
    118,
    65,
    1,
    113,
    33,
    6,
    2,
    64,
    32,
    2,
    69,
    13,
    0,
    32,
    3,
    32,
    2,
    65,
    127,
    106,
    34,
    5,
    65,
    3,
    118,
    106,
    45,
    0,
    0,
    32,
    5,
    65,
    7,
    113,
    118,
    65,
    1,
    113,
    33,
    5,
    11,
    32,
    6,
    32,
    5,
    71,
    13,
    1,
    11,
    32,
    4,
    65,
    127,
    106,
    33,
    1,
    12,
    1,
    11,
    65,
    0,
    33,
    7,
    65,
    0,
    32,
    3,
    32,
    2,
    65,
    3,
    118,
    106,
    45,
    0,
    0,
    32,
    2,
    65,
    7,
    113,
    118,
    65,
    1,
    113,
    32,
    2,
    65,
    1,
    106,
    34,
    5,
    32,
    1,
    32,
    5,
    32,
    1,
    72,
    27,
    34,
    8,
    65,
    127,
    106,
    34,
    9,
    116,
    107,
    33,
    10,
    2,
    64,
    32,
    8,
    65,
    2,
    72,
    13,
    0,
    32,
    2,
    32,
    9,
    107,
    33,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    65,
    0,
    33,
    5,
    2,
    64,
    32,
    11,
    32,
    1,
    106,
    34,
    6,
    65,
    0,
    72,
    13,
    0,
    32,
    3,
    32,
    6,
    65,
    3,
    118,
    106,
    45,
    0,
    0,
    32,
    6,
    65,
    7,
    113,
    118,
    65,
    1,
    113,
    33,
    5,
    11,
    32,
    5,
    32,
    1,
    116,
    32,
    10,
    106,
    33,
    10,
    32,
    9,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    71,
    13,
    0,
    11,
    11,
    2,
    64,
    32,
    2,
    32,
    8,
    107,
    34,
    1,
    65,
    0,
    72,
    13,
    0,
    32,
    3,
    32,
    1,
    65,
    3,
    118,
    106,
    45,
    0,
    0,
    32,
    1,
    65,
    7,
    113,
    118,
    65,
    1,
    113,
    33,
    7,
    11,
    32,
    0,
    32,
    7,
    32,
    10,
    106,
    34,
    5,
    32,
    5,
    65,
    0,
    32,
    5,
    107,
    113,
    34,
    5,
    65,
    204,
    1,
    113,
    65,
    0,
    71,
    65,
    1,
    116,
    32,
    5,
    65,
    170,
    1,
    113,
    65,
    0,
    71,
    114,
    32,
    5,
    65,
    240,
    1,
    113,
    65,
    0,
    71,
    65,
    2,
    116,
    114,
    34,
    5,
    117,
    58,
    0,
    2,
    32,
    0,
    32,
    1,
    32,
    5,
    106,
    65,
    1,
    106,
    59,
    1,
    0,
    32,
    4,
    32,
    8,
    107,
    33,
    1,
    11,
    32,
    0,
    32,
    1,
    58,
    0,
    3,
    11,
    65,
    0,
    33,
    1,
    2,
    64,
    32,
    0,
    46,
    1,
    0,
    32,
    2,
    71,
    13,
    0,
    32,
    0,
    44,
    0,
    2,
    33,
    1,
    11,
    32,
    1,
    11,
    203,
    3,
    1,
    4,
    127,
    65,
    0,
    33,
    5,
    3,
    64,
    32,
    3,
    32,
    5,
    106,
    32,
    1,
    32,
    5,
    106,
    34,
    6,
    40,
    2,
    0,
    32,
    6,
    65,
    40,
    106,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    5,
    65,
    4,
    106,
    34,
    5,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    5,
    3,
    64,
    32,
    4,
    32,
    5,
    106,
    32,
    1,
    32,
    5,
    106,
    34,
    6,
    65,
    40,
    106,
    40,
    2,
    0,
    32,
    6,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    5,
    65,
    4,
    106,
    34,
    5,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    3,
    32,
    3,
    32,
    2,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    4,
    32,
    4,
    32,
    2,
    65,
    40,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    0,
    65,
    40,
    106,
    33,
    6,
    65,
    0,
    33,
    5,
    3,
    64,
    32,
    6,
    32,
    5,
    106,
    32,
    4,
    32,
    5,
    106,
    40,
    2,
    0,
    32,
    3,
    32,
    5,
    106,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    5,
    65,
    4,
    106,
    34,
    5,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    0,
    65,
    40,
    106,
    33,
    7,
    65,
    0,
    33,
    5,
    3,
    64,
    32,
    0,
    32,
    5,
    106,
    32,
    3,
    32,
    5,
    106,
    40,
    2,
    0,
    32,
    4,
    32,
    5,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    5,
    65,
    4,
    106,
    34,
    5,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    1,
    65,
    208,
    0,
    106,
    33,
    6,
    32,
    0,
    65,
    208,
    0,
    106,
    33,
    8,
    65,
    0,
    33,
    5,
    3,
    64,
    32,
    8,
    32,
    5,
    106,
    32,
    6,
    32,
    5,
    106,
    40,
    2,
    0,
    65,
    1,
    116,
    54,
    2,
    0,
    32,
    5,
    65,
    4,
    106,
    34,
    5,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    0,
    65,
    248,
    0,
    106,
    34,
    6,
    32,
    1,
    65,
    248,
    0,
    106,
    32,
    2,
    65,
    208,
    0,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    5,
    3,
    64,
    32,
    3,
    32,
    5,
    106,
    32,
    0,
    32,
    5,
    106,
    34,
    1,
    65,
    248,
    0,
    106,
    40,
    2,
    0,
    32,
    1,
    65,
    208,
    0,
    106,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    5,
    65,
    4,
    106,
    34,
    5,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    5,
    3,
    64,
    32,
    4,
    32,
    5,
    106,
    32,
    0,
    32,
    5,
    106,
    34,
    1,
    65,
    208,
    0,
    106,
    40,
    2,
    0,
    32,
    1,
    65,
    248,
    0,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    5,
    65,
    4,
    106,
    34,
    5,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    6,
    32,
    0,
    32,
    7,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    0,
    32,
    4,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    7,
    32,
    7,
    32,
    3,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    0,
    65,
    208,
    0,
    106,
    32,
    3,
    32,
    4,
    16,
    169,
    128,
    128,
    128,
    0,
    11,
    85,
    1,
    1,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    224,
    2,
    107,
    34,
    4,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    4,
    32,
    0,
    32,
    1,
    65,
    192,
    137,
    128,
    128,
    0,
    16,
    190,
    128,
    128,
    128,
    0,
    32,
    4,
    32,
    2,
    32,
    3,
    32,
    4,
    40,
    2,
    0,
    40,
    2,
    8,
    17,
    128,
    128,
    128,
    128,
    0,
    0,
    32,
    4,
    16,
    191,
    128,
    128,
    128,
    0,
    33,
    2,
    32,
    4,
    65,
    224,
    2,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    2,
    11,
    138,
    1,
    1,
    1,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    192,
    0,
    107,
    34,
    2,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    192,
    0,
    65,
    0,
    65,
    0,
    32,
    1,
    65,
    32,
    16,
    155,
    128,
    128,
    128,
    0,
    32,
    0,
    65,
    24,
    106,
    32,
    2,
    65,
    24,
    106,
    41,
    3,
    0,
    55,
    0,
    0,
    32,
    0,
    65,
    16,
    106,
    32,
    2,
    65,
    16,
    106,
    41,
    3,
    0,
    55,
    0,
    0,
    32,
    0,
    65,
    8,
    106,
    32,
    2,
    41,
    3,
    8,
    55,
    0,
    0,
    32,
    0,
    32,
    2,
    41,
    3,
    0,
    55,
    0,
    0,
    65,
    0,
    33,
    0,
    3,
    64,
    32,
    2,
    32,
    0,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    0,
    65,
    1,
    106,
    34,
    0,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    192,
    0,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    244,
    1,
    1,
    2,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    224,
    0,
    107,
    34,
    2,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    2,
    32,
    1,
    16,
    168,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    48,
    106,
    32,
    1,
    106,
    32,
    2,
    32,
    1,
    106,
    40,
    2,
    0,
    32,
    1,
    65,
    160,
    164,
    128,
    128,
    0,
    106,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    32,
    1,
    106,
    34,
    3,
    32,
    1,
    65,
    160,
    164,
    128,
    128,
    0,
    106,
    40,
    2,
    0,
    32,
    3,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    2,
    32,
    2,
    16,
    172,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    2,
    65,
    48,
    106,
    16,
    173,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    48,
    106,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    224,
    0,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    140,
    6,
    1,
    2,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    144,
    1,
    107,
    34,
    2,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    1,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    224,
    0,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    48,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    48,
    106,
    32,
    1,
    32,
    2,
    65,
    48,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    2,
    65,
    48,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    2,
    65,
    224,
    0,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    224,
    0,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    224,
    0,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    65,
    4,
    33,
    3,
    3,
    64,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    48,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    3,
    65,
    127,
    106,
    34,
    3,
    13,
    0,
    11,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    224,
    0,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    224,
    0,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    65,
    9,
    33,
    3,
    3,
    64,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    48,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    3,
    65,
    127,
    106,
    34,
    3,
    13,
    0,
    11,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    224,
    0,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    2,
    32,
    2,
    65,
    48,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    65,
    19,
    33,
    3,
    3,
    64,
    32,
    2,
    32,
    2,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    3,
    65,
    127,
    106,
    34,
    3,
    13,
    0,
    11,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    32,
    2,
    65,
    48,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    48,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    65,
    9,
    33,
    3,
    3,
    64,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    48,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    3,
    65,
    127,
    106,
    34,
    3,
    13,
    0,
    11,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    224,
    0,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    224,
    0,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    65,
    49,
    33,
    3,
    3,
    64,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    48,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    3,
    65,
    127,
    106,
    34,
    3,
    13,
    0,
    11,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    224,
    0,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    2,
    32,
    2,
    65,
    48,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    65,
    227,
    0,
    33,
    3,
    3,
    64,
    32,
    2,
    32,
    2,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    3,
    65,
    127,
    106,
    34,
    3,
    13,
    0,
    11,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    32,
    2,
    65,
    48,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    48,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    65,
    49,
    33,
    3,
    3,
    64,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    48,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    3,
    65,
    127,
    106,
    34,
    3,
    13,
    0,
    11,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    224,
    0,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    2,
    65,
    224,
    0,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    2,
    65,
    224,
    0,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    1,
    16,
    169,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    3,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    3,
    65,
    1,
    106,
    34,
    3,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    2,
    65,
    48,
    106,
    32,
    3,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    3,
    65,
    1,
    106,
    34,
    3,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    2,
    32,
    3,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    3,
    65,
    1,
    106,
    34,
    3,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    144,
    1,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    188,
    1,
    2,
    1,
    127,
    1,
    126,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    32,
    107,
    34,
    2,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    24,
    106,
    32,
    1,
    65,
    24,
    106,
    41,
    0,
    0,
    55,
    3,
    0,
    32,
    2,
    65,
    16,
    106,
    32,
    1,
    65,
    16,
    106,
    41,
    0,
    0,
    55,
    3,
    0,
    32,
    2,
    32,
    1,
    41,
    0,
    0,
    34,
    3,
    55,
    3,
    0,
    32,
    2,
    32,
    1,
    65,
    8,
    106,
    41,
    0,
    0,
    55,
    3,
    8,
    32,
    2,
    32,
    3,
    167,
    65,
    248,
    1,
    113,
    58,
    0,
    0,
    32,
    2,
    32,
    2,
    45,
    0,
    31,
    65,
    63,
    113,
    65,
    192,
    0,
    114,
    58,
    0,
    31,
    32,
    2,
    32,
    1,
    45,
    0,
    0,
    65,
    5,
    108,
    65,
    255,
    1,
    113,
    16,
    202,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    2,
    65,
    128,
    138,
    128,
    128,
    0,
    65,
    128,
    2,
    16,
    167,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    32,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    32,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    80,
    2,
    2,
    126,
    1,
    127,
    32,
    1,
    173,
    66,
    7,
    131,
    33,
    2,
    66,
    0,
    33,
    3,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    0,
    32,
    1,
    106,
    34,
    4,
    32,
    4,
    53,
    0,
    0,
    32,
    3,
    124,
    32,
    1,
    65,
    192,
    156,
    128,
    128,
    0,
    106,
    53,
    2,
    0,
    32,
    2,
    126,
    124,
    34,
    3,
    62,
    0,
    0,
    32,
    3,
    66,
    32,
    136,
    33,
    3,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    32,
    71,
    13,
    0,
    11,
    11,
    157,
    10,
    3,
    1,
    127,
    1,
    126,
    6,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    208,
    3,
    107,
    34,
    2,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    176,
    3,
    106,
    65,
    24,
    106,
    32,
    1,
    65,
    24,
    106,
    41,
    0,
    0,
    55,
    3,
    0,
    32,
    2,
    65,
    176,
    3,
    106,
    65,
    16,
    106,
    32,
    1,
    65,
    16,
    106,
    41,
    0,
    0,
    55,
    3,
    0,
    32,
    2,
    32,
    1,
    41,
    0,
    0,
    34,
    3,
    55,
    3,
    176,
    3,
    32,
    2,
    32,
    1,
    65,
    8,
    106,
    41,
    0,
    0,
    55,
    3,
    184,
    3,
    32,
    2,
    32,
    3,
    167,
    65,
    248,
    1,
    113,
    58,
    0,
    176,
    3,
    32,
    2,
    32,
    2,
    45,
    0,
    207,
    3,
    65,
    63,
    113,
    65,
    192,
    0,
    114,
    58,
    0,
    207,
    3,
    32,
    2,
    65,
    144,
    2,
    106,
    32,
    2,
    65,
    176,
    3,
    106,
    16,
    176,
    128,
    128,
    128,
    0,
    32,
    1,
    45,
    0,
    0,
    33,
    1,
    32,
    2,
    65,
    224,
    1,
    106,
    65,
    0,
    65,
    40,
    252,
    11,
    0,
    32,
    2,
    65,
    0,
    32,
    1,
    65,
    7,
    113,
    34,
    4,
    65,
    1,
    118,
    65,
    1,
    113,
    34,
    5,
    107,
    34,
    6,
    65,
    176,
    193,
    186,
    112,
    113,
    54,
    2,
    224,
    1,
    65,
    4,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    224,
    1,
    106,
    32,
    1,
    106,
    34,
    7,
    32,
    1,
    65,
    160,
    138,
    128,
    128,
    0,
    106,
    40,
    2,
    0,
    32,
    7,
    40,
    2,
    0,
    34,
    7,
    115,
    32,
    6,
    113,
    32,
    7,
    115,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    65,
    0,
    32,
    4,
    65,
    1,
    113,
    107,
    33,
    7,
    3,
    64,
    32,
    2,
    65,
    224,
    1,
    106,
    32,
    1,
    106,
    34,
    8,
    32,
    1,
    65,
    208,
    138,
    128,
    128,
    0,
    106,
    40,
    2,
    0,
    32,
    8,
    40,
    2,
    0,
    34,
    8,
    115,
    32,
    7,
    113,
    32,
    8,
    115,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    4,
    65,
    2,
    118,
    33,
    9,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    128,
    1,
    106,
    32,
    1,
    106,
    65,
    0,
    32,
    2,
    65,
    224,
    1,
    106,
    32,
    1,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    65,
    0,
    32,
    9,
    107,
    33,
    4,
    3,
    64,
    32,
    2,
    65,
    224,
    1,
    106,
    32,
    1,
    106,
    34,
    8,
    32,
    2,
    65,
    128,
    1,
    106,
    32,
    1,
    106,
    40,
    2,
    0,
    32,
    8,
    40,
    2,
    0,
    34,
    8,
    115,
    32,
    4,
    113,
    32,
    8,
    115,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    1,
    54,
    2,
    176,
    1,
    32,
    2,
    65,
    176,
    1,
    106,
    65,
    4,
    114,
    65,
    0,
    65,
    36,
    252,
    11,
    0,
    32,
    2,
    65,
    128,
    1,
    106,
    65,
    0,
    65,
    40,
    252,
    11,
    0,
    32,
    2,
    32,
    2,
    40,
    2,
    128,
    1,
    65,
    1,
    115,
    32,
    6,
    113,
    65,
    1,
    115,
    54,
    2,
    176,
    1,
    65,
    4,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    176,
    1,
    106,
    32,
    1,
    106,
    34,
    8,
    32,
    2,
    65,
    128,
    1,
    106,
    32,
    1,
    106,
    40,
    2,
    0,
    32,
    8,
    40,
    2,
    0,
    34,
    8,
    115,
    32,
    6,
    113,
    32,
    8,
    115,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    176,
    1,
    106,
    32,
    1,
    106,
    34,
    6,
    32,
    1,
    65,
    128,
    139,
    128,
    128,
    0,
    106,
    40,
    2,
    0,
    32,
    6,
    40,
    2,
    0,
    34,
    6,
    115,
    32,
    7,
    113,
    32,
    6,
    115,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    128,
    1,
    106,
    32,
    1,
    106,
    65,
    0,
    32,
    2,
    65,
    176,
    1,
    106,
    32,
    1,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    65,
    0,
    32,
    5,
    32,
    9,
    115,
    107,
    33,
    7,
    3,
    64,
    32,
    2,
    65,
    176,
    1,
    106,
    32,
    1,
    106,
    34,
    6,
    32,
    2,
    65,
    128,
    1,
    106,
    32,
    1,
    106,
    40,
    2,
    0,
    32,
    6,
    40,
    2,
    0,
    34,
    6,
    115,
    32,
    7,
    113,
    32,
    6,
    115,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    8,
    106,
    32,
    1,
    106,
    32,
    2,
    65,
    224,
    1,
    106,
    32,
    1,
    106,
    40,
    2,
    0,
    32,
    2,
    65,
    176,
    1,
    106,
    32,
    1,
    106,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    8,
    106,
    32,
    1,
    106,
    65,
    40,
    106,
    32,
    2,
    65,
    176,
    1,
    106,
    32,
    1,
    106,
    40,
    2,
    0,
    32,
    2,
    65,
    224,
    1,
    106,
    32,
    1,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    8,
    106,
    65,
    208,
    0,
    106,
    34,
    1,
    32,
    2,
    65,
    176,
    1,
    106,
    32,
    2,
    65,
    224,
    1,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    1,
    32,
    1,
    65,
    176,
    139,
    128,
    128,
    0,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    144,
    2,
    106,
    32,
    2,
    65,
    144,
    2,
    106,
    32,
    2,
    65,
    8,
    106,
    32,
    2,
    65,
    224,
    1,
    106,
    32,
    2,
    65,
    176,
    1,
    106,
    16,
    196,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    224,
    1,
    106,
    32,
    1,
    106,
    32,
    2,
    65,
    144,
    2,
    106,
    32,
    1,
    106,
    34,
    6,
    65,
    40,
    106,
    40,
    2,
    0,
    32,
    6,
    65,
    208,
    0,
    106,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    176,
    1,
    106,
    32,
    1,
    106,
    32,
    2,
    65,
    144,
    2,
    106,
    32,
    1,
    106,
    34,
    6,
    65,
    208,
    0,
    106,
    40,
    2,
    0,
    32,
    6,
    65,
    40,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    176,
    1,
    106,
    32,
    2,
    65,
    176,
    1,
    106,
    16,
    172,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    224,
    1,
    106,
    32,
    2,
    65,
    224,
    1,
    106,
    32,
    2,
    65,
    176,
    1,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    2,
    65,
    224,
    1,
    106,
    16,
    173,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    224,
    1,
    106,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    176,
    3,
    106,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    32,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    176,
    1,
    106,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    144,
    2,
    106,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    160,
    1,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    128,
    1,
    106,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    8,
    106,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    248,
    0,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    208,
    3,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    213,
    6,
    1,
    3,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    144,
    2,
    107,
    34,
    2,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    240,
    1,
    106,
    65,
    24,
    106,
    32,
    1,
    65,
    24,
    106,
    41,
    0,
    0,
    55,
    3,
    0,
    32,
    2,
    65,
    240,
    1,
    106,
    65,
    16,
    106,
    32,
    1,
    65,
    16,
    106,
    41,
    0,
    0,
    55,
    3,
    0,
    32,
    2,
    32,
    1,
    41,
    0,
    0,
    55,
    3,
    240,
    1,
    32,
    2,
    32,
    1,
    65,
    8,
    106,
    41,
    0,
    0,
    55,
    3,
    248,
    1,
    32,
    2,
    32,
    2,
    45,
    0,
    143,
    2,
    65,
    63,
    113,
    58,
    0,
    143,
    2,
    32,
    2,
    65,
    192,
    1,
    106,
    32,
    2,
    65,
    240,
    1,
    106,
    16,
    168,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    2,
    65,
    192,
    1,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    2,
    65,
    224,
    0,
    106,
    65,
    2,
    16,
    171,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    144,
    1,
    106,
    32,
    1,
    106,
    32,
    1,
    65,
    160,
    164,
    128,
    128,
    0,
    106,
    40,
    2,
    0,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    1,
    106,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    144,
    1,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    208,
    164,
    128,
    128,
    0,
    32,
    2,
    65,
    224,
    0,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    32,
    1,
    106,
    34,
    3,
    32,
    3,
    40,
    2,
    0,
    32,
    2,
    65,
    48,
    106,
    32,
    1,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    2,
    32,
    2,
    65,
    128,
    165,
    128,
    128,
    0,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    2,
    65,
    48,
    106,
    32,
    2,
    65,
    144,
    1,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    2,
    32,
    2,
    65,
    224,
    0,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    2,
    65,
    224,
    0,
    106,
    16,
    192,
    128,
    128,
    128,
    0,
    33,
    3,
    32,
    2,
    65,
    144,
    1,
    106,
    32,
    2,
    65,
    192,
    1,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    144,
    1,
    106,
    32,
    2,
    65,
    144,
    1,
    106,
    65,
    224,
    139,
    128,
    128,
    0,
    16,
    169,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    1,
    65,
    0,
    32,
    3,
    107,
    33,
    4,
    3,
    64,
    32,
    2,
    65,
    144,
    1,
    106,
    32,
    1,
    106,
    34,
    3,
    32,
    1,
    65,
    160,
    164,
    128,
    128,
    0,
    106,
    40,
    2,
    0,
    32,
    3,
    40,
    2,
    0,
    34,
    3,
    115,
    32,
    4,
    113,
    32,
    3,
    115,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    2,
    65,
    224,
    0,
    106,
    16,
    170,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    144,
    1,
    106,
    32,
    2,
    65,
    144,
    1,
    106,
    65,
    128,
    165,
    128,
    128,
    0,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    144,
    1,
    106,
    32,
    2,
    65,
    144,
    1,
    106,
    32,
    2,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    144,
    1,
    106,
    32,
    2,
    65,
    144,
    1,
    106,
    32,
    2,
    65,
    48,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    144,
    1,
    106,
    32,
    2,
    65,
    144,
    1,
    106,
    32,
    2,
    65,
    224,
    0,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    144,
    1,
    106,
    32,
    1,
    106,
    34,
    3,
    65,
    0,
    32,
    3,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    0,
    32,
    2,
    65,
    144,
    1,
    106,
    16,
    173,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    224,
    0,
    106,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    192,
    1,
    106,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    48,
    106,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    144,
    1,
    106,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    240,
    1,
    106,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    32,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    144,
    2,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    138,
    1,
    1,
    1,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    192,
    0,
    107,
    34,
    2,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    32,
    106,
    32,
    0,
    16,
    173,
    128,
    128,
    128,
    0,
    32,
    2,
    32,
    1,
    16,
    173,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    32,
    106,
    32,
    2,
    16,
    131,
    128,
    128,
    128,
    0,
    33,
    0,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    65,
    32,
    106,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    32,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    2,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    32,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    192,
    0,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    0,
    65,
    1,
    106,
    11,
    207,
    4,
    1,
    3,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    144,
    1,
    107,
    34,
    3,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    3,
    65,
    224,
    0,
    106,
    32,
    1,
    16,
    168,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    3,
    65,
    48,
    106,
    32,
    1,
    106,
    32,
    1,
    65,
    128,
    165,
    128,
    128,
    0,
    106,
    40,
    2,
    0,
    32,
    3,
    65,
    224,
    0,
    106,
    32,
    1,
    106,
    40,
    2,
    0,
    106,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    3,
    32,
    3,
    65,
    224,
    0,
    106,
    32,
    3,
    65,
    48,
    106,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    3,
    32,
    3,
    65,
    126,
    16,
    171,
    128,
    128,
    128,
    0,
    2,
    64,
    2,
    64,
    32,
    3,
    32,
    3,
    16,
    192,
    128,
    128,
    128,
    0,
    13,
    0,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    3,
    65,
    224,
    0,
    106,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    3,
    65,
    48,
    106,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    3,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    127,
    33,
    4,
    12,
    1,
    11,
    65,
    0,
    33,
    1,
    65,
    0,
    32,
    2,
    65,
    1,
    113,
    107,
    33,
    5,
    3,
    64,
    32,
    3,
    65,
    224,
    0,
    106,
    32,
    1,
    106,
    34,
    4,
    32,
    3,
    65,
    48,
    106,
    32,
    1,
    106,
    40,
    2,
    0,
    32,
    4,
    40,
    2,
    0,
    34,
    4,
    115,
    32,
    5,
    113,
    32,
    4,
    115,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    3,
    32,
    3,
    65,
    224,
    0,
    106,
    32,
    3,
    16,
    169,
    128,
    128,
    128,
    0,
    32,
    3,
    65,
    224,
    0,
    106,
    32,
    3,
    65,
    2,
    16,
    171,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    3,
    65,
    48,
    106,
    32,
    1,
    106,
    65,
    0,
    32,
    3,
    32,
    1,
    106,
    40,
    2,
    0,
    107,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    65,
    0,
    32,
    3,
    65,
    224,
    0,
    106,
    16,
    181,
    128,
    128,
    128,
    0,
    107,
    33,
    5,
    3,
    64,
    32,
    3,
    32,
    1,
    106,
    34,
    4,
    32,
    3,
    65,
    48,
    106,
    32,
    1,
    106,
    40,
    2,
    0,
    32,
    4,
    40,
    2,
    0,
    34,
    4,
    115,
    32,
    5,
    113,
    32,
    4,
    115,
    54,
    2,
    0,
    32,
    1,
    65,
    4,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    32,
    0,
    32,
    3,
    16,
    173,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    0,
    45,
    0,
    31,
    32,
    2,
    65,
    192,
    1,
    113,
    114,
    58,
    0,
    31,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    3,
    65,
    224,
    0,
    106,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    3,
    65,
    48,
    106,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    4,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    3,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    40,
    71,
    13,
    0,
    11,
    11,
    32,
    3,
    65,
    144,
    1,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    4,
    11,
    238,
    2,
    1,
    3,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    224,
    0,
    107,
    34,
    3,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    3,
    65,
    56,
    106,
    32,
    2,
    65,
    24,
    106,
    41,
    0,
    0,
    55,
    3,
    0,
    32,
    3,
    65,
    48,
    106,
    32,
    2,
    65,
    16,
    106,
    41,
    0,
    0,
    55,
    3,
    0,
    32,
    3,
    65,
    40,
    106,
    32,
    2,
    65,
    8,
    106,
    41,
    0,
    0,
    55,
    3,
    0,
    32,
    3,
    32,
    2,
    41,
    0,
    0,
    55,
    3,
    32,
    32,
    3,
    65,
    32,
    106,
    33,
    4,
    3,
    64,
    32,
    3,
    65,
    0,
    65,
    192,
    0,
    32,
    4,
    65,
    128,
    136,
    128,
    128,
    0,
    66,
    0,
    16,
    137,
    128,
    128,
    128,
    0,
    26,
    32,
    3,
    65,
    192,
    0,
    106,
    32,
    3,
    16,
    203,
    128,
    128,
    128,
    0,
    32,
    4,
    32,
    3,
    65,
    192,
    0,
    106,
    32,
    3,
    45,
    0,
    32,
    16,
    206,
    128,
    128,
    128,
    0,
    13,
    0,
    11,
    65,
    0,
    33,
    5,
    3,
    64,
    32,
    2,
    32,
    5,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    5,
    65,
    1,
    106,
    34,
    5,
    65,
    32,
    71,
    13,
    0,
    11,
    32,
    0,
    32,
    4,
    41,
    0,
    0,
    55,
    0,
    0,
    32,
    0,
    65,
    24,
    106,
    32,
    4,
    65,
    24,
    106,
    41,
    0,
    0,
    55,
    0,
    0,
    32,
    0,
    65,
    16,
    106,
    32,
    4,
    65,
    16,
    106,
    41,
    0,
    0,
    55,
    0,
    0,
    32,
    0,
    65,
    8,
    106,
    32,
    4,
    65,
    8,
    106,
    41,
    0,
    0,
    55,
    0,
    0,
    32,
    1,
    32,
    3,
    41,
    3,
    0,
    55,
    0,
    0,
    32,
    1,
    65,
    8,
    106,
    32,
    3,
    41,
    3,
    8,
    55,
    0,
    0,
    32,
    1,
    65,
    16,
    106,
    32,
    3,
    65,
    16,
    106,
    41,
    3,
    0,
    55,
    0,
    0,
    32,
    1,
    65,
    24,
    106,
    32,
    3,
    65,
    24,
    106,
    41,
    3,
    0,
    55,
    0,
    0,
    65,
    0,
    33,
    5,
    3,
    64,
    32,
    3,
    32,
    5,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    5,
    65,
    1,
    106,
    34,
    5,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    5,
    3,
    64,
    32,
    3,
    65,
    192,
    0,
    106,
    32,
    5,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    5,
    65,
    1,
    106,
    34,
    5,
    65,
    32,
    71,
    13,
    0,
    11,
    32,
    3,
    65,
    224,
    0,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    30,
    0,
    32,
    0,
    32,
    1,
    32,
    2,
    16,
    166,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    0,
    65,
    128,
    136,
    128,
    128,
    0,
    16,
    134,
    128,
    128,
    128,
    0,
    11,
    195,
    6,
    2,
    2,
    127,
    1,
    126,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    160,
    1,
    107,
    34,
    3,
    36,
    128,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    4,
    32,
    3,
    65,
    128,
    1,
    106,
    65,
    24,
    106,
    65,
    0,
    41,
    3,
    200,
    140,
    128,
    128,
    0,
    55,
    3,
    0,
    32,
    3,
    65,
    128,
    1,
    106,
    65,
    16,
    106,
    65,
    0,
    41,
    3,
    192,
    140,
    128,
    128,
    0,
    55,
    3,
    0,
    32,
    3,
    65,
    0,
    41,
    3,
    184,
    140,
    128,
    128,
    0,
    55,
    3,
    136,
    1,
    32,
    3,
    65,
    0,
    41,
    3,
    176,
    140,
    128,
    128,
    0,
    55,
    3,
    128,
    1,
    32,
    3,
    65,
    224,
    0,
    106,
    65,
    24,
    106,
    32,
    1,
    65,
    24,
    106,
    41,
    0,
    0,
    55,
    3,
    0,
    32,
    3,
    65,
    224,
    0,
    106,
    65,
    16,
    106,
    32,
    1,
    65,
    16,
    106,
    41,
    0,
    0,
    55,
    3,
    0,
    32,
    3,
    32,
    1,
    41,
    0,
    0,
    34,
    5,
    55,
    3,
    96,
    32,
    3,
    32,
    1,
    65,
    8,
    106,
    41,
    0,
    0,
    55,
    3,
    104,
    32,
    3,
    32,
    5,
    167,
    65,
    248,
    1,
    113,
    58,
    0,
    96,
    32,
    3,
    32,
    3,
    45,
    0,
    127,
    65,
    63,
    113,
    65,
    192,
    0,
    114,
    58,
    0,
    127,
    32,
    3,
    65,
    24,
    106,
    66,
    0,
    55,
    3,
    0,
    32,
    3,
    65,
    16,
    106,
    66,
    0,
    55,
    3,
    0,
    32,
    3,
    66,
    0,
    55,
    3,
    8,
    32,
    3,
    66,
    0,
    55,
    3,
    0,
    32,
    3,
    65,
    32,
    106,
    33,
    1,
    3,
    64,
    32,
    1,
    32,
    4,
    106,
    32,
    3,
    65,
    224,
    0,
    106,
    32,
    4,
    106,
    40,
    2,
    0,
    54,
    2,
    0,
    32,
    4,
    65,
    4,
    106,
    34,
    4,
    65,
    32,
    71,
    13,
    0,
    11,
    32,
    3,
    65,
    224,
    0,
    106,
    32,
    3,
    16,
    186,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    4,
    3,
    64,
    32,
    3,
    65,
    192,
    0,
    106,
    32,
    4,
    106,
    32,
    3,
    65,
    224,
    0,
    106,
    32,
    4,
    106,
    40,
    2,
    0,
    54,
    2,
    0,
    32,
    4,
    65,
    4,
    106,
    34,
    4,
    65,
    32,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    4,
    3,
    64,
    32,
    3,
    32,
    4,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    4,
    65,
    1,
    106,
    34,
    4,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    65,
    252,
    1,
    33,
    4,
    3,
    64,
    32,
    3,
    65,
    0,
    65,
    192,
    0,
    252,
    11,
    0,
    32,
    3,
    32,
    3,
    65,
    128,
    1,
    106,
    32,
    3,
    65,
    128,
    1,
    106,
    16,
    188,
    128,
    128,
    128,
    0,
    32,
    3,
    65,
    128,
    1,
    106,
    32,
    3,
    16,
    210,
    128,
    128,
    128,
    0,
    2,
    64,
    32,
    4,
    65,
    3,
    118,
    65,
    144,
    140,
    128,
    128,
    0,
    106,
    45,
    0,
    0,
    32,
    4,
    65,
    7,
    113,
    118,
    65,
    1,
    113,
    69,
    13,
    0,
    32,
    3,
    65,
    0,
    65,
    192,
    0,
    252,
    11,
    0,
    32,
    3,
    32,
    3,
    65,
    128,
    1,
    106,
    32,
    3,
    65,
    192,
    0,
    106,
    16,
    188,
    128,
    128,
    128,
    0,
    32,
    3,
    65,
    128,
    1,
    106,
    32,
    3,
    16,
    210,
    128,
    128,
    128,
    0,
    11,
    32,
    4,
    65,
    127,
    106,
    34,
    4,
    65,
    127,
    71,
    13,
    0,
    11,
    32,
    3,
    65,
    40,
    106,
    66,
    0,
    55,
    3,
    0,
    32,
    3,
    65,
    48,
    106,
    66,
    0,
    55,
    3,
    0,
    32,
    3,
    65,
    56,
    106,
    66,
    0,
    55,
    3,
    0,
    32,
    3,
    65,
    24,
    106,
    32,
    3,
    65,
    128,
    1,
    106,
    65,
    24,
    106,
    41,
    3,
    0,
    55,
    3,
    0,
    32,
    3,
    65,
    16,
    106,
    32,
    3,
    65,
    128,
    1,
    106,
    65,
    16,
    106,
    41,
    3,
    0,
    55,
    3,
    0,
    32,
    3,
    32,
    3,
    41,
    3,
    136,
    1,
    55,
    3,
    8,
    32,
    3,
    32,
    3,
    41,
    3,
    128,
    1,
    55,
    3,
    0,
    32,
    3,
    66,
    0,
    55,
    3,
    32,
    32,
    3,
    65,
    128,
    1,
    106,
    32,
    3,
    16,
    210,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    4,
    3,
    64,
    32,
    3,
    65,
    224,
    0,
    106,
    32,
    4,
    106,
    32,
    3,
    65,
    128,
    1,
    106,
    32,
    4,
    106,
    40,
    2,
    0,
    54,
    2,
    0,
    32,
    4,
    65,
    4,
    106,
    34,
    4,
    65,
    32,
    71,
    13,
    0,
    11,
    32,
    3,
    65,
    224,
    0,
    106,
    32,
    3,
    45,
    0,
    96,
    65,
    3,
    108,
    65,
    255,
    1,
    113,
    16,
    202,
    128,
    128,
    128,
    0,
    32,
    0,
    32,
    3,
    65,
    224,
    0,
    106,
    32,
    2,
    65,
    128,
    2,
    16,
    167,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    4,
    3,
    64,
    32,
    3,
    65,
    224,
    0,
    106,
    32,
    4,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    4,
    65,
    1,
    106,
    34,
    4,
    65,
    32,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    4,
    3,
    64,
    32,
    3,
    65,
    192,
    0,
    106,
    32,
    4,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    4,
    65,
    1,
    106,
    34,
    4,
    65,
    32,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    4,
    3,
    64,
    32,
    3,
    32,
    4,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    4,
    65,
    1,
    106,
    34,
    4,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    4,
    3,
    64,
    32,
    3,
    65,
    128,
    1,
    106,
    32,
    4,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    4,
    65,
    1,
    106,
    34,
    4,
    65,
    32,
    71,
    13,
    0,
    11,
    32,
    3,
    65,
    160,
    1,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    240,
    2,
    5,
    4,
    127,
    1,
    126,
    1,
    127,
    1,
    126,
    1,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    224,
    0,
    107,
    34,
    2,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    2,
    65,
    216,
    0,
    106,
    66,
    0,
    55,
    3,
    0,
    32,
    2,
    65,
    208,
    0,
    106,
    66,
    0,
    55,
    3,
    0,
    32,
    2,
    66,
    0,
    55,
    3,
    72,
    32,
    2,
    66,
    0,
    55,
    3,
    64,
    65,
    0,
    33,
    3,
    65,
    32,
    33,
    4,
    32,
    2,
    65,
    192,
    0,
    106,
    33,
    5,
    3,
    64,
    32,
    1,
    32,
    3,
    65,
    2,
    116,
    106,
    53,
    2,
    0,
    33,
    6,
    65,
    0,
    33,
    7,
    66,
    0,
    33,
    8,
    3,
    64,
    32,
    5,
    32,
    7,
    106,
    34,
    9,
    32,
    8,
    32,
    9,
    53,
    2,
    0,
    124,
    32,
    7,
    65,
    224,
    165,
    128,
    128,
    0,
    106,
    53,
    2,
    0,
    32,
    6,
    126,
    124,
    34,
    8,
    62,
    2,
    0,
    32,
    8,
    66,
    32,
    136,
    33,
    8,
    32,
    4,
    32,
    7,
    65,
    4,
    106,
    34,
    7,
    71,
    13,
    0,
    11,
    32,
    5,
    65,
    4,
    106,
    33,
    5,
    32,
    4,
    65,
    124,
    106,
    33,
    4,
    32,
    3,
    65,
    1,
    106,
    34,
    3,
    65,
    8,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    7,
    32,
    2,
    65,
    0,
    65,
    192,
    0,
    252,
    11,
    0,
    32,
    2,
    32,
    2,
    65,
    192,
    0,
    106,
    65,
    192,
    156,
    128,
    128,
    0,
    16,
    188,
    128,
    128,
    128,
    0,
    66,
    0,
    33,
    8,
    3,
    64,
    32,
    2,
    32,
    7,
    106,
    34,
    9,
    32,
    8,
    32,
    9,
    53,
    2,
    0,
    124,
    32,
    1,
    32,
    7,
    106,
    53,
    2,
    0,
    124,
    34,
    8,
    62,
    2,
    0,
    32,
    8,
    66,
    32,
    136,
    33,
    8,
    32,
    7,
    65,
    4,
    106,
    34,
    7,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    32,
    0,
    32,
    2,
    65,
    32,
    106,
    16,
    211,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    7,
    3,
    64,
    32,
    2,
    65,
    192,
    0,
    106,
    32,
    7,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    7,
    65,
    1,
    106,
    34,
    7,
    65,
    32,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    7,
    3,
    64,
    32,
    2,
    32,
    7,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    7,
    65,
    1,
    106,
    34,
    7,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    32,
    2,
    65,
    224,
    0,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    140,
    1,
    2,
    1,
    126,
    2,
    127,
    66,
    1,
    33,
    2,
    65,
    0,
    33,
    3,
    3,
    64,
    32,
    2,
    32,
    1,
    32,
    3,
    106,
    53,
    2,
    0,
    124,
    32,
    3,
    65,
    192,
    156,
    128,
    128,
    0,
    106,
    53,
    2,
    0,
    66,
    255,
    255,
    255,
    255,
    15,
    133,
    124,
    66,
    32,
    136,
    33,
    2,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    32,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    3,
    65,
    0,
    32,
    2,
    167,
    107,
    33,
    4,
    3,
    64,
    32,
    0,
    32,
    3,
    106,
    32,
    2,
    32,
    1,
    32,
    3,
    106,
    53,
    2,
    0,
    124,
    32,
    3,
    65,
    192,
    156,
    128,
    128,
    0,
    106,
    40,
    2,
    0,
    65,
    127,
    115,
    32,
    4,
    113,
    173,
    124,
    34,
    2,
    62,
    2,
    0,
    32,
    2,
    66,
    32,
    136,
    33,
    2,
    32,
    3,
    65,
    4,
    106,
    34,
    3,
    65,
    32,
    71,
    13,
    0,
    11,
    11,
    183,
    1,
    1,
    1,
    127,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    224,
    0,
    107,
    34,
    8,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    8,
    65,
    192,
    0,
    106,
    32,
    2,
    32,
    3,
    16,
    134,
    128,
    128,
    128,
    0,
    32,
    8,
    65,
    0,
    65,
    192,
    0,
    32,
    8,
    65,
    192,
    0,
    106,
    32,
    3,
    65,
    16,
    106,
    34,
    3,
    66,
    0,
    16,
    137,
    128,
    128,
    128,
    0,
    26,
    32,
    1,
    32,
    6,
    32,
    7,
    32,
    8,
    65,
    192,
    0,
    106,
    32,
    3,
    66,
    1,
    16,
    137,
    128,
    128,
    128,
    0,
    26,
    32,
    0,
    32,
    8,
    32,
    4,
    32,
    5,
    32,
    1,
    32,
    7,
    16,
    213,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    8,
    65,
    192,
    0,
    106,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    32,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    1,
    3,
    64,
    32,
    8,
    32,
    1,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    1,
    65,
    1,
    106,
    34,
    1,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    32,
    8,
    65,
    224,
    0,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    234,
    1,
    2,
    1,
    127,
    1,
    126,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    224,
    0,
    107,
    34,
    6,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    6,
    65,
    0,
    54,
    2,
    92,
    32,
    6,
    32,
    5,
    58,
    0,
    88,
    32,
    6,
    65,
    0,
    54,
    2,
    84,
    32,
    6,
    32,
    3,
    58,
    0,
    80,
    32,
    6,
    32,
    5,
    173,
    34,
    7,
    66,
    24,
    136,
    60,
    0,
    91,
    32,
    6,
    32,
    7,
    66,
    16,
    136,
    60,
    0,
    90,
    32,
    6,
    32,
    7,
    66,
    8,
    136,
    60,
    0,
    89,
    32,
    6,
    32,
    3,
    173,
    34,
    7,
    66,
    24,
    136,
    60,
    0,
    83,
    32,
    6,
    32,
    7,
    66,
    16,
    136,
    60,
    0,
    82,
    32,
    6,
    32,
    7,
    66,
    8,
    136,
    60,
    0,
    81,
    32,
    6,
    32,
    1,
    16,
    142,
    128,
    128,
    128,
    0,
    32,
    6,
    32,
    2,
    32,
    3,
    16,
    143,
    128,
    128,
    128,
    0,
    32,
    6,
    65,
    128,
    136,
    128,
    128,
    0,
    65,
    0,
    32,
    3,
    107,
    65,
    15,
    113,
    16,
    143,
    128,
    128,
    128,
    0,
    32,
    6,
    32,
    4,
    32,
    5,
    16,
    143,
    128,
    128,
    128,
    0,
    32,
    6,
    65,
    128,
    136,
    128,
    128,
    0,
    65,
    0,
    32,
    5,
    107,
    65,
    15,
    113,
    16,
    143,
    128,
    128,
    128,
    0,
    32,
    6,
    32,
    6,
    65,
    208,
    0,
    106,
    65,
    16,
    16,
    143,
    128,
    128,
    128,
    0,
    32,
    6,
    32,
    0,
    16,
    146,
    128,
    128,
    128,
    0,
    32,
    6,
    65,
    224,
    0,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    11,
    215,
    2,
    2,
    1,
    127,
    1,
    126,
    35,
    128,
    128,
    128,
    128,
    0,
    65,
    240,
    0,
    107,
    34,
    8,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    8,
    65,
    208,
    0,
    106,
    32,
    1,
    32,
    2,
    16,
    134,
    128,
    128,
    128,
    0,
    32,
    8,
    65,
    16,
    106,
    65,
    0,
    65,
    192,
    0,
    32,
    8,
    65,
    208,
    0,
    106,
    32,
    2,
    65,
    16,
    106,
    34,
    1,
    66,
    0,
    16,
    137,
    128,
    128,
    128,
    0,
    26,
    32,
    8,
    32,
    8,
    65,
    16,
    106,
    32,
    4,
    32,
    5,
    32,
    6,
    32,
    7,
    16,
    213,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    8,
    65,
    16,
    106,
    32,
    2,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    2,
    65,
    1,
    106,
    34,
    2,
    65,
    192,
    0,
    71,
    13,
    0,
    11,
    2,
    64,
    2,
    64,
    32,
    3,
    32,
    8,
    16,
    129,
    128,
    128,
    128,
    0,
    34,
    9,
    66,
    32,
    136,
    32,
    9,
    66,
    255,
    255,
    255,
    255,
    15,
    131,
    132,
    66,
    127,
    124,
    66,
    128,
    128,
    128,
    128,
    16,
    131,
    66,
    0,
    82,
    13,
    0,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    8,
    65,
    208,
    0,
    106,
    32,
    2,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    2,
    65,
    1,
    106,
    34,
    2,
    65,
    32,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    8,
    32,
    2,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    2,
    65,
    1,
    106,
    34,
    2,
    65,
    16,
    71,
    13,
    0,
    11,
    65,
    127,
    33,
    6,
    12,
    1,
    11,
    32,
    0,
    32,
    6,
    32,
    7,
    32,
    8,
    65,
    208,
    0,
    106,
    32,
    1,
    66,
    1,
    16,
    137,
    128,
    128,
    128,
    0,
    26,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    8,
    65,
    208,
    0,
    106,
    32,
    2,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    2,
    65,
    1,
    106,
    34,
    2,
    65,
    32,
    71,
    13,
    0,
    11,
    65,
    0,
    33,
    6,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    8,
    32,
    2,
    106,
    65,
    0,
    58,
    0,
    0,
    32,
    2,
    65,
    1,
    106,
    34,
    2,
    65,
    16,
    71,
    13,
    0,
    11,
    11,
    32,
    8,
    65,
    240,
    0,
    106,
    36,
    128,
    128,
    128,
    128,
    0,
    32,
    6,
    11,
    24,
    0,
    32,
    0,
    32,
    1,
    32,
    2,
    32,
    3,
    65,
    0,
    65,
    0,
    32,
    4,
    32,
    5,
    16,
    212,
    128,
    128,
    128,
    0,
    11,
    24,
    0,
    32,
    0,
    32,
    1,
    32,
    2,
    32,
    3,
    65,
    0,
    65,
    0,
    32,
    4,
    32,
    5,
    16,
    214,
    128,
    128,
    128,
    0,
    11,
    92,
    1,
    2,
    127,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    1,
    32,
    2,
    106,
    32,
    0,
    32,
    2,
    106,
    41,
    3,
    0,
    55,
    3,
    0,
    32,
    2,
    65,
    8,
    106,
    34,
    2,
    65,
    128,
    8,
    71,
    13,
    0,
    11,
    32,
    0,
    16,
    164,
    128,
    128,
    128,
    0,
    65,
    0,
    33,
    2,
    3,
    64,
    32,
    0,
    32,
    2,
    106,
    34,
    3,
    32,
    3,
    41,
    3,
    0,
    32,
    1,
    32,
    2,
    106,
    41,
    3,
    0,
    133,
    55,
    3,
    0,
    32,
    2,
    65,
    8,
    106,
    34,
    2,
    65,
    128,
    8,
    71,
    13,
    0,
    11,
    11,
    223,
    2,
    1,
    5,
    127,
    65,
    0,
    33,
    1,
    2,
    64,
    32,
    0,
    65,
    7,
    106,
    34,
    2,
    65,
    16,
    73,
    13,
    0,
    65,
    1,
    33,
    1,
    32,
    2,
    65,
    3,
    118,
    34,
    3,
    65,
    2,
    70,
    13,
    0,
    65,
    2,
    33,
    1,
    32,
    2,
    65,
    32,
    73,
    13,
    0,
    65,
    3,
    33,
    1,
    32,
    3,
    65,
    4,
    70,
    13,
    0,
    65,
    4,
    33,
    1,
    32,
    2,
    65,
    48,
    73,
    13,
    0,
    65,
    5,
    33,
    1,
    32,
    3,
    65,
    6,
    70,
    13,
    0,
    65,
    6,
    33,
    1,
    32,
    2,
    65,
    200,
    0,
    73,
    13,
    0,
    65,
    7,
    33,
    1,
    32,
    2,
    65,
    216,
    0,
    73,
    13,
    0,
    65,
    8,
    33,
    1,
    32,
    2,
    65,
    136,
    1,
    73,
    13,
    0,
    65,
    9,
    33,
    1,
    32,
    2,
    65,
    136,
    2,
    73,
    13,
    0,
    32,
    0,
    16,
    219,
    128,
    128,
    128,
    0,
    34,
    0,
    65,
    8,
    106,
    65,
    0,
    32,
    0,
    27,
    15,
    11,
    2,
    64,
    2,
    64,
    32,
    1,
    65,
    2,
    116,
    65,
    192,
    166,
    128,
    128,
    0,
    106,
    34,
    4,
    40,
    2,
    0,
    34,
    0,
    13,
    0,
    65,
    0,
    33,
    0,
    2,
    64,
    2,
    64,
    65,
    0,
    40,
    2,
    228,
    166,
    128,
    128,
    0,
    34,
    2,
    69,
    13,
    0,
    65,
    0,
    32,
    2,
    40,
    2,
    0,
    54,
    2,
    228,
    166,
    128,
    128,
    0,
    12,
    1,
    11,
    65,
    0,
    16,
    219,
    128,
    128,
    128,
    0,
    34,
    2,
    69,
    13,
    2,
    11,
    32,
    2,
    65,
    128,
    128,
    124,
    113,
    34,
    0,
    32,
    2,
    65,
    8,
    118,
    65,
    255,
    1,
    113,
    34,
    2,
    114,
    32,
    1,
    58,
    0,
    0,
    32,
    2,
    65,
    8,
    116,
    32,
    0,
    114,
    65,
    128,
    2,
    106,
    33,
    0,
    65,
    0,
    33,
    2,
    65,
    0,
    32,
    1,
    65,
    2,
    116,
    65,
    128,
    166,
    128,
    128,
    0,
    106,
    40,
    2,
    0,
    34,
    3,
    107,
    33,
    5,
    32,
    3,
    33,
    1,
    3,
    64,
    32,
    0,
    32,
    5,
    106,
    34,
    0,
    32,
    2,
    54,
    2,
    0,
    32,
    0,
    33,
    2,
    32,
    1,
    32,
    3,
    106,
    34,
    1,
    65,
    129,
    2,
    73,
    13,
    0,
    11,
    32,
    4,
    32,
    0,
    54,
    2,
    0,
    11,
    32,
    4,
    32,
    0,
    40,
    2,
    0,
    54,
    2,
    0,
    11,
    32,
    0,
    11,
    190,
    9,
    1,
    7,
    127,
    2,
    64,
    2,
    64,
    2,
    64,
    2,
    64,
    2,
    64,
    2,
    64,
    65,
    0,
    45,
    0,
    180,
    166,
    128,
    128,
    0,
    69,
    13,
    0,
    65,
    0,
    65,
    0,
    58,
    0,
    180,
    166,
    128,
    128,
    0,
    65,
    0,
    40,
    2,
    176,
    166,
    128,
    128,
    0,
    34,
    1,
    69,
    13,
    1,
    65,
    176,
    166,
    128,
    128,
    0,
    33,
    2,
    3,
    64,
    32,
    1,
    65,
    8,
    106,
    34,
    3,
    32,
    1,
    40,
    2,
    4,
    34,
    4,
    106,
    34,
    5,
    65,
    255,
    1,
    106,
    65,
    128,
    126,
    113,
    32,
    5,
    71,
    13,
    6,
    32,
    5,
    33,
    6,
    3,
    64,
    2,
    64,
    2,
    64,
    32,
    5,
    65,
    8,
    118,
    65,
    255,
    1,
    113,
    34,
    7,
    69,
    13,
    0,
    32,
    5,
    65,
    128,
    128,
    124,
    113,
    32,
    7,
    114,
    45,
    0,
    0,
    65,
    254,
    1,
    71,
    13,
    0,
    65,
    0,
    40,
    2,
    176,
    166,
    128,
    128,
    0,
    34,
    5,
    69,
    13,
    9,
    2,
    64,
    32,
    5,
    32,
    6,
    71,
    13,
    0,
    65,
    176,
    166,
    128,
    128,
    0,
    33,
    7,
    12,
    2,
    11,
    3,
    64,
    32,
    5,
    34,
    7,
    40,
    2,
    0,
    34,
    5,
    69,
    13,
    10,
    32,
    5,
    32,
    6,
    70,
    13,
    2,
    12,
    0,
    11,
    11,
    32,
    2,
    40,
    2,
    0,
    34,
    2,
    40,
    2,
    0,
    34,
    1,
    13,
    2,
    12,
    3,
    11,
    32,
    7,
    32,
    6,
    40,
    2,
    0,
    54,
    2,
    0,
    32,
    1,
    32,
    4,
    32,
    6,
    40,
    2,
    4,
    106,
    65,
    8,
    106,
    34,
    4,
    54,
    2,
    4,
    32,
    7,
    32,
    2,
    32,
    2,
    32,
    6,
    70,
    27,
    33,
    2,
    32,
    3,
    32,
    4,
    106,
    34,
    5,
    33,
    6,
    32,
    5,
    65,
    255,
    1,
    106,
    65,
    128,
    126,
    113,
    32,
    5,
    70,
    13,
    0,
    12,
    7,
    11,
    11,
    11,
    65,
    0,
    40,
    2,
    176,
    166,
    128,
    128,
    0,
    34,
    6,
    69,
    13,
    0,
    32,
    0,
    65,
    135,
    2,
    106,
    65,
    128,
    126,
    113,
    33,
    3,
    65,
    127,
    33,
    2,
    65,
    176,
    166,
    128,
    128,
    0,
    33,
    4,
    65,
    0,
    33,
    1,
    65,
    176,
    166,
    128,
    128,
    0,
    33,
    5,
    3,
    64,
    32,
    5,
    33,
    7,
    2,
    64,
    32,
    6,
    34,
    5,
    40,
    2,
    4,
    34,
    6,
    32,
    0,
    73,
    13,
    0,
    32,
    6,
    32,
    2,
    79,
    13,
    0,
    32,
    6,
    33,
    2,
    32,
    7,
    33,
    4,
    32,
    5,
    33,
    1,
    32,
    6,
    65,
    8,
    106,
    32,
    3,
    71,
    13,
    0,
    32,
    7,
    33,
    4,
    32,
    6,
    33,
    2,
    32,
    5,
    33,
    1,
    12,
    4,
    11,
    32,
    5,
    40,
    2,
    0,
    34,
    6,
    13,
    0,
    11,
    32,
    1,
    13,
    2,
    12,
    1,
    11,
    65,
    176,
    166,
    128,
    128,
    0,
    33,
    4,
    11,
    63,
    0,
    65,
    16,
    116,
    33,
    3,
    32,
    0,
    65,
    136,
    2,
    106,
    33,
    2,
    65,
    0,
    33,
    7,
    2,
    64,
    2,
    64,
    65,
    0,
    40,
    2,
    184,
    166,
    128,
    128,
    0,
    34,
    1,
    69,
    13,
    0,
    65,
    0,
    33,
    6,
    32,
    3,
    33,
    5,
    12,
    1,
    11,
    65,
    0,
    32,
    3,
    65,
    240,
    166,
    132,
    128,
    0,
    65,
    255,
    255,
    3,
    106,
    65,
    128,
    128,
    124,
    113,
    34,
    5,
    107,
    34,
    1,
    54,
    2,
    184,
    166,
    128,
    128,
    0,
    32,
    1,
    33,
    6,
    11,
    2,
    64,
    32,
    2,
    32,
    6,
    77,
    13,
    0,
    32,
    2,
    32,
    6,
    107,
    34,
    7,
    32,
    1,
    65,
    1,
    118,
    34,
    2,
    32,
    2,
    32,
    7,
    73,
    27,
    65,
    255,
    255,
    3,
    106,
    34,
    2,
    65,
    128,
    128,
    124,
    113,
    34,
    7,
    69,
    13,
    3,
    32,
    2,
    65,
    16,
    118,
    64,
    0,
    65,
    127,
    70,
    13,
    2,
    65,
    0,
    65,
    0,
    40,
    2,
    184,
    166,
    128,
    128,
    0,
    32,
    7,
    106,
    54,
    2,
    184,
    166,
    128,
    128,
    0,
    11,
    32,
    7,
    32,
    6,
    106,
    34,
    6,
    69,
    13,
    2,
    32,
    6,
    32,
    6,
    65,
    255,
    255,
    3,
    106,
    65,
    128,
    128,
    124,
    113,
    71,
    13,
    2,
    32,
    5,
    69,
    13,
    1,
    32,
    5,
    65,
    255,
    1,
    58,
    0,
    1,
    32,
    5,
    65,
    132,
    2,
    106,
    32,
    6,
    65,
    128,
    128,
    124,
    113,
    65,
    248,
    125,
    106,
    34,
    2,
    54,
    2,
    0,
    32,
    5,
    65,
    0,
    40,
    2,
    176,
    166,
    128,
    128,
    0,
    54,
    2,
    128,
    2,
    32,
    2,
    32,
    0,
    65,
    8,
    106,
    73,
    13,
    2,
    32,
    5,
    65,
    128,
    2,
    106,
    33,
    1,
    11,
    32,
    1,
    65,
    128,
    128,
    124,
    113,
    34,
    5,
    32,
    1,
    65,
    8,
    118,
    65,
    255,
    1,
    113,
    114,
    65,
    255,
    1,
    58,
    0,
    0,
    32,
    4,
    32,
    1,
    40,
    2,
    0,
    54,
    2,
    0,
    2,
    64,
    2,
    64,
    32,
    2,
    32,
    0,
    107,
    65,
    128,
    126,
    113,
    34,
    6,
    13,
    0,
    32,
    1,
    33,
    3,
    12,
    1,
    11,
    2,
    64,
    2,
    64,
    32,
    5,
    32,
    6,
    65,
    127,
    115,
    32,
    1,
    65,
    8,
    106,
    34,
    4,
    32,
    2,
    106,
    34,
    7,
    106,
    65,
    128,
    128,
    124,
    113,
    71,
    13,
    0,
    32,
    1,
    33,
    3,
    32,
    7,
    65,
    255,
    1,
    106,
    65,
    128,
    126,
    113,
    32,
    7,
    71,
    13,
    4,
    12,
    1,
    11,
    32,
    7,
    65,
    255,
    255,
    3,
    106,
    65,
    128,
    128,
    124,
    113,
    33,
    6,
    2,
    64,
    32,
    0,
    65,
    247,
    253,
    3,
    75,
    13,
    0,
    32,
    6,
    32,
    7,
    71,
    13,
    4,
    32,
    5,
    32,
    4,
    65,
    8,
    118,
    65,
    255,
    1,
    113,
    106,
    65,
    254,
    1,
    58,
    0,
    0,
    32,
    1,
    65,
    0,
    40,
    2,
    176,
    166,
    128,
    128,
    0,
    54,
    2,
    0,
    32,
    1,
    65,
    128,
    128,
    4,
    32,
    4,
    65,
    255,
    255,
    3,
    113,
    107,
    34,
    6,
    54,
    2,
    4,
    65,
    0,
    32,
    1,
    54,
    2,
    176,
    166,
    128,
    128,
    0,
    16,
    221,
    128,
    128,
    128,
    0,
    32,
    5,
    65,
    132,
    130,
    4,
    106,
    32,
    2,
    32,
    6,
    107,
    65,
    248,
    125,
    106,
    34,
    6,
    54,
    2,
    0,
    32,
    5,
    65,
    129,
    128,
    4,
    106,
    65,
    255,
    1,
    58,
    0,
    0,
    32,
    6,
    32,
    0,
    73,
    13,
    4,
    32,
    5,
    65,
    128,
    130,
    4,
    106,
    33,
    3,
    32,
    6,
    32,
    0,
    107,
    65,
    128,
    126,
    113,
    33,
    6,
    12,
    1,
    11,
    32,
    6,
    32,
    7,
    71,
    13,
    3,
    32,
    2,
    32,
    4,
    65,
    255,
    255,
    3,
    113,
    34,
    5,
    106,
    32,
    0,
    32,
    5,
    106,
    65,
    127,
    106,
    65,
    128,
    128,
    124,
    113,
    107,
    65,
    128,
    128,
    124,
    106,
    33,
    6,
    32,
    1,
    33,
    3,
    11,
    32,
    3,
    32,
    3,
    40,
    2,
    4,
    32,
    6,
    107,
    54,
    2,
    4,
    65,
    0,
    32,
    6,
    107,
    33,
    5,
    32,
    7,
    32,
    6,
    107,
    65,
    8,
    118,
    65,
    255,
    1,
    113,
    33,
    6,
    2,
    64,
    3,
    64,
    32,
    5,
    34,
    7,
    65,
    128,
    2,
    106,
    33,
    5,
    32,
    6,
    34,
    4,
    13,
    1,
    65,
    1,
    33,
    6,
    32,
    7,
    13,
    0,
    11,
    11,
    32,
    7,
    69,
    13,
    0,
    32,
    2,
    32,
    1,
    106,
    32,
    5,
    106,
    65,
    136,
    126,
    106,
    65,
    128,
    128,
    124,
    113,
    34,
    6,
    32,
    4,
    106,
    65,
    254,
    1,
    58,
    0,
    0,
    32,
    6,
    32,
    4,
    65,
    8,
    116,
    106,
    34,
    6,
    65,
    248,
    1,
    32,
    5,
    107,
    54,
    2,
    4,
    32,
    6,
    65,
    0,
    40,
    2,
    176,
    166,
    128,
    128,
    0,
    54,
    2,
    0,
    32,
    6,
    32,
    5,
    107,
    34,
    5,
    65,
    128,
    2,
    106,
    32,
    5,
    65,
    255,
    3,
    106,
    65,
    128,
    126,
    113,
    71,
    13,
    2,
    65,
    0,
    32,
    6,
    54,
    2,
    176,
    166,
    128,
    128,
    0,
    16,
    221,
    128,
    128,
    128,
    0,
    11,
    32,
    3,
    32,
    3,
    40,
    2,
    4,
    106,
    34,
    5,
    65,
    135,
    2,
    106,
    65,
    128,
    126,
    113,
    32,
    5,
    65,
    8,
    106,
    71,
    13,
    1,
    32,
    3,
    15,
    11,
    65,
    0,
    15,
    11,
    0,
    0,
    11,
    137,
    1,
    1,
    2,
    127,
    2,
    64,
    2,
    64,
    32,
    0,
    69,
    13,
    0,
    2,
    64,
    32,
    0,
    65,
    128,
    128,
    124,
    113,
    32,
    0,
    65,
    8,
    118,
    65,
    255,
    1,
    113,
    114,
    34,
    1,
    45,
    0,
    0,
    34,
    2,
    65,
    255,
    1,
    71,
    13,
    0,
    32,
    0,
    65,
    120,
    106,
    34,
    0,
    65,
    0,
    40,
    2,
    176,
    166,
    128,
    128,
    0,
    54,
    2,
    0,
    65,
    0,
    32,
    0,
    54,
    2,
    176,
    166,
    128,
    128,
    0,
    32,
    1,
    65,
    254,
    1,
    58,
    0,
    0,
    65,
    0,
    65,
    1,
    58,
    0,
    180,
    166,
    128,
    128,
    0,
    15,
    11,
    32,
    2,
    65,
    10,
    79,
    13,
    1,
    32,
    0,
    32,
    2,
    65,
    2,
    116,
    65,
    192,
    166,
    128,
    128,
    0,
    106,
    34,
    2,
    40,
    2,
    0,
    54,
    2,
    0,
    32,
    2,
    32,
    0,
    54,
    2,
    0,
    11,
    15,
    11,
    0,
    0,
    11,
    107,
    1,
    2,
    127,
    2,
    64,
    65,
    0,
    40,
    2,
    176,
    166,
    128,
    128,
    0,
    34,
    0,
    40,
    2,
    4,
    65,
    255,
    1,
    75,
    13,
    0,
    32,
    0,
    65,
    128,
    128,
    124,
    113,
    34,
    1,
    32,
    0,
    65,
    8,
    118,
    65,
    255,
    1,
    113,
    34,
    0,
    114,
    65,
    9,
    58,
    0,
    0,
    65,
    0,
    65,
    0,
    40,
    2,
    176,
    166,
    128,
    128,
    0,
    40,
    2,
    0,
    54,
    2,
    176,
    166,
    128,
    128,
    0,
    32,
    1,
    32,
    0,
    65,
    8,
    116,
    114,
    34,
    0,
    65,
    0,
    40,
    2,
    228,
    166,
    128,
    128,
    0,
    54,
    2,
    0,
    65,
    0,
    32,
    0,
    54,
    2,
    228,
    166,
    128,
    128,
    0,
    11,
    11,
    11,
    176,
    30,
    1,
    0,
    65,
    128,
    8,
    11,
    168,
    30,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8,
    201,
    188,
    243,
    103,
    230,
    9,
    106,
    59,
    167,
    202,
    132,
    133,
    174,
    103,
    187,
    43,
    248,
    148,
    254,
    114,
    243,
    110,
    60,
    241,
    54,
    29,
    95,
    58,
    245,
    79,
    165,
    209,
    130,
    230,
    173,
    127,
    82,
    14,
    81,
    31,
    108,
    62,
    43,
    140,
    104,
    5,
    155,
    107,
    189,
    65,
    251,
    171,
    217,
    131,
    31,
    121,
    33,
    126,
    19,
    25,
    205,
    224,
    91,
    1,
    0,
    0,
    0,
    2,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    4,
    0,
    0,
    0,
    96,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    9,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    52,
    252,
    108,
    183,
    200,
    222,
    88,
    151,
    119,
    112,
    217,
    82,
    22,
    204,
    220,
    108,
    133,
    144,
    190,
    205,
    145,
    156,
    7,
    89,
    148,
    20,
    86,
    59,
    75,
    164,
    71,
    15,
    176,
    160,
    14,
    254,
    211,
    201,
    134,
    255,
    158,
    24,
    143,
    0,
    127,
    105,
    53,
    0,
    96,
    12,
    189,
    0,
    167,
    215,
    251,
    255,
    159,
    76,
    128,
    254,
    106,
    101,
    225,
    255,
    30,
    252,
    4,
    0,
    146,
    12,
    174,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    74,
    209,
    69,
    1,
    177,
    145,
    81,
    0,
    212,
    27,
    71,
    0,
    47,
    159,
    128,
    255,
    242,
    100,
    112,
    1,
    187,
    74,
    222,
    0,
    28,
    153,
    204,
    1,
    38,
    29,
    69,
    255,
    149,
    99,
    0,
    254,
    231,
    86,
    127,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    38,
    232,
    149,
    255,
    164,
    176,
    236,
    255,
    5,
    182,
    104,
    0,
    166,
    79,
    148,
    255,
    192,
    99,
    194,
    255,
    214,
    223,
    172,
    255,
    131,
    105,
    227,
    1,
    38,
    39,
    22,
    255,
    36,
    128,
    216,
    254,
    78,
    241,
    23,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    89,
    241,
    178,
    254,
    10,
    229,
    166,
    255,
    123,
    221,
    42,
    254,
    30,
    20,
    212,
    0,
    82,
    128,
    3,
    0,
    48,
    209,
    243,
    0,
    119,
    121,
    64,
    255,
    50,
    227,
    156,
    255,
    0,
    110,
    197,
    1,
    103,
    27,
    144,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    141,
    190,
    226,
    255,
    91,
    108,
    242,
    0,
    196,
    206,
    225,
    254,
    2,
    45,
    149,
    255,
    64,
    231,
    133,
    254,
    178,
    80,
    8,
    0,
    194,
    102,
    255,
    254,
    45,
    53,
    61,
    0,
    196,
    7,
    246,
    255,
    220,
    230,
    163,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    235,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16,
    29,
    149,
    152,
    141,
    116,
    49,
    236,
    214,
    112,
    207,
    125,
    115,
    244,
    91,
    239,
    198,
    254,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    15,
    247,
    233,
    122,
    46,
    141,
    49,
    9,
    44,
    107,
    206,
    123,
    81,
    239,
    124,
    111,
    10,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8,
    142,
    74,
    204,
    70,
    186,
    24,
    118,
    107,
    184,
    231,
    190,
    57,
    250,
    173,
    119,
    99,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    7,
    167,
    252,
    151,
    255,
    65,
    137,
    220,
    255,
    75,
    197,
    167,
    254,
    204,
    229,
    1,
    0,
    2,
    229,
    18,
    1,
    233,
    196,
    127,
    0,
    124,
    20,
    49,
    1,
    224,
    53,
    30,
    0,
    91,
    243,
    228,
    254,
    131,
    160,
    138,
    0,
    17,
    67,
    157,
    0,
    48,
    39,
    6,
    0,
    85,
    112,
    226,
    0,
    170,
    255,
    146,
    0,
    206,
    35,
    129,
    0,
    91,
    131,
    128,
    255,
    119,
    182,
    37,
    255,
    47,
    212,
    223,
    0,
    182,
    83,
    145,
    1,
    0,
    2,
    43,
    0,
    68,
    154,
    165,
    254,
    232,
    3,
    207,
    255,
    132,
    243,
    44,
    255,
    140,
    83,
    211,
    255,
    63,
    225,
    6,
    255,
    152,
    32,
    42,
    255,
    110,
    118,
    197,
    0,
    241,
    182,
    2,
    0,
    139,
    161,
    185,
    0,
    59,
    105,
    219,
    255,
    106,
    150,
    68,
    255,
    14,
    218,
    148,
    255,
    157,
    95,
    151,
    0,
    218,
    61,
    209,
    255,
    245,
    119,
    21,
    254,
    174,
    172,
    44,
    0,
    116,
    174,
    85,
    1,
    121,
    94,
    29,
    255,
    231,
    128,
    41,
    0,
    197,
    70,
    250,
    0,
    159,
    146,
    145,
    255,
    80,
    212,
    183,
    255,
    2,
    252,
    40,
    0,
    129,
    111,
    156,
    255,
    238,
    21,
    142,
    254,
    141,
    197,
    12,
    255,
    199,
    206,
    160,
    255,
    39,
    227,
    214,
    0,
    181,
    80,
    153,
    0,
    93,
    150,
    186,
    0,
    156,
    172,
    46,
    254,
    191,
    65,
    59,
    255,
    83,
    177,
    85,
    255,
    205,
    1,
    54,
    0,
    128,
    124,
    80,
    255,
    60,
    164,
    251,
    0,
    242,
    162,
    95,
    254,
    254,
    166,
    26,
    255,
    89,
    6,
    145,
    255,
    9,
    220,
    12,
    255,
    238,
    84,
    13,
    1,
    153,
    226,
    8,
    0,
    4,
    223,
    242,
    255,
    159,
    34,
    253,
    255,
    60,
    200,
    71,
    255,
    1,
    252,
    92,
    255,
    131,
    114,
    201,
    254,
    208,
    100,
    237,
    0,
    115,
    224,
    37,
    254,
    75,
    106,
    179,
    255,
    144,
    30,
    160,
    255,
    134,
    132,
    221,
    255,
    57,
    173,
    184,
    255,
    63,
    211,
    185,
    255,
    104,
    154,
    193,
    255,
    232,
    192,
    189,
    0,
    33,
    187,
    34,
    254,
    155,
    45,
    16,
    0,
    47,
    118,
    95,
    0,
    86,
    236,
    159,
    0,
    78,
    88,
    44,
    255,
    60,
    235,
    30,
    0,
    20,
    102,
    177,
    254,
    155,
    42,
    214,
    255,
    248,
    70,
    219,
    255,
    84,
    101,
    133,
    255,
    126,
    60,
    112,
    0,
    252,
    18,
    240,
    0,
    106,
    64,
    155,
    254,
    107,
    70,
    114,
    0,
    31,
    8,
    105,
    0,
    100,
    155,
    10,
    0,
    235,
    244,
    97,
    1,
    170,
    40,
    147,
    0,
    170,
    227,
    1,
    254,
    136,
    66,
    173,
    0,
    50,
    197,
    204,
    254,
    89,
    122,
    97,
    0,
    95,
    232,
    129,
    255,
    114,
    108,
    126,
    255,
    178,
    66,
    138,
    255,
    169,
    101,
    48,
    255,
    226,
    198,
    47,
    255,
    38,
    46,
    225,
    0,
    65,
    131,
    215,
    254,
    236,
    157,
    27,
    255,
    236,
    18,
    158,
    0,
    42,
    62,
    87,
    255,
    101,
    75,
    177,
    254,
    171,
    93,
    184,
    0,
    159,
    73,
    84,
    255,
    246,
    182,
    12,
    255,
    64,
    77,
    153,
    0,
    229,
    158,
    82,
    0,
    67,
    10,
    123,
    1,
    167,
    101,
    123,
    0,
    170,
    216,
    153,
    255,
    179,
    149,
    150,
    0,
    132,
    189,
    241,
    0,
    237,
    109,
    8,
    255,
    231,
    21,
    147,
    0,
    139,
    56,
    180,
    0,
    158,
    171,
    145,
    254,
    138,
    201,
    113,
    255,
    233,
    180,
    59,
    0,
    65,
    152,
    105,
    255,
    29,
    51,
    15,
    0,
    157,
    210,
    122,
    255,
    110,
    231,
    119,
    255,
    166,
    228,
    40,
    255,
    227,
    155,
    110,
    0,
    212,
    197,
    220,
    0,
    92,
    245,
    128,
    1,
    101,
    204,
    121,
    255,
    99,
    232,
    218,
    0,
    22,
    128,
    125,
    0,
    203,
    122,
    97,
    0,
    205,
    108,
    146,
    255,
    122,
    178,
    98,
    0,
    113,
    238,
    122,
    255,
    27,
    182,
    236,
    0,
    247,
    148,
    235,
    0,
    242,
    8,
    112,
    0,
    178,
    2,
    101,
    255,
    46,
    189,
    18,
    1,
    79,
    34,
    145,
    255,
    255,
    91,
    33,
    0,
    160,
    136,
    74,
    0,
    71,
    51,
    165,
    0,
    37,
    226,
    108,
    0,
    178,
    66,
    39,
    255,
    128,
    213,
    80,
    0,
    82,
    140,
    166,
    255,
    58,
    95,
    164,
    255,
    91,
    181,
    172,
    1,
    69,
    163,
    64,
    0,
    74,
    70,
    39,
    255,
    236,
    226,
    29,
    0,
    21,
    101,
    255,
    254,
    219,
    140,
    58,
    0,
    2,
    232,
    171,
    255,
    50,
    240,
    54,
    255,
    9,
    133,
    60,
    254,
    9,
    73,
    188,
    0,
    62,
    218,
    233,
    0,
    214,
    175,
    12,
    255,
    127,
    133,
    121,
    255,
    92,
    1,
    169,
    0,
    14,
    206,
    212,
    254,
    229,
    96,
    198,
    255,
    160,
    244,
    178,
    0,
    84,
    136,
    146,
    0,
    131,
    59,
    185,
    255,
    89,
    15,
    175,
    255,
    217,
    142,
    136,
    255,
    84,
    148,
    41,
    0,
    95,
    160,
    220,
    1,
    145,
    66,
    0,
    255,
    248,
    22,
    145,
    255,
    156,
    211,
    225,
    0,
    80,
    229,
    71,
    254,
    188,
    220,
    73,
    0,
    182,
    41,
    72,
    255,
    112,
    31,
    117,
    255,
    168,
    241,
    233,
    255,
    209,
    211,
    5,
    0,
    186,
    83,
    39,
    254,
    131,
    223,
    3,
    255,
    44,
    177,
    19,
    0,
    151,
    74,
    195,
    0,
    99,
    193,
    159,
    1,
    238,
    131,
    98,
    255,
    162,
    181,
    225,
    0,
    96,
    117,
    34,
    255,
    54,
    231,
    80,
    0,
    88,
    139,
    122,
    255,
    58,
    15,
    204,
    255,
    123,
    174,
    192,
    255,
    35,
    20,
    99,
    254,
    145,
    6,
    164,
    0,
    23,
    52,
    134,
    1,
    96,
    82,
    160,
    255,
    51,
    187,
    21,
    255,
    56,
    184,
    244,
    0,
    180,
    125,
    17,
    0,
    198,
    125,
    0,
    0,
    114,
    98,
    102,
    1,
    205,
    67,
    146,
    0,
    75,
    29,
    121,
    1,
    231,
    91,
    234,
    255,
    217,
    206,
    46,
    1,
    12,
    78,
    4,
    0,
    213,
    179,
    243,
    254,
    115,
    232,
    167,
    0,
    83,
    167,
    23,
    254,
    125,
    142,
    214,
    255,
    18,
    40,
    93,
    0,
    97,
    228,
    229,
    255,
    132,
    105,
    191,
    254,
    141,
    201,
    218,
    0,
    113,
    125,
    122,
    0,
    126,
    252,
    124,
    0,
    53,
    163,
    229,
    254,
    135,
    197,
    67,
    255,
    246,
    29,
    128,
    1,
    191,
    155,
    165,
    255,
    129,
    176,
    235,
    0,
    36,
    49,
    114,
    0,
    7,
    132,
    47,
    254,
    20,
    186,
    152,
    0,
    83,
    82,
    40,
    255,
    181,
    77,
    192,
    255,
    185,
    89,
    156,
    0,
    9,
    10,
    32,
    255,
    159,
    252,
    255,
    1,
    249,
    45,
    42,
    255,
    238,
    137,
    100,
    1,
    83,
    28,
    230,
    0,
    56,
    99,
    134,
    255,
    113,
    239,
    116,
    0,
    143,
    100,
    248,
    1,
    99,
    96,
    188,
    255,
    197,
    9,
    248,
    255,
    213,
    136,
    101,
    0,
    115,
    132,
    14,
    0,
    160,
    97,
    160,
    255,
    20,
    75,
    177,
    255,
    157,
    190,
    106,
    0,
    62,
    164,
    173,
    255,
    245,
    105,
    149,
    255,
    238,
    63,
    61,
    0,
    55,
    79,
    106,
    0,
    112,
    59,
    73,
    255,
    194,
    108,
    60,
    0,
    197,
    25,
    122,
    0,
    62,
    72,
    78,
    0,
    196,
    30,
    223,
    255,
    174,
    3,
    227,
    255,
    195,
    105,
    24,
    254,
    104,
    52,
    9,
    255,
    141,
    73,
    248,
    0,
    236,
    107,
    115,
    255,
    154,
    12,
    107,
    1,
    94,
    41,
    11,
    0,
    75,
    50,
    118,
    254,
    228,
    226,
    201,
    255,
    120,
    68,
    106,
    0,
    154,
    64,
    183,
    255,
    81,
    125,
    167,
    0,
    197,
    92,
    153,
    0,
    143,
    166,
    38,
    0,
    73,
    144,
    190,
    255,
    200,
    166,
    138,
    254,
    179,
    251,
    66,
    255,
    189,
    196,
    50,
    255,
    200,
    229,
    221,
    0,
    13,
    122,
    196,
    0,
    159,
    255,
    211,
    0,
    116,
    234,
    229,
    0,
    104,
    37,
    131,
    0,
    29,
    76,
    50,
    1,
    59,
    163,
    78,
    255,
    207,
    76,
    48,
    0,
    134,
    206,
    55,
    255,
    0,
    62,
    201,
    0,
    240,
    231,
    79,
    255,
    51,
    242,
    91,
    255,
    81,
    69,
    50,
    255,
    74,
    125,
    195,
    1,
    47,
    135,
    33,
    0,
    78,
    117,
    239,
    255,
    141,
    137,
    180,
    0,
    181,
    9,
    92,
    0,
    132,
    148,
    214,
    0,
    12,
    11,
    225,
    0,
    38,
    125,
    131,
    255,
    160,
    207,
    195,
    254,
    84,
    45,
    179,
    0,
    2,
    166,
    222,
    1,
    240,
    210,
    200,
    0,
    108,
    73,
    31,
    0,
    11,
    119,
    157,
    255,
    127,
    200,
    233,
    0,
    16,
    119,
    80,
    0,
    148,
    219,
    132,
    1,
    174,
    230,
    1,
    0,
    228,
    122,
    234,
    254,
    89,
    180,
    147,
    255,
    219,
    228,
    153,
    255,
    8,
    38,
    33,
    255,
    20,
    165,
    151,
    0,
    201,
    0,
    33,
    0,
    6,
    9,
    162,
    255,
    112,
    227,
    229,
    255,
    148,
    74,
    65,
    0,
    125,
    89,
    216,
    255,
    128,
    24,
    163,
    254,
    12,
    158,
    146,
    255,
    160,
    219,
    140,
    254,
    5,
    60,
    179,
    0,
    72,
    192,
    165,
    254,
    252,
    72,
    38,
    255,
    173,
    6,
    91,
    0,
    157,
    45,
    143,
    0,
    45,
    242,
    55,
    1,
    240,
    83,
    89,
    0,
    55,
    18,
    175,
    1,
    77,
    234,
    234,
    255,
    114,
    163,
    90,
    255,
    58,
    81,
    209,
    0,
    86,
    94,
    126,
    255,
    42,
    249,
    249,
    0,
    84,
    180,
    145,
    0,
    253,
    35,
    180,
    255,
    221,
    117,
    187,
    255,
    61,
    117,
    196,
    255,
    112,
    85,
    94,
    0,
    33,
    49,
    60,
    255,
    241,
    79,
    150,
    1,
    16,
    159,
    158,
    0,
    24,
    2,
    161,
    1,
    89,
    23,
    14,
    255,
    180,
    187,
    117,
    0,
    134,
    4,
    133,
    0,
    226,
    97,
    115,
    255,
    248,
    181,
    32,
    255,
    234,
    59,
    186,
    1,
    194,
    129,
    169,
    255,
    44,
    130,
    64,
    0,
    228,
    177,
    3,
    0,
    57,
    93,
    53,
    255,
    40,
    33,
    134,
    255,
    144,
    169,
    147,
    255,
    52,
    188,
    133,
    0,
    170,
    202,
    95,
    254,
    143,
    64,
    47,
    0,
    83,
    219,
    196,
    1,
    205,
    131,
    116,
    255,
    149,
    156,
    59,
    0,
    218,
    229,
    171,
    0,
    205,
    219,
    181,
    0,
    184,
    90,
    239,
    0,
    117,
    11,
    241,
    254,
    108,
    214,
    84,
    255,
    217,
    162,
    91,
    254,
    173,
    13,
    74,
    0,
    197,
    111,
    97,
    254,
    63,
    223,
    103,
    0,
    141,
    219,
    104,
    0,
    223,
    149,
    239,
    255,
    142,
    116,
    69,
    254,
    67,
    98,
    213,
    0,
    124,
    78,
    98,
    254,
    158,
    152,
    214,
    255,
    95,
    226,
    172,
    1,
    229,
    146,
    53,
    255,
    118,
    235,
    93,
    0,
    146,
    122,
    230,
    0,
    39,
    255,
    53,
    0,
    68,
    89,
    141,
    255,
    118,
    50,
    215,
    0,
    121,
    106,
    171,
    0,
    43,
    240,
    5,
    254,
    106,
    153,
    141,
    0,
    8,
    61,
    217,
    1,
    242,
    37,
    66,
    0,
    160,
    27,
    228,
    255,
    103,
    13,
    70,
    0,
    137,
    6,
    213,
    0,
    0,
    32,
    195,
    0,
    206,
    106,
    22,
    0,
    39,
    153,
    0,
    255,
    88,
    211,
    253,
    1,
    40,
    192,
    212,
    0,
    142,
    123,
    123,
    0,
    16,
    14,
    122,
    255,
    119,
    162,
    85,
    255,
    146,
    240,
    21,
    0,
    208,
    166,
    87,
    1,
    6,
    98,
    213,
    255,
    129,
    103,
    222,
    1,
    72,
    165,
    182,
    255,
    60,
    137,
    125,
    254,
    79,
    118,
    60,
    0,
    126,
    94,
    191,
    0,
    157,
    146,
    112,
    255,
    99,
    132,
    93,
    254,
    146,
    136,
    121,
    0,
    147,
    98,
    148,
    254,
    167,
    141,
    84,
    0,
    75,
    92,
    119,
    254,
    9,
    64,
    151,
    255,
    24,
    232,
    107,
    1,
    163,
    96,
    46,
    0,
    38,
    108,
    116,
    255,
    160,
    230,
    91,
    0,
    43,
    148,
    93,
    254,
    185,
    151,
    161,
    0,
    219,
    50,
    130,
    1,
    218,
    209,
    231,
    255,
    48,
    202,
    161,
    254,
    116,
    10,
    77,
    0,
    73,
    38,
    219,
    1,
    148,
    24,
    253,
    255,
    81,
    206,
    213,
    254,
    122,
    113,
    246,
    255,
    31,
    46,
    245,
    254,
    75,
    12,
    4,
    255,
    15,
    90,
    224,
    254,
    204,
    220,
    57,
    255,
    102,
    56,
    108,
    255,
    154,
    6,
    224,
    0,
    16,
    52,
    209,
    1,
    139,
    195,
    117,
    0,
    115,
    192,
    90,
    255,
    33,
    243,
    146,
    0,
    117,
    50,
    206,
    1,
    88,
    77,
    95,
    255,
    46,
    210,
    87,
    254,
    167,
    59,
    45,
    255,
    251,
    236,
    88,
    0,
    83,
    159,
    245,
    0,
    177,
    35,
    138,
    254,
    155,
    140,
    184,
    0,
    212,
    32,
    113,
    0,
    47,
    171,
    174,
    0,
    207,
    31,
    172,
    1,
    61,
    160,
    228,
    255,
    235,
    129,
    41,
    255,
    144,
    132,
    66,
    0,
    239,
    168,
    145,
    1,
    188,
    190,
    35,
    0,
    207,
    4,
    178,
    254,
    50,
    57,
    231,
    255,
    52,
    127,
    163,
    255,
    210,
    38,
    32,
    0,
    85,
    177,
    73,
    254,
    176,
    226,
    137,
    0,
    209,
    165,
    212,
    254,
    43,
    203,
    56,
    255,
    80,
    219,
    58,
    254,
    86,
    71,
    226,
    0,
    147,
    221,
    185,
    255,
    57,
    251,
    216,
    0,
    199,
    226,
    53,
    254,
    125,
    25,
    45,
    0,
    148,
    138,
    184,
    0,
    44,
    13,
    47,
    255,
    59,
    87,
    165,
    255,
    145,
    137,
    107,
    0,
    71,
    36,
    207,
    255,
    212,
    237,
    219,
    0,
    44,
    1,
    72,
    255,
    203,
    124,
    5,
    255,
    121,
    32,
    118,
    255,
    184,
    194,
    145,
    255,
    176,
    68,
    141,
    0,
    196,
    89,
    21,
    0,
    144,
    212,
    207,
    1,
    102,
    66,
    169,
    255,
    182,
    120,
    89,
    255,
    133,
    114,
    211,
    0,
    189,
    110,
    21,
    255,
    15,
    10,
    106,
    0,
    41,
    192,
    1,
    0,
    152,
    232,
    121,
    255,
    188,
    60,
    160,
    255,
    153,
    113,
    206,
    255,
    0,
    183,
    226,
    254,
    180,
    13,
    72,
    255,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16,
    133,
    59,
    140,
    1,
    189,
    241,
    36,
    255,
    248,
    37,
    195,
    1,
    96,
    220,
    55,
    0,
    183,
    76,
    62,
    255,
    195,
    66,
    61,
    0,
    50,
    76,
    164,
    1,
    225,
    164,
    76,
    255,
    76,
    61,
    163,
    255,
    117,
    62,
    31,
    0,
    81,
    145,
    64,
    255,
    118,
    65,
    14,
    0,
    162,
    115,
    214,
    255,
    6,
    138,
    46,
    0,
    124,
    230,
    244,
    255,
    10,
    138,
    143,
    0,
    52,
    26,
    194,
    0,
    184,
    244,
    76,
    0,
    129,
    143,
    41,
    1,
    190,
    244,
    19,
    255,
    123,
    170,
    122,
    255,
    98,
    129,
    68,
    0,
    121,
    213,
    147,
    0,
    86,
    101,
    30,
    255,
    161,
    103,
    155,
    0,
    140,
    89,
    67,
    255,
    239,
    229,
    190,
    1,
    67,
    11,
    181,
    0,
    198,
    240,
    137,
    254,
    238,
    69,
    188,
    255,
    67,
    151,
    238,
    0,
    19,
    42,
    108,
    255,
    229,
    85,
    113,
    1,
    50,
    68,
    135,
    255,
    17,
    106,
    9,
    0,
    50,
    103,
    1,
    255,
    80,
    1,
    168,
    1,
    35,
    152,
    30,
    255,
    16,
    168,
    185,
    1,
    56,
    89,
    232,
    255,
    101,
    210,
    252,
    0,
    41,
    250,
    71,
    0,
    204,
    170,
    79,
    255,
    14,
    46,
    239,
    255,
    80,
    77,
    239,
    0,
    189,
    214,
    75,
    255,
    17,
    141,
    249,
    0,
    38,
    80,
    76,
    255,
    190,
    85,
    117,
    0,
    86,
    228,
    170,
    0,
    156,
    216,
    208,
    1,
    195,
    207,
    164,
    255,
    150,
    66,
    76,
    255,
    175,
    225,
    16,
    255,
    141,
    80,
    98,
    1,
    76,
    219,
    242,
    0,
    198,
    162,
    114,
    0,
    46,
    218,
    152,
    0,
    155,
    43,
    241,
    254,
    155,
    160,
    104,
    255,
    51,
    187,
    165,
    0,
    2,
    17,
    175,
    0,
    66,
    84,
    160,
    1,
    247,
    58,
    30,
    0,
    35,
    65,
    53,
    254,
    69,
    236,
    191,
    0,
    45,
    134,
    245,
    1,
    163,
    123,
    221,
    0,
    32,
    110,
    20,
    255,
    52,
    23,
    165,
    0,
    186,
    214,
    71,
    0,
    233,
    176,
    96,
    0,
    242,
    239,
    54,
    1,
    57,
    89,
    138,
    0,
    83,
    0,
    84,
    255,
    136,
    160,
    100,
    0,
    92,
    142,
    120,
    254,
    104,
    124,
    190,
    0,
    181,
    177,
    62,
    255,
    250,
    41,
    85,
    0,
    152,
    130,
    42,
    1,
    96,
    252,
    246,
    0,
    151,
    151,
    63,
    254,
    239,
    133,
    62,
    0,
    32,
    56,
    156,
    0,
    45,
    167,
    189,
    255,
    142,
    133,
    179,
    1,
    131,
    86,
    211,
    0,
    187,
    179,
    150,
    254,
    250,
    170,
    14,
    255,
    210,
    163,
    78,
    0,
    37,
    52,
    151,
    0,
    99,
    77,
    26,
    0,
    238,
    156,
    213,
    255,
    213,
    192,
    209,
    1,
    73,
    46,
    84,
    0,
    20,
    65,
    41,
    1,
    54,
    206,
    79,
    0,
    201,
    131,
    146,
    254,
    170,
    111,
    24,
    255,
    177,
    33,
    50,
    254,
    171,
    38,
    203,
    255,
    78,
    247,
    116,
    0,
    209,
    221,
    153,
    0,
    133,
    128,
    178,
    1,
    58,
    44,
    25,
    0,
    201,
    39,
    59,
    1,
    189,
    19,
    252,
    0,
    49,
    229,
    210,
    1,
    117,
    187,
    117,
    0,
    181,
    179,
    184,
    1,
    0,
    114,
    219,
    0,
    48,
    94,
    147,
    0,
    245,
    41,
    56,
    0,
    125,
    13,
    204,
    254,
    244,
    173,
    119,
    0,
    44,
    221,
    32,
    254,
    84,
    234,
    20,
    0,
    249,
    160,
    198,
    1,
    236,
    126,
    234,
    255,
    47,
    99,
    168,
    254,
    170,
    226,
    153,
    255,
    102,
    179,
    216,
    0,
    226,
    141,
    122,
    255,
    122,
    66,
    153,
    254,
    182,
    245,
    134,
    0,
    227,
    228,
    25,
    1,
    214,
    57,
    235,
    255,
    216,
    173,
    56,
    255,
    181,
    231,
    210,
    0,
    119,
    128,
    157,
    255,
    129,
    95,
    136,
    255,
    110,
    126,
    51,
    0,
    2,
    169,
    183,
    255,
    7,
    130,
    98,
    254,
    69,
    176,
    94,
    255,
    116,
    4,
    227,
    1,
    217,
    242,
    145,
    255,
    202,
    173,
    31,
    1,
    105,
    1,
    39,
    255,
    46,
    175,
    69,
    0,
    228,
    47,
    58,
    255,
    215,
    224,
    69,
    254,
    207,
    56,
    69,
    255,
    16,
    254,
    139,
    255,
    23,
    207,
    212,
    255,
    202,
    20,
    126,
    255,
    95,
    213,
    96,
    255,
    9,
    176,
    33,
    0,
    200,
    5,
    207,
    255,
    241,
    42,
    128,
    254,
    35,
    33,
    192,
    255,
    248,
    229,
    196,
    1,
    129,
    17,
    120,
    0,
    251,
    103,
    151,
    255,
    7,
    52,
    112,
    255,
    140,
    56,
    66,
    255,
    40,
    226,
    245,
    255,
    217,
    70,
    37,
    254,
    172,
    214,
    9,
    255,
    72,
    67,
    134,
    1,
    146,
    192,
    214,
    255,
    44,
    38,
    112,
    0,
    68,
    184,
    75,
    255,
    206,
    90,
    251,
    0,
    149,
    235,
    141,
    0,
    181,
    170,
    58,
    0,
    116,
    244,
    239,
    0,
    92,
    157,
    2,
    0,
    102,
    173,
    98,
    0,
    233,
    137,
    96,
    1,
    127,
    49,
    203,
    0,
    5,
    155,
    148,
    0,
    23,
    148,
    9,
    255,
    211,
    122,
    12,
    0,
    34,
    134,
    26,
    255,
    219,
    204,
    136,
    0,
    134,
    8,
    41,
    255,
    224,
    83,
    43,
    254,
    85,
    25,
    247,
    0,
    109,
    127,
    0,
    254,
    169,
    136,
    48,
    0,
    238,
    119,
    219,
    255,
    231,
    173,
    213,
    0,
    206,
    18,
    254,
    254,
    8,
    186,
    7,
    255,
    126,
    9,
    7,
    1,
    111,
    42,
    72,
    0,
    111,
    52,
    236,
    254,
    96,
    63,
    141,
    0,
    147,
    191,
    127,
    254,
    205,
    78,
    192,
    255,
    14,
    106,
    237,
    1,
    187,
    219,
    76,
    0,
    175,
    243,
    187,
    254,
    105,
    89,
    173,
    0,
    85,
    25,
    89,
    1,
    162,
    243,
    148,
    0,
    2,
    118,
    209,
    254,
    33,
    158,
    9,
    0,
    139,
    163,
    46,
    255,
    93,
    70,
    40,
    0,
    108,
    42,
    142,
    254,
    111,
    252,
    142,
    255,
    155,
    223,
    144,
    0,
    51,
    229,
    167,
    255,
    73,
    252,
    155,
    255,
    94,
    116,
    12,
    255,
    152,
    160,
    218,
    255,
    156,
    238,
    37,
    255,
    179,
    234,
    207,
    255,
    197,
    0,
    179,
    255,
    154,
    164,
    141,
    0,
    225,
    196,
    104,
    0,
    10,
    35,
    25,
    254,
    209,
    212,
    242,
    255,
    97,
    253,
    222,
    254,
    184,
    101,
    229,
    0,
    222,
    18,
    127,
    1,
    164,
    136,
    135,
    255,
    30,
    207,
    140,
    254,
    146,
    97,
    243,
    0,
    129,
    192,
    26,
    254,
    201,
    84,
    33,
    255,
    111,
    10,
    78,
    255,
    147,
    81,
    178,
    255,
    4,
    4,
    24,
    0,
    161,
    238,
    215,
    255,
    6,
    141,
    33,
    0,
    53,
    215,
    14,
    255,
    41,
    181,
    208,
    255,
    231,
    139,
    157,
    0,
    179,
    203,
    221,
    255,
    255,
    185,
    113,
    0,
    189,
    226,
    172,
    255,
    113,
    66,
    214,
    255,
    202,
    62,
    45,
    255,
    102,
    64,
    8,
    255,
    78,
    174,
    16,
    254,
    133,
    117,
    68,
    255,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    36,
    28,
    194,
    0,
    201,
    13,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    109,
    7,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    27,
    19,
    44,
    10,
    163,
    229,
    156,
    237,
    167,
    41,
    99,
    8,
    93,
    33,
    6,
    33,
    235,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    15,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    27,
    126,
    84,
    18,
    163,
    29,
    181,
    210,
    255,
    132,
    186,
    253,
    242,
    6,
    162,
    177,
    234,
    107,
    163,
    255,
    56,
    84,
    231,
    20,
    54,
    24,
    233,
    111,
    242,
    198,
    182,
    157,
    8,
    0,
    0,
    0,
    16,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    32,
    0,
    0,
    0,
    40,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    64,
    0,
    0,
    0,
    80,
    0,
    0,
    0,
    128,
    0,
    0,
    0,
    0,
    1,
    0,
    0
]);
Promise.resolve();
const instance = new WebAssembly.Instance(new WebAssembly.Module(WASM_BIN), {});
const wasm1 = instance.exports;
let allocPtr = 0, allocSize = 0;
function alloc(size) {
    if (allocSize < size) {
        if (allocPtr) wasm1.free(allocPtr);
        allocPtr = wasm1.malloc(size);
        allocSize = size;
    }
    return allocPtr;
}
function write1(value, ptr, size = value.length) {
    const buf = new Uint8Array(wasm1.memory.buffer, ptr, size);
    buf.set(value);
}
function read1(ptr, size) {
    return new Uint8Array(wasm1.memory.buffer, ptr, size).slice(0, size);
}
function crypto_key_exchange(your_secret_key, their_public_key) {
    const ptr = alloc(32 * 3);
    if (your_secret_key) write1(your_secret_key, ptr + 32);
    if (their_public_key) write1(their_public_key, ptr + 32 * 2);
    wasm1.crypto_key_exchange(ptr, your_secret_key ? ptr + 32 : 0, their_public_key ? ptr + 32 * 2 : 0);
    return read1(ptr, 32);
}
function crypto_key_exchange_public_key(your_secret_key) {
    return crypto_x25519_public_key(your_secret_key);
}
function crypto_lock(key, nonce, plain_text) {
    const textLength = plain_text ? plain_text.length : 0;
    const ptr = alloc(16 + textLength + 32 + 24);
    if (plain_text) write1(plain_text, ptr + 16);
    if (key) write1(key, ptr + 16 + textLength);
    if (nonce) write1(nonce, ptr + 16 + textLength + 32);
    wasm1.crypto_lock(ptr, ptr + 16, key ? ptr + 16 + textLength : 0, nonce ? ptr + 16 + textLength + 32 : 0, ptr + 16, textLength);
    wasm1.crypto_wipe(ptr + 16 + textLength, 32);
    return read1(ptr, 16 + textLength);
}
function crypto_unlock(key, nonce, cipher_text) {
    if (!cipher_text || cipher_text.length < 16) return null;
    const textLength = cipher_text.length - 16;
    const ptr = alloc(16 + textLength + 32 + 24);
    write1(cipher_text, ptr);
    if (key) write1(key, ptr + 16 + textLength);
    if (nonce) write1(nonce, ptr + 16 + textLength + 32);
    const success = wasm1.crypto_unlock(ptr + 16, key ? ptr + 16 + textLength : 0, nonce ? ptr + 16 + textLength + 32 : 0, ptr, ptr + 16, textLength) === 0;
    wasm1.crypto_wipe(ptr + 16 + textLength, 32);
    return success ? read1(ptr + 16, textLength) : null;
}
function crypto_x25519_public_key(secret_key) {
    const ptr = alloc(32 * 2);
    if (secret_key) write1(secret_key, ptr + 32);
    wasm1.crypto_x25519_public_key(ptr, secret_key ? ptr + 32 : 0);
    wasm1.crypto_wipe(ptr + 32, 32);
    return read1(ptr, 32);
}
const importMeta = {
    url: "file:///home/hortinstein/enkodo/typescript/main.ts",
    main: import.meta.main
};
const require1 = createRequire(importMeta.url);
const serialize1 = require1("./serialize.js");
function splitMAC(encBuffer) {
    return [
        encBuffer.slice(0, MAC_LEN),
        encBuffer.slice(MAC_LEN)
    ];
}
function randomBytes2(n) {
    const buf = new Uint8Array(n);
    return crypto.getRandomValues(buf);
}
const MAC_LEN = 16;
function enc(privateKey, publicKey, data) {
    const sharedKey = crypto_key_exchange(privateKey, publicKey);
    const nonce = randomBytes2(24);
    const maccipher = crypto_lock(sharedKey, nonce, data);
    const [mac, cipher] = splitMAC(maccipher);
    const myPubKey = crypto_key_exchange_public_key(privateKey);
    return serialize1.returnEncObj(myPubKey, nonce, mac, cipher.length, cipher);
}
function dec(privateKey, encObj) {
    const sharedKey = crypto_key_exchange(privateKey, encObj.publicKey);
    const mac = new Uint8Array(encObj.mac);
    const cipher = new Uint8Array(encObj.cipherText);
    const maccipher = new Uint8Array([
        ...mac,
        ...cipher
    ]);
    const plain = crypto_unlock(sharedKey, encObj.nonce, maccipher);
    return plain;
}
function generateKeyPair1() {
    const privateKey = randomBytes2(32);
    const publicKey = crypto_key_exchange_public_key(privateKey);
    return [
        privateKey,
        publicKey
    ];
}
function wrap1(obj) {
    return serialize1.wrap(obj);
}
function unwrap(wrappedObj) {
    return serialize1.unwrap(wrappedObj);
}
function wrapKey(obj) {
    return serialize1.wrapKey(obj);
}
function unwrapKey(wrappedObj) {
    return serialize1.unwrapKey(wrappedObj);
}
export { enc as enc };
export { dec as dec };
export { generateKeyPair1 as generateKeyPair };
export { wrap1 as wrap };
export { unwrap as unwrap };
export { wrapKey as wrapKey };
export { unwrapKey as unwrapKey };

